
MP3MultiChannel.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00016784  080001d0  080001d0  000101d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00003d84  08016958  08016958  00026958  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0801a6dc  0801a6dc  00030864  2**0
                  CONTENTS
  4 .ARM          00000008  0801a6dc  0801a6dc  0002a6dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0801a6e4  0801a6e4  00030864  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0801a6e4  0801a6e4  0002a6e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0801a6e8  0801a6e8  0002a6e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000864  20000000  0801a6ec  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0004e5e8  20000880  0801af50  00030880  2**5
                  ALLOC
 10 ._user_heap_stack 00000c00  2004ee68  0801af50  0003ee68  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00030864  2**0
                  CONTENTS, READONLY
 12 .debug_info   00045771  00000000  00000000  00030894  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000081b5  00000000  00000000  00076005  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    00049334  00000000  00000000  0007e1ba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001aa0  00000000  00000000  000c74f0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00008ad0  00000000  00000000  000c8f90  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00008184  00000000  00000000  000d1a60  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00048824  00000000  00000000  000d9be4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00107f0a  00000000  00000000  00122408  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  0022a312  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00006f34  00000000  00000000  0022a364  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001d0 <__do_global_dtors_aux>:
 80001d0:	b510      	push	{r4, lr}
 80001d2:	4c05      	ldr	r4, [pc, #20]	; (80001e8 <__do_global_dtors_aux+0x18>)
 80001d4:	7823      	ldrb	r3, [r4, #0]
 80001d6:	b933      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x16>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x1c>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x12>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x20>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	20000880 	.word	0x20000880
 80001ec:	00000000 	.word	0x00000000
 80001f0:	0801693c 	.word	0x0801693c

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b03      	ldr	r3, [pc, #12]	; (8000204 <frame_dummy+0x10>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4903      	ldr	r1, [pc, #12]	; (8000208 <frame_dummy+0x14>)
 80001fc:	4803      	ldr	r0, [pc, #12]	; (800020c <frame_dummy+0x18>)
 80001fe:	f3af 8000 	nop.w
 8000202:	bd08      	pop	{r3, pc}
 8000204:	00000000 	.word	0x00000000
 8000208:	20000884 	.word	0x20000884
 800020c:	0801693c 	.word	0x0801693c

08000210 <xmp3_PolyphaseStereo>:


// void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
	.thumb_func
xmp3_PolyphaseStereo:
    stmfd    sp!, {r4-r11, r14}
 8000210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    
	//; clear out stack space for 2 local variables (4 bytes each)
    sub        sp, sp, #8
 8000214:	b082      	sub	sp, #8
    str        PCM , [sp, #4]                // sp[1] = pcm pointer
 8000216:	9001      	str	r0, [sp, #4]

    // special case, output sample 0
    mov        SUM1LL, #RNDVAL               // load rndVal (low 32)
 8000218:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM1RL, #RNDVAL               // load rndVal (low 32)
 800021c:	f04f 7800 	mov.w	r8, #33554432	; 0x2000000
    mov        SUM1LH, #0
 8000220:	f04f 0500 	mov.w	r5, #0
    mov        SUM1RH, #0
 8000224:	f04f 0900 	mov.w	r9, #0

    MC0S    0
 8000228:	f852 cb04 	ldr.w	ip, [r2], #4
 800022c:	f852 eb04 	ldr.w	lr, [r2], #4
 8000230:	6808      	ldr	r0, [r1, #0]
 8000232:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 8000234:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000238:	f8d1 0080 	ldr.w	r0, [r1, #128]	; 0x80
 800023c:	f1ce 0e00 	rsb	lr, lr, #0
 8000240:	fbc3 450e 	smlal	r4, r5, r3, lr
 8000244:	f8d1 30dc 	ldr.w	r3, [r1, #220]	; 0xdc
 8000248:	fbc0 890c 	smlal	r8, r9, r0, ip
 800024c:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    1
 8000250:	f852 cb04 	ldr.w	ip, [r2], #4
 8000254:	f852 eb04 	ldr.w	lr, [r2], #4
 8000258:	6848      	ldr	r0, [r1, #4]
 800025a:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 800025c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000260:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
 8000264:	f1ce 0e00 	rsb	lr, lr, #0
 8000268:	fbc3 450e 	smlal	r4, r5, r3, lr
 800026c:	f8d1 30d8 	ldr.w	r3, [r1, #216]	; 0xd8
 8000270:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000274:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    2
 8000278:	f852 cb04 	ldr.w	ip, [r2], #4
 800027c:	f852 eb04 	ldr.w	lr, [r2], #4
 8000280:	6888      	ldr	r0, [r1, #8]
 8000282:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 8000284:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000288:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
 800028c:	f1ce 0e00 	rsb	lr, lr, #0
 8000290:	fbc3 450e 	smlal	r4, r5, r3, lr
 8000294:	f8d1 30d4 	ldr.w	r3, [r1, #212]	; 0xd4
 8000298:	fbc0 890c 	smlal	r8, r9, r0, ip
 800029c:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    3
 80002a0:	f852 cb04 	ldr.w	ip, [r2], #4
 80002a4:	f852 eb04 	ldr.w	lr, [r2], #4
 80002a8:	68c8      	ldr	r0, [r1, #12]
 80002aa:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 80002ac:	fbc0 450c 	smlal	r4, r5, r0, ip
 80002b0:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
 80002b4:	f1ce 0e00 	rsb	lr, lr, #0
 80002b8:	fbc3 450e 	smlal	r4, r5, r3, lr
 80002bc:	f8d1 30d0 	ldr.w	r3, [r1, #208]	; 0xd0
 80002c0:	fbc0 890c 	smlal	r8, r9, r0, ip
 80002c4:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    4
 80002c8:	f852 cb04 	ldr.w	ip, [r2], #4
 80002cc:	f852 eb04 	ldr.w	lr, [r2], #4
 80002d0:	6908      	ldr	r0, [r1, #16]
 80002d2:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 80002d4:	fbc0 450c 	smlal	r4, r5, r0, ip
 80002d8:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
 80002dc:	f1ce 0e00 	rsb	lr, lr, #0
 80002e0:	fbc3 450e 	smlal	r4, r5, r3, lr
 80002e4:	f8d1 30cc 	ldr.w	r3, [r1, #204]	; 0xcc
 80002e8:	fbc0 890c 	smlal	r8, r9, r0, ip
 80002ec:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    5
 80002f0:	f852 cb04 	ldr.w	ip, [r2], #4
 80002f4:	f852 eb04 	ldr.w	lr, [r2], #4
 80002f8:	6948      	ldr	r0, [r1, #20]
 80002fa:	6c8b      	ldr	r3, [r1, #72]	; 0x48
 80002fc:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000300:	f8d1 0094 	ldr.w	r0, [r1, #148]	; 0x94
 8000304:	f1ce 0e00 	rsb	lr, lr, #0
 8000308:	fbc3 450e 	smlal	r4, r5, r3, lr
 800030c:	f8d1 30c8 	ldr.w	r3, [r1, #200]	; 0xc8
 8000310:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000314:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    6
 8000318:	f852 cb04 	ldr.w	ip, [r2], #4
 800031c:	f852 eb04 	ldr.w	lr, [r2], #4
 8000320:	6988      	ldr	r0, [r1, #24]
 8000322:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8000324:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000328:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
 800032c:	f1ce 0e00 	rsb	lr, lr, #0
 8000330:	fbc3 450e 	smlal	r4, r5, r3, lr
 8000334:	f8d1 30c4 	ldr.w	r3, [r1, #196]	; 0xc4
 8000338:	fbc0 890c 	smlal	r8, r9, r0, ip
 800033c:	fbc3 890e 	smlal	r8, r9, r3, lr
    MC0S    7
 8000340:	f852 cb04 	ldr.w	ip, [r2], #4
 8000344:	f852 eb04 	ldr.w	lr, [r2], #4
 8000348:	69c8      	ldr	r0, [r1, #28]
 800034a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800034c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000350:	f8d1 009c 	ldr.w	r0, [r1, #156]	; 0x9c
 8000354:	f1ce 0e00 	rsb	lr, lr, #0
 8000358:	fbc3 450e 	smlal	r4, r5, r3, lr
 800035c:	f8d1 30c0 	ldr.w	r3, [r1, #192]	; 0xc0
 8000360:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000364:	fbc3 890e 	smlal	r8, r9, r3, lr

    ldr        PCM, [sp, #4]         // load pcm pointer
 8000368:	9801      	ldr	r0, [sp, #4]
    mov        MAXPOS, #0x7f00
 800036a:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr        MAXPOS, MAXPOS, #0xff
 800036e:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS    SUM1LL, SUM1LH, SIGN, MAXPOS
 8000372:	ea4f 6494 	mov.w	r4, r4, lsr #26
 8000376:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 800037a:	f304 040f 	ssat	r4, #16, r4
    C64TOS    SUM1RL, SUM1RH, SIGN, MAXPOS
 800037e:	ea4f 6898 	mov.w	r8, r8, lsr #26
 8000382:	ea48 1889 	orr.w	r8, r8, r9, lsl #6
 8000386:	f308 080f 	ssat	r8, #16, r8

    strh    SUM1LL, [PCM, #(2*0)]
 800038a:	8004      	strh	r4, [r0, #0]
    strh    SUM1RL, [PCM, #(2*1)]
 800038c:	f8a0 8002 	strh.w	r8, [r0, #2]

	// special case, output sample 16
    add        COEF, COEF, #(4*(256-16))    // coef = coefBase + 256 (was coefBase + 16 after MC0S block)
 8000390:	f502 7270 	add.w	r2, r2, #960	; 0x3c0
    add        VB1, VB1, #(4*1024)          // vb1 = vbuf + 64*16
 8000394:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    
    mov        SUM1LL, #RNDVAL              // load rndVal (low 32)
 8000398:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM1RL, #RNDVAL              // load rndVal (low 32)
 800039c:	f04f 7800 	mov.w	r8, #33554432	; 0x2000000
    mov        SUM1LH, #0
 80003a0:	f04f 0500 	mov.w	r5, #0
    mov        SUM1RH, #0
 80003a4:	f04f 0900 	mov.w	r9, #0

    MC1S    0
 80003a8:	f852 cb04 	ldr.w	ip, [r2], #4
 80003ac:	6808      	ldr	r0, [r1, #0]
 80003ae:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
 80003b2:	fbc0 450c 	smlal	r4, r5, r0, ip
 80003b6:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    1
 80003ba:	f852 cb04 	ldr.w	ip, [r2], #4
 80003be:	6848      	ldr	r0, [r1, #4]
 80003c0:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
 80003c4:	fbc0 450c 	smlal	r4, r5, r0, ip
 80003c8:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    2
 80003cc:	f852 cb04 	ldr.w	ip, [r2], #4
 80003d0:	6888      	ldr	r0, [r1, #8]
 80003d2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80003d6:	fbc0 450c 	smlal	r4, r5, r0, ip
 80003da:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    3
 80003de:	f852 cb04 	ldr.w	ip, [r2], #4
 80003e2:	68c8      	ldr	r0, [r1, #12]
 80003e4:	f8d1 308c 	ldr.w	r3, [r1, #140]	; 0x8c
 80003e8:	fbc0 450c 	smlal	r4, r5, r0, ip
 80003ec:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    4
 80003f0:	f852 cb04 	ldr.w	ip, [r2], #4
 80003f4:	6908      	ldr	r0, [r1, #16]
 80003f6:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
 80003fa:	fbc0 450c 	smlal	r4, r5, r0, ip
 80003fe:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    5
 8000402:	f852 cb04 	ldr.w	ip, [r2], #4
 8000406:	6948      	ldr	r0, [r1, #20]
 8000408:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
 800040c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000410:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    6
 8000414:	f852 cb04 	ldr.w	ip, [r2], #4
 8000418:	6988      	ldr	r0, [r1, #24]
 800041a:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
 800041e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000422:	fbc3 890c 	smlal	r8, r9, r3, ip
    MC1S    7
 8000426:	f852 cb04 	ldr.w	ip, [r2], #4
 800042a:	69c8      	ldr	r0, [r1, #28]
 800042c:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8000430:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000434:	fbc3 890c 	smlal	r8, r9, r3, ip

    ldr     PCM, [sp, #4]        // load pcm pointer
 8000438:	9801      	ldr	r0, [sp, #4]
    mov     MAXPOS, #0x7f00
 800043a:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr     MAXPOS, MAXPOS, #0xff
 800043e:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS  SUM1LL, SUM1LH, SIGN, MAXPOS
 8000442:	ea4f 6494 	mov.w	r4, r4, lsr #26
 8000446:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 800044a:	f304 040f 	ssat	r4, #16, r4
    C64TOS  SUM1RL, SUM1RH, SIGN, MAXPOS
 800044e:	ea4f 6898 	mov.w	r8, r8, lsr #26
 8000452:	ea48 1889 	orr.w	r8, r8, r9, lsl #6
 8000456:	f308 080f 	ssat	r8, #16, r8

    strh    SUM1LL, [PCM, #(2*(2*16+0))]
 800045a:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
    strh    SUM1RL, [PCM, #(2*(2*16+1))]
 800045e:	f8a0 8042 	strh.w	r8, [r0, #66]	; 0x42

    // main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17
    sub        COEF, COEF, #(4*(264-16))    //; coef = coefBase + 16 (was coefBase + 264 after MC1S block)
 8000462:	f5a2 7278 	sub.w	r2, r2, #992	; 0x3e0
    sub        VB1, VB1, #(4*(1024-64))     //; vb1 = vbuf + 64 (was vbuf + 64*16 after MC1S block)
 8000466:	f5a1 6170 	sub.w	r1, r1, #3840	; 0xf00
    mov        I, #15                       //; loop counter, count down
 800046a:	f04f 0c0f 	mov.w	ip, #15
    add        PCM, PCM, #(2*2)             //; pcm+=2
 800046e:	f100 0004 	add.w	r0, r0, #4

08000472 <LoopPS>:
    
LoopPS:
    str        I, [sp, #0]                  //; sp[0] = i (loop counter)
 8000472:	f8cd c000 	str.w	ip, [sp]
    str        PCM, [sp, #4]                //; sp[1] = pcm (pointer to pcm buffer)
 8000476:	9001      	str	r0, [sp, #4]
    
    mov        SUM1LL, #RNDVAL              //; load rndVal (low 32)
 8000478:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM1RL, #RNDVAL              //; load rndVal (low 32)
 800047c:	f04f 7800 	mov.w	r8, #33554432	; 0x2000000
    mov        SUM2LL, #RNDVAL              //; load rndVal (low 32)
 8000480:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
    mov        SUM2RL, #RNDVAL              //; load rndVal (low 32)
 8000484:	f04f 7a00 	mov.w	sl, #33554432	; 0x2000000
    
    mov        SUM1LH, #0
 8000488:	f04f 0500 	mov.w	r5, #0
    mov        SUM1RH, #0
 800048c:	f04f 0900 	mov.w	r9, #0
    mov        SUM2LH, #0
 8000490:	f04f 0700 	mov.w	r7, #0
    mov        SUM2RH, #0
 8000494:	f04f 0b00 	mov.w	fp, #0

    MC2S    0
 8000498:	f852 cb04 	ldr.w	ip, [r2], #4
 800049c:	f852 eb04 	ldr.w	lr, [r2], #4
 80004a0:	6808      	ldr	r0, [r1, #0]
 80004a2:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 80004a4:	fbc0 450c 	smlal	r4, r5, r0, ip
 80004a8:	fbc0 670e 	smlal	r6, r7, r0, lr
 80004ac:	f1ce 0e00 	rsb	lr, lr, #0
 80004b0:	fbc3 670c 	smlal	r6, r7, r3, ip
 80004b4:	fbc3 450e 	smlal	r4, r5, r3, lr
 80004b8:	f8d1 30dc 	ldr.w	r3, [r1, #220]	; 0xdc
 80004bc:	f8d1 0080 	ldr.w	r0, [r1, #128]	; 0x80
 80004c0:	fbc3 890e 	smlal	r8, r9, r3, lr
 80004c4:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 80004c8:	f1ce 0e00 	rsb	lr, lr, #0
 80004cc:	fbc0 890c 	smlal	r8, r9, r0, ip
 80004d0:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    1
 80004d4:	f852 cb04 	ldr.w	ip, [r2], #4
 80004d8:	f852 eb04 	ldr.w	lr, [r2], #4
 80004dc:	6848      	ldr	r0, [r1, #4]
 80004de:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 80004e0:	fbc0 450c 	smlal	r4, r5, r0, ip
 80004e4:	fbc0 670e 	smlal	r6, r7, r0, lr
 80004e8:	f1ce 0e00 	rsb	lr, lr, #0
 80004ec:	fbc3 670c 	smlal	r6, r7, r3, ip
 80004f0:	fbc3 450e 	smlal	r4, r5, r3, lr
 80004f4:	f8d1 30d8 	ldr.w	r3, [r1, #216]	; 0xd8
 80004f8:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
 80004fc:	fbc3 890e 	smlal	r8, r9, r3, lr
 8000500:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 8000504:	f1ce 0e00 	rsb	lr, lr, #0
 8000508:	fbc0 890c 	smlal	r8, r9, r0, ip
 800050c:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    2
 8000510:	f852 cb04 	ldr.w	ip, [r2], #4
 8000514:	f852 eb04 	ldr.w	lr, [r2], #4
 8000518:	6888      	ldr	r0, [r1, #8]
 800051a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 800051c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000520:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000524:	f1ce 0e00 	rsb	lr, lr, #0
 8000528:	fbc3 670c 	smlal	r6, r7, r3, ip
 800052c:	fbc3 450e 	smlal	r4, r5, r3, lr
 8000530:	f8d1 30d4 	ldr.w	r3, [r1, #212]	; 0xd4
 8000534:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
 8000538:	fbc3 890e 	smlal	r8, r9, r3, lr
 800053c:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 8000540:	f1ce 0e00 	rsb	lr, lr, #0
 8000544:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000548:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    3
 800054c:	f852 cb04 	ldr.w	ip, [r2], #4
 8000550:	f852 eb04 	ldr.w	lr, [r2], #4
 8000554:	68c8      	ldr	r0, [r1, #12]
 8000556:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 8000558:	fbc0 450c 	smlal	r4, r5, r0, ip
 800055c:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000560:	f1ce 0e00 	rsb	lr, lr, #0
 8000564:	fbc3 670c 	smlal	r6, r7, r3, ip
 8000568:	fbc3 450e 	smlal	r4, r5, r3, lr
 800056c:	f8d1 30d0 	ldr.w	r3, [r1, #208]	; 0xd0
 8000570:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
 8000574:	fbc3 890e 	smlal	r8, r9, r3, lr
 8000578:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 800057c:	f1ce 0e00 	rsb	lr, lr, #0
 8000580:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000584:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    4
 8000588:	f852 cb04 	ldr.w	ip, [r2], #4
 800058c:	f852 eb04 	ldr.w	lr, [r2], #4
 8000590:	6908      	ldr	r0, [r1, #16]
 8000592:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 8000594:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000598:	fbc0 670e 	smlal	r6, r7, r0, lr
 800059c:	f1ce 0e00 	rsb	lr, lr, #0
 80005a0:	fbc3 670c 	smlal	r6, r7, r3, ip
 80005a4:	fbc3 450e 	smlal	r4, r5, r3, lr
 80005a8:	f8d1 30cc 	ldr.w	r3, [r1, #204]	; 0xcc
 80005ac:	f8d1 0090 	ldr.w	r0, [r1, #144]	; 0x90
 80005b0:	fbc3 890e 	smlal	r8, r9, r3, lr
 80005b4:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 80005b8:	f1ce 0e00 	rsb	lr, lr, #0
 80005bc:	fbc0 890c 	smlal	r8, r9, r0, ip
 80005c0:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    5
 80005c4:	f852 cb04 	ldr.w	ip, [r2], #4
 80005c8:	f852 eb04 	ldr.w	lr, [r2], #4
 80005cc:	6948      	ldr	r0, [r1, #20]
 80005ce:	6c8b      	ldr	r3, [r1, #72]	; 0x48
 80005d0:	fbc0 450c 	smlal	r4, r5, r0, ip
 80005d4:	fbc0 670e 	smlal	r6, r7, r0, lr
 80005d8:	f1ce 0e00 	rsb	lr, lr, #0
 80005dc:	fbc3 670c 	smlal	r6, r7, r3, ip
 80005e0:	fbc3 450e 	smlal	r4, r5, r3, lr
 80005e4:	f8d1 30c8 	ldr.w	r3, [r1, #200]	; 0xc8
 80005e8:	f8d1 0094 	ldr.w	r0, [r1, #148]	; 0x94
 80005ec:	fbc3 890e 	smlal	r8, r9, r3, lr
 80005f0:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 80005f4:	f1ce 0e00 	rsb	lr, lr, #0
 80005f8:	fbc0 890c 	smlal	r8, r9, r0, ip
 80005fc:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    6
 8000600:	f852 cb04 	ldr.w	ip, [r2], #4
 8000604:	f852 eb04 	ldr.w	lr, [r2], #4
 8000608:	6988      	ldr	r0, [r1, #24]
 800060a:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800060c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000610:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000614:	f1ce 0e00 	rsb	lr, lr, #0
 8000618:	fbc3 670c 	smlal	r6, r7, r3, ip
 800061c:	fbc3 450e 	smlal	r4, r5, r3, lr
 8000620:	f8d1 30c4 	ldr.w	r3, [r1, #196]	; 0xc4
 8000624:	f8d1 0098 	ldr.w	r0, [r1, #152]	; 0x98
 8000628:	fbc3 890e 	smlal	r8, r9, r3, lr
 800062c:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 8000630:	f1ce 0e00 	rsb	lr, lr, #0
 8000634:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000638:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    MC2S    7
 800063c:	f852 cb04 	ldr.w	ip, [r2], #4
 8000640:	f852 eb04 	ldr.w	lr, [r2], #4
 8000644:	69c8      	ldr	r0, [r1, #28]
 8000646:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8000648:	fbc0 450c 	smlal	r4, r5, r0, ip
 800064c:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000650:	f1ce 0e00 	rsb	lr, lr, #0
 8000654:	fbc3 670c 	smlal	r6, r7, r3, ip
 8000658:	fbc3 450e 	smlal	r4, r5, r3, lr
 800065c:	f8d1 30c0 	ldr.w	r3, [r1, #192]	; 0xc0
 8000660:	f8d1 009c 	ldr.w	r0, [r1, #156]	; 0x9c
 8000664:	fbc3 890e 	smlal	r8, r9, r3, lr
 8000668:	fbc3 ab0c 	smlal	sl, fp, r3, ip
 800066c:	f1ce 0e00 	rsb	lr, lr, #0
 8000670:	fbc0 890c 	smlal	r8, r9, r0, ip
 8000674:	fbc0 ab0e 	smlal	sl, fp, r0, lr
    
    add        VB1, VB1, #(4*64)    //; vb1 += 64
 8000678:	f501 7180 	add.w	r1, r1, #256	; 0x100
    
    ldr        PCM, [sp, #4]        //; load pcm pointer
 800067c:	9801      	ldr	r0, [sp, #4]
    mov        MAXPOS, #0x7f00
 800067e:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr        MAXPOS, MAXPOS, #0xff
 8000682:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS    SUM1LL, SUM1LH, SIGN, MAXPOS
 8000686:	ea4f 6494 	mov.w	r4, r4, lsr #26
 800068a:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 800068e:	f304 040f 	ssat	r4, #16, r4
    C64TOS    SUM1RL, SUM1RH, SIGN, MAXPOS
 8000692:	ea4f 6898 	mov.w	r8, r8, lsr #26
 8000696:	ea48 1889 	orr.w	r8, r8, r9, lsl #6
 800069a:	f308 080f 	ssat	r8, #16, r8
    C64TOS    SUM2LL, SUM2LH, SIGN, MAXPOS
 800069e:	ea4f 6696 	mov.w	r6, r6, lsr #26
 80006a2:	ea46 1687 	orr.w	r6, r6, r7, lsl #6
 80006a6:	f306 060f 	ssat	r6, #16, r6
    C64TOS    SUM2RL, SUM2RH, SIGN, MAXPOS
 80006aa:	ea4f 6a9a 	mov.w	sl, sl, lsr #26
 80006ae:	ea4a 1a8b 	orr.w	sl, sl, fp, lsl #6
 80006b2:	f30a 0a0f 	ssat	sl, #16, sl
    
    ldr        I, [sp, #0]            //; load loop counter
 80006b6:	f8dd c000 	ldr.w	ip, [sp]
    add        CF2, PCM, I, lsl #3    //; CF2 = PCM + 4*i (short offset)
 80006ba:	eb00 0ecc 	add.w	lr, r0, ip, lsl #3
    strh    SUM2LL, [CF2], #2    	  //; *(pcm + 2*2*i + 0)
 80006be:	f82e 6b02 	strh.w	r6, [lr], #2
    strh    SUM2RL, [CF2], #2         //; *(pcm + 2*2*i + 1)
 80006c2:	f82e ab02 	strh.w	sl, [lr], #2

    strh    SUM1LL, [PCM], #2         //; *(pcm + 0)
 80006c6:	f820 4b02 	strh.w	r4, [r0], #2
    strh    SUM1RL, [PCM], #2         //; *(pcm + 1)
 80006ca:	f820 8b02 	strh.w	r8, [r0], #2
    
    subs    I, I, #1
 80006ce:	f1bc 0c01 	subs.w	ip, ip, #1
    bne     LoopPS
 80006d2:	f47f aece 	bne.w	8000472 <LoopPS>

    // restore stack pointer
    add        sp, sp, #8
 80006d6:	b002      	add	sp, #8

    ldmfd    sp!, {r4-r11, pc}
 80006d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080006dc <xmp3_PolyphaseMono>:


// void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
	.thumb_func
xmp3_PolyphaseMono:
    stmfd    sp!, {r4-r11, r14}
 80006dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    
// clear out stack space for 4 local variables (4 bytes each)
    sub        sp, sp, #8
 80006e0:	b082      	sub	sp, #8
    str        PCM, [sp, #4]            //; sp[1] = pcm pointer
 80006e2:	9001      	str	r0, [sp, #4]

// special case, output sample 0
    mov        SUM1LL, #RNDVAL          //; load rndVal (low 32)
 80006e4:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM1LH, #0
 80006e8:	f04f 0500 	mov.w	r5, #0

    MC0M    0
 80006ec:	f852 cb04 	ldr.w	ip, [r2], #4
 80006f0:	f852 eb04 	ldr.w	lr, [r2], #4
 80006f4:	6808      	ldr	r0, [r1, #0]
 80006f6:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 80006f8:	f1ce 0e00 	rsb	lr, lr, #0
 80006fc:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000700:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    1
 8000704:	f852 cb04 	ldr.w	ip, [r2], #4
 8000708:	f852 eb04 	ldr.w	lr, [r2], #4
 800070c:	6848      	ldr	r0, [r1, #4]
 800070e:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 8000710:	f1ce 0e00 	rsb	lr, lr, #0
 8000714:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000718:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    2
 800071c:	f852 cb04 	ldr.w	ip, [r2], #4
 8000720:	f852 eb04 	ldr.w	lr, [r2], #4
 8000724:	6888      	ldr	r0, [r1, #8]
 8000726:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 8000728:	f1ce 0e00 	rsb	lr, lr, #0
 800072c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000730:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    3
 8000734:	f852 cb04 	ldr.w	ip, [r2], #4
 8000738:	f852 eb04 	ldr.w	lr, [r2], #4
 800073c:	68c8      	ldr	r0, [r1, #12]
 800073e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 8000740:	f1ce 0e00 	rsb	lr, lr, #0
 8000744:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000748:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    4
 800074c:	f852 cb04 	ldr.w	ip, [r2], #4
 8000750:	f852 eb04 	ldr.w	lr, [r2], #4
 8000754:	6908      	ldr	r0, [r1, #16]
 8000756:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 8000758:	f1ce 0e00 	rsb	lr, lr, #0
 800075c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000760:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    5
 8000764:	f852 cb04 	ldr.w	ip, [r2], #4
 8000768:	f852 eb04 	ldr.w	lr, [r2], #4
 800076c:	6948      	ldr	r0, [r1, #20]
 800076e:	6c8b      	ldr	r3, [r1, #72]	; 0x48
 8000770:	f1ce 0e00 	rsb	lr, lr, #0
 8000774:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000778:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    6
 800077c:	f852 cb04 	ldr.w	ip, [r2], #4
 8000780:	f852 eb04 	ldr.w	lr, [r2], #4
 8000784:	6988      	ldr	r0, [r1, #24]
 8000786:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8000788:	f1ce 0e00 	rsb	lr, lr, #0
 800078c:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000790:	fbc3 450e 	smlal	r4, r5, r3, lr
    MC0M    7
 8000794:	f852 cb04 	ldr.w	ip, [r2], #4
 8000798:	f852 eb04 	ldr.w	lr, [r2], #4
 800079c:	69c8      	ldr	r0, [r1, #28]
 800079e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80007a0:	f1ce 0e00 	rsb	lr, lr, #0
 80007a4:	fbc0 450c 	smlal	r4, r5, r0, ip
 80007a8:	fbc3 450e 	smlal	r4, r5, r3, lr

    ldr        PCM, [sp, #4]        // load pcm pointer
 80007ac:	9801      	ldr	r0, [sp, #4]
    mov        MAXPOS, #0x7f00
 80007ae:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr        MAXPOS, MAXPOS, #0xff
 80007b2:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS    	SUM1LL, SUM1LH, SIGN, MAXPOS
 80007b6:	ea4f 6494 	mov.w	r4, r4, lsr #26
 80007ba:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 80007be:	f304 040f 	ssat	r4, #16, r4
    strh    	SUM1LL, [PCM, #(2*0)]
 80007c2:	8004      	strh	r4, [r0, #0]

    // special case, output sample 16
    add        COEF, COEF, #(4*(256-16))    // coef = coefBase + 256 (was coefBase + 16 after MC0M block)
 80007c4:	f502 7270 	add.w	r2, r2, #960	; 0x3c0
    add        VB1, VB1, #(4*1024)          // vb1 = vbuf + 64*16
 80007c8:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    
    mov        SUM1LL, #RNDVAL              // load rndVal (low 32)
 80007cc:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM1LH, #0
 80007d0:	f04f 0500 	mov.w	r5, #0

    MC1M    0
 80007d4:	f852 cb04 	ldr.w	ip, [r2], #4
 80007d8:	6808      	ldr	r0, [r1, #0]
 80007da:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    1
 80007de:	f852 cb04 	ldr.w	ip, [r2], #4
 80007e2:	6848      	ldr	r0, [r1, #4]
 80007e4:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    2
 80007e8:	f852 cb04 	ldr.w	ip, [r2], #4
 80007ec:	6888      	ldr	r0, [r1, #8]
 80007ee:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    3
 80007f2:	f852 cb04 	ldr.w	ip, [r2], #4
 80007f6:	68c8      	ldr	r0, [r1, #12]
 80007f8:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    4
 80007fc:	f852 cb04 	ldr.w	ip, [r2], #4
 8000800:	6908      	ldr	r0, [r1, #16]
 8000802:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    5
 8000806:	f852 cb04 	ldr.w	ip, [r2], #4
 800080a:	6948      	ldr	r0, [r1, #20]
 800080c:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    6
 8000810:	f852 cb04 	ldr.w	ip, [r2], #4
 8000814:	6988      	ldr	r0, [r1, #24]
 8000816:	fbc0 450c 	smlal	r4, r5, r0, ip
    MC1M    7
 800081a:	f852 cb04 	ldr.w	ip, [r2], #4
 800081e:	69c8      	ldr	r0, [r1, #28]
 8000820:	fbc0 450c 	smlal	r4, r5, r0, ip

    ldr        PCM, [sp, #4]        // load pcm pointer
 8000824:	9801      	ldr	r0, [sp, #4]
    mov        MAXPOS, #0x7f00
 8000826:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr        MAXPOS, MAXPOS, #0xff
 800082a:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS    SUM1LL, SUM1LH, SIGN, MAXPOS
 800082e:	ea4f 6494 	mov.w	r4, r4, lsr #26
 8000832:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8000836:	f304 040f 	ssat	r4, #16, r4

    strh    SUM1LL, [PCM, #(2*16)]
 800083a:	8404      	strh	r4, [r0, #32]

    //; main convolution loop: sum1L = samples 1, 2, 3, ... 15   sum2L = samples 31, 30, ... 17
    sub        COEF, COEF, #(4*(264-16))    //; coef = coefBase + 16 (was coefBase + 264 after MC1M block)
 800083c:	f5a2 7278 	sub.w	r2, r2, #992	; 0x3e0
    sub        VB1, VB1, #(4*(1024-64))     //; vb1 = vbuf + 64 (was vbuf + 64*16 after MC1M block)
 8000840:	f5a1 6170 	sub.w	r1, r1, #3840	; 0xf00
    mov        I, #15                       //; loop counter, count down
 8000844:	f04f 0c0f 	mov.w	ip, #15
    add        PCM, PCM, #(2)               //; pcm++
 8000848:	f100 0002 	add.w	r0, r0, #2

0800084c <LoopPM>:

LoopPM:
    str        I, [sp, #0]                  //; sp[0] = i (loop counter)
 800084c:	f8cd c000 	str.w	ip, [sp]
    str        PCM, [sp, #4]                //; sp[1] = pcm (pointer to pcm buffer)
 8000850:	9001      	str	r0, [sp, #4]
    
    mov        SUM1LL, #RNDVAL              //; load rndVal (low 32)
 8000852:	f04f 7400 	mov.w	r4, #33554432	; 0x2000000
    mov        SUM2LL, #RNDVAL              //; load rndVal (low 32)
 8000856:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
    mov        SUM1LH, #0
 800085a:	f04f 0500 	mov.w	r5, #0
    mov        SUM2LH, #0
 800085e:	f04f 0700 	mov.w	r7, #0

    MC2M    0
 8000862:	f852 cb04 	ldr.w	ip, [r2], #4
 8000866:	f852 eb04 	ldr.w	lr, [r2], #4
 800086a:	6808      	ldr	r0, [r1, #0]
 800086c:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 800086e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000872:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000876:	f1ce 0e00 	rsb	lr, lr, #0
 800087a:	fbc3 450e 	smlal	r4, r5, r3, lr
 800087e:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    1
 8000882:	f852 cb04 	ldr.w	ip, [r2], #4
 8000886:	f852 eb04 	ldr.w	lr, [r2], #4
 800088a:	6848      	ldr	r0, [r1, #4]
 800088c:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 800088e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000892:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000896:	f1ce 0e00 	rsb	lr, lr, #0
 800089a:	fbc3 450e 	smlal	r4, r5, r3, lr
 800089e:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    2
 80008a2:	f852 cb04 	ldr.w	ip, [r2], #4
 80008a6:	f852 eb04 	ldr.w	lr, [r2], #4
 80008aa:	6888      	ldr	r0, [r1, #8]
 80008ac:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 80008ae:	fbc0 450c 	smlal	r4, r5, r0, ip
 80008b2:	fbc0 670e 	smlal	r6, r7, r0, lr
 80008b6:	f1ce 0e00 	rsb	lr, lr, #0
 80008ba:	fbc3 450e 	smlal	r4, r5, r3, lr
 80008be:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    3
 80008c2:	f852 cb04 	ldr.w	ip, [r2], #4
 80008c6:	f852 eb04 	ldr.w	lr, [r2], #4
 80008ca:	68c8      	ldr	r0, [r1, #12]
 80008cc:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 80008ce:	fbc0 450c 	smlal	r4, r5, r0, ip
 80008d2:	fbc0 670e 	smlal	r6, r7, r0, lr
 80008d6:	f1ce 0e00 	rsb	lr, lr, #0
 80008da:	fbc3 450e 	smlal	r4, r5, r3, lr
 80008de:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    4
 80008e2:	f852 cb04 	ldr.w	ip, [r2], #4
 80008e6:	f852 eb04 	ldr.w	lr, [r2], #4
 80008ea:	6908      	ldr	r0, [r1, #16]
 80008ec:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 80008ee:	fbc0 450c 	smlal	r4, r5, r0, ip
 80008f2:	fbc0 670e 	smlal	r6, r7, r0, lr
 80008f6:	f1ce 0e00 	rsb	lr, lr, #0
 80008fa:	fbc3 450e 	smlal	r4, r5, r3, lr
 80008fe:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    5
 8000902:	f852 cb04 	ldr.w	ip, [r2], #4
 8000906:	f852 eb04 	ldr.w	lr, [r2], #4
 800090a:	6948      	ldr	r0, [r1, #20]
 800090c:	6c8b      	ldr	r3, [r1, #72]	; 0x48
 800090e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000912:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000916:	f1ce 0e00 	rsb	lr, lr, #0
 800091a:	fbc3 450e 	smlal	r4, r5, r3, lr
 800091e:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    6
 8000922:	f852 cb04 	ldr.w	ip, [r2], #4
 8000926:	f852 eb04 	ldr.w	lr, [r2], #4
 800092a:	6988      	ldr	r0, [r1, #24]
 800092c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800092e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000932:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000936:	f1ce 0e00 	rsb	lr, lr, #0
 800093a:	fbc3 450e 	smlal	r4, r5, r3, lr
 800093e:	fbc3 670c 	smlal	r6, r7, r3, ip
    MC2M    7
 8000942:	f852 cb04 	ldr.w	ip, [r2], #4
 8000946:	f852 eb04 	ldr.w	lr, [r2], #4
 800094a:	69c8      	ldr	r0, [r1, #28]
 800094c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800094e:	fbc0 450c 	smlal	r4, r5, r0, ip
 8000952:	fbc0 670e 	smlal	r6, r7, r0, lr
 8000956:	f1ce 0e00 	rsb	lr, lr, #0
 800095a:	fbc3 450e 	smlal	r4, r5, r3, lr
 800095e:	fbc3 670c 	smlal	r6, r7, r3, ip
    
    add        VB1, VB1, #(4*64)    //; vb1 += 64
 8000962:	f501 7180 	add.w	r1, r1, #256	; 0x100
    
    ldr        PCM, [sp, #4]        //; load pcm pointer
 8000966:	9801      	ldr	r0, [sp, #4]
    mov        MAXPOS, #0x7f00
 8000968:	f44f 4efe 	mov.w	lr, #32512	; 0x7f00
    orr        MAXPOS, MAXPOS, #0xff
 800096c:	f04e 0eff 	orr.w	lr, lr, #255	; 0xff
    
    C64TOS    SUM1LL, SUM1LH, SIGN, MAXPOS
 8000970:	ea4f 6494 	mov.w	r4, r4, lsr #26
 8000974:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
 8000978:	f304 040f 	ssat	r4, #16, r4
    C64TOS    SUM2LL, SUM2LH, SIGN, MAXPOS
 800097c:	ea4f 6696 	mov.w	r6, r6, lsr #26
 8000980:	ea46 1687 	orr.w	r6, r6, r7, lsl #6
 8000984:	f306 060f 	ssat	r6, #16, r6
    
    ldr        I, [sp, #0]            //; load loop counter*/
 8000988:	f8dd c000 	ldr.w	ip, [sp]
    add        CF2, PCM, I, lsl #2   // ; CF2 = PCM + 2*i (short offset)*/
 800098c:	eb00 0e8c 	add.w	lr, r0, ip, lsl #2
    strh    SUM2LL, [CF2], #2    	  //; (pcm + 2*i + 0)
 8000990:	f82e 6b02 	strh.w	r6, [lr], #2
    strh    SUM1LL, [PCM], #2         //; (pcm + 0) ; pcm++
 8000994:	f820 4b02 	strh.w	r4, [r0], #2
    
    subs    I, I, #1
 8000998:	f1bc 0c01 	subs.w	ip, ip, #1
    bne        LoopPM
 800099c:	f47f af56 	bne.w	800084c <LoopPM>

    //; restore stack pointer
    add        sp, sp, #8
 80009a0:	b002      	add	sp, #8

    ldmfd    sp!, {r4-r11, pc}
 80009a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080009a6 <strcmp>:
 80009a6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80009aa:	f811 3b01 	ldrb.w	r3, [r1], #1
 80009ae:	2a01      	cmp	r2, #1
 80009b0:	bf28      	it	cs
 80009b2:	429a      	cmpcs	r2, r3
 80009b4:	d0f7      	beq.n	80009a6 <strcmp>
 80009b6:	1ad0      	subs	r0, r2, r3
 80009b8:	4770      	bx	lr

080009ba <strlen>:
 80009ba:	4603      	mov	r3, r0
 80009bc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80009c0:	2a00      	cmp	r2, #0
 80009c2:	d1fb      	bne.n	80009bc <strlen+0x2>
 80009c4:	1a18      	subs	r0, r3, r0
 80009c6:	3801      	subs	r0, #1
 80009c8:	4770      	bx	lr
 80009ca:	0000      	movs	r0, r0
 80009cc:	0000      	movs	r0, r0
	...

080009d0 <memchr>:
 80009d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80009d4:	2a10      	cmp	r2, #16
 80009d6:	db2b      	blt.n	8000a30 <memchr+0x60>
 80009d8:	f010 0f07 	tst.w	r0, #7
 80009dc:	d008      	beq.n	80009f0 <memchr+0x20>
 80009de:	f810 3b01 	ldrb.w	r3, [r0], #1
 80009e2:	3a01      	subs	r2, #1
 80009e4:	428b      	cmp	r3, r1
 80009e6:	d02d      	beq.n	8000a44 <memchr+0x74>
 80009e8:	f010 0f07 	tst.w	r0, #7
 80009ec:	b342      	cbz	r2, 8000a40 <memchr+0x70>
 80009ee:	d1f6      	bne.n	80009de <memchr+0xe>
 80009f0:	b4f0      	push	{r4, r5, r6, r7}
 80009f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80009f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80009fa:	f022 0407 	bic.w	r4, r2, #7
 80009fe:	f07f 0700 	mvns.w	r7, #0
 8000a02:	2300      	movs	r3, #0
 8000a04:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000a08:	3c08      	subs	r4, #8
 8000a0a:	ea85 0501 	eor.w	r5, r5, r1
 8000a0e:	ea86 0601 	eor.w	r6, r6, r1
 8000a12:	fa85 f547 	uadd8	r5, r5, r7
 8000a16:	faa3 f587 	sel	r5, r3, r7
 8000a1a:	fa86 f647 	uadd8	r6, r6, r7
 8000a1e:	faa5 f687 	sel	r6, r5, r7
 8000a22:	b98e      	cbnz	r6, 8000a48 <memchr+0x78>
 8000a24:	d1ee      	bne.n	8000a04 <memchr+0x34>
 8000a26:	bcf0      	pop	{r4, r5, r6, r7}
 8000a28:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000a2c:	f002 0207 	and.w	r2, r2, #7
 8000a30:	b132      	cbz	r2, 8000a40 <memchr+0x70>
 8000a32:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000a36:	3a01      	subs	r2, #1
 8000a38:	ea83 0301 	eor.w	r3, r3, r1
 8000a3c:	b113      	cbz	r3, 8000a44 <memchr+0x74>
 8000a3e:	d1f8      	bne.n	8000a32 <memchr+0x62>
 8000a40:	2000      	movs	r0, #0
 8000a42:	4770      	bx	lr
 8000a44:	3801      	subs	r0, #1
 8000a46:	4770      	bx	lr
 8000a48:	2d00      	cmp	r5, #0
 8000a4a:	bf06      	itte	eq
 8000a4c:	4635      	moveq	r5, r6
 8000a4e:	3803      	subeq	r0, #3
 8000a50:	3807      	subne	r0, #7
 8000a52:	f015 0f01 	tst.w	r5, #1
 8000a56:	d107      	bne.n	8000a68 <memchr+0x98>
 8000a58:	3001      	adds	r0, #1
 8000a5a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8000a5e:	bf02      	ittt	eq
 8000a60:	3001      	addeq	r0, #1
 8000a62:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000a66:	3001      	addeq	r0, #1
 8000a68:	bcf0      	pop	{r4, r5, r6, r7}
 8000a6a:	3801      	subs	r0, #1
 8000a6c:	4770      	bx	lr
 8000a6e:	bf00      	nop

08000a70 <__aeabi_drsub>:
 8000a70:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000a74:	e002      	b.n	8000a7c <__adddf3>
 8000a76:	bf00      	nop

08000a78 <__aeabi_dsub>:
 8000a78:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000a7c <__adddf3>:
 8000a7c:	b530      	push	{r4, r5, lr}
 8000a7e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000a82:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000a86:	ea94 0f05 	teq	r4, r5
 8000a8a:	bf08      	it	eq
 8000a8c:	ea90 0f02 	teqeq	r0, r2
 8000a90:	bf1f      	itttt	ne
 8000a92:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000a96:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000a9a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000a9e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000aa2:	f000 80e2 	beq.w	8000c6a <__adddf3+0x1ee>
 8000aa6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000aaa:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000aae:	bfb8      	it	lt
 8000ab0:	426d      	neglt	r5, r5
 8000ab2:	dd0c      	ble.n	8000ace <__adddf3+0x52>
 8000ab4:	442c      	add	r4, r5
 8000ab6:	ea80 0202 	eor.w	r2, r0, r2
 8000aba:	ea81 0303 	eor.w	r3, r1, r3
 8000abe:	ea82 0000 	eor.w	r0, r2, r0
 8000ac2:	ea83 0101 	eor.w	r1, r3, r1
 8000ac6:	ea80 0202 	eor.w	r2, r0, r2
 8000aca:	ea81 0303 	eor.w	r3, r1, r3
 8000ace:	2d36      	cmp	r5, #54	; 0x36
 8000ad0:	bf88      	it	hi
 8000ad2:	bd30      	pophi	{r4, r5, pc}
 8000ad4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000ad8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000adc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000ae0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000ae4:	d002      	beq.n	8000aec <__adddf3+0x70>
 8000ae6:	4240      	negs	r0, r0
 8000ae8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000aec:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000af0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000af4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000af8:	d002      	beq.n	8000b00 <__adddf3+0x84>
 8000afa:	4252      	negs	r2, r2
 8000afc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000b00:	ea94 0f05 	teq	r4, r5
 8000b04:	f000 80a7 	beq.w	8000c56 <__adddf3+0x1da>
 8000b08:	f1a4 0401 	sub.w	r4, r4, #1
 8000b0c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000b10:	db0d      	blt.n	8000b2e <__adddf3+0xb2>
 8000b12:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000b16:	fa22 f205 	lsr.w	r2, r2, r5
 8000b1a:	1880      	adds	r0, r0, r2
 8000b1c:	f141 0100 	adc.w	r1, r1, #0
 8000b20:	fa03 f20e 	lsl.w	r2, r3, lr
 8000b24:	1880      	adds	r0, r0, r2
 8000b26:	fa43 f305 	asr.w	r3, r3, r5
 8000b2a:	4159      	adcs	r1, r3
 8000b2c:	e00e      	b.n	8000b4c <__adddf3+0xd0>
 8000b2e:	f1a5 0520 	sub.w	r5, r5, #32
 8000b32:	f10e 0e20 	add.w	lr, lr, #32
 8000b36:	2a01      	cmp	r2, #1
 8000b38:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000b3c:	bf28      	it	cs
 8000b3e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000b42:	fa43 f305 	asr.w	r3, r3, r5
 8000b46:	18c0      	adds	r0, r0, r3
 8000b48:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000b4c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000b50:	d507      	bpl.n	8000b62 <__adddf3+0xe6>
 8000b52:	f04f 0e00 	mov.w	lr, #0
 8000b56:	f1dc 0c00 	rsbs	ip, ip, #0
 8000b5a:	eb7e 0000 	sbcs.w	r0, lr, r0
 8000b5e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000b62:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000b66:	d31b      	bcc.n	8000ba0 <__adddf3+0x124>
 8000b68:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000b6c:	d30c      	bcc.n	8000b88 <__adddf3+0x10c>
 8000b6e:	0849      	lsrs	r1, r1, #1
 8000b70:	ea5f 0030 	movs.w	r0, r0, rrx
 8000b74:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000b78:	f104 0401 	add.w	r4, r4, #1
 8000b7c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000b80:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000b84:	f080 809a 	bcs.w	8000cbc <__adddf3+0x240>
 8000b88:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000b8c:	bf08      	it	eq
 8000b8e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000b92:	f150 0000 	adcs.w	r0, r0, #0
 8000b96:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b9a:	ea41 0105 	orr.w	r1, r1, r5
 8000b9e:	bd30      	pop	{r4, r5, pc}
 8000ba0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000ba4:	4140      	adcs	r0, r0
 8000ba6:	eb41 0101 	adc.w	r1, r1, r1
 8000baa:	3c01      	subs	r4, #1
 8000bac:	bf28      	it	cs
 8000bae:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000bb2:	d2e9      	bcs.n	8000b88 <__adddf3+0x10c>
 8000bb4:	f091 0f00 	teq	r1, #0
 8000bb8:	bf04      	itt	eq
 8000bba:	4601      	moveq	r1, r0
 8000bbc:	2000      	moveq	r0, #0
 8000bbe:	fab1 f381 	clz	r3, r1
 8000bc2:	bf08      	it	eq
 8000bc4:	3320      	addeq	r3, #32
 8000bc6:	f1a3 030b 	sub.w	r3, r3, #11
 8000bca:	f1b3 0220 	subs.w	r2, r3, #32
 8000bce:	da0c      	bge.n	8000bea <__adddf3+0x16e>
 8000bd0:	320c      	adds	r2, #12
 8000bd2:	dd08      	ble.n	8000be6 <__adddf3+0x16a>
 8000bd4:	f102 0c14 	add.w	ip, r2, #20
 8000bd8:	f1c2 020c 	rsb	r2, r2, #12
 8000bdc:	fa01 f00c 	lsl.w	r0, r1, ip
 8000be0:	fa21 f102 	lsr.w	r1, r1, r2
 8000be4:	e00c      	b.n	8000c00 <__adddf3+0x184>
 8000be6:	f102 0214 	add.w	r2, r2, #20
 8000bea:	bfd8      	it	le
 8000bec:	f1c2 0c20 	rsble	ip, r2, #32
 8000bf0:	fa01 f102 	lsl.w	r1, r1, r2
 8000bf4:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000bf8:	bfdc      	itt	le
 8000bfa:	ea41 010c 	orrle.w	r1, r1, ip
 8000bfe:	4090      	lslle	r0, r2
 8000c00:	1ae4      	subs	r4, r4, r3
 8000c02:	bfa2      	ittt	ge
 8000c04:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000c08:	4329      	orrge	r1, r5
 8000c0a:	bd30      	popge	{r4, r5, pc}
 8000c0c:	ea6f 0404 	mvn.w	r4, r4
 8000c10:	3c1f      	subs	r4, #31
 8000c12:	da1c      	bge.n	8000c4e <__adddf3+0x1d2>
 8000c14:	340c      	adds	r4, #12
 8000c16:	dc0e      	bgt.n	8000c36 <__adddf3+0x1ba>
 8000c18:	f104 0414 	add.w	r4, r4, #20
 8000c1c:	f1c4 0220 	rsb	r2, r4, #32
 8000c20:	fa20 f004 	lsr.w	r0, r0, r4
 8000c24:	fa01 f302 	lsl.w	r3, r1, r2
 8000c28:	ea40 0003 	orr.w	r0, r0, r3
 8000c2c:	fa21 f304 	lsr.w	r3, r1, r4
 8000c30:	ea45 0103 	orr.w	r1, r5, r3
 8000c34:	bd30      	pop	{r4, r5, pc}
 8000c36:	f1c4 040c 	rsb	r4, r4, #12
 8000c3a:	f1c4 0220 	rsb	r2, r4, #32
 8000c3e:	fa20 f002 	lsr.w	r0, r0, r2
 8000c42:	fa01 f304 	lsl.w	r3, r1, r4
 8000c46:	ea40 0003 	orr.w	r0, r0, r3
 8000c4a:	4629      	mov	r1, r5
 8000c4c:	bd30      	pop	{r4, r5, pc}
 8000c4e:	fa21 f004 	lsr.w	r0, r1, r4
 8000c52:	4629      	mov	r1, r5
 8000c54:	bd30      	pop	{r4, r5, pc}
 8000c56:	f094 0f00 	teq	r4, #0
 8000c5a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8000c5e:	bf06      	itte	eq
 8000c60:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000c64:	3401      	addeq	r4, #1
 8000c66:	3d01      	subne	r5, #1
 8000c68:	e74e      	b.n	8000b08 <__adddf3+0x8c>
 8000c6a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000c6e:	bf18      	it	ne
 8000c70:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000c74:	d029      	beq.n	8000cca <__adddf3+0x24e>
 8000c76:	ea94 0f05 	teq	r4, r5
 8000c7a:	bf08      	it	eq
 8000c7c:	ea90 0f02 	teqeq	r0, r2
 8000c80:	d005      	beq.n	8000c8e <__adddf3+0x212>
 8000c82:	ea54 0c00 	orrs.w	ip, r4, r0
 8000c86:	bf04      	itt	eq
 8000c88:	4619      	moveq	r1, r3
 8000c8a:	4610      	moveq	r0, r2
 8000c8c:	bd30      	pop	{r4, r5, pc}
 8000c8e:	ea91 0f03 	teq	r1, r3
 8000c92:	bf1e      	ittt	ne
 8000c94:	2100      	movne	r1, #0
 8000c96:	2000      	movne	r0, #0
 8000c98:	bd30      	popne	{r4, r5, pc}
 8000c9a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000c9e:	d105      	bne.n	8000cac <__adddf3+0x230>
 8000ca0:	0040      	lsls	r0, r0, #1
 8000ca2:	4149      	adcs	r1, r1
 8000ca4:	bf28      	it	cs
 8000ca6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000caa:	bd30      	pop	{r4, r5, pc}
 8000cac:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000cb0:	bf3c      	itt	cc
 8000cb2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000cb6:	bd30      	popcc	{r4, r5, pc}
 8000cb8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000cbc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000cc0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000cc4:	f04f 0000 	mov.w	r0, #0
 8000cc8:	bd30      	pop	{r4, r5, pc}
 8000cca:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000cce:	bf1a      	itte	ne
 8000cd0:	4619      	movne	r1, r3
 8000cd2:	4610      	movne	r0, r2
 8000cd4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000cd8:	bf1c      	itt	ne
 8000cda:	460b      	movne	r3, r1
 8000cdc:	4602      	movne	r2, r0
 8000cde:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000ce2:	bf06      	itte	eq
 8000ce4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000ce8:	ea91 0f03 	teqeq	r1, r3
 8000cec:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000cf0:	bd30      	pop	{r4, r5, pc}
 8000cf2:	bf00      	nop

08000cf4 <__aeabi_ui2d>:
 8000cf4:	f090 0f00 	teq	r0, #0
 8000cf8:	bf04      	itt	eq
 8000cfa:	2100      	moveq	r1, #0
 8000cfc:	4770      	bxeq	lr
 8000cfe:	b530      	push	{r4, r5, lr}
 8000d00:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000d04:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000d08:	f04f 0500 	mov.w	r5, #0
 8000d0c:	f04f 0100 	mov.w	r1, #0
 8000d10:	e750      	b.n	8000bb4 <__adddf3+0x138>
 8000d12:	bf00      	nop

08000d14 <__aeabi_i2d>:
 8000d14:	f090 0f00 	teq	r0, #0
 8000d18:	bf04      	itt	eq
 8000d1a:	2100      	moveq	r1, #0
 8000d1c:	4770      	bxeq	lr
 8000d1e:	b530      	push	{r4, r5, lr}
 8000d20:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000d24:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000d28:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000d2c:	bf48      	it	mi
 8000d2e:	4240      	negmi	r0, r0
 8000d30:	f04f 0100 	mov.w	r1, #0
 8000d34:	e73e      	b.n	8000bb4 <__adddf3+0x138>
 8000d36:	bf00      	nop

08000d38 <__aeabi_f2d>:
 8000d38:	0042      	lsls	r2, r0, #1
 8000d3a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8000d3e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000d42:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000d46:	bf1f      	itttt	ne
 8000d48:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000d4c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000d50:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000d54:	4770      	bxne	lr
 8000d56:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8000d5a:	bf08      	it	eq
 8000d5c:	4770      	bxeq	lr
 8000d5e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000d62:	bf04      	itt	eq
 8000d64:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000d68:	4770      	bxeq	lr
 8000d6a:	b530      	push	{r4, r5, lr}
 8000d6c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000d70:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000d74:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000d78:	e71c      	b.n	8000bb4 <__adddf3+0x138>
 8000d7a:	bf00      	nop

08000d7c <__aeabi_ul2d>:
 8000d7c:	ea50 0201 	orrs.w	r2, r0, r1
 8000d80:	bf08      	it	eq
 8000d82:	4770      	bxeq	lr
 8000d84:	b530      	push	{r4, r5, lr}
 8000d86:	f04f 0500 	mov.w	r5, #0
 8000d8a:	e00a      	b.n	8000da2 <__aeabi_l2d+0x16>

08000d8c <__aeabi_l2d>:
 8000d8c:	ea50 0201 	orrs.w	r2, r0, r1
 8000d90:	bf08      	it	eq
 8000d92:	4770      	bxeq	lr
 8000d94:	b530      	push	{r4, r5, lr}
 8000d96:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000d9a:	d502      	bpl.n	8000da2 <__aeabi_l2d+0x16>
 8000d9c:	4240      	negs	r0, r0
 8000d9e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000da2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000da6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000daa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000dae:	f43f aed8 	beq.w	8000b62 <__adddf3+0xe6>
 8000db2:	f04f 0203 	mov.w	r2, #3
 8000db6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000dba:	bf18      	it	ne
 8000dbc:	3203      	addne	r2, #3
 8000dbe:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000dc2:	bf18      	it	ne
 8000dc4:	3203      	addne	r2, #3
 8000dc6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000dca:	f1c2 0320 	rsb	r3, r2, #32
 8000dce:	fa00 fc03 	lsl.w	ip, r0, r3
 8000dd2:	fa20 f002 	lsr.w	r0, r0, r2
 8000dd6:	fa01 fe03 	lsl.w	lr, r1, r3
 8000dda:	ea40 000e 	orr.w	r0, r0, lr
 8000dde:	fa21 f102 	lsr.w	r1, r1, r2
 8000de2:	4414      	add	r4, r2
 8000de4:	e6bd      	b.n	8000b62 <__adddf3+0xe6>
 8000de6:	bf00      	nop

08000de8 <__aeabi_dmul>:
 8000de8:	b570      	push	{r4, r5, r6, lr}
 8000dea:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000dee:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000df2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000df6:	bf1d      	ittte	ne
 8000df8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000dfc:	ea94 0f0c 	teqne	r4, ip
 8000e00:	ea95 0f0c 	teqne	r5, ip
 8000e04:	f000 f8de 	bleq	8000fc4 <__aeabi_dmul+0x1dc>
 8000e08:	442c      	add	r4, r5
 8000e0a:	ea81 0603 	eor.w	r6, r1, r3
 8000e0e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000e12:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000e16:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000e1a:	bf18      	it	ne
 8000e1c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000e20:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000e24:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000e28:	d038      	beq.n	8000e9c <__aeabi_dmul+0xb4>
 8000e2a:	fba0 ce02 	umull	ip, lr, r0, r2
 8000e2e:	f04f 0500 	mov.w	r5, #0
 8000e32:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000e36:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000e3a:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000e3e:	f04f 0600 	mov.w	r6, #0
 8000e42:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000e46:	f09c 0f00 	teq	ip, #0
 8000e4a:	bf18      	it	ne
 8000e4c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000e50:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000e54:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000e58:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000e5c:	d204      	bcs.n	8000e68 <__aeabi_dmul+0x80>
 8000e5e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000e62:	416d      	adcs	r5, r5
 8000e64:	eb46 0606 	adc.w	r6, r6, r6
 8000e68:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000e6c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000e70:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000e74:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000e78:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000e7c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000e80:	bf88      	it	hi
 8000e82:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000e86:	d81e      	bhi.n	8000ec6 <__aeabi_dmul+0xde>
 8000e88:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000e8c:	bf08      	it	eq
 8000e8e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000e92:	f150 0000 	adcs.w	r0, r0, #0
 8000e96:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000e9a:	bd70      	pop	{r4, r5, r6, pc}
 8000e9c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000ea0:	ea46 0101 	orr.w	r1, r6, r1
 8000ea4:	ea40 0002 	orr.w	r0, r0, r2
 8000ea8:	ea81 0103 	eor.w	r1, r1, r3
 8000eac:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000eb0:	bfc2      	ittt	gt
 8000eb2:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000eb6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000eba:	bd70      	popgt	{r4, r5, r6, pc}
 8000ebc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000ec0:	f04f 0e00 	mov.w	lr, #0
 8000ec4:	3c01      	subs	r4, #1
 8000ec6:	f300 80ab 	bgt.w	8001020 <__aeabi_dmul+0x238>
 8000eca:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000ece:	bfde      	ittt	le
 8000ed0:	2000      	movle	r0, #0
 8000ed2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000ed6:	bd70      	pople	{r4, r5, r6, pc}
 8000ed8:	f1c4 0400 	rsb	r4, r4, #0
 8000edc:	3c20      	subs	r4, #32
 8000ede:	da35      	bge.n	8000f4c <__aeabi_dmul+0x164>
 8000ee0:	340c      	adds	r4, #12
 8000ee2:	dc1b      	bgt.n	8000f1c <__aeabi_dmul+0x134>
 8000ee4:	f104 0414 	add.w	r4, r4, #20
 8000ee8:	f1c4 0520 	rsb	r5, r4, #32
 8000eec:	fa00 f305 	lsl.w	r3, r0, r5
 8000ef0:	fa20 f004 	lsr.w	r0, r0, r4
 8000ef4:	fa01 f205 	lsl.w	r2, r1, r5
 8000ef8:	ea40 0002 	orr.w	r0, r0, r2
 8000efc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000f00:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000f04:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000f08:	fa21 f604 	lsr.w	r6, r1, r4
 8000f0c:	eb42 0106 	adc.w	r1, r2, r6
 8000f10:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000f14:	bf08      	it	eq
 8000f16:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000f1a:	bd70      	pop	{r4, r5, r6, pc}
 8000f1c:	f1c4 040c 	rsb	r4, r4, #12
 8000f20:	f1c4 0520 	rsb	r5, r4, #32
 8000f24:	fa00 f304 	lsl.w	r3, r0, r4
 8000f28:	fa20 f005 	lsr.w	r0, r0, r5
 8000f2c:	fa01 f204 	lsl.w	r2, r1, r4
 8000f30:	ea40 0002 	orr.w	r0, r0, r2
 8000f34:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000f38:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000f3c:	f141 0100 	adc.w	r1, r1, #0
 8000f40:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000f44:	bf08      	it	eq
 8000f46:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000f4a:	bd70      	pop	{r4, r5, r6, pc}
 8000f4c:	f1c4 0520 	rsb	r5, r4, #32
 8000f50:	fa00 f205 	lsl.w	r2, r0, r5
 8000f54:	ea4e 0e02 	orr.w	lr, lr, r2
 8000f58:	fa20 f304 	lsr.w	r3, r0, r4
 8000f5c:	fa01 f205 	lsl.w	r2, r1, r5
 8000f60:	ea43 0302 	orr.w	r3, r3, r2
 8000f64:	fa21 f004 	lsr.w	r0, r1, r4
 8000f68:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000f6c:	fa21 f204 	lsr.w	r2, r1, r4
 8000f70:	ea20 0002 	bic.w	r0, r0, r2
 8000f74:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000f78:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000f7c:	bf08      	it	eq
 8000f7e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000f82:	bd70      	pop	{r4, r5, r6, pc}
 8000f84:	f094 0f00 	teq	r4, #0
 8000f88:	d10f      	bne.n	8000faa <__aeabi_dmul+0x1c2>
 8000f8a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000f8e:	0040      	lsls	r0, r0, #1
 8000f90:	eb41 0101 	adc.w	r1, r1, r1
 8000f94:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000f98:	bf08      	it	eq
 8000f9a:	3c01      	subeq	r4, #1
 8000f9c:	d0f7      	beq.n	8000f8e <__aeabi_dmul+0x1a6>
 8000f9e:	ea41 0106 	orr.w	r1, r1, r6
 8000fa2:	f095 0f00 	teq	r5, #0
 8000fa6:	bf18      	it	ne
 8000fa8:	4770      	bxne	lr
 8000faa:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000fae:	0052      	lsls	r2, r2, #1
 8000fb0:	eb43 0303 	adc.w	r3, r3, r3
 8000fb4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000fb8:	bf08      	it	eq
 8000fba:	3d01      	subeq	r5, #1
 8000fbc:	d0f7      	beq.n	8000fae <__aeabi_dmul+0x1c6>
 8000fbe:	ea43 0306 	orr.w	r3, r3, r6
 8000fc2:	4770      	bx	lr
 8000fc4:	ea94 0f0c 	teq	r4, ip
 8000fc8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000fcc:	bf18      	it	ne
 8000fce:	ea95 0f0c 	teqne	r5, ip
 8000fd2:	d00c      	beq.n	8000fee <__aeabi_dmul+0x206>
 8000fd4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000fd8:	bf18      	it	ne
 8000fda:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000fde:	d1d1      	bne.n	8000f84 <__aeabi_dmul+0x19c>
 8000fe0:	ea81 0103 	eor.w	r1, r1, r3
 8000fe4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000fe8:	f04f 0000 	mov.w	r0, #0
 8000fec:	bd70      	pop	{r4, r5, r6, pc}
 8000fee:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000ff2:	bf06      	itte	eq
 8000ff4:	4610      	moveq	r0, r2
 8000ff6:	4619      	moveq	r1, r3
 8000ff8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000ffc:	d019      	beq.n	8001032 <__aeabi_dmul+0x24a>
 8000ffe:	ea94 0f0c 	teq	r4, ip
 8001002:	d102      	bne.n	800100a <__aeabi_dmul+0x222>
 8001004:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8001008:	d113      	bne.n	8001032 <__aeabi_dmul+0x24a>
 800100a:	ea95 0f0c 	teq	r5, ip
 800100e:	d105      	bne.n	800101c <__aeabi_dmul+0x234>
 8001010:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8001014:	bf1c      	itt	ne
 8001016:	4610      	movne	r0, r2
 8001018:	4619      	movne	r1, r3
 800101a:	d10a      	bne.n	8001032 <__aeabi_dmul+0x24a>
 800101c:	ea81 0103 	eor.w	r1, r1, r3
 8001020:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8001024:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8001028:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800102c:	f04f 0000 	mov.w	r0, #0
 8001030:	bd70      	pop	{r4, r5, r6, pc}
 8001032:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8001036:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800103a:	bd70      	pop	{r4, r5, r6, pc}

0800103c <__aeabi_ddiv>:
 800103c:	b570      	push	{r4, r5, r6, lr}
 800103e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8001042:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8001046:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800104a:	bf1d      	ittte	ne
 800104c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8001050:	ea94 0f0c 	teqne	r4, ip
 8001054:	ea95 0f0c 	teqne	r5, ip
 8001058:	f000 f8a7 	bleq	80011aa <__aeabi_ddiv+0x16e>
 800105c:	eba4 0405 	sub.w	r4, r4, r5
 8001060:	ea81 0e03 	eor.w	lr, r1, r3
 8001064:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8001068:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800106c:	f000 8088 	beq.w	8001180 <__aeabi_ddiv+0x144>
 8001070:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8001074:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8001078:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800107c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8001080:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8001084:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8001088:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800108c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8001090:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8001094:	429d      	cmp	r5, r3
 8001096:	bf08      	it	eq
 8001098:	4296      	cmpeq	r6, r2
 800109a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800109e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80010a2:	d202      	bcs.n	80010aa <__aeabi_ddiv+0x6e>
 80010a4:	085b      	lsrs	r3, r3, #1
 80010a6:	ea4f 0232 	mov.w	r2, r2, rrx
 80010aa:	1ab6      	subs	r6, r6, r2
 80010ac:	eb65 0503 	sbc.w	r5, r5, r3
 80010b0:	085b      	lsrs	r3, r3, #1
 80010b2:	ea4f 0232 	mov.w	r2, r2, rrx
 80010b6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80010ba:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80010be:	ebb6 0e02 	subs.w	lr, r6, r2
 80010c2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80010c6:	bf22      	ittt	cs
 80010c8:	1ab6      	subcs	r6, r6, r2
 80010ca:	4675      	movcs	r5, lr
 80010cc:	ea40 000c 	orrcs.w	r0, r0, ip
 80010d0:	085b      	lsrs	r3, r3, #1
 80010d2:	ea4f 0232 	mov.w	r2, r2, rrx
 80010d6:	ebb6 0e02 	subs.w	lr, r6, r2
 80010da:	eb75 0e03 	sbcs.w	lr, r5, r3
 80010de:	bf22      	ittt	cs
 80010e0:	1ab6      	subcs	r6, r6, r2
 80010e2:	4675      	movcs	r5, lr
 80010e4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80010e8:	085b      	lsrs	r3, r3, #1
 80010ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80010ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80010f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80010f6:	bf22      	ittt	cs
 80010f8:	1ab6      	subcs	r6, r6, r2
 80010fa:	4675      	movcs	r5, lr
 80010fc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8001100:	085b      	lsrs	r3, r3, #1
 8001102:	ea4f 0232 	mov.w	r2, r2, rrx
 8001106:	ebb6 0e02 	subs.w	lr, r6, r2
 800110a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800110e:	bf22      	ittt	cs
 8001110:	1ab6      	subcs	r6, r6, r2
 8001112:	4675      	movcs	r5, lr
 8001114:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8001118:	ea55 0e06 	orrs.w	lr, r5, r6
 800111c:	d018      	beq.n	8001150 <__aeabi_ddiv+0x114>
 800111e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8001122:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8001126:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800112a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800112e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8001132:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8001136:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800113a:	d1c0      	bne.n	80010be <__aeabi_ddiv+0x82>
 800113c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8001140:	d10b      	bne.n	800115a <__aeabi_ddiv+0x11e>
 8001142:	ea41 0100 	orr.w	r1, r1, r0
 8001146:	f04f 0000 	mov.w	r0, #0
 800114a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800114e:	e7b6      	b.n	80010be <__aeabi_ddiv+0x82>
 8001150:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8001154:	bf04      	itt	eq
 8001156:	4301      	orreq	r1, r0
 8001158:	2000      	moveq	r0, #0
 800115a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800115e:	bf88      	it	hi
 8001160:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8001164:	f63f aeaf 	bhi.w	8000ec6 <__aeabi_dmul+0xde>
 8001168:	ebb5 0c03 	subs.w	ip, r5, r3
 800116c:	bf04      	itt	eq
 800116e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8001172:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8001176:	f150 0000 	adcs.w	r0, r0, #0
 800117a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800117e:	bd70      	pop	{r4, r5, r6, pc}
 8001180:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8001184:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8001188:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800118c:	bfc2      	ittt	gt
 800118e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8001192:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8001196:	bd70      	popgt	{r4, r5, r6, pc}
 8001198:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800119c:	f04f 0e00 	mov.w	lr, #0
 80011a0:	3c01      	subs	r4, #1
 80011a2:	e690      	b.n	8000ec6 <__aeabi_dmul+0xde>
 80011a4:	ea45 0e06 	orr.w	lr, r5, r6
 80011a8:	e68d      	b.n	8000ec6 <__aeabi_dmul+0xde>
 80011aa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80011ae:	ea94 0f0c 	teq	r4, ip
 80011b2:	bf08      	it	eq
 80011b4:	ea95 0f0c 	teqeq	r5, ip
 80011b8:	f43f af3b 	beq.w	8001032 <__aeabi_dmul+0x24a>
 80011bc:	ea94 0f0c 	teq	r4, ip
 80011c0:	d10a      	bne.n	80011d8 <__aeabi_ddiv+0x19c>
 80011c2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80011c6:	f47f af34 	bne.w	8001032 <__aeabi_dmul+0x24a>
 80011ca:	ea95 0f0c 	teq	r5, ip
 80011ce:	f47f af25 	bne.w	800101c <__aeabi_dmul+0x234>
 80011d2:	4610      	mov	r0, r2
 80011d4:	4619      	mov	r1, r3
 80011d6:	e72c      	b.n	8001032 <__aeabi_dmul+0x24a>
 80011d8:	ea95 0f0c 	teq	r5, ip
 80011dc:	d106      	bne.n	80011ec <__aeabi_ddiv+0x1b0>
 80011de:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80011e2:	f43f aefd 	beq.w	8000fe0 <__aeabi_dmul+0x1f8>
 80011e6:	4610      	mov	r0, r2
 80011e8:	4619      	mov	r1, r3
 80011ea:	e722      	b.n	8001032 <__aeabi_dmul+0x24a>
 80011ec:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80011f0:	bf18      	it	ne
 80011f2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80011f6:	f47f aec5 	bne.w	8000f84 <__aeabi_dmul+0x19c>
 80011fa:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80011fe:	f47f af0d 	bne.w	800101c <__aeabi_dmul+0x234>
 8001202:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8001206:	f47f aeeb 	bne.w	8000fe0 <__aeabi_dmul+0x1f8>
 800120a:	e712      	b.n	8001032 <__aeabi_dmul+0x24a>

0800120c <__gedf2>:
 800120c:	f04f 3cff 	mov.w	ip, #4294967295
 8001210:	e006      	b.n	8001220 <__cmpdf2+0x4>
 8001212:	bf00      	nop

08001214 <__ledf2>:
 8001214:	f04f 0c01 	mov.w	ip, #1
 8001218:	e002      	b.n	8001220 <__cmpdf2+0x4>
 800121a:	bf00      	nop

0800121c <__cmpdf2>:
 800121c:	f04f 0c01 	mov.w	ip, #1
 8001220:	f84d cd04 	str.w	ip, [sp, #-4]!
 8001224:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8001228:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800122c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8001230:	bf18      	it	ne
 8001232:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8001236:	d01b      	beq.n	8001270 <__cmpdf2+0x54>
 8001238:	b001      	add	sp, #4
 800123a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800123e:	bf0c      	ite	eq
 8001240:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8001244:	ea91 0f03 	teqne	r1, r3
 8001248:	bf02      	ittt	eq
 800124a:	ea90 0f02 	teqeq	r0, r2
 800124e:	2000      	moveq	r0, #0
 8001250:	4770      	bxeq	lr
 8001252:	f110 0f00 	cmn.w	r0, #0
 8001256:	ea91 0f03 	teq	r1, r3
 800125a:	bf58      	it	pl
 800125c:	4299      	cmppl	r1, r3
 800125e:	bf08      	it	eq
 8001260:	4290      	cmpeq	r0, r2
 8001262:	bf2c      	ite	cs
 8001264:	17d8      	asrcs	r0, r3, #31
 8001266:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800126a:	f040 0001 	orr.w	r0, r0, #1
 800126e:	4770      	bx	lr
 8001270:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8001274:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8001278:	d102      	bne.n	8001280 <__cmpdf2+0x64>
 800127a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800127e:	d107      	bne.n	8001290 <__cmpdf2+0x74>
 8001280:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8001284:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8001288:	d1d6      	bne.n	8001238 <__cmpdf2+0x1c>
 800128a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800128e:	d0d3      	beq.n	8001238 <__cmpdf2+0x1c>
 8001290:	f85d 0b04 	ldr.w	r0, [sp], #4
 8001294:	4770      	bx	lr
 8001296:	bf00      	nop

08001298 <__aeabi_cdrcmple>:
 8001298:	4684      	mov	ip, r0
 800129a:	4610      	mov	r0, r2
 800129c:	4662      	mov	r2, ip
 800129e:	468c      	mov	ip, r1
 80012a0:	4619      	mov	r1, r3
 80012a2:	4663      	mov	r3, ip
 80012a4:	e000      	b.n	80012a8 <__aeabi_cdcmpeq>
 80012a6:	bf00      	nop

080012a8 <__aeabi_cdcmpeq>:
 80012a8:	b501      	push	{r0, lr}
 80012aa:	f7ff ffb7 	bl	800121c <__cmpdf2>
 80012ae:	2800      	cmp	r0, #0
 80012b0:	bf48      	it	mi
 80012b2:	f110 0f00 	cmnmi.w	r0, #0
 80012b6:	bd01      	pop	{r0, pc}

080012b8 <__aeabi_dcmpeq>:
 80012b8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80012bc:	f7ff fff4 	bl	80012a8 <__aeabi_cdcmpeq>
 80012c0:	bf0c      	ite	eq
 80012c2:	2001      	moveq	r0, #1
 80012c4:	2000      	movne	r0, #0
 80012c6:	f85d fb08 	ldr.w	pc, [sp], #8
 80012ca:	bf00      	nop

080012cc <__aeabi_dcmplt>:
 80012cc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80012d0:	f7ff ffea 	bl	80012a8 <__aeabi_cdcmpeq>
 80012d4:	bf34      	ite	cc
 80012d6:	2001      	movcc	r0, #1
 80012d8:	2000      	movcs	r0, #0
 80012da:	f85d fb08 	ldr.w	pc, [sp], #8
 80012de:	bf00      	nop

080012e0 <__aeabi_dcmple>:
 80012e0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80012e4:	f7ff ffe0 	bl	80012a8 <__aeabi_cdcmpeq>
 80012e8:	bf94      	ite	ls
 80012ea:	2001      	movls	r0, #1
 80012ec:	2000      	movhi	r0, #0
 80012ee:	f85d fb08 	ldr.w	pc, [sp], #8
 80012f2:	bf00      	nop

080012f4 <__aeabi_dcmpge>:
 80012f4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80012f8:	f7ff ffce 	bl	8001298 <__aeabi_cdrcmple>
 80012fc:	bf94      	ite	ls
 80012fe:	2001      	movls	r0, #1
 8001300:	2000      	movhi	r0, #0
 8001302:	f85d fb08 	ldr.w	pc, [sp], #8
 8001306:	bf00      	nop

08001308 <__aeabi_dcmpgt>:
 8001308:	f84d ed08 	str.w	lr, [sp, #-8]!
 800130c:	f7ff ffc4 	bl	8001298 <__aeabi_cdrcmple>
 8001310:	bf34      	ite	cc
 8001312:	2001      	movcc	r0, #1
 8001314:	2000      	movcs	r0, #0
 8001316:	f85d fb08 	ldr.w	pc, [sp], #8
 800131a:	bf00      	nop

0800131c <__aeabi_dcmpun>:
 800131c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8001320:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8001324:	d102      	bne.n	800132c <__aeabi_dcmpun+0x10>
 8001326:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800132a:	d10a      	bne.n	8001342 <__aeabi_dcmpun+0x26>
 800132c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8001330:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8001334:	d102      	bne.n	800133c <__aeabi_dcmpun+0x20>
 8001336:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800133a:	d102      	bne.n	8001342 <__aeabi_dcmpun+0x26>
 800133c:	f04f 0000 	mov.w	r0, #0
 8001340:	4770      	bx	lr
 8001342:	f04f 0001 	mov.w	r0, #1
 8001346:	4770      	bx	lr

08001348 <__aeabi_d2iz>:
 8001348:	ea4f 0241 	mov.w	r2, r1, lsl #1
 800134c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8001350:	d215      	bcs.n	800137e <__aeabi_d2iz+0x36>
 8001352:	d511      	bpl.n	8001378 <__aeabi_d2iz+0x30>
 8001354:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8001358:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800135c:	d912      	bls.n	8001384 <__aeabi_d2iz+0x3c>
 800135e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8001362:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001366:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800136a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800136e:	fa23 f002 	lsr.w	r0, r3, r2
 8001372:	bf18      	it	ne
 8001374:	4240      	negne	r0, r0
 8001376:	4770      	bx	lr
 8001378:	f04f 0000 	mov.w	r0, #0
 800137c:	4770      	bx	lr
 800137e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8001382:	d105      	bne.n	8001390 <__aeabi_d2iz+0x48>
 8001384:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8001388:	bf08      	it	eq
 800138a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800138e:	4770      	bx	lr
 8001390:	f04f 0000 	mov.w	r0, #0
 8001394:	4770      	bx	lr
 8001396:	bf00      	nop

08001398 <__aeabi_uldivmod>:
 8001398:	b953      	cbnz	r3, 80013b0 <__aeabi_uldivmod+0x18>
 800139a:	b94a      	cbnz	r2, 80013b0 <__aeabi_uldivmod+0x18>
 800139c:	2900      	cmp	r1, #0
 800139e:	bf08      	it	eq
 80013a0:	2800      	cmpeq	r0, #0
 80013a2:	bf1c      	itt	ne
 80013a4:	f04f 31ff 	movne.w	r1, #4294967295
 80013a8:	f04f 30ff 	movne.w	r0, #4294967295
 80013ac:	f000 b974 	b.w	8001698 <__aeabi_idiv0>
 80013b0:	f1ad 0c08 	sub.w	ip, sp, #8
 80013b4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80013b8:	f000 f806 	bl	80013c8 <__udivmoddi4>
 80013bc:	f8dd e004 	ldr.w	lr, [sp, #4]
 80013c0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80013c4:	b004      	add	sp, #16
 80013c6:	4770      	bx	lr

080013c8 <__udivmoddi4>:
 80013c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80013cc:	9d08      	ldr	r5, [sp, #32]
 80013ce:	4604      	mov	r4, r0
 80013d0:	468e      	mov	lr, r1
 80013d2:	2b00      	cmp	r3, #0
 80013d4:	d14d      	bne.n	8001472 <__udivmoddi4+0xaa>
 80013d6:	428a      	cmp	r2, r1
 80013d8:	4694      	mov	ip, r2
 80013da:	d969      	bls.n	80014b0 <__udivmoddi4+0xe8>
 80013dc:	fab2 f282 	clz	r2, r2
 80013e0:	b152      	cbz	r2, 80013f8 <__udivmoddi4+0x30>
 80013e2:	fa01 f302 	lsl.w	r3, r1, r2
 80013e6:	f1c2 0120 	rsb	r1, r2, #32
 80013ea:	fa20 f101 	lsr.w	r1, r0, r1
 80013ee:	fa0c fc02 	lsl.w	ip, ip, r2
 80013f2:	ea41 0e03 	orr.w	lr, r1, r3
 80013f6:	4094      	lsls	r4, r2
 80013f8:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80013fc:	0c21      	lsrs	r1, r4, #16
 80013fe:	fbbe f6f8 	udiv	r6, lr, r8
 8001402:	fa1f f78c 	uxth.w	r7, ip
 8001406:	fb08 e316 	mls	r3, r8, r6, lr
 800140a:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 800140e:	fb06 f107 	mul.w	r1, r6, r7
 8001412:	4299      	cmp	r1, r3
 8001414:	d90a      	bls.n	800142c <__udivmoddi4+0x64>
 8001416:	eb1c 0303 	adds.w	r3, ip, r3
 800141a:	f106 30ff 	add.w	r0, r6, #4294967295
 800141e:	f080 811f 	bcs.w	8001660 <__udivmoddi4+0x298>
 8001422:	4299      	cmp	r1, r3
 8001424:	f240 811c 	bls.w	8001660 <__udivmoddi4+0x298>
 8001428:	3e02      	subs	r6, #2
 800142a:	4463      	add	r3, ip
 800142c:	1a5b      	subs	r3, r3, r1
 800142e:	b2a4      	uxth	r4, r4
 8001430:	fbb3 f0f8 	udiv	r0, r3, r8
 8001434:	fb08 3310 	mls	r3, r8, r0, r3
 8001438:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 800143c:	fb00 f707 	mul.w	r7, r0, r7
 8001440:	42a7      	cmp	r7, r4
 8001442:	d90a      	bls.n	800145a <__udivmoddi4+0x92>
 8001444:	eb1c 0404 	adds.w	r4, ip, r4
 8001448:	f100 33ff 	add.w	r3, r0, #4294967295
 800144c:	f080 810a 	bcs.w	8001664 <__udivmoddi4+0x29c>
 8001450:	42a7      	cmp	r7, r4
 8001452:	f240 8107 	bls.w	8001664 <__udivmoddi4+0x29c>
 8001456:	4464      	add	r4, ip
 8001458:	3802      	subs	r0, #2
 800145a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800145e:	1be4      	subs	r4, r4, r7
 8001460:	2600      	movs	r6, #0
 8001462:	b11d      	cbz	r5, 800146c <__udivmoddi4+0xa4>
 8001464:	40d4      	lsrs	r4, r2
 8001466:	2300      	movs	r3, #0
 8001468:	e9c5 4300 	strd	r4, r3, [r5]
 800146c:	4631      	mov	r1, r6
 800146e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001472:	428b      	cmp	r3, r1
 8001474:	d909      	bls.n	800148a <__udivmoddi4+0xc2>
 8001476:	2d00      	cmp	r5, #0
 8001478:	f000 80ef 	beq.w	800165a <__udivmoddi4+0x292>
 800147c:	2600      	movs	r6, #0
 800147e:	e9c5 0100 	strd	r0, r1, [r5]
 8001482:	4630      	mov	r0, r6
 8001484:	4631      	mov	r1, r6
 8001486:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800148a:	fab3 f683 	clz	r6, r3
 800148e:	2e00      	cmp	r6, #0
 8001490:	d14a      	bne.n	8001528 <__udivmoddi4+0x160>
 8001492:	428b      	cmp	r3, r1
 8001494:	d302      	bcc.n	800149c <__udivmoddi4+0xd4>
 8001496:	4282      	cmp	r2, r0
 8001498:	f200 80f9 	bhi.w	800168e <__udivmoddi4+0x2c6>
 800149c:	1a84      	subs	r4, r0, r2
 800149e:	eb61 0303 	sbc.w	r3, r1, r3
 80014a2:	2001      	movs	r0, #1
 80014a4:	469e      	mov	lr, r3
 80014a6:	2d00      	cmp	r5, #0
 80014a8:	d0e0      	beq.n	800146c <__udivmoddi4+0xa4>
 80014aa:	e9c5 4e00 	strd	r4, lr, [r5]
 80014ae:	e7dd      	b.n	800146c <__udivmoddi4+0xa4>
 80014b0:	b902      	cbnz	r2, 80014b4 <__udivmoddi4+0xec>
 80014b2:	deff      	udf	#255	; 0xff
 80014b4:	fab2 f282 	clz	r2, r2
 80014b8:	2a00      	cmp	r2, #0
 80014ba:	f040 8092 	bne.w	80015e2 <__udivmoddi4+0x21a>
 80014be:	eba1 010c 	sub.w	r1, r1, ip
 80014c2:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80014c6:	fa1f fe8c 	uxth.w	lr, ip
 80014ca:	2601      	movs	r6, #1
 80014cc:	0c20      	lsrs	r0, r4, #16
 80014ce:	fbb1 f3f7 	udiv	r3, r1, r7
 80014d2:	fb07 1113 	mls	r1, r7, r3, r1
 80014d6:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 80014da:	fb0e f003 	mul.w	r0, lr, r3
 80014de:	4288      	cmp	r0, r1
 80014e0:	d908      	bls.n	80014f4 <__udivmoddi4+0x12c>
 80014e2:	eb1c 0101 	adds.w	r1, ip, r1
 80014e6:	f103 38ff 	add.w	r8, r3, #4294967295
 80014ea:	d202      	bcs.n	80014f2 <__udivmoddi4+0x12a>
 80014ec:	4288      	cmp	r0, r1
 80014ee:	f200 80cb 	bhi.w	8001688 <__udivmoddi4+0x2c0>
 80014f2:	4643      	mov	r3, r8
 80014f4:	1a09      	subs	r1, r1, r0
 80014f6:	b2a4      	uxth	r4, r4
 80014f8:	fbb1 f0f7 	udiv	r0, r1, r7
 80014fc:	fb07 1110 	mls	r1, r7, r0, r1
 8001500:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8001504:	fb0e fe00 	mul.w	lr, lr, r0
 8001508:	45a6      	cmp	lr, r4
 800150a:	d908      	bls.n	800151e <__udivmoddi4+0x156>
 800150c:	eb1c 0404 	adds.w	r4, ip, r4
 8001510:	f100 31ff 	add.w	r1, r0, #4294967295
 8001514:	d202      	bcs.n	800151c <__udivmoddi4+0x154>
 8001516:	45a6      	cmp	lr, r4
 8001518:	f200 80bb 	bhi.w	8001692 <__udivmoddi4+0x2ca>
 800151c:	4608      	mov	r0, r1
 800151e:	eba4 040e 	sub.w	r4, r4, lr
 8001522:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8001526:	e79c      	b.n	8001462 <__udivmoddi4+0x9a>
 8001528:	f1c6 0720 	rsb	r7, r6, #32
 800152c:	40b3      	lsls	r3, r6
 800152e:	fa22 fc07 	lsr.w	ip, r2, r7
 8001532:	ea4c 0c03 	orr.w	ip, ip, r3
 8001536:	fa20 f407 	lsr.w	r4, r0, r7
 800153a:	fa01 f306 	lsl.w	r3, r1, r6
 800153e:	431c      	orrs	r4, r3
 8001540:	40f9      	lsrs	r1, r7
 8001542:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8001546:	fa00 f306 	lsl.w	r3, r0, r6
 800154a:	fbb1 f8f9 	udiv	r8, r1, r9
 800154e:	0c20      	lsrs	r0, r4, #16
 8001550:	fa1f fe8c 	uxth.w	lr, ip
 8001554:	fb09 1118 	mls	r1, r9, r8, r1
 8001558:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800155c:	fb08 f00e 	mul.w	r0, r8, lr
 8001560:	4288      	cmp	r0, r1
 8001562:	fa02 f206 	lsl.w	r2, r2, r6
 8001566:	d90b      	bls.n	8001580 <__udivmoddi4+0x1b8>
 8001568:	eb1c 0101 	adds.w	r1, ip, r1
 800156c:	f108 3aff 	add.w	sl, r8, #4294967295
 8001570:	f080 8088 	bcs.w	8001684 <__udivmoddi4+0x2bc>
 8001574:	4288      	cmp	r0, r1
 8001576:	f240 8085 	bls.w	8001684 <__udivmoddi4+0x2bc>
 800157a:	f1a8 0802 	sub.w	r8, r8, #2
 800157e:	4461      	add	r1, ip
 8001580:	1a09      	subs	r1, r1, r0
 8001582:	b2a4      	uxth	r4, r4
 8001584:	fbb1 f0f9 	udiv	r0, r1, r9
 8001588:	fb09 1110 	mls	r1, r9, r0, r1
 800158c:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
 8001590:	fb00 fe0e 	mul.w	lr, r0, lr
 8001594:	458e      	cmp	lr, r1
 8001596:	d908      	bls.n	80015aa <__udivmoddi4+0x1e2>
 8001598:	eb1c 0101 	adds.w	r1, ip, r1
 800159c:	f100 34ff 	add.w	r4, r0, #4294967295
 80015a0:	d26c      	bcs.n	800167c <__udivmoddi4+0x2b4>
 80015a2:	458e      	cmp	lr, r1
 80015a4:	d96a      	bls.n	800167c <__udivmoddi4+0x2b4>
 80015a6:	3802      	subs	r0, #2
 80015a8:	4461      	add	r1, ip
 80015aa:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 80015ae:	fba0 9402 	umull	r9, r4, r0, r2
 80015b2:	eba1 010e 	sub.w	r1, r1, lr
 80015b6:	42a1      	cmp	r1, r4
 80015b8:	46c8      	mov	r8, r9
 80015ba:	46a6      	mov	lr, r4
 80015bc:	d356      	bcc.n	800166c <__udivmoddi4+0x2a4>
 80015be:	d053      	beq.n	8001668 <__udivmoddi4+0x2a0>
 80015c0:	b15d      	cbz	r5, 80015da <__udivmoddi4+0x212>
 80015c2:	ebb3 0208 	subs.w	r2, r3, r8
 80015c6:	eb61 010e 	sbc.w	r1, r1, lr
 80015ca:	fa01 f707 	lsl.w	r7, r1, r7
 80015ce:	fa22 f306 	lsr.w	r3, r2, r6
 80015d2:	40f1      	lsrs	r1, r6
 80015d4:	431f      	orrs	r7, r3
 80015d6:	e9c5 7100 	strd	r7, r1, [r5]
 80015da:	2600      	movs	r6, #0
 80015dc:	4631      	mov	r1, r6
 80015de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80015e2:	f1c2 0320 	rsb	r3, r2, #32
 80015e6:	40d8      	lsrs	r0, r3
 80015e8:	fa0c fc02 	lsl.w	ip, ip, r2
 80015ec:	fa21 f303 	lsr.w	r3, r1, r3
 80015f0:	4091      	lsls	r1, r2
 80015f2:	4301      	orrs	r1, r0
 80015f4:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80015f8:	fa1f fe8c 	uxth.w	lr, ip
 80015fc:	fbb3 f0f7 	udiv	r0, r3, r7
 8001600:	fb07 3610 	mls	r6, r7, r0, r3
 8001604:	0c0b      	lsrs	r3, r1, #16
 8001606:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
 800160a:	fb00 f60e 	mul.w	r6, r0, lr
 800160e:	429e      	cmp	r6, r3
 8001610:	fa04 f402 	lsl.w	r4, r4, r2
 8001614:	d908      	bls.n	8001628 <__udivmoddi4+0x260>
 8001616:	eb1c 0303 	adds.w	r3, ip, r3
 800161a:	f100 38ff 	add.w	r8, r0, #4294967295
 800161e:	d22f      	bcs.n	8001680 <__udivmoddi4+0x2b8>
 8001620:	429e      	cmp	r6, r3
 8001622:	d92d      	bls.n	8001680 <__udivmoddi4+0x2b8>
 8001624:	3802      	subs	r0, #2
 8001626:	4463      	add	r3, ip
 8001628:	1b9b      	subs	r3, r3, r6
 800162a:	b289      	uxth	r1, r1
 800162c:	fbb3 f6f7 	udiv	r6, r3, r7
 8001630:	fb07 3316 	mls	r3, r7, r6, r3
 8001634:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8001638:	fb06 f30e 	mul.w	r3, r6, lr
 800163c:	428b      	cmp	r3, r1
 800163e:	d908      	bls.n	8001652 <__udivmoddi4+0x28a>
 8001640:	eb1c 0101 	adds.w	r1, ip, r1
 8001644:	f106 38ff 	add.w	r8, r6, #4294967295
 8001648:	d216      	bcs.n	8001678 <__udivmoddi4+0x2b0>
 800164a:	428b      	cmp	r3, r1
 800164c:	d914      	bls.n	8001678 <__udivmoddi4+0x2b0>
 800164e:	3e02      	subs	r6, #2
 8001650:	4461      	add	r1, ip
 8001652:	1ac9      	subs	r1, r1, r3
 8001654:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
 8001658:	e738      	b.n	80014cc <__udivmoddi4+0x104>
 800165a:	462e      	mov	r6, r5
 800165c:	4628      	mov	r0, r5
 800165e:	e705      	b.n	800146c <__udivmoddi4+0xa4>
 8001660:	4606      	mov	r6, r0
 8001662:	e6e3      	b.n	800142c <__udivmoddi4+0x64>
 8001664:	4618      	mov	r0, r3
 8001666:	e6f8      	b.n	800145a <__udivmoddi4+0x92>
 8001668:	454b      	cmp	r3, r9
 800166a:	d2a9      	bcs.n	80015c0 <__udivmoddi4+0x1f8>
 800166c:	ebb9 0802 	subs.w	r8, r9, r2
 8001670:	eb64 0e0c 	sbc.w	lr, r4, ip
 8001674:	3801      	subs	r0, #1
 8001676:	e7a3      	b.n	80015c0 <__udivmoddi4+0x1f8>
 8001678:	4646      	mov	r6, r8
 800167a:	e7ea      	b.n	8001652 <__udivmoddi4+0x28a>
 800167c:	4620      	mov	r0, r4
 800167e:	e794      	b.n	80015aa <__udivmoddi4+0x1e2>
 8001680:	4640      	mov	r0, r8
 8001682:	e7d1      	b.n	8001628 <__udivmoddi4+0x260>
 8001684:	46d0      	mov	r8, sl
 8001686:	e77b      	b.n	8001580 <__udivmoddi4+0x1b8>
 8001688:	3b02      	subs	r3, #2
 800168a:	4461      	add	r1, ip
 800168c:	e732      	b.n	80014f4 <__udivmoddi4+0x12c>
 800168e:	4630      	mov	r0, r6
 8001690:	e709      	b.n	80014a6 <__udivmoddi4+0xde>
 8001692:	4464      	add	r4, ip
 8001694:	3802      	subs	r0, #2
 8001696:	e742      	b.n	800151e <__udivmoddi4+0x156>

08001698 <__aeabi_idiv0>:
 8001698:	4770      	bx	lr
 800169a:	bf00      	nop

0800169c <StartIdleTask>:
  }
  return 0;
}

void StartIdleTask(void *argument)
{
 800169c:	4c04      	ldr	r4, [pc, #16]	; (80016b0 <StartIdleTask+0x14>)
 800169e:	b508      	push	{r3, lr}
  while(1) {
    gIdleTick++;
 80016a0:	6823      	ldr	r3, [r4, #0]
    osDelay(1);
 80016a2:	2001      	movs	r0, #1
    gIdleTick++;
 80016a4:	4403      	add	r3, r0
 80016a6:	6023      	str	r3, [r4, #0]
    osDelay(1);
 80016a8:	f007 fe86 	bl	80093b8 <osDelay>
  while(1) {
 80016ac:	e7f8      	b.n	80016a0 <StartIdleTask+0x4>
 80016ae:	bf00      	nop
 80016b0:	20000000 	.word	0x20000000

080016b4 <StartPlayerTask>:
    }
  }
}

void StartPlayerTask(void *argument)
{
 80016b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80016b8:	2500      	movs	r5, #0
 80016ba:	4607      	mov	r7, r0
  uint8_t enabled = 0;
  uint8_t changed = 0;
  uint8_t restart = 0;
  float volume = 1.0f;

  FIL file = {0};
 80016bc:	2224      	movs	r2, #36	; 0x24
 80016be:	4ec8      	ldr	r6, [pc, #800]	; (80019e0 <StartPlayerTask+0x32c>)
 80016c0:	4629      	mov	r1, r5
  FRESULT res;
  UINT read;
  uint32_t toread = 0;
  uint32_t mp3read = 0;
  uint32_t mp3read_prev = 0;
  uint32_t content = 0;
 80016c2:	462c      	mov	r4, r5
  uint8_t restart = 0;
 80016c4:	46ab      	mov	fp, r5

  uint8_t *tempfilebuffer;
  int16_t *mp3buffer;

  playing = 0;
 80016c6:	46aa      	mov	sl, r5
  uint8_t *filebuffer = NULL;
 80016c8:	46a8      	mov	r8, r5
{
 80016ca:	ed2d 8b04 	vpush	{d8-d9}
 80016ce:	b09d      	sub	sp, #116	; 0x74
  float volume = 1.0f;
 80016d0:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
      filebuffer = playerdata->fileBuffer;
      filebuffersize = playerdata->fileBufferSize;
      samplebuffer = playerdata->sampleBuffer;
      buffer = playerdata->buffer;
      stereo = (int16_t *)buffer;
      volume = playerdata->volume * 0.01f;
 80016d4:	eddf 8ac3 	vldr	s17, [pc, #780]	; 80019e4 <StartPlayerTask+0x330>
  FIL file = {0};
 80016d8:	a813      	add	r0, sp, #76	; 0x4c

      if(mp3Info.samprate == 0 || mp3Info.nChans <= 0) {
        continue;
      }

      playerdata->file_percentage = ((float)f_tell(&file) / (float)f_size(&file)) * 100.0f;
 80016da:	ed9f 9ac3 	vldr	s18, [pc, #780]	; 80019e8 <StartPlayerTask+0x334>
  FIL file = {0};
 80016de:	f011 fd4b 	bl	8013178 <memset>
  uint32_t mp3read = 0;
 80016e2:	f107 0308 	add.w	r3, r7, #8
 80016e6:	950a      	str	r5, [sp, #40]	; 0x28
  playing = 0;
 80016e8:	ee09 3a90 	vmov	s19, r3
  uint8_t changed = 0;
 80016ec:	9502      	str	r5, [sp, #8]
  uint8_t enabled = 0;
 80016ee:	9504      	str	r5, [sp, #16]
  uint32_t filebuffersize = 0;
 80016f0:	9503      	str	r5, [sp, #12]
  int16_t *stereo = NULL;
 80016f2:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if(osMutexAcquire(playerdata->mutex, osWaitForever) == osOK) {
 80016f6:	f04f 31ff 	mov.w	r1, #4294967295
 80016fa:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 80016fe:	f007 feed 	bl	80094dc <osMutexAcquire>
 8001702:	2800      	cmp	r0, #0
 8001704:	f000 808a 	beq.w	800181c <StartPlayerTask+0x168>
    if(changed || restart) {
 8001708:	9b02      	ldr	r3, [sp, #8]
 800170a:	ea43 090b 	orr.w	r9, r3, fp
 800170e:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
 8001712:	f040 80a7 	bne.w	8001864 <StartPlayerTask+0x1b0>
    playerdata->playing = playing;
 8001716:	f887 a089 	strb.w	sl, [r7, #137]	; 0x89
    if(playing) {
 800171a:	f1ba 0f00 	cmp.w	sl, #0
 800171e:	f000 80c9 	beq.w	80018b4 <StartPlayerTask+0x200>
      if(f_eof(&file)) {
 8001722:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8001724:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8001726:	429a      	cmp	r2, r3
 8001728:	f000 8168 	beq.w	80019fc <StartPlayerTask+0x348>
      if(content < 2048) {
 800172c:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
 8001730:	d25a      	bcs.n	80017e8 <StartPlayerTask+0x134>
        if(toread > f_size(&file) - f_tell(&file))
 8001732:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8001734:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8001736:	eba2 0b03 	sub.w	fp, r2, r3
        toread = filebuffersize - content;
 800173a:	9b03      	ldr	r3, [sp, #12]
 800173c:	1b1a      	subs	r2, r3, r4
        if(toread > f_size(&file) - f_tell(&file))
 800173e:	4593      	cmp	fp, r2
 8001740:	bf28      	it	cs
 8001742:	4693      	movcs	fp, r2
        for(int i = 0; i < content; i++) {
 8001744:	2c00      	cmp	r4, #0
 8001746:	f000 80c8 	beq.w	80018da <StartPlayerTask+0x226>
 800174a:	ea6f 030b 	mvn.w	r3, fp
 800174e:	2b02      	cmp	r3, #2
 8001750:	f240 80b7 	bls.w	80018c2 <StartPlayerTask+0x20e>
 8001754:	1e63      	subs	r3, r4, #1
 8001756:	2b07      	cmp	r3, #7
 8001758:	f240 80b3 	bls.w	80018c2 <StartPlayerTask+0x20e>
 800175c:	eb08 0c0b 	add.w	ip, r8, fp
 8001760:	f024 0003 	bic.w	r0, r4, #3
 8001764:	4642      	mov	r2, r8
 8001766:	4460      	add	r0, ip
 8001768:	4663      	mov	r3, ip
          filebuffer[i] = filebuffer[toread + i];
 800176a:	f853 1b04 	ldr.w	r1, [r3], #4
 800176e:	4283      	cmp	r3, r0
 8001770:	f842 1b04 	str.w	r1, [r2], #4
        for(int i = 0; i < content; i++) {
 8001774:	d1f9      	bne.n	800176a <StartPlayerTask+0xb6>
 8001776:	07a2      	lsls	r2, r4, #30
 8001778:	f024 0303 	bic.w	r3, r4, #3
 800177c:	f000 80ad 	beq.w	80018da <StartPlayerTask+0x226>
          filebuffer[i] = filebuffer[toread + i];
 8001780:	eb08 0203 	add.w	r2, r8, r3
 8001784:	f812 200b 	ldrb.w	r2, [r2, fp]
 8001788:	f808 2003 	strb.w	r2, [r8, r3]
        for(int i = 0; i < content; i++) {
 800178c:	1c5a      	adds	r2, r3, #1
 800178e:	42a2      	cmp	r2, r4
 8001790:	f080 80a3 	bcs.w	80018da <StartPlayerTask+0x226>
 8001794:	3302      	adds	r3, #2
          filebuffer[i] = filebuffer[toread + i];
 8001796:	f81c 1002 	ldrb.w	r1, [ip, r2]
        for(int i = 0; i < content; i++) {
 800179a:	42a3      	cmp	r3, r4
          filebuffer[i] = filebuffer[toread + i];
 800179c:	f808 1002 	strb.w	r1, [r8, r2]
        for(int i = 0; i < content; i++) {
 80017a0:	f080 809b 	bcs.w	80018da <StartPlayerTask+0x226>
          filebuffer[i] = filebuffer[toread + i];
 80017a4:	f81c 2003 	ldrb.w	r2, [ip, r3]
 80017a8:	46a2      	mov	sl, r4
 80017aa:	465c      	mov	r4, fp
 80017ac:	f808 2003 	strb.w	r2, [r8, r3]
        for(int i = 0; i < content; i++) {
 80017b0:	e013      	b.n	80017da <StartPlayerTask+0x126>
          osMutexAcquire(gFSMutex, osWaitForever);
 80017b2:	6830      	ldr	r0, [r6, #0]
 80017b4:	f007 fe92 	bl	80094dc <osMutexAcquire>
          res = f_read(&file, &filebuffer[content], toread, &read);
 80017b8:	ab09      	add	r3, sp, #36	; 0x24
 80017ba:	4622      	mov	r2, r4
 80017bc:	eb08 010a 	add.w	r1, r8, sl
 80017c0:	a813      	add	r0, sp, #76	; 0x4c
 80017c2:	f007 f94f 	bl	8008a64 <f_read>
 80017c6:	4605      	mov	r5, r0
          osMutexRelease(gFSMutex);
 80017c8:	6830      	ldr	r0, [r6, #0]
 80017ca:	f007 febf 	bl	800954c <osMutexRelease>
          content += read;
 80017ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80017d0:	449a      	add	sl, r3
          toread -= read;
 80017d2:	1ae4      	subs	r4, r4, r3
          if(res != FR_OK) {
 80017d4:	2d00      	cmp	r5, #0
 80017d6:	f040 8083 	bne.w	80018e0 <StartPlayerTask+0x22c>
          osMutexAcquire(gFSMutex, osWaitForever);
 80017da:	f04f 31ff 	mov.w	r1, #4294967295
        while(toread > 0) {
 80017de:	2c00      	cmp	r4, #0
 80017e0:	d1e7      	bne.n	80017b2 <StartPlayerTask+0xfe>
        if(res != FR_OK) {
 80017e2:	4654      	mov	r4, sl
 80017e4:	2d00      	cmp	r5, #0
 80017e6:	d17c      	bne.n	80018e2 <StartPlayerTask+0x22e>
      tempfilebuffer = &filebuffer[filebuffersize - content];
 80017e8:	9b03      	ldr	r3, [sp, #12]
      syncword = MP3FindSyncWord(tempfilebuffer, content);
 80017ea:	4621      	mov	r1, r4
 80017ec:	46cb      	mov	fp, r9
      tempfilebuffer = &filebuffer[filebuffersize - content];
 80017ee:	1b18      	subs	r0, r3, r4
 80017f0:	4440      	add	r0, r8
 80017f2:	900b      	str	r0, [sp, #44]	; 0x2c
      syncword = MP3FindSyncWord(tempfilebuffer, content);
 80017f4:	f00a fef6 	bl	800c5e4 <MP3FindSyncWord>
      if(syncword <= ERR_MP3_INDATA_UNDERFLOW)
 80017f8:	f1b0 0a00 	subs.w	sl, r0, #0
 80017fc:	f2c0 810f 	blt.w	8001a1e <StartPlayerTask+0x36a>
      if(syncword > 0)
 8001800:	d078      	beq.n	80018f4 <StartPlayerTask+0x240>
    if(osMutexAcquire(playerdata->mutex, osWaitForever) == osOK) {
 8001802:	f04f 31ff 	mov.w	r1, #4294967295
 8001806:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
        content -= syncword;
 800180a:	eba4 040a 	sub.w	r4, r4, sl
        continue;
 800180e:	f04f 0a01 	mov.w	sl, #1
    if(osMutexAcquire(playerdata->mutex, osWaitForever) == osOK) {
 8001812:	f007 fe63 	bl	80094dc <osMutexAcquire>
 8001816:	2800      	cmp	r0, #0
 8001818:	f47f af76 	bne.w	8001708 <StartPlayerTask+0x54>
      volume = playerdata->volume * 0.01f;
 800181c:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
      enabled = playerdata->enabled;
 8001820:	f897 2088 	ldrb.w	r2, [r7, #136]	; 0x88
      volume = playerdata->volume * 0.01f;
 8001824:	ee07 3a90 	vmov	s15, r3
      osMutexRelease(playerdata->mutex);
 8001828:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
      enabled = playerdata->enabled;
 800182c:	b2d3      	uxtb	r3, r2
      volume = playerdata->volume * 0.01f;
 800182e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
      enabled = playerdata->enabled;
 8001832:	9304      	str	r3, [sp, #16]
      changed = playerdata->changed;
 8001834:	f897 308a 	ldrb.w	r3, [r7, #138]	; 0x8a
      volume = playerdata->volume * 0.01f;
 8001838:	ee27 8aa8 	vmul.f32	s16, s15, s17
      changed = playerdata->changed;
 800183c:	b2db      	uxtb	r3, r3
 800183e:	9302      	str	r3, [sp, #8]
      filebuffersize = playerdata->fileBufferSize;
 8001840:	e9d7 8327 	ldrd	r8, r3, [r7, #156]	; 0x9c
 8001844:	9303      	str	r3, [sp, #12]
      samplebuffer = playerdata->sampleBuffer;
 8001846:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800184a:	9305      	str	r3, [sp, #20]
      buffer = playerdata->buffer;
 800184c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8001850:	9306      	str	r3, [sp, #24]
      osMutexRelease(playerdata->mutex);
 8001852:	f007 fe7b 	bl	800954c <osMutexRelease>
    if(changed || restart) {
 8001856:	9b02      	ldr	r3, [sp, #8]
 8001858:	ea43 090b 	orr.w	r9, r3, fp
 800185c:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
 8001860:	f43f af59 	beq.w	8001716 <StartPlayerTask+0x62>
      if(osMutexAcquire(playerdata->mutex, 0) == osOK) {
 8001864:	2100      	movs	r1, #0
 8001866:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800186a:	f007 fe37 	bl	80094dc <osMutexAcquire>
 800186e:	2800      	cmp	r0, #0
 8001870:	f040 80b3 	bne.w	80019da <StartPlayerTask+0x326>
        playerdata->changed = 0;
 8001874:	f887 008a 	strb.w	r0, [r7, #138]	; 0x8a
        playerdata->buffer_wr = 0;
 8001878:	e9c7 002b 	strd	r0, r0, [r7, #172]	; 0xac
        if(playing) {
 800187c:	f1ba 0f00 	cmp.w	sl, #0
 8001880:	f000 80d6 	beq.w	8001a30 <StartPlayerTask+0x37c>
          content = 0;
 8001884:	4604      	mov	r4, r0
          osMutexRelease(playerdata->mutex);
 8001886:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800188a:	f007 fe5f 	bl	800954c <osMutexRelease>
          osMutexAcquire(gFSMutex, osWaitForever);
 800188e:	f04f 31ff 	mov.w	r1, #4294967295
 8001892:	6830      	ldr	r0, [r6, #0]
 8001894:	f007 fe22 	bl	80094dc <osMutexAcquire>
          res = f_close(&file);
 8001898:	a813      	add	r0, sp, #76	; 0x4c
 800189a:	f007 fa27 	bl	8008cec <f_close>
 800189e:	4605      	mov	r5, r0
          osMutexRelease(gFSMutex);
 80018a0:	6830      	ldr	r0, [r6, #0]
 80018a2:	f007 fe53 	bl	800954c <osMutexRelease>
        if(enabled) {
 80018a6:	9b04      	ldr	r3, [sp, #16]
 80018a8:	2b00      	cmp	r3, #0
 80018aa:	f040 80c9 	bne.w	8001a40 <StartPlayerTask+0x38c>
        restart = 0;
 80018ae:	4699      	mov	r9, r3
    playerdata->playing = playing;
 80018b0:	f887 3089 	strb.w	r3, [r7, #137]	; 0x89
        HAL_GPIO_TogglePin(LED_D6_GPIO_Port, LED_D6_Pin);
      }
      taskEXIT_CRITICAL();

    } else {
      osDelay(1);
 80018b4:	2001      	movs	r0, #1
 80018b6:	46cb      	mov	fp, r9
 80018b8:	f04f 0a00 	mov.w	sl, #0
 80018bc:	f007 fd7c 	bl	80093b8 <osDelay>
 80018c0:	e719      	b.n	80016f6 <StartPlayerTask+0x42>
 80018c2:	f10b 32ff 	add.w	r2, fp, #4294967295
 80018c6:	f108 33ff 	add.w	r3, r8, #4294967295
 80018ca:	4442      	add	r2, r8
 80018cc:	1918      	adds	r0, r3, r4
          filebuffer[i] = filebuffer[toread + i];
 80018ce:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 80018d2:	f803 1f01 	strb.w	r1, [r3, #1]!
        for(int i = 0; i < content; i++) {
 80018d6:	4283      	cmp	r3, r0
 80018d8:	d1f9      	bne.n	80018ce <StartPlayerTask+0x21a>
 80018da:	46a2      	mov	sl, r4
 80018dc:	465c      	mov	r4, fp
 80018de:	e77c      	b.n	80017da <StartPlayerTask+0x126>
 80018e0:	4654      	mov	r4, sl
          playerdata->fs_errors++;
 80018e2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
          restart = 1;
 80018e6:	f04f 0b01 	mov.w	fp, #1
          playerdata->fs_errors++;
 80018ea:	3301      	adds	r3, #1
          continue;
 80018ec:	46da      	mov	sl, fp
          playerdata->fs_errors++;
 80018ee:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
          continue;
 80018f2:	e700      	b.n	80016f6 <StartPlayerTask+0x42>
      osMutexAcquire(gMp3Mutex, osWaitForever);
 80018f4:	4b3d      	ldr	r3, [pc, #244]	; (80019ec <StartPlayerTask+0x338>)
 80018f6:	f04f 31ff 	mov.w	r1, #4294967295
 80018fa:	6818      	ldr	r0, [r3, #0]
 80018fc:	f007 fdee 	bl	80094dc <osMutexAcquire>
      syncword = MP3GetNextFrameInfo(playerdata->decoder, &mp3Info, tempfilebuffer);
 8001900:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8001902:	a90c      	add	r1, sp, #48	; 0x30
 8001904:	6878      	ldr	r0, [r7, #4]
 8001906:	f00a fe87 	bl	800c618 <MP3GetNextFrameInfo>
      if(syncword != ERR_MP3_NONE)
 800190a:	4681      	mov	r9, r0
 800190c:	2800      	cmp	r0, #0
 800190e:	f040 80e4 	bne.w	8001ada <StartPlayerTask+0x426>
      if(playerdata == &gPlayersData.player[0] && mp3read_prev == 3678 && f_tell(&file) == 6228) {
 8001912:	4b37      	ldr	r3, [pc, #220]	; (80019f0 <StartPlayerTask+0x33c>)
      mp3read = content;
 8001914:	940a      	str	r4, [sp, #40]	; 0x28
      if(playerdata == &gPlayersData.player[0] && mp3read_prev == 3678 && f_tell(&file) == 6228) {
 8001916:	429f      	cmp	r7, r3
 8001918:	f000 80b7 	beq.w	8001a8a <StartPlayerTask+0x3d6>
      syncword = MP3Decode(playerdata->decoder, &tempfilebuffer, (int*)&mp3read, mp3buffer, 0);
 800191c:	9000      	str	r0, [sp, #0]
 800191e:	aa0a      	add	r2, sp, #40	; 0x28
 8001920:	9b05      	ldr	r3, [sp, #20]
 8001922:	a90b      	add	r1, sp, #44	; 0x2c
 8001924:	6878      	ldr	r0, [r7, #4]
 8001926:	f00a fea7 	bl	800c678 <MP3Decode>
      osMutexRelease(gMp3Mutex);
 800192a:	4b30      	ldr	r3, [pc, #192]	; (80019ec <StartPlayerTask+0x338>)
      syncword = MP3Decode(playerdata->decoder, &tempfilebuffer, (int*)&mp3read, mp3buffer, 0);
 800192c:	4682      	mov	sl, r0
      osMutexRelease(gMp3Mutex);
 800192e:	6818      	ldr	r0, [r3, #0]
 8001930:	f007 fe0c 	bl	800954c <osMutexRelease>
      content = mp3read;
 8001934:	9c0a      	ldr	r4, [sp, #40]	; 0x28
      if(syncword != ERR_MP3_NONE) {
 8001936:	f1ba 0f00 	cmp.w	sl, #0
 800193a:	f040 80c6 	bne.w	8001aca <StartPlayerTask+0x416>
      if(mp3Info.samprate == 0 || mp3Info.nChans <= 0) {
 800193e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8001940:	2b00      	cmp	r3, #0
 8001942:	f000 809f 	beq.w	8001a84 <StartPlayerTask+0x3d0>
 8001946:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001948:	2b00      	cmp	r3, #0
 800194a:	f340 809b 	ble.w	8001a84 <StartPlayerTask+0x3d0>
      playerdata->file_percentage = ((float)f_tell(&file) / (float)f_size(&file)) * 100.0f;
 800194e:	eddd 7a18 	vldr	s15, [sp, #96]	; 0x60
 8001952:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8001956:	eddd 7a16 	vldr	s15, [sp, #88]	; 0x58
 800195a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800195e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8001962:	ee67 7a89 	vmul.f32	s15, s15, s18
 8001966:	edc7 7a30 	vstr	s15, [r7, #192]	; 0xc0
      while(getfree(playerdata->buffer_wr, playerdata->buffer_rd, playerdata->bufferSize) <= mp3Info.outputSamps / 2) {
 800196a:	e009      	b.n	8001980 <StartPlayerTask+0x2cc>
 800196c:	2a00      	cmp	r2, #0
 800196e:	4696      	mov	lr, r2
 8001970:	bfb8      	it	lt
 8001972:	eb02 0e00 	addlt.w	lr, r2, r0
 8001976:	ebbc 0f6e 	cmp.w	ip, lr, asr #1
 800197a:	d815      	bhi.n	80019a8 <StartPlayerTask+0x2f4>
        osDelay(1);
 800197c:	f007 fd1c 	bl	80093b8 <osDelay>
      while(getfree(playerdata->buffer_wr, playerdata->buffer_rd, playerdata->bufferSize) <= mp3Info.outputSamps / 2) {
 8001980:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
        osDelay(1);
 8001984:	2001      	movs	r0, #1
      while(getfree(playerdata->buffer_wr, playerdata->buffer_rd, playerdata->bufferSize) <= mp3Info.outputSamps / 2) {
 8001986:	e9d7 232b 	ldrd	r2, r3, [r7, #172]	; 0xac
  return size - getavail(wr, rd, size);
 800198a:	eba2 0c03 	sub.w	ip, r2, r3
  if(wr >= rd) return (wr - rd);
 800198e:	4293      	cmp	r3, r2
      while(getfree(playerdata->buffer_wr, playerdata->buffer_rd, playerdata->bufferSize) <= mp3Info.outputSamps / 2) {
 8001990:	9a10      	ldr	r2, [sp, #64]	; 0x40
  return size - getavail(wr, rd, size);
 8001992:	46e6      	mov	lr, ip
 8001994:	448c      	add	ip, r1
  if(wr >= rd) return (wr - rd);
 8001996:	d2e9      	bcs.n	800196c <StartPlayerTask+0x2b8>
      while(getfree(playerdata->buffer_wr, playerdata->buffer_rd, playerdata->bufferSize) <= mp3Info.outputSamps / 2) {
 8001998:	2a00      	cmp	r2, #0
 800199a:	4694      	mov	ip, r2
 800199c:	bfb8      	it	lt
 800199e:	f102 0c01 	addlt.w	ip, r2, #1
 80019a2:	ebbe 0f6c 	cmp.w	lr, ip, asr #1
 80019a6:	d9e9      	bls.n	800197c <StartPlayerTask+0x2c8>
      if(mp3Info.nChans == 2) {
 80019a8:	980d      	ldr	r0, [sp, #52]	; 0x34
 80019aa:	2802      	cmp	r0, #2
 80019ac:	f000 80cb 	beq.w	8001b46 <StartPlayerTask+0x492>
      } else if(mp3Info.nChans == 1) {
 80019b0:	2801      	cmp	r0, #1
 80019b2:	f000 80fb 	beq.w	8001bac <StartPlayerTask+0x4f8>
      playerdata->playing = 1;
 80019b6:	2301      	movs	r3, #1
 80019b8:	f887 3089 	strb.w	r3, [r7, #137]	; 0x89
      taskENTER_CRITICAL();
 80019bc:	f00a fb9a 	bl	800c0f4 <vPortEnterCritical>
      if(xTaskGetTickCount() - gMp3LedLast > 100) {
 80019c0:	f009 fc8e 	bl	800b2e0 <xTaskGetTickCount>
 80019c4:	4b0b      	ldr	r3, [pc, #44]	; (80019f4 <StartPlayerTask+0x340>)
 80019c6:	681b      	ldr	r3, [r3, #0]
 80019c8:	1ac0      	subs	r0, r0, r3
 80019ca:	2864      	cmp	r0, #100	; 0x64
 80019cc:	f200 80b2 	bhi.w	8001b34 <StartPlayerTask+0x480>
      taskEXIT_CRITICAL();
 80019d0:	f04f 0a01 	mov.w	sl, #1
 80019d4:	f00a fbb4 	bl	800c140 <vPortExitCritical>
 80019d8:	e68d      	b.n	80016f6 <StartPlayerTask+0x42>
 80019da:	46d9      	mov	r9, fp
 80019dc:	e69b      	b.n	8001716 <StartPlayerTask+0x62>
 80019de:	bf00      	nop
 80019e0:	20000b00 	.word	0x20000b00
 80019e4:	3c23d70a 	.word	0x3c23d70a
 80019e8:	42c80000 	.word	0x42c80000
 80019ec:	20004b08 	.word	0x20004b08
 80019f0:	20000008 	.word	0x20000008
 80019f4:	20004b04 	.word	0x20004b04
        restart = 0;
 80019f8:	462c      	mov	r4, r5
          content = 0;
 80019fa:	46a9      	mov	r9, r5
        osMutexAcquire(gFSMutex, osWaitForever);
 80019fc:	f04f 31ff 	mov.w	r1, #4294967295
 8001a00:	6830      	ldr	r0, [r6, #0]
 8001a02:	f007 fd6b 	bl	80094dc <osMutexAcquire>
        res = f_rewind(&file);
 8001a06:	2100      	movs	r1, #0
 8001a08:	a813      	add	r0, sp, #76	; 0x4c
 8001a0a:	f007 f99b 	bl	8008d44 <f_lseek>
 8001a0e:	4605      	mov	r5, r0
        osMutexRelease(gFSMutex);
 8001a10:	6830      	ldr	r0, [r6, #0]
 8001a12:	f007 fd9b 	bl	800954c <osMutexRelease>
        playerdata->playing = 0;
 8001a16:	2300      	movs	r3, #0
 8001a18:	f887 3089 	strb.w	r3, [r7, #137]	; 0x89
 8001a1c:	e686      	b.n	800172c <StartPlayerTask+0x78>
        playerdata->mp3_errors++;
 8001a1e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8001a22:	3301      	adds	r3, #1
 8001a24:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
        content = 0;
 8001a28:	2400      	movs	r4, #0
        continue;
 8001a2a:	f04f 0a01 	mov.w	sl, #1
 8001a2e:	e662      	b.n	80016f6 <StartPlayerTask+0x42>
          osMutexRelease(playerdata->mutex);
 8001a30:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 8001a34:	f007 fd8a 	bl	800954c <osMutexRelease>
        if(enabled) {
 8001a38:	9b04      	ldr	r3, [sp, #16]
 8001a3a:	2b00      	cmp	r3, #0
 8001a3c:	f43f af37 	beq.w	80018ae <StartPlayerTask+0x1fa>
          osMutexAcquire(gFSMutex, osWaitForever);
 8001a40:	f04f 31ff 	mov.w	r1, #4294967295
 8001a44:	6830      	ldr	r0, [r6, #0]
 8001a46:	f007 fd49 	bl	80094dc <osMutexAcquire>
          res = f_open(&file, playerdata->file, FA_READ);
 8001a4a:	2201      	movs	r2, #1
 8001a4c:	ee19 1a90 	vmov	r1, s19
 8001a50:	a813      	add	r0, sp, #76	; 0x4c
 8001a52:	f006 fc85 	bl	8008360 <f_open>
 8001a56:	4605      	mov	r5, r0
          osMutexRelease(gFSMutex);
 8001a58:	6830      	ldr	r0, [r6, #0]
 8001a5a:	f007 fd77 	bl	800954c <osMutexRelease>
          if(res != FR_OK) {
 8001a5e:	2d00      	cmp	r5, #0
 8001a60:	d14b      	bne.n	8001afa <StartPlayerTask+0x446>
    playerdata->playing = playing;
 8001a62:	2301      	movs	r3, #1
      if(f_eof(&file)) {
 8001a64:	9a18      	ldr	r2, [sp, #96]	; 0x60
    playerdata->playing = playing;
 8001a66:	f887 3089 	strb.w	r3, [r7, #137]	; 0x89
      if(f_eof(&file)) {
 8001a6a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8001a6c:	429a      	cmp	r2, r3
 8001a6e:	d0c3      	beq.n	80019f8 <StartPlayerTask+0x344>
        if(toread > f_size(&file) - f_tell(&file))
 8001a70:	eba3 0b02 	sub.w	fp, r3, r2
 8001a74:	9b03      	ldr	r3, [sp, #12]
        restart = 0;
 8001a76:	46a9      	mov	r9, r5
 8001a78:	46aa      	mov	sl, r5
 8001a7a:	459b      	cmp	fp, r3
 8001a7c:	bf28      	it	cs
 8001a7e:	469b      	movcs	fp, r3
        for(int i = 0; i < content; i++) {
 8001a80:	465c      	mov	r4, fp
 8001a82:	e6aa      	b.n	80017da <StartPlayerTask+0x126>
 8001a84:	f04f 0a01 	mov.w	sl, #1
 8001a88:	e635      	b.n	80016f6 <StartPlayerTask+0x42>
      if(playerdata == &gPlayersData.player[0] && mp3read_prev == 3678 && f_tell(&file) == 6228) {
 8001a8a:	f640 635e 	movw	r3, #3678	; 0xe5e
 8001a8e:	429c      	cmp	r4, r3
 8001a90:	d041      	beq.n	8001b16 <StartPlayerTask+0x462>
      syncword = MP3Decode(playerdata->decoder, &tempfilebuffer, (int*)&mp3read, mp3buffer, 0);
 8001a92:	2300      	movs	r3, #0
 8001a94:	4858      	ldr	r0, [pc, #352]	; (8001bf8 <StartPlayerTask+0x544>)
 8001a96:	aa0a      	add	r2, sp, #40	; 0x28
 8001a98:	a90b      	add	r1, sp, #44	; 0x2c
 8001a9a:	9300      	str	r3, [sp, #0]
 8001a9c:	9b05      	ldr	r3, [sp, #20]
 8001a9e:	6880      	ldr	r0, [r0, #8]
 8001aa0:	f00a fdea 	bl	800c678 <MP3Decode>
      osMutexRelease(gMp3Mutex);
 8001aa4:	4b55      	ldr	r3, [pc, #340]	; (8001bfc <StartPlayerTask+0x548>)
      syncword = MP3Decode(playerdata->decoder, &tempfilebuffer, (int*)&mp3read, mp3buffer, 0);
 8001aa6:	4682      	mov	sl, r0
      osMutexRelease(gMp3Mutex);
 8001aa8:	6818      	ldr	r0, [r3, #0]
 8001aaa:	f007 fd4f 	bl	800954c <osMutexRelease>
      content = mp3read;
 8001aae:	9c0a      	ldr	r4, [sp, #40]	; 0x28
      if(syncword != ERR_MP3_NONE) {
 8001ab0:	f1ba 0f00 	cmp.w	sl, #0
 8001ab4:	f43f af43 	beq.w	800193e <StartPlayerTask+0x28a>
          playerdata->file_percentage++;
 8001ab8:	4b4f      	ldr	r3, [pc, #316]	; (8001bf8 <StartPlayerTask+0x544>)
 8001aba:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8001abe:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8001ac2:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001ac6:	edc3 7a31 	vstr	s15, [r3, #196]	; 0xc4
        playerdata->mp3_errors++;
 8001aca:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
        continue;
 8001ace:	f04f 0a01 	mov.w	sl, #1
        playerdata->mp3_errors++;
 8001ad2:	3301      	adds	r3, #1
 8001ad4:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
        continue;
 8001ad8:	e60d      	b.n	80016f6 <StartPlayerTask+0x42>
        osMutexRelease(gMp3Mutex);
 8001ada:	4b48      	ldr	r3, [pc, #288]	; (8001bfc <StartPlayerTask+0x548>)
 8001adc:	6818      	ldr	r0, [r3, #0]
 8001ade:	f007 fd35 	bl	800954c <osMutexRelease>
        playerdata->mp3_errors++;
 8001ae2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
        if(content > 2) {
 8001ae6:	2c02      	cmp	r4, #2
        playerdata->mp3_errors++;
 8001ae8:	f102 0201 	add.w	r2, r2, #1
 8001aec:	f8c7 20b8 	str.w	r2, [r7, #184]	; 0xb8
        if(content > 2) {
 8001af0:	d99a      	bls.n	8001a28 <StartPlayerTask+0x374>
          content -= 2;
 8001af2:	3c02      	subs	r4, #2
 8001af4:	f04f 0a01 	mov.w	sl, #1
 8001af8:	e5fd      	b.n	80016f6 <StartPlayerTask+0x42>
            playerdata->enabled = 0;
 8001afa:	2400      	movs	r4, #0
      osDelay(1);
 8001afc:	2001      	movs	r0, #1
 8001afe:	f04f 0a00 	mov.w	sl, #0
        restart = 0;
 8001b02:	46a1      	mov	r9, r4
            playerdata->enabled = 0;
 8001b04:	f887 4088 	strb.w	r4, [r7, #136]	; 0x88
    playerdata->playing = playing;
 8001b08:	f887 4089 	strb.w	r4, [r7, #137]	; 0x89
            enabled = 0;
 8001b0c:	9404      	str	r4, [sp, #16]
      osDelay(1);
 8001b0e:	46cb      	mov	fp, r9
 8001b10:	f007 fc52 	bl	80093b8 <osDelay>
 8001b14:	e5ef      	b.n	80016f6 <StartPlayerTask+0x42>
      if(playerdata == &gPlayersData.player[0] && mp3read_prev == 3678 && f_tell(&file) == 6228) {
 8001b16:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8001b18:	f641 0354 	movw	r3, #6228	; 0x1854
 8001b1c:	429a      	cmp	r2, r3
 8001b1e:	d1b8      	bne.n	8001a92 <StartPlayerTask+0x3de>
        playerdata->file_percentage++;
 8001b20:	4b35      	ldr	r3, [pc, #212]	; (8001bf8 <StartPlayerTask+0x544>)
 8001b22:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8001b26:	edd3 7a31 	vldr	s15, [r3, #196]	; 0xc4
 8001b2a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001b2e:	edc3 7a31 	vstr	s15, [r3, #196]	; 0xc4
 8001b32:	e7ae      	b.n	8001a92 <StartPlayerTask+0x3de>
        gMp3LedLast = xTaskGetTickCount();
 8001b34:	f009 fbd4 	bl	800b2e0 <xTaskGetTickCount>
 8001b38:	4b31      	ldr	r3, [pc, #196]	; (8001c00 <StartPlayerTask+0x54c>)
        HAL_GPIO_TogglePin(LED_D6_GPIO_Port, LED_D6_Pin);
 8001b3a:	2140      	movs	r1, #64	; 0x40
        gMp3LedLast = xTaskGetTickCount();
 8001b3c:	6018      	str	r0, [r3, #0]
        HAL_GPIO_TogglePin(LED_D6_GPIO_Port, LED_D6_Pin);
 8001b3e:	4831      	ldr	r0, [pc, #196]	; (8001c04 <StartPlayerTask+0x550>)
 8001b40:	f001 fed4 	bl	80038ec <HAL_GPIO_TogglePin>
 8001b44:	e744      	b.n	80019d0 <StartPlayerTask+0x31c>
        for(int i = 0; i < mp3Info.outputSamps;) {
 8001b46:	2a00      	cmp	r2, #0
 8001b48:	f77f af35 	ble.w	80019b6 <StartPlayerTask+0x302>
 8001b4c:	9805      	ldr	r0, [sp, #20]
 8001b4e:	9407      	str	r4, [sp, #28]
 8001b50:	f1a0 0c02 	sub.w	ip, r0, #2
 8001b54:	e9dd a005 	ldrd	sl, r0, [sp, #20]
          stereo[playerdata->buffer_wr * 2] = (float)mp3buffer[i++] * volume;
 8001b58:	f93a e019 	ldrsh.w	lr, [sl, r9, lsl #1]
          stereo[playerdata->buffer_wr * 2 + 1] = (float)mp3buffer[i++] * volume;
 8001b5c:	f109 0902 	add.w	r9, r9, #2
          stereo[playerdata->buffer_wr * 2] = (float)mp3buffer[i++] * volume;
 8001b60:	ee07 ea90 	vmov	s15, lr
          stereo[playerdata->buffer_wr * 2 + 1] = (float)mp3buffer[i++] * volume;
 8001b64:	eb00 0e83 	add.w	lr, r0, r3, lsl #2
          stereo[playerdata->buffer_wr * 2] = (float)mp3buffer[i++] * volume;
 8001b68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001b6c:	ee67 7a88 	vmul.f32	s15, s15, s16
 8001b70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001b74:	ee17 4a90 	vmov	r4, s15
 8001b78:	f820 4023 	strh.w	r4, [r0, r3, lsl #2]
          if(playerdata->buffer_wr + 1 >= playerdata->bufferSize)
 8001b7c:	3301      	adds	r3, #1
          stereo[playerdata->buffer_wr * 2 + 1] = (float)mp3buffer[i++] * volume;
 8001b7e:	f93c 4019 	ldrsh.w	r4, [ip, r9, lsl #1]
            playerdata->buffer_wr = 0;
 8001b82:	4299      	cmp	r1, r3
 8001b84:	bf98      	it	ls
 8001b86:	2300      	movls	r3, #0
        for(int i = 0; i < mp3Info.outputSamps;) {
 8001b88:	4591      	cmp	r9, r2
          stereo[playerdata->buffer_wr * 2 + 1] = (float)mp3buffer[i++] * volume;
 8001b8a:	ee07 4a90 	vmov	s15, r4
 8001b8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001b92:	ee67 7a88 	vmul.f32	s15, s15, s16
 8001b96:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001b9a:	ee17 4a90 	vmov	r4, s15
 8001b9e:	f8ae 4002 	strh.w	r4, [lr, #2]
        for(int i = 0; i < mp3Info.outputSamps;) {
 8001ba2:	dbd9      	blt.n	8001b58 <StartPlayerTask+0x4a4>
 8001ba4:	9c07      	ldr	r4, [sp, #28]
 8001ba6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8001baa:	e704      	b.n	80019b6 <StartPlayerTask+0x302>
        for(int i = 0; i < mp3Info.outputSamps; i++) {
 8001bac:	2a00      	cmp	r2, #0
 8001bae:	f77f af02 	ble.w	80019b6 <StartPlayerTask+0x302>
 8001bb2:	9905      	ldr	r1, [sp, #20]
 8001bb4:	1e88      	subs	r0, r1, #2
 8001bb6:	9906      	ldr	r1, [sp, #24]
 8001bb8:	eb00 0942 	add.w	r9, r0, r2, lsl #1
 8001bbc:	eb01 0e83 	add.w	lr, r1, r3, lsl #2
          mp3buffer[i] = (float)mp3buffer[i] * volume;
 8001bc0:	f930 1f02 	ldrsh.w	r1, [r0, #2]!
          stereo[playerdata->buffer_wr * 2] = mp3buffer[i];
 8001bc4:	f04f 0c00 	mov.w	ip, #0
          mp3buffer[i] = (float)mp3buffer[i] * volume;
 8001bc8:	ee07 1a90 	vmov	s15, r1
        for(int i = 0; i < mp3Info.outputSamps; i++) {
 8001bcc:	4548      	cmp	r0, r9
          mp3buffer[i] = (float)mp3buffer[i] * volume;
 8001bce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001bd2:	ee67 7a88 	vmul.f32	s15, s15, s16
 8001bd6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8001bda:	ee17 1a90 	vmov	r1, s15
 8001bde:	b209      	sxth	r1, r1
          stereo[playerdata->buffer_wr * 2] = mp3buffer[i];
 8001be0:	f361 0c0f 	bfi	ip, r1, #0, #16
          mp3buffer[i] = (float)mp3buffer[i] * volume;
 8001be4:	8001      	strh	r1, [r0, #0]
          stereo[playerdata->buffer_wr * 2] = mp3buffer[i];
 8001be6:	f361 4c1f 	bfi	ip, r1, #16, #16
 8001bea:	f84e cb04 	str.w	ip, [lr], #4
        for(int i = 0; i < mp3Info.outputSamps; i++) {
 8001bee:	d1e7      	bne.n	8001bc0 <StartPlayerTask+0x50c>
          playerdata->buffer_wr++;
 8001bf0:	4413      	add	r3, r2
 8001bf2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8001bf6:	e6de      	b.n	80019b6 <StartPlayerTask+0x302>
 8001bf8:	20000004 	.word	0x20000004
 8001bfc:	20004b08 	.word	0x20004b08
 8001c00:	20004b04 	.word	0x20004b04
 8001c04:	40020c00 	.word	0x40020c00

08001c08 <Comm_Transmit.constprop.0>:
osStatus_t Comm_Transmit(sCommData *commdata, char *cmd, ...)
 8001c08:	b40e      	push	{r1, r2, r3}
 8001c0a:	b5f0      	push	{r4, r5, r6, r7, lr}
  sem_status = osMutexAcquire(commdata->mutex, osWaitForever);
 8001c0c:	4d4b      	ldr	r5, [pc, #300]	; (8001d3c <Comm_Transmit.constprop.0+0x134>)
osStatus_t Comm_Transmit(sCommData *commdata, char *cmd, ...)
 8001c0e:	b082      	sub	sp, #8
  sem_status = osMutexAcquire(commdata->mutex, osWaitForever);
 8001c10:	f04f 31ff 	mov.w	r1, #4294967295
 8001c14:	f8d5 0254 	ldr.w	r0, [r5, #596]	; 0x254
 8001c18:	f007 fc60 	bl	80094dc <osMutexAcquire>
  if(sem_status == osOK) {
 8001c1c:	b130      	cbz	r0, 8001c2c <Comm_Transmit.constprop.0+0x24>
 8001c1e:	4604      	mov	r4, r0
}
 8001c20:	4620      	mov	r0, r4
 8001c22:	b002      	add	sp, #8
 8001c24:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8001c28:	b003      	add	sp, #12
 8001c2a:	4770      	bx	lr
    sem_status = osSemaphoreAcquire(commdata->tx_sem, osWaitForever);
 8001c2c:	f04f 31ff 	mov.w	r1, #4294967295
 8001c30:	f8d5 0250 	ldr.w	r0, [r5, #592]	; 0x250
 8001c34:	f007 fd1a 	bl	800966c <osSemaphoreAcquire>
    if(sem_status == osOK) {
 8001c38:	4604      	mov	r4, r0
 8001c3a:	b120      	cbz	r0, 8001c46 <Comm_Transmit.constprop.0+0x3e>
    osMutexRelease(commdata->mutex);
 8001c3c:	f8d5 0254 	ldr.w	r0, [r5, #596]	; 0x254
 8001c40:	f007 fc84 	bl	800954c <osMutexRelease>
  return sem_status;
 8001c44:	e7ec      	b.n	8001c20 <Comm_Transmit.constprop.0+0x18>
      vsnprintf(commdata->tx_buffer, UART_TX_BUFFER - 4, cmd, va_args);
 8001c46:	f505 7680 	add.w	r6, r5, #256	; 0x100
      va_start(va_args, cmd);
 8001c4a:	ab08      	add	r3, sp, #32
      vsnprintf(commdata->tx_buffer, UART_TX_BUFFER - 4, cmd, va_args);
 8001c4c:	9a07      	ldr	r2, [sp, #28]
 8001c4e:	21fc      	movs	r1, #252	; 0xfc
 8001c50:	4630      	mov	r0, r6
      va_start(va_args, cmd);
 8001c52:	9301      	str	r3, [sp, #4]
      vsnprintf(commdata->tx_buffer, UART_TX_BUFFER - 4, cmd, va_args);
 8001c54:	f011 ffea 	bl	8013c2c <vsniprintf>
      strl = strlen(commdata->tx_buffer);
 8001c58:	4630      	mov	r0, r6
 8001c5a:	f7fe feae 	bl	80009ba <strlen>
      commdata->tx_buffer[strl++] = '\r';
 8001c5e:	f640 210d 	movw	r1, #2573	; 0xa0d
 8001c62:	f500 7380 	add.w	r3, r0, #256	; 0x100
      commdata->tx_buffer[strl++] = '\n';
 8001c66:	1c82      	adds	r2, r0, #2
      commdata->tx_buffer[strl++] = '\r';
 8001c68:	52e9      	strh	r1, [r5, r3]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001c6a:	f3bf 8f4f 	dsb	sy
    __DSB();

    while (op_size > 0) {
      SCB->DCCMVAC = op_addr;
      op_addr += (uint32_t)linesize;
      op_size -=           linesize;
 8001c6e:	f1a0 011e 	sub.w	r1, r0, #30
      SCB->DCCMVAC = op_addr;
 8001c72:	4b33      	ldr	r3, [pc, #204]	; (8001d40 <Comm_Transmit.constprop.0+0x138>)
      op_addr += (uint32_t)linesize;
 8001c74:	f505 7790 	add.w	r7, r5, #288	; 0x120
    while (op_size > 0) {
 8001c78:	2900      	cmp	r1, #0
      SCB->DCCMVAC = op_addr;
 8001c7a:	f8c3 6268 	str.w	r6, [r3, #616]	; 0x268
    while (op_size > 0) {
 8001c7e:	dd49      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001c80:	f1a0 013e 	sub.w	r1, r0, #62	; 0x3e
      SCB->DCCMVAC = op_addr;
 8001c84:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001c88:	f505 77a0 	add.w	r7, r5, #320	; 0x140
    while (op_size > 0) {
 8001c8c:	2900      	cmp	r1, #0
 8001c8e:	dd41      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001c90:	f1a0 015e 	sub.w	r1, r0, #94	; 0x5e
      SCB->DCCMVAC = op_addr;
 8001c94:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001c98:	f505 77b0 	add.w	r7, r5, #352	; 0x160
    while (op_size > 0) {
 8001c9c:	2900      	cmp	r1, #0
 8001c9e:	dd39      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001ca0:	f1a0 017e 	sub.w	r1, r0, #126	; 0x7e
      SCB->DCCMVAC = op_addr;
 8001ca4:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001ca8:	f505 77c0 	add.w	r7, r5, #384	; 0x180
    while (op_size > 0) {
 8001cac:	2900      	cmp	r1, #0
 8001cae:	dd31      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001cb0:	f1a0 019e 	sub.w	r1, r0, #158	; 0x9e
      SCB->DCCMVAC = op_addr;
 8001cb4:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001cb8:	f505 77d0 	add.w	r7, r5, #416	; 0x1a0
    while (op_size > 0) {
 8001cbc:	2900      	cmp	r1, #0
 8001cbe:	dd29      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001cc0:	f1a0 01be 	sub.w	r1, r0, #190	; 0xbe
      SCB->DCCMVAC = op_addr;
 8001cc4:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001cc8:	f505 77e0 	add.w	r7, r5, #448	; 0x1c0
    while (op_size > 0) {
 8001ccc:	2900      	cmp	r1, #0
 8001cce:	dd21      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001cd0:	f1a0 01de 	sub.w	r1, r0, #222	; 0xde
      SCB->DCCMVAC = op_addr;
 8001cd4:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001cd8:	f505 77f0 	add.w	r7, r5, #480	; 0x1e0
    while (op_size > 0) {
 8001cdc:	2900      	cmp	r1, #0
 8001cde:	dd19      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      SCB->DCCMVAC = op_addr;
 8001ce0:	f8c3 7268 	str.w	r7, [r3, #616]	; 0x268
      op_size -=           linesize;
 8001ce4:	f1a0 03fe 	sub.w	r3, r0, #254	; 0xfe
      op_addr += (uint32_t)linesize;
 8001ce8:	f505 7700 	add.w	r7, r5, #512	; 0x200
    while (op_size > 0) {
 8001cec:	2b00      	cmp	r3, #0
 8001cee:	dd11      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      op_size -=           linesize;
 8001cf0:	f5a0 738f 	sub.w	r3, r0, #286	; 0x11e
      SCB->DCCMVAC = op_addr;
 8001cf4:	4912      	ldr	r1, [pc, #72]	; (8001d40 <Comm_Transmit.constprop.0+0x138>)
    while (op_size > 0) {
 8001cf6:	2b00      	cmp	r3, #0
      SCB->DCCMVAC = op_addr;
 8001cf8:	f8c1 7268 	str.w	r7, [r1, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001cfc:	f506 7790 	add.w	r7, r6, #288	; 0x120
    while (op_size > 0) {
 8001d00:	dd08      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
 8001d02:	f5b0 7f9f 	cmp.w	r0, #318	; 0x13e
      op_addr += (uint32_t)linesize;
 8001d06:	f506 76a0 	add.w	r6, r6, #320	; 0x140
      SCB->DCCMVAC = op_addr;
 8001d0a:	f8c1 7268 	str.w	r7, [r1, #616]	; 0x268
    while (op_size > 0) {
 8001d0e:	dd01      	ble.n	8001d14 <Comm_Transmit.constprop.0+0x10c>
      SCB->DCCMVAC = op_addr;
 8001d10:	f8c1 6268 	str.w	r6, [r1, #616]	; 0x268
 8001d14:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8001d18:	f3bf 8f6f 	isb	sy
      if(HAL_UART_Transmit_DMA(commdata->huart, (uint8_t *)commdata->tx_buffer, strl) != HAL_OK) {
 8001d1c:	4909      	ldr	r1, [pc, #36]	; (8001d44 <Comm_Transmit.constprop.0+0x13c>)
 8001d1e:	b292      	uxth	r2, r2
 8001d20:	f8d5 0240 	ldr.w	r0, [r5, #576]	; 0x240
 8001d24:	f003 ffa4 	bl	8005c70 <HAL_UART_Transmit_DMA>
 8001d28:	2800      	cmp	r0, #0
 8001d2a:	d087      	beq.n	8001c3c <Comm_Transmit.constprop.0+0x34>
        osSemaphoreRelease(gCommData.tx_sem);
 8001d2c:	f8d5 0250 	ldr.w	r0, [r5, #592]	; 0x250
        sem_status = osError;
 8001d30:	f04f 34ff 	mov.w	r4, #4294967295
        osSemaphoreRelease(gCommData.tx_sem);
 8001d34:	f007 fcdc 	bl	80096f0 <osSemaphoreRelease>
        sem_status = osError;
 8001d38:	e780      	b.n	8001c3c <Comm_Transmit.constprop.0+0x34>
 8001d3a:	bf00      	nop
 8001d3c:	200008a0 	.word	0x200008a0
 8001d40:	e000ed00 	.word	0xe000ed00
 8001d44:	200009a0 	.word	0x200009a0

08001d48 <HandleSaiDma.constprop.0>:
static void HandleSaiDma(uint32_t *buffer, uint32_t size)
 8001d48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001d4c:	4d39      	ldr	r5, [pc, #228]	; (8001e34 <HandleSaiDma.constprop.0+0xec>)
  for(int i = 0; i < PLAYERS_COUNT; i++)
 8001d4e:	f04f 0e00 	mov.w	lr, #0
      if(gPlayersData.player[i].playing) {
 8001d52:	f04f 08c4 	mov.w	r8, #196	; 0xc4
static void HandleSaiDma(uint32_t *buffer, uint32_t size)
 8001d56:	4684      	mov	ip, r0
 8001d58:	462a      	mov	r2, r5
        buffer[j * PLAYERS_COUNT + i] = 0;
 8001d5a:	4674      	mov	r4, lr
    if(/* gPlayersData.player[i].playing && */ getavail(gPlayersData.player[i].buffer_wr, gPlayersData.player[i].buffer_rd, gPlayersData.player[i].bufferSize) >= samples_per_channel)
 8001d5c:	f8d2 7098 	ldr.w	r7, [r2, #152]	; 0x98
 8001d60:	e9d2 312c 	ldrd	r3, r1, [r2, #176]	; 0xb0
  if(wr >= rd) return (wr - rd);
 8001d64:	4299      	cmp	r1, r3
  else return (size - rd + wr);
 8001d66:	bf38      	it	cc
 8001d68:	19c9      	addcc	r1, r1, r7
 8001d6a:	1ac9      	subs	r1, r1, r3
    if(/* gPlayersData.player[i].playing && */ getavail(gPlayersData.player[i].buffer_wr, gPlayersData.player[i].buffer_rd, gPlayersData.player[i].bufferSize) >= samples_per_channel)
 8001d6c:	2923      	cmp	r1, #35	; 0x23
 8001d6e:	d94e      	bls.n	8001e0e <HandleSaiDma.constprop.0+0xc6>
        buffer[j * PLAYERS_COUNT + i] = gPlayersData.player[i].buffer[gPlayersData.player[i].buffer_rd];
 8001d70:	f8d2 709c 	ldr.w	r7, [r2, #156]	; 0x9c
 8001d74:	2100      	movs	r1, #0
 8001d76:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 8001d7a:	f84c 3021 	str.w	r3, [ip, r1, lsl #2]
      for(int j = 0; j < samples_per_channel; j++)
 8001d7e:	3108      	adds	r1, #8
        if(gPlayersData.player[i].buffer_rd + 1 >= gPlayersData.player[i].bufferSize)
 8001d80:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 8001d84:	f8d2 6098 	ldr.w	r6, [r2, #152]	; 0x98
 8001d88:	3301      	adds	r3, #1
 8001d8a:	429e      	cmp	r6, r3
 8001d8c:	d937      	bls.n	8001dfe <HandleSaiDma.constprop.0+0xb6>
      for(int j = 0; j < samples_per_channel; j++)
 8001d8e:	f5b1 7f90 	cmp.w	r1, #288	; 0x120
 8001d92:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8001d96:	d1ee      	bne.n	8001d76 <HandleSaiDma.constprop.0+0x2e>
  for(int i = 0; i < PLAYERS_COUNT; i++)
 8001d98:	f10e 0e01 	add.w	lr, lr, #1
 8001d9c:	32c4      	adds	r2, #196	; 0xc4
 8001d9e:	f10c 0c04 	add.w	ip, ip, #4
 8001da2:	f1be 0f08 	cmp.w	lr, #8
 8001da6:	d1d9      	bne.n	8001d5c <HandleSaiDma.constprop.0+0x14>
  __ASM volatile ("dsb 0xF":::"memory");
 8001da8:	f3bf 8f4f 	dsb	sy
 8001dac:	4b22      	ldr	r3, [pc, #136]	; (8001e38 <HandleSaiDma.constprop.0+0xf0>)
      op_addr += (uint32_t)linesize;
 8001dae:	f100 0420 	add.w	r4, r0, #32
 8001db2:	f100 0240 	add.w	r2, r0, #64	; 0x40
 8001db6:	f100 0160 	add.w	r1, r0, #96	; 0x60
      SCB->DCCMVAC = op_addr;
 8001dba:	f8c3 0268 	str.w	r0, [r3, #616]	; 0x268
 8001dbe:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001dc2:	f100 04a0 	add.w	r4, r0, #160	; 0xa0
      SCB->DCCMVAC = op_addr;
 8001dc6:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001dca:	f100 0280 	add.w	r2, r0, #128	; 0x80
      SCB->DCCMVAC = op_addr;
 8001dce:	f8c3 1268 	str.w	r1, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001dd2:	f100 01c0 	add.w	r1, r0, #192	; 0xc0
      SCB->DCCMVAC = op_addr;
 8001dd6:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8001dda:	f100 02e0 	add.w	r2, r0, #224	; 0xe0
 8001dde:	f500 7080 	add.w	r0, r0, #256	; 0x100
      SCB->DCCMVAC = op_addr;
 8001de2:	f8c3 4268 	str.w	r4, [r3, #616]	; 0x268
 8001de6:	f8c3 1268 	str.w	r1, [r3, #616]	; 0x268
 8001dea:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
 8001dee:	f8c3 0268 	str.w	r0, [r3, #616]	; 0x268
 8001df2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8001df6:	f3bf 8f6f 	isb	sy
}
 8001dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      for(int j = 0; j < samples_per_channel; j++)
 8001dfe:	f5b1 7f90 	cmp.w	r1, #288	; 0x120
          gPlayersData.player[i].buffer_rd = 0;
 8001e02:	f04f 0300 	mov.w	r3, #0
 8001e06:	f8c2 40b0 	str.w	r4, [r2, #176]	; 0xb0
      for(int j = 0; j < samples_per_channel; j++)
 8001e0a:	d1b4      	bne.n	8001d76 <HandleSaiDma.constprop.0+0x2e>
 8001e0c:	e7c4      	b.n	8001d98 <HandleSaiDma.constprop.0+0x50>
      if(gPlayersData.player[i].playing) {
 8001e0e:	fb08 530e 	mla	r3, r8, lr, r5
 8001e12:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
 8001e16:	b123      	cbz	r3, 8001e22 <HandleSaiDma.constprop.0+0xda>
        gPlayersData.player[i].underflow_rd++;
 8001e18:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
 8001e1c:	3301      	adds	r3, #1
 8001e1e:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
          gPlayersData.player[i].buffer_rd = 0;
 8001e22:	2300      	movs	r3, #0
        buffer[j * PLAYERS_COUNT + i] = 0;
 8001e24:	f84c 4023 	str.w	r4, [ip, r3, lsl #2]
      for(int j = 0; j < samples_per_channel; j++)
 8001e28:	3308      	adds	r3, #8
 8001e2a:	f5b3 7f90 	cmp.w	r3, #288	; 0x120
 8001e2e:	d1f9      	bne.n	8001e24 <HandleSaiDma.constprop.0+0xdc>
 8001e30:	e7b2      	b.n	8001d98 <HandleSaiDma.constprop.0+0x50>
 8001e32:	bf00      	nop
 8001e34:	20000004 	.word	0x20000004
 8001e38:	e000ed00 	.word	0xe000ed00

08001e3c <StartCommTask>:
{
 8001e3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e40:	ed2d 8b0a 	vpush	{d8-d12}
 8001e44:	f5ad 7d2d 	sub.w	sp, sp, #692	; 0x2b4
 8001e48:	4603      	mov	r3, r0
  FATFS fs = {0};
 8001e4a:	f44f 720c 	mov.w	r2, #560	; 0x230
 8001e4e:	2100      	movs	r1, #0
 8001e50:	a820      	add	r0, sp, #128	; 0x80
{
 8001e52:	9312      	str	r3, [sp, #72]	; 0x48
  FATFS fs = {0};
 8001e54:	f011 f990 	bl	8013178 <memset>
  HAL_GPIO_WritePin(LED_D3_GPIO_Port, LED_D3_Pin, GPIO_PIN_SET);
 8001e58:	2201      	movs	r2, #1
 8001e5a:	2108      	movs	r1, #8
 8001e5c:	4802      	ldr	r0, [pc, #8]	; (8001e68 <StartCommTask+0x2c>)
    res = f_mount(&fs, SDPath, 1);
 8001e5e:	4e03      	ldr	r6, [pc, #12]	; (8001e6c <StartCommTask+0x30>)
  HAL_GPIO_WritePin(LED_D3_GPIO_Port, LED_D3_Pin, GPIO_PIN_SET);
 8001e60:	f001 fd40 	bl	80038e4 <HAL_GPIO_WritePin>
    HAL_GPIO_TogglePin(LED_D4_GPIO_Port, LED_D4_Pin);
 8001e64:	4c00      	ldr	r4, [pc, #0]	; (8001e68 <StartCommTask+0x2c>)
 8001e66:	e008      	b.n	8001e7a <StartCommTask+0x3e>
 8001e68:	40020c00 	.word	0x40020c00
 8001e6c:	200194c8 	.word	0x200194c8
 8001e70:	f001 fd3c 	bl	80038ec <HAL_GPIO_TogglePin>
    osDelay(200);
 8001e74:	20c8      	movs	r0, #200	; 0xc8
 8001e76:	f007 fa9f 	bl	80093b8 <osDelay>
    res = f_mount(&fs, SDPath, 1);
 8001e7a:	4631      	mov	r1, r6
 8001e7c:	2201      	movs	r2, #1
 8001e7e:	a820      	add	r0, sp, #128	; 0x80
 8001e80:	f006 fa1a 	bl	80082b8 <f_mount>
 8001e84:	4605      	mov	r5, r0
    HAL_GPIO_TogglePin(LED_D4_GPIO_Port, LED_D4_Pin);
 8001e86:	2110      	movs	r1, #16
 8001e88:	4620      	mov	r0, r4
    if(res == FR_OK)
 8001e8a:	2d00      	cmp	r5, #0
 8001e8c:	d1f0      	bne.n	8001e70 <StartCommTask+0x34>
  HAL_GPIO_WritePin(LED_D4_GPIO_Port, LED_D4_Pin, GPIO_PIN_SET);
 8001e8e:	2110      	movs	r1, #16
 8001e90:	2201      	movs	r2, #1
 8001e92:	48cc      	ldr	r0, [pc, #816]	; (80021c4 <StartCommTask+0x388>)
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001e94:	462e      	mov	r6, r5
  HAL_GPIO_WritePin(LED_D4_GPIO_Port, LED_D4_Pin, GPIO_PIN_SET);
 8001e96:	f001 fd25 	bl	80038e4 <HAL_GPIO_WritePin>
  gMp3Mutex = osMutexNew(&mutexMp3_attributes);
 8001e9a:	48cb      	ldr	r0, [pc, #812]	; (80021c8 <StartCommTask+0x38c>)
 8001e9c:	f007 fad6 	bl	800944c <osMutexNew>
 8001ea0:	4bca      	ldr	r3, [pc, #808]	; (80021cc <StartCommTask+0x390>)
 8001ea2:	4602      	mov	r2, r0
  gFSMutex = osMutexNew(&mutexFS_attributes);
 8001ea4:	48ca      	ldr	r0, [pc, #808]	; (80021d0 <StartCommTask+0x394>)
  memset(&gCommData, 0, sizeof(gCommData));
 8001ea6:	4ccb      	ldr	r4, [pc, #812]	; (80021d4 <StartCommTask+0x398>)
  gMp3Mutex = osMutexNew(&mutexMp3_attributes);
 8001ea8:	601a      	str	r2, [r3, #0]
  gFSMutex = osMutexNew(&mutexFS_attributes);
 8001eaa:	f007 facf 	bl	800944c <osMutexNew>
 8001eae:	4bca      	ldr	r3, [pc, #808]	; (80021d8 <StartCommTask+0x39c>)
  memset(&gCommData, 0, sizeof(gCommData));
 8001eb0:	4629      	mov	r1, r5
 8001eb2:	f44f 7216 	mov.w	r2, #600	; 0x258
 8001eb6:	4fc9      	ldr	r7, [pc, #804]	; (80021dc <StartCommTask+0x3a0>)
  gFSMutex = osMutexNew(&mutexFS_attributes);
 8001eb8:	6018      	str	r0, [r3, #0]
  memset(&gCommData, 0, sizeof(gCommData));
 8001eba:	4620      	mov	r0, r4
 8001ebc:	f011 f95c 	bl	8013178 <memset>
  gCommData.tx_sem = osSemaphoreNew(1, 1, NULL);
 8001ec0:	2101      	movs	r1, #1
  gCommData.huart = &huart1;
 8001ec2:	4bc7      	ldr	r3, [pc, #796]	; (80021e0 <StartCommTask+0x3a4>)
  gCommData.tx_sem = osSemaphoreNew(1, 1, NULL);
 8001ec4:	462a      	mov	r2, r5
 8001ec6:	4608      	mov	r0, r1
 8001ec8:	f8df a374 	ldr.w	sl, [pc, #884]	; 8002240 <StartCommTask+0x404>
  gCommData.huart = &huart1;
 8001ecc:	f8c4 3240 	str.w	r3, [r4, #576]	; 0x240
  gCommData.tx_sem = osSemaphoreNew(1, 1, NULL);
 8001ed0:	f007 fb72 	bl	80095b8 <osSemaphoreNew>
 8001ed4:	4603      	mov	r3, r0
  gCommData.mutex = osMutexNew(&mutexCommTx_attributes);
 8001ed6:	48c3      	ldr	r0, [pc, #780]	; (80021e4 <StartCommTask+0x3a8>)
  gCommData.tx_sem = osSemaphoreNew(1, 1, NULL);
 8001ed8:	f8c4 3250 	str.w	r3, [r4, #592]	; 0x250
  gCommData.mutex = osMutexNew(&mutexCommTx_attributes);
 8001edc:	f007 fab6 	bl	800944c <osMutexNew>
  HAL_UART_Receive_DMA(gCommData.huart, gCommData.rx_buffer, UART_RX_BUFFER);
 8001ee0:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001ee4:	4621      	mov	r1, r4
  gCommData.mutex = osMutexNew(&mutexCommTx_attributes);
 8001ee6:	f8c4 0254 	str.w	r0, [r4, #596]	; 0x254
  HAL_UART_Receive_DMA(gCommData.huart, gCommData.rx_buffer, UART_RX_BUFFER);
 8001eea:	f8d4 0240 	ldr.w	r0, [r4, #576]	; 0x240
 8001eee:	f004 fc1d 	bl	800672c <HAL_UART_Receive_DMA>
  memset(gTdmFinalBuffer, 0, sizeof(gTdmFinalBuffer));
 8001ef2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8001ef4:	4629      	mov	r1, r5
 8001ef6:	f44f 6210 	mov.w	r2, #2304	; 0x900
 8001efa:	f103 050c 	add.w	r5, r3, #12
 8001efe:	4bba      	ldr	r3, [pc, #744]	; (80021e8 <StartCommTask+0x3ac>)
 8001f00:	48ba      	ldr	r0, [pc, #744]	; (80021ec <StartCommTask+0x3b0>)
 8001f02:	9310      	str	r3, [sp, #64]	; 0x40
 8001f04:	f011 f938 	bl	8013178 <memset>
    memset(&playersdata->player[i], 0, sizeof(playersdata->player[i]));
 8001f08:	f1a5 0308 	sub.w	r3, r5, #8
 8001f0c:	f04f 09c4 	mov.w	r9, #196	; 0xc4
 8001f10:	2100      	movs	r1, #0
 8001f12:	46b0      	mov	r8, r6
 8001f14:	4618      	mov	r0, r3
 8001f16:	464a      	mov	r2, r9
 8001f18:	9315      	str	r3, [sp, #84]	; 0x54
    str = (char *)pvPortMalloc(12); sprintf(str, "player%d", i+1); playersdata->player[i].name = str;
 8001f1a:	3601      	adds	r6, #1
    memset(&playersdata->player[i], 0, sizeof(playersdata->player[i]));
 8001f1c:	f011 f92c 	bl	8013178 <memset>
    str = (char *)pvPortMalloc(12); sprintf(str, "player%d", i+1); playersdata->player[i].name = str;
 8001f20:	200c      	movs	r0, #12
 8001f22:	f00a fa39 	bl	800c398 <pvPortMalloc>
 8001f26:	4683      	mov	fp, r0
 8001f28:	4632      	mov	r2, r6
 8001f2a:	49b1      	ldr	r1, [pc, #708]	; (80021f0 <StartCommTask+0x3b4>)
 8001f2c:	f011 fd96 	bl	8013a5c <siprintf>
 8001f30:	f845 bc08 	str.w	fp, [r5, #-8]
    str = (char *)pvPortMalloc(16); sprintf(str, "mutexPlayer%d", i+1); mutexPlayer_attributes.name = str;
 8001f34:	2010      	movs	r0, #16
 8001f36:	f00a fa2f 	bl	800c398 <pvPortMalloc>
 8001f3a:	4632      	mov	r2, r6
 8001f3c:	49ad      	ldr	r1, [pc, #692]	; (80021f4 <StartCommTask+0x3b8>)
 8001f3e:	4683      	mov	fp, r0
 8001f40:	f011 fd8c 	bl	8013a5c <siprintf>
 8001f44:	4bac      	ldr	r3, [pc, #688]	; (80021f8 <StartCommTask+0x3bc>)
    str = (char *)pvPortMalloc(16); sprintf(str, "taskPlayer%d", i+1); taskPlayer_attributes.name = str;
 8001f46:	2010      	movs	r0, #16
    str = (char *)pvPortMalloc(16); sprintf(str, "mutexPlayer%d", i+1); mutexPlayer_attributes.name = str;
 8001f48:	f8c3 b000 	str.w	fp, [r3]
    str = (char *)pvPortMalloc(16); sprintf(str, "taskPlayer%d", i+1); taskPlayer_attributes.name = str;
 8001f4c:	f00a fa24 	bl	800c398 <pvPortMalloc>
 8001f50:	4632      	mov	r2, r6
 8001f52:	49aa      	ldr	r1, [pc, #680]	; (80021fc <StartCommTask+0x3c0>)
 8001f54:	4683      	mov	fp, r0
 8001f56:	f011 fd81 	bl	8013a5c <siprintf>
 8001f5a:	4ba9      	ldr	r3, [pc, #676]	; (8002200 <StartCommTask+0x3c4>)
    sprintf(playersdata->player[i].file, "music/%d.mp3", i+1);
 8001f5c:	4632      	mov	r2, r6
 8001f5e:	49a9      	ldr	r1, [pc, #676]	; (8002204 <StartCommTask+0x3c8>)
 8001f60:	4628      	mov	r0, r5
    str = (char *)pvPortMalloc(16); sprintf(str, "taskPlayer%d", i+1); taskPlayer_attributes.name = str;
 8001f62:	f8c3 b000 	str.w	fp, [r3]
    sprintf(playersdata->player[i].file, "music/%d.mp3", i+1);
 8001f66:	f011 fd79 	bl	8013a5c <siprintf>
    playersdata->player[i].enabled = 0;
 8001f6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    playersdata->player[i].volume = 100;
 8001f6c:	2264      	movs	r2, #100	; 0x64
    playersdata->player[i].enabled = 0;
 8001f6e:	fb09 3808 	mla	r8, r9, r8, r3
 8001f72:	f04f 0300 	mov.w	r3, #0
 8001f76:	f888 308c 	strb.w	r3, [r8, #140]	; 0x8c
    playersdata->player[i].playing = 0;
 8001f7a:	f888 308d 	strb.w	r3, [r8, #141]	; 0x8d
    playersdata->player[i].volume = 100;
 8001f7e:	f885 2083 	strb.w	r2, [r5, #131]	; 0x83
    playersdata->player[i].bufferSize = SAMPLE_BUFFER_SIZE;
 8001f82:	f240 5224 	movw	r2, #1316	; 0x524
    playersdata->player[i].fileBuffer = gFileBuffer[i];
 8001f86:	9b10      	ldr	r3, [sp, #64]	; 0x40
    playersdata->player[i].bufferSize = SAMPLE_BUFFER_SIZE;
 8001f88:	f8c5 208c 	str.w	r2, [r5, #140]	; 0x8c
    playersdata->player[i].sampleBufferSize = MP3_SAMPLE_SIZE;
 8001f8c:	f44f 6210 	mov.w	r2, #2304	; 0x900
    playersdata->player[i].buffer = gSamplesBuffer[i];
 8001f90:	f8c5 7090 	str.w	r7, [r5, #144]	; 0x90
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001f94:	f507 57a4 	add.w	r7, r7, #5248	; 0x1480
    playersdata->player[i].sampleBufferSize = MP3_SAMPLE_SIZE;
 8001f98:	f8c5 20a0 	str.w	r2, [r5, #160]	; 0xa0
    playersdata->player[i].fileBufferSize = FILE_BUFFER_SIZE;
 8001f9c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    playersdata->player[i].sampleBuffer = gSampleBuffer[i];
 8001fa0:	f8c5 a09c 	str.w	sl, [r5, #156]	; 0x9c
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001fa4:	3710      	adds	r7, #16
    playersdata->player[i].fileBufferSize = FILE_BUFFER_SIZE;
 8001fa6:	f8c5 2098 	str.w	r2, [r5, #152]	; 0x98
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001faa:	f50a 5a90 	add.w	sl, sl, #4608	; 0x1200
    playersdata->player[i].fileBuffer = gFileBuffer[i];
 8001fae:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001fb2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8001fb6:	444d      	add	r5, r9
 8001fb8:	9310      	str	r3, [sp, #64]	; 0x40
    playersdata->player[i].decoder = MP3InitDecoder();
 8001fba:	f00a fb11 	bl	800c5e0 <MP3InitDecoder>
 8001fbe:	f845 0cc8 	str.w	r0, [r5, #-200]
    playersdata->player[i].mutex = osMutexNew(&mutexPlayer_attributes);
 8001fc2:	488d      	ldr	r0, [pc, #564]	; (80021f8 <StartCommTask+0x3bc>)
 8001fc4:	f007 fa42 	bl	800944c <osMutexNew>
    playersdata->player[i].task = osThreadNew(StartPlayerTask, &playersdata->player[i], &taskPlayer_attributes);
 8001fc8:	9b15      	ldr	r3, [sp, #84]	; 0x54
    playersdata->player[i].mutex = osMutexNew(&mutexPlayer_attributes);
 8001fca:	f845 0c40 	str.w	r0, [r5, #-64]
    playersdata->player[i].task = osThreadNew(StartPlayerTask, &playersdata->player[i], &taskPlayer_attributes);
 8001fce:	4619      	mov	r1, r3
 8001fd0:	4a8b      	ldr	r2, [pc, #556]	; (8002200 <StartCommTask+0x3c4>)
 8001fd2:	488d      	ldr	r0, [pc, #564]	; (8002208 <StartCommTask+0x3cc>)
 8001fd4:	f007 f996 	bl	8009304 <osThreadNew>
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001fd8:	2e08      	cmp	r6, #8
    playersdata->player[i].task = osThreadNew(StartPlayerTask, &playersdata->player[i], &taskPlayer_attributes);
 8001fda:	f845 0c3c 	str.w	r0, [r5, #-60]
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001fde:	d193      	bne.n	8001f08 <StartCommTask+0xcc>
 8001fe0:	4e82      	ldr	r6, [pc, #520]	; (80021ec <StartCommTask+0x3b0>)
  for(int i = 0; i < PLAYERS_COUNT; i++)
 8001fe2:	2700      	movs	r7, #0
 8001fe4:	4a89      	ldr	r2, [pc, #548]	; (800220c <StartCommTask+0x3d0>)
  for(int i = 0; i < PLAYERS_COUNT; i++) {
 8001fe6:	4630      	mov	r0, r6
        buffer[j * PLAYERS_COUNT + i] = 0;
 8001fe8:	463d      	mov	r5, r7
 8001fea:	46b0      	mov	r8, r6
    if(/* gPlayersData.player[i].playing && */ getavail(gPlayersData.player[i].buffer_wr, gPlayersData.player[i].buffer_rd, gPlayersData.player[i].bufferSize) >= samples_per_channel)
 8001fec:	f8d2 c098 	ldr.w	ip, [r2, #152]	; 0x98
 8001ff0:	e9d2 312c 	ldrd	r3, r1, [r2, #176]	; 0xb0
  if(wr >= rd) return (wr - rd);
 8001ff4:	4299      	cmp	r1, r3
  else return (size - rd + wr);
 8001ff6:	bf38      	it	cc
 8001ff8:	4461      	addcc	r1, ip
 8001ffa:	1ac9      	subs	r1, r1, r3
    if(/* gPlayersData.player[i].playing && */ getavail(gPlayersData.player[i].buffer_wr, gPlayersData.player[i].buffer_rd, gPlayersData.player[i].bufferSize) >= samples_per_channel)
 8001ffc:	2947      	cmp	r1, #71	; 0x47
 8001ffe:	f240 831c 	bls.w	800263a <StartCommTask+0x7fe>
        buffer[j * PLAYERS_COUNT + i] = gPlayersData.player[i].buffer[gPlayersData.player[i].buffer_rd];
 8002002:	f8d2 e09c 	ldr.w	lr, [r2, #156]	; 0x9c
 8002006:	2100      	movs	r1, #0
 8002008:	f85e 6023 	ldr.w	r6, [lr, r3, lsl #2]
        if(gPlayersData.player[i].buffer_rd + 1 >= gPlayersData.player[i].bufferSize)
 800200c:	3301      	adds	r3, #1
 800200e:	459c      	cmp	ip, r3
        buffer[j * PLAYERS_COUNT + i] = gPlayersData.player[i].buffer[gPlayersData.player[i].buffer_rd];
 8002010:	f840 6021 	str.w	r6, [r0, r1, lsl #2]
      for(int j = 0; j < samples_per_channel; j++)
 8002014:	f101 0108 	add.w	r1, r1, #8
        if(gPlayersData.player[i].buffer_rd + 1 >= gPlayersData.player[i].bufferSize)
 8002018:	f240 823c 	bls.w	8002494 <StartCommTask+0x658>
      for(int j = 0; j < samples_per_channel; j++)
 800201c:	f5b1 7f10 	cmp.w	r1, #576	; 0x240
 8002020:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8002024:	d1f0      	bne.n	8002008 <StartCommTask+0x1cc>
  for(int i = 0; i < PLAYERS_COUNT; i++)
 8002026:	3701      	adds	r7, #1
 8002028:	32c4      	adds	r2, #196	; 0xc4
 800202a:	3004      	adds	r0, #4
 800202c:	2f08      	cmp	r7, #8
 800202e:	d1dd      	bne.n	8001fec <StartCommTask+0x1b0>
 8002030:	4646      	mov	r6, r8
  __ASM volatile ("dsb 0xF":::"memory");
 8002032:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
 8002036:	4a76      	ldr	r2, [pc, #472]	; (8002210 <StartCommTask+0x3d4>)
      SCB->DCCMVAC = op_addr;
 8002038:	4b76      	ldr	r3, [pc, #472]	; (8002214 <StartCommTask+0x3d8>)
 800203a:	f8c3 6268 	str.w	r6, [r3, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 800203e:	3620      	adds	r6, #32
    while (op_size > 0) {
 8002040:	42b2      	cmp	r2, r6
 8002042:	d1fa      	bne.n	800203a <StartCommTask+0x1fe>
 8002044:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002048:	f3bf 8f6f 	isb	sy
  HAL_SAI_Transmit_DMA(&hsai_BlockA1, (uint8_t*)gTdmFinalBuffer, TDM_BUFFER_SIZE);
 800204c:	f44f 7210 	mov.w	r2, #576	; 0x240
 8002050:	4966      	ldr	r1, [pc, #408]	; (80021ec <StartCommTask+0x3b0>)
 8002052:	4871      	ldr	r0, [pc, #452]	; (8002218 <StartCommTask+0x3dc>)
  tick = 0;
 8002054:	f04f 0b00 	mov.w	fp, #0
  HAL_SAI_Transmit_DMA(&hsai_BlockA1, (uint8_t*)gTdmFinalBuffer, TDM_BUFFER_SIZE);
 8002058:	f002 fc02 	bl	8004860 <HAL_SAI_Transmit_DMA>
  float cpu_avg = 0;
 800205c:	ed9f aa6f 	vldr	s20, [pc, #444]	; 800221c <StartCommTask+0x3e0>
  gTaskIdle = osThreadNew(StartIdleTask, NULL, &taskIdle_attributes);
 8002060:	4a6f      	ldr	r2, [pc, #444]	; (8002220 <StartCommTask+0x3e4>)
 8002062:	2100      	movs	r1, #0
 8002064:	486f      	ldr	r0, [pc, #444]	; (8002224 <StartCommTask+0x3e8>)
  float ram_avg = 0;
 8002066:	eef0 8a4a 	vmov.f32	s17, s20
  gTaskIdle = osThreadNew(StartIdleTask, NULL, &taskIdle_attributes);
 800206a:	f007 f94b 	bl	8009304 <osThreadNew>
 800206e:	4b6e      	ldr	r3, [pc, #440]	; (8002228 <StartCommTask+0x3ec>)
  float sd_avg = 0;
 8002070:	eef0 9a4a 	vmov.f32	s19, s20
 8002074:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8002244 <StartCommTask+0x408>
  gTaskIdle = osThreadNew(StartIdleTask, NULL, &taskIdle_attributes);
 8002078:	6018      	str	r0, [r3, #0]
  current = xTaskGetTickCount();
 800207a:	f009 f931 	bl	800b2e0 <xTaskGetTickCount>
      gCpuLoad = (float)(1000 - gIdleTick) * 0.1f;
 800207e:	eddf ba6b 	vldr	s23, [pc, #428]	; 800222c <StartCommTask+0x3f0>
  current = xTaskGetTickCount();
 8002082:	4681      	mov	r9, r0
          (float)sdstats.readMax / 1024.0f,
 8002084:	ed9f 8a6a 	vldr	s16, [pc, #424]	; 8002230 <StartCommTask+0x3f4>
      else ram_avg = ram_avg * (1.0f - msr_koff) + xPortGetFreeHeapSize() * msr_koff;
 8002088:	ed9f ba6a 	vldr	s22, [pc, #424]	; 8002234 <StartCommTask+0x3f8>
 800208c:	eddf aa6a 	vldr	s21, [pc, #424]	; 8002238 <StartCommTask+0x3fc>
      SCB->DCIMVAC = op_addr;
 8002090:	4d60      	ldr	r5, [pc, #384]	; (8002214 <StartCommTask+0x3d8>)
  while(commdata->rx_wr != commdata->rx_rd) {
 8002092:	e9d4 3190 	ldrd	r3, r1, [r4, #576]	; 0x240
  commdata->rx_wr = commdata->huart->RxXferSize - commdata->huart->hdmarx->Instance->NDTR;
 8002096:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8002098:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
 800209c:	6803      	ldr	r3, [r0, #0]
 800209e:	685b      	ldr	r3, [r3, #4]
 80020a0:	1ad3      	subs	r3, r2, r3
  while(commdata->rx_wr != commdata->rx_rd) {
 80020a2:	4299      	cmp	r1, r3
  commdata->rx_wr = commdata->huart->RxXferSize - commdata->huart->hdmarx->Instance->NDTR;
 80020a4:	f8c4 3248 	str.w	r3, [r4, #584]	; 0x248
  while(commdata->rx_wr != commdata->rx_rd) {
 80020a8:	f000 80e8 	beq.w	800227c <StartCommTask+0x440>
      commdata->rx_rd = 0;
 80020ac:	2100      	movs	r1, #0
  __ASM volatile ("dsb 0xF":::"memory");
 80020ae:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
 80020b2:	b14a      	cbz	r2, 80020c8 <StartCommTask+0x28c>
 80020b4:	3a01      	subs	r2, #1
    uint32_t op_addr = (uint32_t)addr;
 80020b6:	4623      	mov	r3, r4
 80020b8:	f022 021f 	bic.w	r2, r2, #31
 80020bc:	4442      	add	r2, r8
      SCB->DCIMVAC = op_addr;
 80020be:	f8c5 325c 	str.w	r3, [r5, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
 80020c2:	3320      	adds	r3, #32
    while (op_size > 0) {
 80020c4:	4293      	cmp	r3, r2
 80020c6:	d1fa      	bne.n	80020be <StartCommTask+0x282>
 80020c8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80020cc:	f3bf 8f6f 	isb	sy
    chr = commdata->rx_buffer[commdata->rx_rd++];
 80020d0:	f8d4 2244 	ldr.w	r2, [r4, #580]	; 0x244
 80020d4:	1c53      	adds	r3, r2, #1
 80020d6:	5ca0      	ldrb	r0, [r4, r2]
    if(commdata->rx_rd >= UART_RX_BUFFER || commdata->rx_rd >= commdata->huart->RxXferSize) {
 80020d8:	2bff      	cmp	r3, #255	; 0xff
    chr = commdata->rx_buffer[commdata->rx_rd++];
 80020da:	f8c4 3244 	str.w	r3, [r4, #580]	; 0x244
    if(commdata->rx_rd >= UART_RX_BUFFER || commdata->rx_rd >= commdata->huart->RxXferSize) {
 80020de:	d805      	bhi.n	80020ec <StartCommTask+0x2b0>
 80020e0:	f8d4 2240 	ldr.w	r2, [r4, #576]	; 0x240
 80020e4:	f8b2 2058 	ldrh.w	r2, [r2, #88]	; 0x58
 80020e8:	4293      	cmp	r3, r2
 80020ea:	d301      	bcc.n	80020f0 <StartCommTask+0x2b4>
      commdata->rx_rd = 0;
 80020ec:	f8c4 1244 	str.w	r1, [r4, #580]	; 0x244
    if(commdata->rx_cmd_ptr + 1 >= UART_CMD_BUFFER || chr == '\r' || chr == '\n') {
 80020f0:	f8d4 224c 	ldr.w	r2, [r4, #588]	; 0x24c
 80020f4:	1c53      	adds	r3, r2, #1
 80020f6:	2b3f      	cmp	r3, #63	; 0x3f
 80020f8:	f240 8185 	bls.w	8002406 <StartCommTask+0x5ca>
      commdata->rx_cmd[commdata->rx_cmd_ptr] = '\0';
 80020fc:	18a3      	adds	r3, r4, r2
 80020fe:	2100      	movs	r1, #0
 8002100:	f883 1200 	strb.w	r1, [r3, #512]	; 0x200
          memset(&commdata->rx_cmd[commdata->rx_cmd_ptr], 0, UART_CMD_BUFFER - commdata->rx_cmd_ptr);
 8002104:	f502 7000 	add.w	r0, r2, #512	; 0x200
 8002108:	2100      	movs	r1, #0
 800210a:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
        commdata->rx_cmd_ptr = 0;
 800210e:	2700      	movs	r7, #0
          memset(&commdata->rx_cmd[commdata->rx_cmd_ptr], 0, UART_CMD_BUFFER - commdata->rx_cmd_ptr);
 8002110:	4420      	add	r0, r4
 8002112:	f011 f831 	bl	8013178 <memset>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002116:	4b3d      	ldr	r3, [pc, #244]	; (800220c <StartCommTask+0x3d0>)
        commdata->rx_cmd_ptr = 0;
 8002118:	f8c4 724c 	str.w	r7, [r4, #588]	; 0x24c
      for(int i = 0; i < gPlayersData.count; i++) {
 800211c:	681e      	ldr	r6, [r3, #0]
 800211e:	2e00      	cmp	r6, #0
 8002120:	f000 80ac 	beq.w	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002124:	4b39      	ldr	r3, [pc, #228]	; (800220c <StartCommTask+0x3d0>)
 8002126:	4845      	ldr	r0, [pc, #276]	; (800223c <StartCommTask+0x400>)
 8002128:	f8d3 a004 	ldr.w	sl, [r3, #4]
 800212c:	4651      	mov	r1, sl
 800212e:	f011 fd3b 	bl	8013ba8 <strstr>
 8002132:	4b42      	ldr	r3, [pc, #264]	; (800223c <StartCommTask+0x400>)
 8002134:	4283      	cmp	r3, r0
 8002136:	f000 81bc 	beq.w	80024b2 <StartCommTask+0x676>
      for(int i = 0; i < gPlayersData.count; i++) {
 800213a:	2e01      	cmp	r6, #1
 800213c:	f000 809e 	beq.w	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002140:	4b32      	ldr	r3, [pc, #200]	; (800220c <StartCommTask+0x3d0>)
 8002142:	483e      	ldr	r0, [pc, #248]	; (800223c <StartCommTask+0x400>)
 8002144:	f8d3 70c8 	ldr.w	r7, [r3, #200]	; 0xc8
 8002148:	4639      	mov	r1, r7
 800214a:	f011 fd2d 	bl	8013ba8 <strstr>
 800214e:	4b3b      	ldr	r3, [pc, #236]	; (800223c <StartCommTask+0x400>)
 8002150:	4283      	cmp	r3, r0
 8002152:	f000 8225 	beq.w	80025a0 <StartCommTask+0x764>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002156:	2e02      	cmp	r6, #2
 8002158:	f000 8090 	beq.w	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 800215c:	4b2b      	ldr	r3, [pc, #172]	; (800220c <StartCommTask+0x3d0>)
 800215e:	4837      	ldr	r0, [pc, #220]	; (800223c <StartCommTask+0x400>)
 8002160:	f8d3 718c 	ldr.w	r7, [r3, #396]	; 0x18c
 8002164:	4639      	mov	r1, r7
 8002166:	f011 fd1f 	bl	8013ba8 <strstr>
 800216a:	4b34      	ldr	r3, [pc, #208]	; (800223c <StartCommTask+0x400>)
 800216c:	4283      	cmp	r3, r0
 800216e:	f000 8222 	beq.w	80025b6 <StartCommTask+0x77a>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002172:	2e03      	cmp	r6, #3
 8002174:	f000 8082 	beq.w	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002178:	4b24      	ldr	r3, [pc, #144]	; (800220c <StartCommTask+0x3d0>)
 800217a:	4830      	ldr	r0, [pc, #192]	; (800223c <StartCommTask+0x400>)
 800217c:	f8d3 7250 	ldr.w	r7, [r3, #592]	; 0x250
 8002180:	4639      	mov	r1, r7
 8002182:	f011 fd11 	bl	8013ba8 <strstr>
 8002186:	4b2d      	ldr	r3, [pc, #180]	; (800223c <StartCommTask+0x400>)
 8002188:	4283      	cmp	r3, r0
 800218a:	f000 822a 	beq.w	80025e2 <StartCommTask+0x7a6>
      for(int i = 0; i < gPlayersData.count; i++) {
 800218e:	2e04      	cmp	r6, #4
 8002190:	d074      	beq.n	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002192:	4b1e      	ldr	r3, [pc, #120]	; (800220c <StartCommTask+0x3d0>)
 8002194:	4829      	ldr	r0, [pc, #164]	; (800223c <StartCommTask+0x400>)
 8002196:	f8d3 7314 	ldr.w	r7, [r3, #788]	; 0x314
 800219a:	4639      	mov	r1, r7
 800219c:	f011 fd04 	bl	8013ba8 <strstr>
 80021a0:	4b26      	ldr	r3, [pc, #152]	; (800223c <StartCommTask+0x400>)
 80021a2:	4283      	cmp	r3, r0
 80021a4:	f000 8212 	beq.w	80025cc <StartCommTask+0x790>
      for(int i = 0; i < gPlayersData.count; i++) {
 80021a8:	2e05      	cmp	r6, #5
 80021aa:	d067      	beq.n	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80021ac:	4b17      	ldr	r3, [pc, #92]	; (800220c <StartCommTask+0x3d0>)
 80021ae:	4823      	ldr	r0, [pc, #140]	; (800223c <StartCommTask+0x400>)
 80021b0:	f8d3 73d8 	ldr.w	r7, [r3, #984]	; 0x3d8
 80021b4:	4639      	mov	r1, r7
 80021b6:	f011 fcf7 	bl	8013ba8 <strstr>
 80021ba:	4b20      	ldr	r3, [pc, #128]	; (800223c <StartCommTask+0x400>)
 80021bc:	4283      	cmp	r3, r0
 80021be:	f000 821b 	beq.w	80025f8 <StartCommTask+0x7bc>
 80021c2:	e041      	b.n	8002248 <StartCommTask+0x40c>
 80021c4:	40020c00 	.word	0x40020c00
 80021c8:	08016aa0 	.word	0x08016aa0
 80021cc:	20004b08 	.word	0x20004b08
 80021d0:	08016a90 	.word	0x08016a90
 80021d4:	200008a0 	.word	0x200008a0
 80021d8:	20000b00 	.word	0x20000b00
 80021dc:	2000db0c 	.word	0x2000db0c
 80021e0:	20018bd4 	.word	0x20018bd4
 80021e4:	08016a80 	.word	0x08016a80
 80021e8:	20000b04 	.word	0x20000b04
 80021ec:	20017fa0 	.word	0x20017fa0
 80021f0:	08016964 	.word	0x08016964
 80021f4:	08016970 	.word	0x08016970
 80021f8:	20000628 	.word	0x20000628
 80021fc:	08016980 	.word	0x08016980
 8002200:	2000065c 	.word	0x2000065c
 8002204:	08016990 	.word	0x08016990
 8002208:	080016b5 	.word	0x080016b5
 800220c:	20000004 	.word	0x20000004
 8002210:	200181e0 	.word	0x200181e0
 8002214:	e000ed00 	.word	0xe000ed00
 8002218:	20018a80 	.word	0x20018a80
 800221c:	00000000 	.word	0x00000000
 8002220:	20000638 	.word	0x20000638
 8002224:	0800169d 	.word	0x0800169d
 8002228:	20017f8c 	.word	0x20017f8c
 800222c:	3dcccccd 	.word	0x3dcccccd
 8002230:	3a800000 	.word	0x3a800000
 8002234:	3c88889a 	.word	0x3c88889a
 8002238:	3f7bbbbb 	.word	0x3f7bbbbb
 800223c:	20000aa0 	.word	0x20000aa0
 8002240:	20004b0c 	.word	0x20004b0c
 8002244:	200008c0 	.word	0x200008c0
      for(int i = 0; i < gPlayersData.count; i++) {
 8002248:	2e06      	cmp	r6, #6
 800224a:	d017      	beq.n	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 800224c:	4bc7      	ldr	r3, [pc, #796]	; (800256c <StartCommTask+0x730>)
 800224e:	48c8      	ldr	r0, [pc, #800]	; (8002570 <StartCommTask+0x734>)
 8002250:	f8d3 749c 	ldr.w	r7, [r3, #1180]	; 0x49c
 8002254:	4639      	mov	r1, r7
 8002256:	f011 fca7 	bl	8013ba8 <strstr>
 800225a:	4bc5      	ldr	r3, [pc, #788]	; (8002570 <StartCommTask+0x734>)
 800225c:	4283      	cmp	r3, r0
 800225e:	f000 81d6 	beq.w	800260e <StartCommTask+0x7d2>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002262:	2e07      	cmp	r6, #7
 8002264:	d00a      	beq.n	800227c <StartCommTask+0x440>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002266:	4bc1      	ldr	r3, [pc, #772]	; (800256c <StartCommTask+0x730>)
 8002268:	48c1      	ldr	r0, [pc, #772]	; (8002570 <StartCommTask+0x734>)
 800226a:	f8d3 6560 	ldr.w	r6, [r3, #1376]	; 0x560
 800226e:	4631      	mov	r1, r6
 8002270:	f011 fc9a 	bl	8013ba8 <strstr>
 8002274:	4bbe      	ldr	r3, [pc, #760]	; (8002570 <StartCommTask+0x734>)
 8002276:	4283      	cmp	r3, r0
 8002278:	f000 81d4 	beq.w	8002624 <StartCommTask+0x7e8>
    taskENTER_CRITICAL();
 800227c:	f009 ff3a 	bl	800c0f4 <vPortEnterCritical>
    if(xTaskGetTickCount() - gMp3LedLast > 1000) {
 8002280:	f009 f82e 	bl	800b2e0 <xTaskGetTickCount>
 8002284:	4bbb      	ldr	r3, [pc, #748]	; (8002574 <StartCommTask+0x738>)
 8002286:	681b      	ldr	r3, [r3, #0]
 8002288:	1ac0      	subs	r0, r0, r3
 800228a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800228e:	f200 80d3 	bhi.w	8002438 <StartCommTask+0x5fc>
    current += 30;
 8002292:	f109 091e 	add.w	r9, r9, #30
    if(++tick >= 1000/30) {
 8002296:	f10b 0b01 	add.w	fp, fp, #1
    taskEXIT_CRITICAL();
 800229a:	f009 ff51 	bl	800c140 <vPortExitCritical>
    osDelayUntil(current);
 800229e:	4648      	mov	r0, r9
 80022a0:	f007 f8aa 	bl	80093f8 <osDelayUntil>
    if(++tick >= 1000/30) {
 80022a4:	f1bb 0f20 	cmp.w	fp, #32
 80022a8:	f67f aef3 	bls.w	8002092 <StartCommTask+0x256>
      sdstats = BSP_SD_GetStats();
 80022ac:	a818      	add	r0, sp, #96	; 0x60
 80022ae:	f005 fb27 	bl	8007900 <BSP_SD_GetStats>
      if(gIdleTick > 1000)
 80022b2:	49b1      	ldr	r1, [pc, #708]	; (8002578 <StartCommTask+0x73c>)
      sdstats = BSP_SD_GetStats();
 80022b4:	9a1c      	ldr	r2, [sp, #112]	; 0x70
      if(gIdleTick > 1000)
 80022b6:	680b      	ldr	r3, [r1, #0]
 80022b8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80022bc:	d902      	bls.n	80022c4 <StartCommTask+0x488>
        gIdleTick = 1000;
 80022be:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80022c2:	600b      	str	r3, [r1, #0]
      gCpuLoad = (float)(1000 - gIdleTick) * 0.1f;
 80022c4:	48ac      	ldr	r0, [pc, #688]	; (8002578 <StartCommTask+0x73c>)
 80022c6:	49ad      	ldr	r1, [pc, #692]	; (800257c <StartCommTask+0x740>)
 80022c8:	6803      	ldr	r3, [r0, #0]
 80022ca:	f5c3 737a 	rsb	r3, r3, #1000	; 0x3e8
 80022ce:	ee07 3a90 	vmov	s15, r3
      gIdleTick = 0;
 80022d2:	2300      	movs	r3, #0
      gCpuLoad = (float)(1000 - gIdleTick) * 0.1f;
 80022d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80022d8:	ee67 7aab 	vmul.f32	s15, s15, s23
 80022dc:	edc1 7a00 	vstr	s15, [r1]
      gIdleTick = 0;
 80022e0:	6003      	str	r3, [r0, #0]
      if(gCpuLoadMax < gCpuLoad)
 80022e2:	48a7      	ldr	r0, [pc, #668]	; (8002580 <StartCommTask+0x744>)
 80022e4:	ed90 7a00 	vldr	s14, [r0]
 80022e8:	edd1 7a00 	vldr	s15, [r1]
 80022ec:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80022f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80022f4:	d501      	bpl.n	80022fa <StartCommTask+0x4be>
        gCpuLoadMax = gCpuLoad;
 80022f6:	680b      	ldr	r3, [r1, #0]
 80022f8:	6003      	str	r3, [r0, #0]
      if(cpu_avg == 0.0f)
 80022fa:	eeb5 aa40 	vcmp.f32	s20, #0.0
        cpu_avg = gCpuLoad;
 80022fe:	4b9f      	ldr	r3, [pc, #636]	; (800257c <StartCommTask+0x740>)
      if(cpu_avg == 0.0f)
 8002300:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002304:	f040 80bd 	bne.w	8002482 <StartCommTask+0x646>
        cpu_avg = gCpuLoad;
 8002308:	ed93 aa00 	vldr	s20, [r3]
      if(sd_avg == 0.0f)
 800230c:	eef5 9a40 	vcmp.f32	s19, #0.0
        sd_avg = sdstats.readLast;
 8002310:	ee07 2a90 	vmov	s15, r2
      if(sd_avg == 0.0f)
 8002314:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002318:	f040 8098 	bne.w	800244c <StartCommTask+0x610>
      if(ram_avg == 0.0f)
 800231c:	eef5 8a40 	vcmp.f32	s17, #0.0
        sd_avg = sdstats.readLast;
 8002320:	eef8 9a67 	vcvt.f32.u32	s19, s15
      if(ram_avg == 0.0f)
 8002324:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        sd_avg = sdstats.readLast;
 8002328:	eeb0 9a69 	vmov.f32	s18, s19
      if(ram_avg == 0.0f)
 800232c:	f040 809c 	bne.w	8002468 <StartCommTask+0x62c>
        ram_avg =  xPortGetFreeHeapSize();
 8002330:	f00a f94a 	bl	800c5c8 <xPortGetFreeHeapSize>
 8002334:	ee07 0a90 	vmov	s15, r0
 8002338:	eef8 8a67 	vcvt.f32.u32	s17, s15
          (float)sdstats.readMax / 1024.0f,
 800233c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
      tick = 0;
 800233e:	f04f 0b00 	mov.w	fp, #0
          (float)sdstats.readMax / 1024.0f,
 8002342:	ee07 3a90 	vmov	s15, r3
 8002346:	9310      	str	r3, [sp, #64]	; 0x40
 8002348:	eef8 7a67 	vcvt.f32.u32	s15, s15
      Comm_Transmit(&gCommData, "SD: %.1fKB/s Max: %.1fKB/s Avg: %.1fKB/s\r\n"
 800234c:	ee67 7a88 	vmul.f32	s15, s15, s16
 8002350:	ee17 0a90 	vmov	r0, s15
 8002354:	f7fe fcf0 	bl	8000d38 <__aeabi_f2d>
 8002358:	4b88      	ldr	r3, [pc, #544]	; (800257c <StartCommTask+0x740>)
 800235a:	681e      	ldr	r6, [r3, #0]
 800235c:	4b88      	ldr	r3, [pc, #544]	; (8002580 <StartCommTask+0x744>)
 800235e:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 8002362:	681f      	ldr	r7, [r3, #0]
          (float)xPortGetFreeHeapSize() / 1024.0f,
 8002364:	f00a f930 	bl	800c5c8 <xPortGetFreeHeapSize>
 8002368:	ee0c 0a10 	vmov	s24, r0
          (float)xPortGetMinimumEverFreeHeapSize() / 1024.0f,
 800236c:	f00a f932 	bl	800c5d4 <xPortGetMinimumEverFreeHeapSize>
      Comm_Transmit(&gCommData, "SD: %.1fKB/s Max: %.1fKB/s Avg: %.1fKB/s\r\n"
 8002370:	ee69 7a08 	vmul.f32	s15, s18, s16
          (float)xPortGetMinimumEverFreeHeapSize() / 1024.0f,
 8002374:	ee0c 0a90 	vmov	s25, r0
      Comm_Transmit(&gCommData, "SD: %.1fKB/s Max: %.1fKB/s Avg: %.1fKB/s\r\n"
 8002378:	ee17 0a90 	vmov	r0, s15
 800237c:	f7fe fcdc 	bl	8000d38 <__aeabi_f2d>
 8002380:	ee68 7a88 	vmul.f32	s15, s17, s16
 8002384:	4602      	mov	r2, r0
 8002386:	460b      	mov	r3, r1
 8002388:	ee17 0a90 	vmov	r0, s15
 800238c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
 8002390:	f7fe fcd2 	bl	8000d38 <__aeabi_f2d>
          (float)xPortGetMinimumEverFreeHeapSize() / 1024.0f,
 8002394:	eef8 7a6c 	vcvt.f32.u32	s15, s25
      Comm_Transmit(&gCommData, "SD: %.1fKB/s Max: %.1fKB/s Avg: %.1fKB/s\r\n"
 8002398:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
 800239c:	ee67 7a88 	vmul.f32	s15, s15, s16
 80023a0:	ee17 0a90 	vmov	r0, s15
 80023a4:	f7fe fcc8 	bl	8000d38 <__aeabi_f2d>
          (float)xPortGetFreeHeapSize() / 1024.0f,
 80023a8:	eef8 7a4c 	vcvt.f32.u32	s15, s24
      Comm_Transmit(&gCommData, "SD: %.1fKB/s Max: %.1fKB/s Avg: %.1fKB/s\r\n"
 80023ac:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 80023b0:	ee67 7a88 	vmul.f32	s15, s15, s16
 80023b4:	ee17 0a90 	vmov	r0, s15
 80023b8:	f7fe fcbe 	bl	8000d38 <__aeabi_f2d>
 80023bc:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 80023c0:	ee1a 0a10 	vmov	r0, s20
 80023c4:	f7fe fcb8 	bl	8000d38 <__aeabi_f2d>
 80023c8:	e9cd 0108 	strd	r0, r1, [sp, #32]
 80023cc:	4638      	mov	r0, r7
 80023ce:	f7fe fcb3 	bl	8000d38 <__aeabi_f2d>
 80023d2:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80023d6:	4630      	mov	r0, r6
 80023d8:	f7fe fcae 	bl	8000d38 <__aeabi_f2d>
 80023dc:	ee69 7a88 	vmul.f32	s15, s19, s16
 80023e0:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80023e4:	ee17 0a90 	vmov	r0, s15
 80023e8:	f7fe fca6 	bl	8000d38 <__aeabi_f2d>
 80023ec:	ed9d 7b10 	vldr	d7, [sp, #64]	; 0x40
 80023f0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80023f4:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 80023f8:	4962      	ldr	r1, [pc, #392]	; (8002584 <StartCommTask+0x748>)
 80023fa:	4863      	ldr	r0, [pc, #396]	; (8002588 <StartCommTask+0x74c>)
 80023fc:	ed8d 7b00 	vstr	d7, [sp]
 8002400:	f7ff fc02 	bl	8001c08 <Comm_Transmit.constprop.0>
 8002404:	e645      	b.n	8002092 <StartCommTask+0x256>
    if(commdata->rx_cmd_ptr + 1 >= UART_CMD_BUFFER || chr == '\r' || chr == '\n') {
 8002406:	280d      	cmp	r0, #13
 8002408:	d010      	beq.n	800242c <StartCommTask+0x5f0>
 800240a:	280a      	cmp	r0, #10
 800240c:	d00e      	beq.n	800242c <StartCommTask+0x5f0>
      commdata->rx_cmd[commdata->rx_cmd_ptr++] = chr;
 800240e:	4422      	add	r2, r4
 8002410:	f8c4 324c 	str.w	r3, [r4, #588]	; 0x24c
 8002414:	f882 0200 	strb.w	r0, [r2, #512]	; 0x200
  while(commdata->rx_wr != commdata->rx_rd) {
 8002418:	e9d4 3291 	ldrd	r3, r2, [r4, #580]	; 0x244
 800241c:	429a      	cmp	r2, r3
 800241e:	f43f af2d 	beq.w	800227c <StartCommTask+0x440>
    SCB_InvalidateDCache_by_Addr((uint32_t *)commdata->rx_buffer, commdata->huart->RxXferSize);
 8002422:	f8d4 3240 	ldr.w	r3, [r4, #576]	; 0x240
 8002426:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
 800242a:	e640      	b.n	80020ae <StartCommTask+0x272>
      commdata->rx_cmd[commdata->rx_cmd_ptr] = '\0';
 800242c:	18a3      	adds	r3, r4, r2
 800242e:	f883 1200 	strb.w	r1, [r3, #512]	; 0x200
      if(commdata->rx_cmd_ptr > 0) {
 8002432:	2a00      	cmp	r2, #0
 8002434:	d0f0      	beq.n	8002418 <StartCommTask+0x5dc>
 8002436:	e665      	b.n	8002104 <StartCommTask+0x2c8>
      gMp3LedLast = xTaskGetTickCount();
 8002438:	f008 ff52 	bl	800b2e0 <xTaskGetTickCount>
 800243c:	4b4d      	ldr	r3, [pc, #308]	; (8002574 <StartCommTask+0x738>)
      HAL_GPIO_WritePin(LED_D6_GPIO_Port, LED_D6_Pin, GPIO_PIN_RESET);
 800243e:	2200      	movs	r2, #0
 8002440:	2140      	movs	r1, #64	; 0x40
      gMp3LedLast = xTaskGetTickCount();
 8002442:	6018      	str	r0, [r3, #0]
      HAL_GPIO_WritePin(LED_D6_GPIO_Port, LED_D6_Pin, GPIO_PIN_RESET);
 8002444:	4851      	ldr	r0, [pc, #324]	; (800258c <StartCommTask+0x750>)
 8002446:	f001 fa4d 	bl	80038e4 <HAL_GPIO_WritePin>
 800244a:	e722      	b.n	8002292 <StartCommTask+0x456>
      else sd_avg = sd_avg * (1.0f - msr_koff) + sdstats.readLast * msr_koff;
 800244c:	eeb8 9a67 	vcvt.f32.u32	s18, s15
      if(ram_avg == 0.0f)
 8002450:	eef5 8a40 	vcmp.f32	s17, #0.0
      else sd_avg = sd_avg * (1.0f - msr_koff) + sdstats.readLast * msr_koff;
 8002454:	ee69 7a0b 	vmul.f32	s15, s18, s22
      if(ram_avg == 0.0f)
 8002458:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      else sd_avg = sd_avg * (1.0f - msr_koff) + sdstats.readLast * msr_koff;
 800245c:	eee9 7aaa 	vfma.f32	s15, s19, s21
 8002460:	eef0 9a67 	vmov.f32	s19, s15
      if(ram_avg == 0.0f)
 8002464:	f43f af64 	beq.w	8002330 <StartCommTask+0x4f4>
      else ram_avg = ram_avg * (1.0f - msr_koff) + xPortGetFreeHeapSize() * msr_koff;
 8002468:	f00a f8ae 	bl	800c5c8 <xPortGetFreeHeapSize>
 800246c:	ee07 0a90 	vmov	s15, r0
 8002470:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002474:	ee67 7a8b 	vmul.f32	s15, s15, s22
 8002478:	eee8 7aaa 	vfma.f32	s15, s17, s21
 800247c:	eef0 8a67 	vmov.f32	s17, s15
 8002480:	e75c      	b.n	800233c <StartCommTask+0x500>
      else cpu_avg = cpu_avg * (1.0f - msr_koff) + gCpuLoad * msr_koff;
 8002482:	edd3 7a00 	vldr	s15, [r3]
 8002486:	ee67 7a8b 	vmul.f32	s15, s15, s22
 800248a:	eeea 7a2a 	vfma.f32	s15, s20, s21
 800248e:	eeb0 aa67 	vmov.f32	s20, s15
 8002492:	e73b      	b.n	800230c <StartCommTask+0x4d0>
      for(int j = 0; j < samples_per_channel; j++)
 8002494:	f5b1 7f10 	cmp.w	r1, #576	; 0x240
          gPlayersData.player[i].buffer_rd = 0;
 8002498:	f04f 0300 	mov.w	r3, #0
 800249c:	f8c2 50b0 	str.w	r5, [r2, #176]	; 0xb0
      for(int j = 0; j < samples_per_channel; j++)
 80024a0:	f47f adb2 	bne.w	8002008 <StartCommTask+0x1cc>
  for(int i = 0; i < PLAYERS_COUNT; i++)
 80024a4:	3701      	adds	r7, #1
 80024a6:	32c4      	adds	r2, #196	; 0xc4
 80024a8:	3004      	adds	r0, #4
 80024aa:	2f08      	cmp	r7, #8
 80024ac:	f47f ad9e 	bne.w	8001fec <StartCommTask+0x1b0>
 80024b0:	e5be      	b.n	8002030 <StartCommTask+0x1f4>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80024b2:	4650      	mov	r0, sl
 80024b4:	f7fe fa81 	bl	80009ba <strlen>
 80024b8:	1823      	adds	r3, r4, r0
 80024ba:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80024be:	2b2e      	cmp	r3, #46	; 0x2e
 80024c0:	f47f ae3b 	bne.w	800213a <StartCommTask+0x2fe>
          str += strlen(gPlayersData.player[i].name) + 1;
 80024c4:	3001      	adds	r0, #1
 80024c6:	4b2a      	ldr	r3, [pc, #168]	; (8002570 <StartCommTask+0x734>)
          args = strchr(str, '(');
 80024c8:	2128      	movs	r1, #40	; 0x28
          str += strlen(gPlayersData.player[i].name) + 1;
 80024ca:	181e      	adds	r6, r3, r0
          args = strchr(str, '(');
 80024cc:	4630      	mov	r0, r6
 80024ce:	f011 fb56 	bl	8013b7e <strchr>
          if(args == NULL)
 80024d2:	2800      	cmp	r0, #0
 80024d4:	f43f aed2 	beq.w	800227c <StartCommTask+0x440>
          arg_end = -1;
 80024d8:	f04f 32ff 	mov.w	r2, #4294967295
 80024dc:	9710      	str	r7, [sp, #64]	; 0x40
          arg_start = args - str;
 80024de:	eba0 0a06 	sub.w	sl, r0, r6
          arg_end = -1;
 80024e2:	4617      	mov	r7, r2
 80024e4:	e000      	b.n	80024e8 <StartCommTask+0x6ac>
            arg_end = args - str;
 80024e6:	1b87      	subs	r7, r0, r6
            args = strchr(args + 1, ')');
 80024e8:	2129      	movs	r1, #41	; 0x29
 80024ea:	3001      	adds	r0, #1
 80024ec:	f011 fb47 	bl	8013b7e <strchr>
            if(args == NULL)
 80024f0:	2800      	cmp	r0, #0
 80024f2:	d1f8      	bne.n	80024e6 <StartCommTask+0x6aa>
          if(arg_start < arg_end) {
 80024f4:	463a      	mov	r2, r7
 80024f6:	9f10      	ldr	r7, [sp, #64]	; 0x40
 80024f8:	1c51      	adds	r1, r2, #1
 80024fa:	f43f aebf 	beq.w	800227c <StartCommTask+0x440>
 80024fe:	4592      	cmp	sl, r2
 8002500:	f4bf aebc 	bcs.w	800227c <StartCommTask+0x440>
            str[arg_start] = '\0';
 8002504:	f806 000a 	strb.w	r0, [r6, sl]
            args = &str[arg_start + 1];
 8002508:	f10a 0a01 	add.w	sl, sl, #1
            str[arg_end] = '\0';
 800250c:	54b0      	strb	r0, [r6, r2]
 800250e:	9010      	str	r0, [sp, #64]	; 0x40
            if(strcmp(str, "play") == 0) {
 8002510:	4630      	mov	r0, r6
 8002512:	491f      	ldr	r1, [pc, #124]	; (8002590 <StartCommTask+0x754>)
            args = &str[arg_start + 1];
 8002514:	44b2      	add	sl, r6
            if(strcmp(str, "play") == 0) {
 8002516:	f7fe fa46 	bl	80009a6 <strcmp>
 800251a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800251c:	2800      	cmp	r0, #0
 800251e:	f000 80be 	beq.w	800269e <StartCommTask+0x862>
            } else if(strcmp(str, "stop") == 0) {
 8002522:	491c      	ldr	r1, [pc, #112]	; (8002594 <StartCommTask+0x758>)
 8002524:	4630      	mov	r0, r6
 8002526:	9310      	str	r3, [sp, #64]	; 0x40
 8002528:	f7fe fa3d 	bl	80009a6 <strcmp>
 800252c:	2800      	cmp	r0, #0
 800252e:	f000 809d 	beq.w	800266c <StartCommTask+0x830>
            } else if(strcmp(str, "vol") == 0) {
 8002532:	4630      	mov	r0, r6
 8002534:	4918      	ldr	r1, [pc, #96]	; (8002598 <StartCommTask+0x75c>)
 8002536:	f7fe fa36 	bl	80009a6 <strcmp>
 800253a:	2800      	cmp	r0, #0
 800253c:	f47f ae9e 	bne.w	800227c <StartCommTask+0x440>
              if(sscanf(args, "%ld", &arg) == 1) {
 8002540:	4650      	mov	r0, sl
 8002542:	aa17      	add	r2, sp, #92	; 0x5c
 8002544:	4915      	ldr	r1, [pc, #84]	; (800259c <StartCommTask+0x760>)
 8002546:	f011 faa9 	bl	8013a9c <siscanf>
 800254a:	2801      	cmp	r0, #1
 800254c:	f47f ae96 	bne.w	800227c <StartCommTask+0x440>
                osMutexAcquire(gPlayersData.player[i].mutex, osWaitForever);
 8002550:	23c4      	movs	r3, #196	; 0xc4
 8002552:	4a06      	ldr	r2, [pc, #24]	; (800256c <StartCommTask+0x730>)
 8002554:	f04f 31ff 	mov.w	r1, #4294967295
 8002558:	fb03 2707 	mla	r7, r3, r7, r2
 800255c:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8002560:	f006 ffbc 	bl	80094dc <osMutexAcquire>
                gPlayersData.player[i].volume = arg;
 8002564:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8002566:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
 800256a:	e08f      	b.n	800268c <StartCommTask+0x850>
 800256c:	20000004 	.word	0x20000004
 8002570:	20000aa0 	.word	0x20000aa0
 8002574:	20004b04 	.word	0x20004b04
 8002578:	20000000 	.word	0x20000000
 800257c:	20000af8 	.word	0x20000af8
 8002580:	20000afc 	.word	0x20000afc
 8002584:	080169bc 	.word	0x080169bc
 8002588:	200008a0 	.word	0x200008a0
 800258c:	40020c00 	.word	0x40020c00
 8002590:	080169a0 	.word	0x080169a0
 8002594:	080169ac 	.word	0x080169ac
 8002598:	080169b4 	.word	0x080169b4
 800259c:	080169b8 	.word	0x080169b8
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80025a0:	4638      	mov	r0, r7
 80025a2:	f7fe fa0a 	bl	80009ba <strlen>
 80025a6:	1823      	adds	r3, r4, r0
 80025a8:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80025ac:	2b2e      	cmp	r3, #46	; 0x2e
 80025ae:	f47f add2 	bne.w	8002156 <StartCommTask+0x31a>
      for(int i = 0; i < gPlayersData.count; i++) {
 80025b2:	2701      	movs	r7, #1
 80025b4:	e786      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80025b6:	4638      	mov	r0, r7
 80025b8:	f7fe f9ff 	bl	80009ba <strlen>
 80025bc:	1823      	adds	r3, r4, r0
 80025be:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80025c2:	2b2e      	cmp	r3, #46	; 0x2e
 80025c4:	f47f add5 	bne.w	8002172 <StartCommTask+0x336>
      for(int i = 0; i < gPlayersData.count; i++) {
 80025c8:	2702      	movs	r7, #2
 80025ca:	e77b      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80025cc:	4638      	mov	r0, r7
 80025ce:	f7fe f9f4 	bl	80009ba <strlen>
 80025d2:	1823      	adds	r3, r4, r0
 80025d4:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80025d8:	2b2e      	cmp	r3, #46	; 0x2e
 80025da:	f47f ade5 	bne.w	80021a8 <StartCommTask+0x36c>
      for(int i = 0; i < gPlayersData.count; i++) {
 80025de:	2704      	movs	r7, #4
 80025e0:	e770      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80025e2:	4638      	mov	r0, r7
 80025e4:	f7fe f9e9 	bl	80009ba <strlen>
 80025e8:	1823      	adds	r3, r4, r0
 80025ea:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 80025ee:	2b2e      	cmp	r3, #46	; 0x2e
 80025f0:	f47f adcd 	bne.w	800218e <StartCommTask+0x352>
      for(int i = 0; i < gPlayersData.count; i++) {
 80025f4:	2703      	movs	r7, #3
 80025f6:	e765      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 80025f8:	4638      	mov	r0, r7
 80025fa:	f7fe f9de 	bl	80009ba <strlen>
 80025fe:	1823      	adds	r3, r4, r0
 8002600:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8002604:	2b2e      	cmp	r3, #46	; 0x2e
 8002606:	f47f ae1f 	bne.w	8002248 <StartCommTask+0x40c>
      for(int i = 0; i < gPlayersData.count; i++) {
 800260a:	2705      	movs	r7, #5
 800260c:	e75a      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 800260e:	4638      	mov	r0, r7
 8002610:	f7fe f9d3 	bl	80009ba <strlen>
 8002614:	1823      	adds	r3, r4, r0
 8002616:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 800261a:	2b2e      	cmp	r3, #46	; 0x2e
 800261c:	f47f ae21 	bne.w	8002262 <StartCommTask+0x426>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002620:	2706      	movs	r7, #6
 8002622:	e74f      	b.n	80024c4 <StartCommTask+0x688>
        if(strstr(str, gPlayersData.player[i].name) == str && str[strlen(gPlayersData.player[i].name)] == '.') {
 8002624:	4630      	mov	r0, r6
 8002626:	f7fe f9c8 	bl	80009ba <strlen>
 800262a:	1823      	adds	r3, r4, r0
 800262c:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8002630:	2b2e      	cmp	r3, #46	; 0x2e
 8002632:	f47f ae23 	bne.w	800227c <StartCommTask+0x440>
      for(int i = 0; i < gPlayersData.count; i++) {
 8002636:	2707      	movs	r7, #7
 8002638:	e744      	b.n	80024c4 <StartCommTask+0x688>
      if(gPlayersData.player[i].playing) {
 800263a:	4b28      	ldr	r3, [pc, #160]	; (80026dc <StartCommTask+0x8a0>)
 800263c:	fb09 3307 	mla	r3, r9, r7, r3
 8002640:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
 8002644:	b123      	cbz	r3, 8002650 <StartCommTask+0x814>
        gPlayersData.player[i].underflow_rd++;
 8002646:	f8d2 30b8 	ldr.w	r3, [r2, #184]	; 0xb8
 800264a:	3301      	adds	r3, #1
 800264c:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
          gPlayersData.player[i].buffer_rd = 0;
 8002650:	2300      	movs	r3, #0
        buffer[j * PLAYERS_COUNT + i] = 0;
 8002652:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
      for(int j = 0; j < samples_per_channel; j++)
 8002656:	3308      	adds	r3, #8
 8002658:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 800265c:	d1f9      	bne.n	8002652 <StartCommTask+0x816>
  for(int i = 0; i < PLAYERS_COUNT; i++)
 800265e:	3701      	adds	r7, #1
 8002660:	32c4      	adds	r2, #196	; 0xc4
 8002662:	3004      	adds	r0, #4
 8002664:	2f08      	cmp	r7, #8
 8002666:	f47f acc1 	bne.w	8001fec <StartCommTask+0x1b0>
 800266a:	e4e1      	b.n	8002030 <StartCommTask+0x1f4>
              osMutexAcquire(gPlayersData.player[i].mutex, osWaitForever);
 800266c:	4b1b      	ldr	r3, [pc, #108]	; (80026dc <StartCommTask+0x8a0>)
 800266e:	22c4      	movs	r2, #196	; 0xc4
 8002670:	f04f 31ff 	mov.w	r1, #4294967295
 8002674:	fb02 3707 	mla	r7, r2, r7, r3
 8002678:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 800267c:	f006 ff2e 	bl	80094dc <osMutexAcquire>
              gPlayersData.player[i].enabled = 0;
 8002680:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8002682:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c
              gPlayersData.player[i].changed = 1;
 8002686:	2301      	movs	r3, #1
 8002688:	f887 308e 	strb.w	r3, [r7, #142]	; 0x8e
                osMutexRelease(gPlayersData.player[i].mutex);
 800268c:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8002690:	f006 ff5c 	bl	800954c <osMutexRelease>
                Comm_Transmit(&gCommData, "OK");
 8002694:	4912      	ldr	r1, [pc, #72]	; (80026e0 <StartCommTask+0x8a4>)
 8002696:	4813      	ldr	r0, [pc, #76]	; (80026e4 <StartCommTask+0x8a8>)
 8002698:	f7ff fab6 	bl	8001c08 <Comm_Transmit.constprop.0>
 800269c:	e5ee      	b.n	800227c <StartCommTask+0x440>
              osMutexAcquire(gPlayersData.player[i].mutex, osWaitForever);
 800269e:	23c4      	movs	r3, #196	; 0xc4
 80026a0:	f04f 31ff 	mov.w	r1, #4294967295
 80026a4:	fb03 f707 	mul.w	r7, r3, r7
 80026a8:	4b0c      	ldr	r3, [pc, #48]	; (80026dc <StartCommTask+0x8a0>)
 80026aa:	19de      	adds	r6, r3, r7
              strcpy(gPlayersData.player[i].file, args);
 80026ac:	370c      	adds	r7, #12
              osMutexAcquire(gPlayersData.player[i].mutex, osWaitForever);
 80026ae:	f8d6 0090 	ldr.w	r0, [r6, #144]	; 0x90
 80026b2:	f006 ff13 	bl	80094dc <osMutexAcquire>
              strcpy(gPlayersData.player[i].file, args);
 80026b6:	4b09      	ldr	r3, [pc, #36]	; (80026dc <StartCommTask+0x8a0>)
 80026b8:	4651      	mov	r1, sl
 80026ba:	19d8      	adds	r0, r3, r7
 80026bc:	f011 fa6c 	bl	8013b98 <strcpy>
              gPlayersData.player[i].enabled = 1;
 80026c0:	2301      	movs	r3, #1
              osMutexRelease(gPlayersData.player[i].mutex);
 80026c2:	f8d6 0090 	ldr.w	r0, [r6, #144]	; 0x90
              gPlayersData.player[i].enabled = 1;
 80026c6:	f886 308c 	strb.w	r3, [r6, #140]	; 0x8c
              gPlayersData.player[i].changed = 1;
 80026ca:	f886 308e 	strb.w	r3, [r6, #142]	; 0x8e
              osMutexRelease(gPlayersData.player[i].mutex);
 80026ce:	f006 ff3d 	bl	800954c <osMutexRelease>
              Comm_Transmit(&gCommData, "OK");
 80026d2:	4903      	ldr	r1, [pc, #12]	; (80026e0 <StartCommTask+0x8a4>)
 80026d4:	4803      	ldr	r0, [pc, #12]	; (80026e4 <StartCommTask+0x8a8>)
 80026d6:	f7ff fa97 	bl	8001c08 <Comm_Transmit.constprop.0>
 80026da:	e5cf      	b.n	800227c <StartCommTask+0x440>
 80026dc:	20000004 	.word	0x20000004
 80026e0:	080169a8 	.word	0x080169a8
 80026e4:	200008a0 	.word	0x200008a0

080026e8 <HAL_SAI_TxCpltCallback>:
  HandleSaiDma(&gTdmFinalBuffer[TDM_BUFFER_SIZE / 2], TDM_BUFFER_SIZE / 2);
 80026e8:	4801      	ldr	r0, [pc, #4]	; (80026f0 <HAL_SAI_TxCpltCallback+0x8>)
 80026ea:	f7ff bb2d 	b.w	8001d48 <HandleSaiDma.constprop.0>
 80026ee:	bf00      	nop
 80026f0:	20018420 	.word	0x20018420

080026f4 <HAL_SAI_TxHalfCpltCallback>:
  HandleSaiDma(&gTdmFinalBuffer[0], TDM_BUFFER_SIZE / 2);
 80026f4:	4801      	ldr	r0, [pc, #4]	; (80026fc <HAL_SAI_TxHalfCpltCallback+0x8>)
 80026f6:	f7ff bb27 	b.w	8001d48 <HandleSaiDma.constprop.0>
 80026fa:	bf00      	nop
 80026fc:	20017fa0 	.word	0x20017fa0

08002700 <HAL_UART_TxCpltCallback>:
  if(huart == gCommData.huart) {
 8002700:	4b04      	ldr	r3, [pc, #16]	; (8002714 <HAL_UART_TxCpltCallback+0x14>)
 8002702:	f8d3 2240 	ldr.w	r2, [r3, #576]	; 0x240
 8002706:	4282      	cmp	r2, r0
 8002708:	d000      	beq.n	800270c <HAL_UART_TxCpltCallback+0xc>
}
 800270a:	4770      	bx	lr
    osSemaphoreRelease(gCommData.tx_sem);
 800270c:	f8d3 0250 	ldr.w	r0, [r3, #592]	; 0x250
 8002710:	f006 bfee 	b.w	80096f0 <osSemaphoreRelease>
 8002714:	200008a0 	.word	0x200008a0

08002718 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8002718:	b500      	push	{lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800271a:	2300      	movs	r3, #0
{
 800271c:	b095      	sub	sp, #84	; 0x54
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 800271e:	492c      	ldr	r1, [pc, #176]	; (80027d0 <SystemClock_Config+0xb8>)
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8002720:	930a      	str	r3, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 432;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8002722:	a808      	add	r0, sp, #32
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8002724:	9302      	str	r3, [sp, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002726:	4a2b      	ldr	r2, [pc, #172]	; (80027d4 <SystemClock_Config+0xbc>)
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8002728:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800272c:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8002730:	e9cd 3305 	strd	r3, r3, [sp, #20]
  __HAL_RCC_PWR_CLK_ENABLE();
 8002734:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8002736:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800273a:	640b      	str	r3, [r1, #64]	; 0x40
 800273c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLQ = 9;
 800273e:	2109      	movs	r1, #9
  __HAL_RCC_PWR_CLK_ENABLE();
 8002740:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002744:	9300      	str	r3, [sp, #0]
 8002746:	9b00      	ldr	r3, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002748:	6813      	ldr	r3, [r2, #0]
 800274a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800274e:	6013      	str	r3, [r2, #0]
 8002750:	6813      	ldr	r3, [r2, #0]
  RCC_OscInitStruct.PLL.PLLQ = 9;
 8002752:	9113      	str	r1, [sp, #76]	; 0x4c
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8002754:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8002758:	9301      	str	r3, [sp, #4]
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800275a:	2302      	movs	r3, #2
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800275c:	9a01      	ldr	r2, [sp, #4]
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800275e:	2201      	movs	r2, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8002760:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8002762:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8002764:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8002768:	920d      	str	r2, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLN = 432;
 800276a:	2210      	movs	r2, #16
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800276c:	930f      	str	r3, [sp, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLN = 432;
 800276e:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8002772:	ed9f 7b13 	vldr	d7, [pc, #76]	; 80027c0 <SystemClock_Config+0xa8>
  RCC_OscInitStruct.PLL.PLLN = 432;
 8002776:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 800277a:	ed8d 7b08 	vstr	d7, [sp, #32]
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800277e:	f001 f8f9 	bl	8003974 <HAL_RCC_OscConfig>
 8002782:	b108      	cbz	r0, 8002788 <SystemClock_Config+0x70>
  __ASM volatile ("cpsid i" : : : "memory");
 8002784:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8002786:	e7fe      	b.n	8002786 <SystemClock_Config+0x6e>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 8002788:	f001 f8ba 	bl	8003900 <HAL_PWREx_EnableOverDrive>
 800278c:	b108      	cbz	r0, 8002792 <SystemClock_Config+0x7a>
 800278e:	b672      	cpsid	i
  while (1)
 8002790:	e7fe      	b.n	8002790 <SystemClock_Config+0x78>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8002792:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8002796:	2200      	movs	r2, #0
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 8002798:	a802      	add	r0, sp, #8
 800279a:	2107      	movs	r1, #7
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800279c:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 80027c8 <SystemClock_Config+0xb0>
 80027a0:	e9cd 2304 	strd	r2, r3, [sp, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80027a4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80027a8:	ed8d 7b02 	vstr	d7, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80027ac:	9306      	str	r3, [sp, #24]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80027ae:	f001 facf 	bl	8003d50 <HAL_RCC_ClockConfig>
 80027b2:	b108      	cbz	r0, 80027b8 <SystemClock_Config+0xa0>
 80027b4:	b672      	cpsid	i
  while (1)
 80027b6:	e7fe      	b.n	80027b6 <SystemClock_Config+0x9e>
}
 80027b8:	b015      	add	sp, #84	; 0x54
 80027ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80027be:	bf00      	nop
 80027c0:	00000009 	.word	0x00000009
 80027c4:	00010000 	.word	0x00010000
 80027c8:	0000000f 	.word	0x0000000f
 80027cc:	00000002 	.word	0x00000002
 80027d0:	40023800 	.word	0x40023800
 80027d4:	40007000 	.word	0x40007000

080027d8 <main>:
{
 80027d8:	b580      	push	{r7, lr}
 80027da:	b090      	sub	sp, #64	; 0x40
  __ASM volatile ("dsb 0xF":::"memory");
 80027dc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80027e0:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80027e4:	49a0      	ldr	r1, [pc, #640]	; (8002a68 <main+0x290>)
 80027e6:	2200      	movs	r2, #0
 80027e8:	f8c1 2250 	str.w	r2, [r1, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80027ec:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80027f0:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80027f4:	694b      	ldr	r3, [r1, #20]
 80027f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80027fa:	614b      	str	r3, [r1, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80027fc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002800:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8002804:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8002808:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 800280c:	f8d1 5080 	ldr.w	r5, [r1, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8002810:	f643 76e0 	movw	r6, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8002814:	f3c5 304e 	ubfx	r0, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8002818:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 800281c:	0140      	lsls	r0, r0, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800281e:	ea00 0206 	and.w	r2, r0, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8002822:	462c      	mov	r4, r5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8002824:	ea42 7384 	orr.w	r3, r2, r4, lsl #30
      } while (ways-- != 0U);
 8002828:	3c01      	subs	r4, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800282a:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
      } while (ways-- != 0U);
 800282e:	1c63      	adds	r3, r4, #1
 8002830:	d1f8      	bne.n	8002824 <main+0x4c>
    } while(sets-- != 0U);
 8002832:	3820      	subs	r0, #32
 8002834:	f110 0f20 	cmn.w	r0, #32
 8002838:	d1f1      	bne.n	800281e <main+0x46>
 800283a:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 800283e:	694b      	ldr	r3, [r1, #20]
 8002840:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002844:	614b      	str	r3, [r1, #20]
 8002846:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800284a:	f3bf 8f6f 	isb	sy
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800284e:	4e87      	ldr	r6, [pc, #540]	; (8002a6c <main+0x294>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002850:	2500      	movs	r5, #0
  HAL_Init();
 8002852:	f000 fc2d 	bl	80030b0 <HAL_Init>
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8002856:	2701      	movs	r7, #1
  SystemClock_Config();
 8002858:	f7ff ff5e 	bl	8002718 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800285c:	950e      	str	r5, [sp, #56]	; 0x38
  HAL_GPIO_WritePin(GPIOD, LED_D3_Pin|LED_D4_Pin|LED_D5_Pin|LED_D6_Pin, GPIO_PIN_RESET);
 800285e:	462a      	mov	r2, r5
 8002860:	2178      	movs	r1, #120	; 0x78
 8002862:	4883      	ldr	r0, [pc, #524]	; (8002a70 <main+0x298>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002864:	e9cd 550a 	strd	r5, r5, [sp, #40]	; 0x28
 8002868:	e9cd 550c 	strd	r5, r5, [sp, #48]	; 0x30
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800286c:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800286e:	f043 0310 	orr.w	r3, r3, #16
 8002872:	6333      	str	r3, [r6, #48]	; 0x30
 8002874:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002876:	f003 0310 	and.w	r3, r3, #16
 800287a:	9301      	str	r3, [sp, #4]
 800287c:	9b01      	ldr	r3, [sp, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800287e:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002880:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002884:	6333      	str	r3, [r6, #48]	; 0x30
 8002886:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002888:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800288c:	9302      	str	r3, [sp, #8]
 800288e:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8002890:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002892:	f043 0302 	orr.w	r3, r3, #2
 8002896:	6333      	str	r3, [r6, #48]	; 0x30
 8002898:	6b33      	ldr	r3, [r6, #48]	; 0x30
 800289a:	f003 0302 	and.w	r3, r3, #2
 800289e:	9303      	str	r3, [sp, #12]
 80028a0:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80028a2:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028a4:	f043 0304 	orr.w	r3, r3, #4
 80028a8:	6333      	str	r3, [r6, #48]	; 0x30
 80028aa:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028ac:	f003 0304 	and.w	r3, r3, #4
 80028b0:	9304      	str	r3, [sp, #16]
 80028b2:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80028b4:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028b6:	f043 0301 	orr.w	r3, r3, #1
 80028ba:	6333      	str	r3, [r6, #48]	; 0x30
 80028bc:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028be:	f003 0301 	and.w	r3, r3, #1
 80028c2:	9305      	str	r3, [sp, #20]
 80028c4:	9b05      	ldr	r3, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80028c6:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028c8:	f043 0308 	orr.w	r3, r3, #8
 80028cc:	6333      	str	r3, [r6, #48]	; 0x30
 80028ce:	6b33      	ldr	r3, [r6, #48]	; 0x30
 80028d0:	f003 0308 	and.w	r3, r3, #8
 80028d4:	9306      	str	r3, [sp, #24]
 80028d6:	9b06      	ldr	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOD, LED_D3_Pin|LED_D4_Pin|LED_D5_Pin|LED_D6_Pin, GPIO_PIN_RESET);
 80028d8:	f001 f804 	bl	80038e4 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = SDMMC1_DETECT_Pin;
 80028dc:	2204      	movs	r2, #4
 80028de:	2300      	movs	r3, #0
  HAL_GPIO_Init(SDMMC1_DETECT_GPIO_Port, &GPIO_InitStruct);
 80028e0:	a90a      	add	r1, sp, #40	; 0x28
 80028e2:	4864      	ldr	r0, [pc, #400]	; (8002a74 <main+0x29c>)
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80028e4:	970c      	str	r7, [sp, #48]	; 0x30
  GPIO_InitStruct.Pin = SDMMC1_DETECT_Pin;
 80028e6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  HAL_GPIO_Init(SDMMC1_DETECT_GPIO_Port, &GPIO_InitStruct);
 80028ea:	f000 fec1 	bl	8003670 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED_D3_Pin|LED_D4_Pin|LED_D5_Pin|LED_D6_Pin;
 80028ee:	2278      	movs	r2, #120	; 0x78
 80028f0:	2301      	movs	r3, #1
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80028f2:	a90a      	add	r1, sp, #40	; 0x28
 80028f4:	485e      	ldr	r0, [pc, #376]	; (8002a70 <main+0x298>)
  GPIO_InitStruct.Pin = LED_D3_Pin|LED_D4_Pin|LED_D5_Pin|LED_D6_Pin;
 80028f6:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 80028fa:	2200      	movs	r2, #0
 80028fc:	2300      	movs	r3, #0
 80028fe:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002902:	f000 feb5 	bl	8003670 <HAL_GPIO_Init>
  __HAL_RCC_DMA2_CLK_ENABLE();
 8002906:	6b33      	ldr	r3, [r6, #48]	; 0x30
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 6, 0);
 8002908:	462a      	mov	r2, r5
 800290a:	2106      	movs	r1, #6
  __HAL_RCC_DMA2_CLK_ENABLE();
 800290c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 6, 0);
 8002910:	203c      	movs	r0, #60	; 0x3c
  __HAL_RCC_DMA2_CLK_ENABLE();
 8002912:	6333      	str	r3, [r6, #48]	; 0x30
 8002914:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8002916:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800291a:	9300      	str	r3, [sp, #0]
 800291c:	9b00      	ldr	r3, [sp, #0]
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 6, 0);
 800291e:	f000 fc13 	bl	8003148 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 8002922:	203c      	movs	r0, #60	; 0x3c
 8002924:	f000 fc4e 	bl	80031c4 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 12, 0);
 8002928:	462a      	mov	r2, r5
 800292a:	210c      	movs	r1, #12
 800292c:	203a      	movs	r0, #58	; 0x3a
 800292e:	f000 fc0b 	bl	8003148 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 8002932:	203a      	movs	r0, #58	; 0x3a
 8002934:	f000 fc46 	bl	80031c4 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 9, 0);
 8002938:	462a      	mov	r2, r5
 800293a:	2109      	movs	r1, #9
 800293c:	203b      	movs	r0, #59	; 0x3b
 800293e:	f000 fc03 	bl	8003148 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 8002942:	203b      	movs	r0, #59	; 0x3b
 8002944:	f000 fc3e 	bl	80031c4 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 9, 0);
 8002948:	462a      	mov	r2, r5
 800294a:	2109      	movs	r1, #9
 800294c:	2045      	movs	r0, #69	; 0x45
 800294e:	f000 fbfb 	bl	8003148 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 8002952:	2045      	movs	r0, #69	; 0x45
 8002954:	f000 fc36 	bl	80031c4 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 12, 0);
 8002958:	462a      	mov	r2, r5
 800295a:	210c      	movs	r1, #12
 800295c:	2046      	movs	r0, #70	; 0x46
 800295e:	f000 fbf3 	bl	8003148 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 8002962:	2046      	movs	r0, #70	; 0x46
 8002964:	f000 fc2e 	bl	80031c4 <HAL_NVIC_EnableIRQ>
  hsai_BlockA1.Instance = SAI2_Block_A;
 8002968:	4843      	ldr	r0, [pc, #268]	; (8002a78 <main+0x2a0>)
  hsai_BlockA1.SlotInit.SlotNumber = 8;
 800296a:	2308      	movs	r3, #8
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_44K;
 800296c:	f04f 0c04 	mov.w	ip, #4
  hsai_BlockA1.FrameInit.ActiveFrameLength = 1;
 8002970:	6447      	str	r7, [r0, #68]	; 0x44
  hsai_BlockA1.Init.Protocol = SAI_FREE_PROTOCOL;
 8002972:	6305      	str	r5, [r0, #48]	; 0x30
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
 8002974:	6045      	str	r5, [r0, #4]
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
 8002976:	6085      	str	r5, [r0, #8]
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8002978:	60c5      	str	r5, [r0, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 800297a:	62c5      	str	r5, [r0, #44]	; 0x2c
  hsai_BlockA1.SlotInit.SlotNumber = 8;
 800297c:	e9c0 5316 	strd	r5, r3, [r0, #88]	; 0x58
  hsai_BlockA1.SlotInit.SlotActive = 0x000000FF;
 8002980:	23ff      	movs	r3, #255	; 0xff
 8002982:	6603      	str	r3, [r0, #96]	; 0x60
  hsai_BlockA1.Instance = SAI2_Block_A;
 8002984:	4b3d      	ldr	r3, [pc, #244]	; (8002a7c <main+0x2a4>)
 8002986:	6003      	str	r3, [r0, #0]
  hsai_BlockA1.Init.DataSize = SAI_DATASIZE_32;
 8002988:	23e0      	movs	r3, #224	; 0xe0
 800298a:	6343      	str	r3, [r0, #52]	; 0x34
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_44K;
 800298c:	f64a 4344 	movw	r3, #44100	; 0xac44
 8002990:	e9c0 c306 	strd	ip, r3, [r0, #24]
  hsai_BlockA1.FrameInit.FrameLength = 256;
 8002994:	f44f 7380 	mov.w	r3, #256	; 0x100
  hsai_BlockA1.Init.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
 8002998:	e9c0 550e 	strd	r5, r5, [r0, #56]	; 0x38
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 800299c:	e9c0 5504 	strd	r5, r5, [r0, #16]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
 80029a0:	e9c0 5509 	strd	r5, r5, [r0, #36]	; 0x24
  hsai_BlockA1.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 80029a4:	e9c0 5512 	strd	r5, r5, [r0, #72]	; 0x48
  hsai_BlockA1.SlotInit.FirstBitOffset = 0;
 80029a8:	e9c0 5514 	strd	r5, r5, [r0, #80]	; 0x50
  hsai_BlockA1.FrameInit.FrameLength = 256;
 80029ac:	6403      	str	r3, [r0, #64]	; 0x40
  if (HAL_SAI_Init(&hsai_BlockA1) != HAL_OK)
 80029ae:	f001 fddb 	bl	8004568 <HAL_SAI_Init>
 80029b2:	b108      	cbz	r0, 80029b8 <main+0x1e0>
  __ASM volatile ("cpsid i" : : : "memory");
 80029b4:	b672      	cpsid	i
  while (1)
 80029b6:	e7fe      	b.n	80029b6 <main+0x1de>
  hsd1.Instance = SDMMC1;
 80029b8:	4a31      	ldr	r2, [pc, #196]	; (8002a80 <main+0x2a8>)
 80029ba:	4b32      	ldr	r3, [pc, #200]	; (8002a84 <main+0x2ac>)
  hsd1.Init.ClockDiv = 0;
 80029bc:	6190      	str	r0, [r2, #24]
  huart1.Init.BaudRate = 115200;
 80029be:	4932      	ldr	r1, [pc, #200]	; (8002a88 <main+0x2b0>)
  hsd1.Instance = SDMMC1;
 80029c0:	e9c2 3000 	strd	r3, r0, [r2]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 80029c4:	e9c2 0002 	strd	r0, r0, [r2, #8]
  huart1.Instance = USART1;
 80029c8:	4b30      	ldr	r3, [pc, #192]	; (8002a8c <main+0x2b4>)
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80029ca:	e9c2 0004 	strd	r0, r0, [r2, #16]
  huart1.Init.BaudRate = 115200;
 80029ce:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
  huart1.Init.Parity = UART_PARITY_NONE;
 80029d2:	6118      	str	r0, [r3, #16]
  huart1.Init.BaudRate = 115200;
 80029d4:	e9c3 1200 	strd	r1, r2, [r3]
  huart1.Init.Mode = UART_MODE_TX_RX;
 80029d8:	220c      	movs	r2, #12
  huart1.Init.StopBits = UART_STOPBITS_1;
 80029da:	e9c3 0002 	strd	r0, r0, [r3, #8]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80029de:	e9c3 0006 	strd	r0, r0, [r3, #24]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80029e2:	e9c3 0008 	strd	r0, r0, [r3, #32]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80029e6:	4618      	mov	r0, r3
  huart1.Init.Mode = UART_MODE_TX_RX;
 80029e8:	615a      	str	r2, [r3, #20]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 80029ea:	f003 fdbd 	bl	8006568 <HAL_UART_Init>
 80029ee:	4603      	mov	r3, r0
 80029f0:	b108      	cbz	r0, 80029f6 <main+0x21e>
 80029f2:	b672      	cpsid	i
  while (1)
 80029f4:	e7fe      	b.n	80029f4 <main+0x21c>
  htim5.Instance = TIM5;
 80029f6:	4d26      	ldr	r5, [pc, #152]	; (8002a90 <main+0x2b8>)
 80029f8:	4a26      	ldr	r2, [pc, #152]	; (8002a94 <main+0x2bc>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80029fa:	9007      	str	r0, [sp, #28]
  htim5.Instance = TIM5;
 80029fc:	602a      	str	r2, [r5, #0]
  htim5.Init.Prescaler = 108-1;
 80029fe:	226b      	movs	r2, #107	; 0x6b
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8002a00:	612b      	str	r3, [r5, #16]
  htim5.Init.Prescaler = 108-1;
 8002a02:	606a      	str	r2, [r5, #4]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8002a04:	61ab      	str	r3, [r5, #24]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8002a06:	e9cd 000a 	strd	r0, r0, [sp, #40]	; 0x28
 8002a0a:	e9cd 000c 	strd	r0, r0, [sp, #48]	; 0x30
  htim5.Init.Period = 0xFFFFFFFF;
 8002a0e:	e9c5 0402 	strd	r0, r4, [r5, #8]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8002a12:	4628      	mov	r0, r5
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8002a14:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8002a18:	f002 ff6a 	bl	80058f0 <HAL_TIM_Base_Init>
 8002a1c:	b108      	cbz	r0, 8002a22 <main+0x24a>
 8002a1e:	b672      	cpsid	i
  while (1)
 8002a20:	e7fe      	b.n	8002a20 <main+0x248>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8002a22:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8002a26:	a90a      	add	r1, sp, #40	; 0x28
 8002a28:	4628      	mov	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8002a2a:	930a      	str	r3, [sp, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8002a2c:	f003 f816 	bl	8005a5c <HAL_TIM_ConfigClockSource>
 8002a30:	4603      	mov	r3, r0
 8002a32:	b108      	cbz	r0, 8002a38 <main+0x260>
 8002a34:	b672      	cpsid	i
  while (1)
 8002a36:	e7fe      	b.n	8002a36 <main+0x25e>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8002a38:	a907      	add	r1, sp, #28
 8002a3a:	4628      	mov	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8002a3c:	9307      	str	r3, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8002a3e:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8002a40:	f003 f8bc 	bl	8005bbc <HAL_TIMEx_MasterConfigSynchronization>
 8002a44:	b108      	cbz	r0, 8002a4a <main+0x272>
 8002a46:	b672      	cpsid	i
  while (1)
 8002a48:	e7fe      	b.n	8002a48 <main+0x270>
  MX_FATFS_Init();
 8002a4a:	f004 ff4b 	bl	80078e4 <MX_FATFS_Init>
  osKernelInitialize();
 8002a4e:	f006 fbef 	bl	8009230 <osKernelInitialize>
  taskCommHandle = osThreadNew(StartCommTask, &gPlayersData, &taskComm_attributes);
 8002a52:	4a11      	ldr	r2, [pc, #68]	; (8002a98 <main+0x2c0>)
 8002a54:	4911      	ldr	r1, [pc, #68]	; (8002a9c <main+0x2c4>)
 8002a56:	4812      	ldr	r0, [pc, #72]	; (8002aa0 <main+0x2c8>)
 8002a58:	f006 fc54 	bl	8009304 <osThreadNew>
 8002a5c:	4b11      	ldr	r3, [pc, #68]	; (8002aa4 <main+0x2cc>)
 8002a5e:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8002a60:	f006 fc14 	bl	800928c <osKernelStart>
  while (1)
 8002a64:	e7fe      	b.n	8002a64 <main+0x28c>
 8002a66:	bf00      	nop
 8002a68:	e000ed00 	.word	0xe000ed00
 8002a6c:	40023800 	.word	0x40023800
 8002a70:	40020c00 	.word	0x40020c00
 8002a74:	40020400 	.word	0x40020400
 8002a78:	20018a80 	.word	0x20018a80
 8002a7c:	40015c04 	.word	0x40015c04
 8002a80:	20018b04 	.word	0x20018b04
 8002a84:	40012c00 	.word	0x40012c00
 8002a88:	40011000 	.word	0x40011000
 8002a8c:	20018bd4 	.word	0x20018bd4
 8002a90:	20018b88 	.word	0x20018b88
 8002a94:	40000c00 	.word	0x40000c00
 8002a98:	08016ab0 	.word	0x08016ab0
 8002a9c:	20000004 	.word	0x20000004
 8002aa0:	08001e3d 	.word	0x08001e3d
 8002aa4:	200194b8 	.word	0x200194b8

08002aa8 <Error_Handler>:
 8002aa8:	b672      	cpsid	i
  while (1)
 8002aaa:	e7fe      	b.n	8002aaa <Error_Handler+0x2>

08002aac <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8002aac:	4b0e      	ldr	r3, [pc, #56]	; (8002ae8 <HAL_MspInit+0x3c>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8002aae:	2200      	movs	r2, #0
 8002ab0:	210f      	movs	r1, #15
 8002ab2:	f06f 0001 	mvn.w	r0, #1
{
 8002ab6:	b410      	push	{r4}
  __HAL_RCC_PWR_CLK_ENABLE();
 8002ab8:	6c1c      	ldr	r4, [r3, #64]	; 0x40
{
 8002aba:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 8002abc:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 8002ac0:	641c      	str	r4, [r3, #64]	; 0x40
 8002ac2:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 8002ac4:	f004 5480 	and.w	r4, r4, #268435456	; 0x10000000
 8002ac8:	9400      	str	r4, [sp, #0]
 8002aca:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002acc:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8002ace:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 8002ad2:	645c      	str	r4, [r3, #68]	; 0x44
 8002ad4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002ad6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002ada:	9301      	str	r3, [sp, #4]
 8002adc:	9b01      	ldr	r3, [sp, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8002ade:	b003      	add	sp, #12
 8002ae0:	f85d 4b04 	ldr.w	r4, [sp], #4
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8002ae4:	f000 bb30 	b.w	8003148 <HAL_NVIC_SetPriority>
 8002ae8:	40023800 	.word	0x40023800

08002aec <HAL_SD_MspInit>:
* This function configures the hardware resources used in this example
* @param hsd: SD handle pointer
* @retval None
*/
void HAL_SD_MspInit(SD_HandleTypeDef* hsd)
{
 8002aec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002aee:	b0ab      	sub	sp, #172	; 0xac
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002af0:	2100      	movs	r1, #0
{
 8002af2:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002af4:	2284      	movs	r2, #132	; 0x84
 8002af6:	a809      	add	r0, sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002af8:	9108      	str	r1, [sp, #32]
 8002afa:	e9cd 1104 	strd	r1, r1, [sp, #16]
 8002afe:	e9cd 1106 	strd	r1, r1, [sp, #24]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002b02:	f010 fb39 	bl	8013178 <memset>
  if(hsd->Instance==SDMMC1)
 8002b06:	4b4f      	ldr	r3, [pc, #316]	; (8002c44 <HAL_SD_MspInit+0x158>)
 8002b08:	6822      	ldr	r2, [r4, #0]
 8002b0a:	429a      	cmp	r2, r3
 8002b0c:	d001      	beq.n	8002b12 <HAL_SD_MspInit+0x26>
  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }

}
 8002b0e:	b02b      	add	sp, #172	; 0xac
 8002b10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48;
 8002b12:	f44f 0320 	mov.w	r3, #10485760	; 0xa00000
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002b16:	a809      	add	r0, sp, #36	; 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48;
 8002b18:	9309      	str	r3, [sp, #36]	; 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002b1a:	f001 fa1f 	bl	8003f5c <HAL_RCCEx_PeriphCLKConfig>
 8002b1e:	2800      	cmp	r0, #0
 8002b20:	f040 8087 	bne.w	8002c32 <HAL_SD_MspInit+0x146>
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8002b24:	4b48      	ldr	r3, [pc, #288]	; (8002c48 <HAL_SD_MspInit+0x15c>)
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8002b26:	2601      	movs	r6, #1
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8002b28:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8002b2a:	2703      	movs	r7, #3
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8002b2c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002b2e:	4847      	ldr	r0, [pc, #284]	; (8002c4c <HAL_SD_MspInit+0x160>)
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8002b30:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002b34:	645a      	str	r2, [r3, #68]	; 0x44
 8002b36:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002b38:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8002b3c:	9201      	str	r2, [sp, #4]
 8002b3e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8002b40:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002b42:	f042 0204 	orr.w	r2, r2, #4
 8002b46:	631a      	str	r2, [r3, #48]	; 0x30
 8002b48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002b4a:	f002 0204 	and.w	r2, r2, #4
 8002b4e:	9202      	str	r2, [sp, #8]
 8002b50:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8002b52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002b54:	f042 0208 	orr.w	r2, r2, #8
 8002b58:	631a      	str	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8002b5a:	f44f 52f8 	mov.w	r2, #7936	; 0x1f00
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8002b5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8002b60:	9508      	str	r5, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8002b62:	f003 0308 	and.w	r3, r3, #8
 8002b66:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8002b68:	2302      	movs	r3, #2
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8002b6a:	9903      	ldr	r1, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002b6c:	a904      	add	r1, sp, #16
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 8002b6e:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8002b72:	e9cd 6706 	strd	r6, r7, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8002b76:	f000 fd7b 	bl	8003670 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8002b7a:	2204      	movs	r2, #4
 8002b7c:	2302      	movs	r3, #2
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002b7e:	a904      	add	r1, sp, #16
 8002b80:	4833      	ldr	r0, [pc, #204]	; (8002c50 <HAL_SD_MspInit+0x164>)
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8002b82:	9508      	str	r5, [sp, #32]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8002b84:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8002b88:	e9cd 6706 	strd	r6, r7, [sp, #24]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002b8c:	f000 fd70 	bl	8003670 <HAL_GPIO_Init>
    hdma_sdmmc1_rx.Instance = DMA2_Stream3;
 8002b90:	4e30      	ldr	r6, [pc, #192]	; (8002c54 <HAL_SD_MspInit+0x168>)
    hdma_sdmmc1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8002b92:	2300      	movs	r3, #0
    hdma_sdmmc1_rx.Instance = DMA2_Stream3;
 8002b94:	4930      	ldr	r1, [pc, #192]	; (8002c58 <HAL_SD_MspInit+0x16c>)
    hdma_sdmmc1_rx.Init.Channel = DMA_CHANNEL_4;
 8002b96:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    hdma_sdmmc1_rx.Init.Mode = DMA_PFCTRL;
 8002b9a:	2020      	movs	r0, #32
    hdma_sdmmc1_rx.Init.MemBurst = DMA_MBURST_SINGLE;
 8002b9c:	62f3      	str	r3, [r6, #44]	; 0x2c
    hdma_sdmmc1_rx.Init.Channel = DMA_CHANNEL_4;
 8002b9e:	e886 000e 	stmia.w	r6, {r1, r2, r3}
    hdma_sdmmc1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8002ba2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    hdma_sdmmc1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8002ba6:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hdma_sdmmc1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8002baa:	e9c6 2305 	strd	r2, r3, [r6, #20]
    hdma_sdmmc1_rx.Init.Priority = DMA_PRIORITY_HIGH;
 8002bae:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_sdmmc1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8002bb2:	e9c6 3103 	strd	r3, r1, [r6, #12]
    hdma_sdmmc1_rx.Init.Priority = DMA_PRIORITY_HIGH;
 8002bb6:	e9c6 0207 	strd	r0, r2, [r6, #28]
    hdma_sdmmc1_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 8002bba:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    hdma_sdmmc1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8002bbe:	2204      	movs	r2, #4
    hdma_sdmmc1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8002bc0:	2303      	movs	r3, #3
    if (HAL_DMA_Init(&hdma_sdmmc1_rx) != HAL_OK)
 8002bc2:	4630      	mov	r0, r6
    hdma_sdmmc1_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 8002bc4:	6331      	str	r1, [r6, #48]	; 0x30
    hdma_sdmmc1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8002bc6:	e9c6 2309 	strd	r2, r3, [r6, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_sdmmc1_rx) != HAL_OK)
 8002bca:	f000 fb1f 	bl	800320c <HAL_DMA_Init>
 8002bce:	2800      	cmp	r0, #0
 8002bd0:	d135      	bne.n	8002c3e <HAL_SD_MspInit+0x152>
    hdma_sdmmc1_tx.Instance = DMA2_Stream6;
 8002bd2:	4d22      	ldr	r5, [pc, #136]	; (8002c5c <HAL_SD_MspInit+0x170>)
    hdma_sdmmc1_tx.Init.Channel = DMA_CHANNEL_4;
 8002bd4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    hdma_sdmmc1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8002bd8:	2300      	movs	r3, #0
    hdma_sdmmc1_tx.Instance = DMA2_Stream6;
 8002bda:	4921      	ldr	r1, [pc, #132]	; (8002c60 <HAL_SD_MspInit+0x174>)
    hdma_sdmmc1_tx.Init.Channel = DMA_CHANNEL_4;
 8002bdc:	606a      	str	r2, [r5, #4]
    hdma_sdmmc1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002bde:	2240      	movs	r2, #64	; 0x40
    hdma_sdmmc1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8002be0:	60eb      	str	r3, [r5, #12]
    if (HAL_DMA_Init(&hdma_sdmmc1_tx) != HAL_OK)
 8002be2:	4628      	mov	r0, r5
    hdma_sdmmc1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8002be4:	61ab      	str	r3, [r5, #24]
    hdma_sdmmc1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002be6:	60aa      	str	r2, [r5, #8]
    hdma_sdmmc1_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 8002be8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    hdma_sdmmc1_tx.Init.MemBurst = DMA_MBURST_SINGLE;
 8002bec:	62eb      	str	r3, [r5, #44]	; 0x2c
    hdma_sdmmc1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8002bee:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    hdma_sdmmc1_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 8002bf2:	632a      	str	r2, [r5, #48]	; 0x30
    hdma_sdmmc1_tx.Init.Priority = DMA_PRIORITY_HIGH;
 8002bf4:	2220      	movs	r2, #32
    hdma_sdmmc1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8002bf6:	616b      	str	r3, [r5, #20]
    hdma_sdmmc1_tx.Init.Priority = DMA_PRIORITY_HIGH;
 8002bf8:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    hdma_sdmmc1_tx.Instance = DMA2_Stream6;
 8002bfc:	6029      	str	r1, [r5, #0]
    hdma_sdmmc1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8002bfe:	f44f 6180 	mov.w	r1, #1024	; 0x400
    __HAL_LINKDMA(hsd,hdmarx,hdma_sdmmc1_rx);
 8002c02:	6426      	str	r6, [r4, #64]	; 0x40
 8002c04:	63b4      	str	r4, [r6, #56]	; 0x38
    hdma_sdmmc1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8002c06:	6129      	str	r1, [r5, #16]
    hdma_sdmmc1_tx.Init.Priority = DMA_PRIORITY_HIGH;
 8002c08:	e9c5 2307 	strd	r2, r3, [r5, #28]
    hdma_sdmmc1_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8002c0c:	2204      	movs	r2, #4
 8002c0e:	2303      	movs	r3, #3
 8002c10:	e9c5 2309 	strd	r2, r3, [r5, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_sdmmc1_tx) != HAL_OK)
 8002c14:	f000 fafa 	bl	800320c <HAL_DMA_Init>
 8002c18:	b970      	cbnz	r0, 8002c38 <HAL_SD_MspInit+0x14c>
    HAL_NVIC_SetPriority(SDMMC1_IRQn, 8, 0);
 8002c1a:	2200      	movs	r2, #0
 8002c1c:	2108      	movs	r1, #8
 8002c1e:	2031      	movs	r0, #49	; 0x31
    __HAL_LINKDMA(hsd,hdmatx,hdma_sdmmc1_tx);
 8002c20:	63e5      	str	r5, [r4, #60]	; 0x3c
 8002c22:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(SDMMC1_IRQn, 8, 0);
 8002c24:	f000 fa90 	bl	8003148 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
 8002c28:	2031      	movs	r0, #49	; 0x31
 8002c2a:	f000 facb 	bl	80031c4 <HAL_NVIC_EnableIRQ>
}
 8002c2e:	b02b      	add	sp, #172	; 0xac
 8002c30:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
 8002c32:	f7ff ff39 	bl	8002aa8 <Error_Handler>
 8002c36:	e775      	b.n	8002b24 <HAL_SD_MspInit+0x38>
      Error_Handler();
 8002c38:	f7ff ff36 	bl	8002aa8 <Error_Handler>
 8002c3c:	e7ed      	b.n	8002c1a <HAL_SD_MspInit+0x12e>
      Error_Handler();
 8002c3e:	f7ff ff33 	bl	8002aa8 <Error_Handler>
 8002c42:	e7c6      	b.n	8002bd2 <HAL_SD_MspInit+0xe6>
 8002c44:	40012c00 	.word	0x40012c00
 8002c48:	40023800 	.word	0x40023800
 8002c4c:	40020800 	.word	0x40020800
 8002c50:	40020c00 	.word	0x40020c00
 8002c54:	20018900 	.word	0x20018900
 8002c58:	40026458 	.word	0x40026458
 8002c5c:	20018960 	.word	0x20018960
 8002c60:	400264a0 	.word	0x400264a0

08002c64 <HAL_TIM_Base_MspInit>:
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM5)
 8002c64:	4b09      	ldr	r3, [pc, #36]	; (8002c8c <HAL_TIM_Base_MspInit+0x28>)
 8002c66:	6802      	ldr	r2, [r0, #0]
 8002c68:	429a      	cmp	r2, r3
 8002c6a:	d000      	beq.n	8002c6e <HAL_TIM_Base_MspInit+0xa>
 8002c6c:	4770      	bx	lr
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
 8002c6e:	f503 330b 	add.w	r3, r3, #142336	; 0x22c00
{
 8002c72:	b082      	sub	sp, #8
    __HAL_RCC_TIM5_CLK_ENABLE();
 8002c74:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002c76:	f042 0208 	orr.w	r2, r2, #8
 8002c7a:	641a      	str	r2, [r3, #64]	; 0x40
 8002c7c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002c7e:	f003 0308 	and.w	r3, r3, #8
 8002c82:	9301      	str	r3, [sp, #4]
 8002c84:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }

}
 8002c86:	b002      	add	sp, #8
 8002c88:	4770      	bx	lr
 8002c8a:	bf00      	nop
 8002c8c:	40000c00 	.word	0x40000c00

08002c90 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8002c90:	b570      	push	{r4, r5, r6, lr}
 8002c92:	b0a8      	sub	sp, #160	; 0xa0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002c94:	2100      	movs	r1, #0
{
 8002c96:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002c98:	2284      	movs	r2, #132	; 0x84
 8002c9a:	a807      	add	r0, sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002c9c:	9106      	str	r1, [sp, #24]
 8002c9e:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8002ca2:	e9cd 1104 	strd	r1, r1, [sp, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002ca6:	f010 fa67 	bl	8013178 <memset>
  if(huart->Instance==USART1)
 8002caa:	4b39      	ldr	r3, [pc, #228]	; (8002d90 <HAL_UART_MspInit+0x100>)
 8002cac:	6822      	ldr	r2, [r4, #0]
 8002cae:	429a      	cmp	r2, r3
 8002cb0:	d001      	beq.n	8002cb6 <HAL_UART_MspInit+0x26>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 8002cb2:	b028      	add	sp, #160	; 0xa0
 8002cb4:	bd70      	pop	{r4, r5, r6, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8002cb6:	2340      	movs	r3, #64	; 0x40
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002cb8:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8002cba:	9307      	str	r3, [sp, #28]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002cbc:	f001 f94e 	bl	8003f5c <HAL_RCCEx_PeriphCLKConfig>
 8002cc0:	2800      	cmp	r0, #0
 8002cc2:	d15c      	bne.n	8002d7e <HAL_UART_MspInit+0xee>
    __HAL_RCC_USART1_CLK_ENABLE();
 8002cc4:	4b33      	ldr	r3, [pc, #204]	; (8002d94 <HAL_UART_MspInit+0x104>)
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8002cc6:	2007      	movs	r0, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002cc8:	a902      	add	r1, sp, #8
    hdma_usart1_rx.Instance = DMA2_Stream2;
 8002cca:	4e33      	ldr	r6, [pc, #204]	; (8002d98 <HAL_UART_MspInit+0x108>)
    __HAL_RCC_USART1_CLK_ENABLE();
 8002ccc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002cce:	f042 0210 	orr.w	r2, r2, #16
 8002cd2:	645a      	str	r2, [r3, #68]	; 0x44
 8002cd4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002cd6:	f002 0210 	and.w	r2, r2, #16
 8002cda:	9200      	str	r2, [sp, #0]
 8002cdc:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cde:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ce0:	f042 0201 	orr.w	r2, r2, #1
 8002ce4:	631a      	str	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8002ce6:	f44f 62c0 	mov.w	r2, #1536	; 0x600
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8002cec:	9006      	str	r0, [sp, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cee:	f003 0301 	and.w	r3, r3, #1
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002cf2:	482a      	ldr	r0, [pc, #168]	; (8002d9c <HAL_UART_MspInit+0x10c>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cf4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8002cf6:	2302      	movs	r3, #2
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002cf8:	9d01      	ldr	r5, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8002cfa:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8002cfe:	2201      	movs	r2, #1
 8002d00:	2303      	movs	r3, #3
 8002d02:	e9cd 2304 	strd	r2, r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8002d06:	f000 fcb3 	bl	8003670 <HAL_GPIO_Init>
    hdma_usart1_rx.Instance = DMA2_Stream2;
 8002d0a:	4925      	ldr	r1, [pc, #148]	; (8002da0 <HAL_UART_MspInit+0x110>)
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 8002d0c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8002d10:	2300      	movs	r3, #0
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 8002d12:	4630      	mov	r0, r6
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 8002d14:	e9c6 1200 	strd	r1, r2, [r6]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8002d18:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
 8002d1c:	f44f 7280 	mov.w	r2, #256	; 0x100
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8002d20:	e9c6 3302 	strd	r3, r3, [r6, #8]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8002d24:	e9c6 3305 	strd	r3, r3, [r6, #20]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8002d28:	6131      	str	r1, [r6, #16]
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR;
 8002d2a:	61f2      	str	r2, [r6, #28]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8002d2c:	e9c6 3308 	strd	r3, r3, [r6, #32]
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 8002d30:	f000 fa6c 	bl	800320c <HAL_DMA_Init>
 8002d34:	bb48      	cbnz	r0, 8002d8a <HAL_UART_MspInit+0xfa>
    hdma_usart1_tx.Instance = DMA2_Stream7;
 8002d36:	4d1b      	ldr	r5, [pc, #108]	; (8002da4 <HAL_UART_MspInit+0x114>)
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
 8002d38:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    hdma_usart1_tx.Instance = DMA2_Stream7;
 8002d3c:	491a      	ldr	r1, [pc, #104]	; (8002da8 <HAL_UART_MspInit+0x118>)
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8002d3e:	2300      	movs	r3, #0
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
 8002d40:	606a      	str	r2, [r5, #4]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8002d42:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hdma_usart1_tx.Instance = DMA2_Stream7;
 8002d46:	6029      	str	r1, [r5, #0]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002d48:	2140      	movs	r1, #64	; 0x40
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 8002d4a:	4628      	mov	r0, r5
    __HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
 8002d4c:	6726      	str	r6, [r4, #112]	; 0x70
 8002d4e:	63b4      	str	r4, [r6, #56]	; 0x38
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8002d50:	60eb      	str	r3, [r5, #12]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8002d52:	616b      	str	r3, [r5, #20]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002d54:	60a9      	str	r1, [r5, #8]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8002d56:	61ab      	str	r3, [r5, #24]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8002d58:	612a      	str	r2, [r5, #16]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8002d5a:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8002d5c:	e9c5 3307 	strd	r3, r3, [r5, #28]
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 8002d60:	f000 fa54 	bl	800320c <HAL_DMA_Init>
 8002d64:	b970      	cbnz	r0, 8002d84 <HAL_UART_MspInit+0xf4>
    HAL_NVIC_SetPriority(USART1_IRQn, 12, 0);
 8002d66:	2200      	movs	r2, #0
 8002d68:	210c      	movs	r1, #12
 8002d6a:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
 8002d6c:	66e5      	str	r5, [r4, #108]	; 0x6c
 8002d6e:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(USART1_IRQn, 12, 0);
 8002d70:	f000 f9ea 	bl	8003148 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8002d74:	2025      	movs	r0, #37	; 0x25
 8002d76:	f000 fa25 	bl	80031c4 <HAL_NVIC_EnableIRQ>
}
 8002d7a:	b028      	add	sp, #160	; 0xa0
 8002d7c:	bd70      	pop	{r4, r5, r6, pc}
      Error_Handler();
 8002d7e:	f7ff fe93 	bl	8002aa8 <Error_Handler>
 8002d82:	e79f      	b.n	8002cc4 <HAL_UART_MspInit+0x34>
      Error_Handler();
 8002d84:	f7ff fe90 	bl	8002aa8 <Error_Handler>
 8002d88:	e7ed      	b.n	8002d66 <HAL_UART_MspInit+0xd6>
      Error_Handler();
 8002d8a:	f7ff fe8d 	bl	8002aa8 <Error_Handler>
 8002d8e:	e7d2      	b.n	8002d36 <HAL_UART_MspInit+0xa6>
 8002d90:	40011000 	.word	0x40011000
 8002d94:	40023800 	.word	0x40023800
 8002d98:	200189c0 	.word	0x200189c0
 8002d9c:	40020000 	.word	0x40020000
 8002da0:	40026440 	.word	0x40026440
 8002da4:	20018a20 	.word	0x20018a20
 8002da8:	400264b8 	.word	0x400264b8
 8002dac:	00000000 	.word	0x00000000

08002db0 <HAL_SAI_MspInit>:
extern DMA_HandleTypeDef hdma_sai2_a;

static uint32_t SAI2_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
 8002db0:	b530      	push	{r4, r5, lr}
 8002db2:	b0a9      	sub	sp, #164	; 0xa4
 8002db4:	4604      	mov	r4, r0

  GPIO_InitTypeDef GPIO_InitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002db6:	2284      	movs	r2, #132	; 0x84
 8002db8:	2100      	movs	r1, #0
 8002dba:	a807      	add	r0, sp, #28
 8002dbc:	f010 f9dc 	bl	8013178 <memset>
/* SAI2 */
    if(hsai->Instance==SAI2_Block_A)
 8002dc0:	4b35      	ldr	r3, [pc, #212]	; (8002e98 <HAL_SAI_MspInit+0xe8>)
 8002dc2:	6822      	ldr	r2, [r4, #0]
 8002dc4:	429a      	cmp	r2, r3
 8002dc6:	d001      	beq.n	8002dcc <HAL_SAI_MspInit+0x1c>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai2_a);

    __HAL_LINKDMA(hsai,hdmatx,hdma_sai2_a);

    }
}
 8002dc8:	b029      	add	sp, #164	; 0xa4
 8002dca:	bd30      	pop	{r4, r5, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 8002dcc:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    PeriphClkInitStruct.PLLSAI.PLLSAIN = 316;
 8002dd0:	f44f 739e 	mov.w	r3, #316	; 0x13c
    PeriphClkInitStruct.PLLSAI.PLLSAIR = 2;
 8002dd4:	2102      	movs	r1, #2
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002dd6:	a807      	add	r0, sp, #28
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
 8002dd8:	9207      	str	r2, [sp, #28]
    PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7;
 8002dda:	2207      	movs	r2, #7
    PeriphClkInitStruct.PLLSAI.PLLSAIN = 316;
 8002ddc:	930c      	str	r3, [sp, #48]	; 0x30
    PeriphClkInitStruct.PLLSAIDivQ = 1;
 8002dde:	2301      	movs	r3, #1
    PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7;
 8002de0:	e9cd 210d 	strd	r2, r1, [sp, #52]	; 0x34
    PeriphClkInitStruct.PLLSAIDivQ = 1;
 8002de4:	9311      	str	r3, [sp, #68]	; 0x44
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002de6:	f001 f8b9 	bl	8003f5c <HAL_RCCEx_PeriphCLKConfig>
 8002dea:	2800      	cmp	r0, #0
 8002dec:	d137      	bne.n	8002e5e <HAL_SAI_MspInit+0xae>
    if (SAI2_client == 0)
 8002dee:	4d2b      	ldr	r5, [pc, #172]	; (8002e9c <HAL_SAI_MspInit+0xec>)
 8002df0:	682a      	ldr	r2, [r5, #0]
 8002df2:	2a00      	cmp	r2, #0
 8002df4:	d039      	beq.n	8002e6a <HAL_SAI_MspInit+0xba>
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8002df6:	f44f 5060 	mov.w	r0, #14336	; 0x3800
 8002dfa:	2102      	movs	r1, #2
    SAI2_client ++;
 8002dfc:	3201      	adds	r2, #1
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8002dfe:	230a      	movs	r3, #10
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8002e00:	ed9f 7b23 	vldr	d7, [pc, #140]	; 8002e90 <HAL_SAI_MspInit+0xe0>
 8002e04:	e9cd 0102 	strd	r0, r1, [sp, #8]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002e08:	a902      	add	r1, sp, #8
 8002e0a:	4825      	ldr	r0, [pc, #148]	; (8002ea0 <HAL_SAI_MspInit+0xf0>)
    SAI2_client ++;
 8002e0c:	602a      	str	r2, [r5, #0]
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 8002e0e:	9306      	str	r3, [sp, #24]
    hdma_sai2_a.Instance = DMA2_Stream4;
 8002e10:	4d24      	ldr	r5, [pc, #144]	; (8002ea4 <HAL_SAI_MspInit+0xf4>)
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 8002e12:	ed8d 7b04 	vstr	d7, [sp, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8002e16:	f000 fc2b 	bl	8003670 <HAL_GPIO_Init>
    hdma_sai2_a.Init.PeriphInc = DMA_PINC_DISABLE;
 8002e1a:	2300      	movs	r3, #0
    hdma_sai2_a.Init.Channel = DMA_CHANNEL_3;
 8002e1c:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
    hdma_sai2_a.Instance = DMA2_Stream4;
 8002e20:	4921      	ldr	r1, [pc, #132]	; (8002ea8 <HAL_SAI_MspInit+0xf8>)
    hdma_sai2_a.Init.PeriphInc = DMA_PINC_DISABLE;
 8002e22:	60eb      	str	r3, [r5, #12]
    if (HAL_DMA_Init(&hdma_sai2_a) != HAL_OK)
 8002e24:	4628      	mov	r0, r5
    hdma_sai2_a.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8002e26:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_sai2_a.Init.MemInc = DMA_MINC_ENABLE;
 8002e28:	f44f 6380 	mov.w	r3, #1024	; 0x400
    hdma_sai2_a.Init.Channel = DMA_CHANNEL_3;
 8002e2c:	e9c5 1200 	strd	r1, r2, [r5]
    hdma_sai2_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002e30:	2240      	movs	r2, #64	; 0x40
    hdma_sai2_a.Init.MemInc = DMA_MINC_ENABLE;
 8002e32:	612b      	str	r3, [r5, #16]
    hdma_sai2_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8002e34:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    hdma_sai2_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8002e38:	60aa      	str	r2, [r5, #8]
    hdma_sai2_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8002e3a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002e3e:	e9c5 2305 	strd	r2, r3, [r5, #20]
    hdma_sai2_a.Init.Priority = DMA_PRIORITY_MEDIUM;
 8002e42:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002e46:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8002e4a:	e9c5 2307 	strd	r2, r3, [r5, #28]
    if (HAL_DMA_Init(&hdma_sai2_a) != HAL_OK)
 8002e4e:	f000 f9dd 	bl	800320c <HAL_DMA_Init>
 8002e52:	b938      	cbnz	r0, 8002e64 <HAL_SAI_MspInit+0xb4>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai2_a);
 8002e54:	6725      	str	r5, [r4, #112]	; 0x70
 8002e56:	63ac      	str	r4, [r5, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai2_a);
 8002e58:	66e5      	str	r5, [r4, #108]	; 0x6c
}
 8002e5a:	b029      	add	sp, #164	; 0xa4
 8002e5c:	bd30      	pop	{r4, r5, pc}
      Error_Handler();
 8002e5e:	f7ff fe23 	bl	8002aa8 <Error_Handler>
 8002e62:	e7c4      	b.n	8002dee <HAL_SAI_MspInit+0x3e>
      Error_Handler();
 8002e64:	f7ff fe20 	bl	8002aa8 <Error_Handler>
 8002e68:	e7f4      	b.n	8002e54 <HAL_SAI_MspInit+0xa4>
       __HAL_RCC_SAI2_CLK_ENABLE();
 8002e6a:	4b10      	ldr	r3, [pc, #64]	; (8002eac <HAL_SAI_MspInit+0xfc>)
    HAL_NVIC_SetPriority(SAI2_IRQn, 5, 0);
 8002e6c:	205b      	movs	r0, #91	; 0x5b
       __HAL_RCC_SAI2_CLK_ENABLE();
 8002e6e:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8002e70:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8002e74:	6459      	str	r1, [r3, #68]	; 0x44
    HAL_NVIC_SetPriority(SAI2_IRQn, 5, 0);
 8002e76:	2105      	movs	r1, #5
       __HAL_RCC_SAI2_CLK_ENABLE();
 8002e78:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002e7a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8002e7e:	9301      	str	r3, [sp, #4]
 8002e80:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI2_IRQn, 5, 0);
 8002e82:	f000 f961 	bl	8003148 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI2_IRQn);
 8002e86:	205b      	movs	r0, #91	; 0x5b
 8002e88:	f000 f99c 	bl	80031c4 <HAL_NVIC_EnableIRQ>
    SAI2_client ++;
 8002e8c:	682a      	ldr	r2, [r5, #0]
 8002e8e:	e7b2      	b.n	8002df6 <HAL_SAI_MspInit+0x46>
 8002e90:	00000001 	.word	0x00000001
 8002e94:	00000003 	.word	0x00000003
 8002e98:	40015c04 	.word	0x40015c04
 8002e9c:	200194bc 	.word	0x200194bc
 8002ea0:	40020c00 	.word	0x40020c00
 8002ea4:	200188a0 	.word	0x200188a0
 8002ea8:	40026470 	.word	0x40026470
 8002eac:	40023800 	.word	0x40023800

08002eb0 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8002eb0:	e7fe      	b.n	8002eb0 <NMI_Handler>
 8002eb2:	bf00      	nop

08002eb4 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8002eb4:	e7fe      	b.n	8002eb4 <HardFault_Handler>
 8002eb6:	bf00      	nop

08002eb8 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8002eb8:	e7fe      	b.n	8002eb8 <MemManage_Handler>
 8002eba:	bf00      	nop

08002ebc <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8002ebc:	e7fe      	b.n	8002ebc <BusFault_Handler>
 8002ebe:	bf00      	nop

08002ec0 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8002ec0:	e7fe      	b.n	8002ec0 <UsageFault_Handler>
 8002ec2:	bf00      	nop

08002ec4 <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8002ec4:	4770      	bx	lr
 8002ec6:	bf00      	nop

08002ec8 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8002ec8:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8002eca:	f000 f907 	bl	80030dc <HAL_IncTick>
#if (INCLUDE_xTaskGetSchedulerState == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8002ece:	f008 fda1 	bl	800ba14 <xTaskGetSchedulerState>
 8002ed2:	2801      	cmp	r0, #1
 8002ed4:	d100      	bne.n	8002ed8 <SysTick_Handler+0x10>
  }
#endif /* INCLUDE_xTaskGetSchedulerState */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8002ed6:	bd08      	pop	{r3, pc}
 8002ed8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  xPortSysTickHandler();
 8002edc:	f009 b97a 	b.w	800c1d4 <xPortSysTickHandler>

08002ee0 <USART1_IRQHandler>:
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8002ee0:	4801      	ldr	r0, [pc, #4]	; (8002ee8 <USART1_IRQHandler+0x8>)
 8002ee2:	f002 bfb1 	b.w	8005e48 <HAL_UART_IRQHandler>
 8002ee6:	bf00      	nop
 8002ee8:	20018bd4 	.word	0x20018bd4

08002eec <SDMMC1_IRQHandler>:
void SDMMC1_IRQHandler(void)
{
  /* USER CODE BEGIN SDMMC1_IRQn 0 */

  /* USER CODE END SDMMC1_IRQn 0 */
  HAL_SD_IRQHandler(&hsd1);
 8002eec:	4801      	ldr	r0, [pc, #4]	; (8002ef4 <SDMMC1_IRQHandler+0x8>)
 8002eee:	f002 b8e9 	b.w	80050c4 <HAL_SD_IRQHandler>
 8002ef2:	bf00      	nop
 8002ef4:	20018b04 	.word	0x20018b04

08002ef8 <DMA2_Stream4_IRQHandler>:
void DMA2_Stream4_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai2_a);
 8002ef8:	4801      	ldr	r0, [pc, #4]	; (8002f00 <DMA2_Stream4_IRQHandler+0x8>)
 8002efa:	f000 bac7 	b.w	800348c <HAL_DMA_IRQHandler>
 8002efe:	bf00      	nop
 8002f00:	200188a0 	.word	0x200188a0

08002f04 <DMA2_Stream2_IRQHandler>:
void DMA2_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream2_IRQn 0 */

  /* USER CODE END DMA2_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 8002f04:	4801      	ldr	r0, [pc, #4]	; (8002f0c <DMA2_Stream2_IRQHandler+0x8>)
 8002f06:	f000 bac1 	b.w	800348c <HAL_DMA_IRQHandler>
 8002f0a:	bf00      	nop
 8002f0c:	200189c0 	.word	0x200189c0

08002f10 <DMA2_Stream3_IRQHandler>:
void DMA2_Stream3_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_rx);
 8002f10:	4801      	ldr	r0, [pc, #4]	; (8002f18 <DMA2_Stream3_IRQHandler+0x8>)
 8002f12:	f000 babb 	b.w	800348c <HAL_DMA_IRQHandler>
 8002f16:	bf00      	nop
 8002f18:	20018900 	.word	0x20018900

08002f1c <DMA2_Stream6_IRQHandler>:
void DMA2_Stream6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_tx);
 8002f1c:	4801      	ldr	r0, [pc, #4]	; (8002f24 <DMA2_Stream6_IRQHandler+0x8>)
 8002f1e:	f000 bab5 	b.w	800348c <HAL_DMA_IRQHandler>
 8002f22:	bf00      	nop
 8002f24:	20018960 	.word	0x20018960

08002f28 <DMA2_Stream7_IRQHandler>:
void DMA2_Stream7_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream7_IRQn 0 */

  /* USER CODE END DMA2_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 8002f28:	4801      	ldr	r0, [pc, #4]	; (8002f30 <DMA2_Stream7_IRQHandler+0x8>)
 8002f2a:	f000 baaf 	b.w	800348c <HAL_DMA_IRQHandler>
 8002f2e:	bf00      	nop
 8002f30:	20018a20 	.word	0x20018a20

08002f34 <SAI2_IRQHandler>:
void SAI2_IRQHandler(void)
{
  /* USER CODE BEGIN SAI2_IRQn 0 */

  /* USER CODE END SAI2_IRQn 0 */
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 8002f34:	4801      	ldr	r0, [pc, #4]	; (8002f3c <SAI2_IRQHandler+0x8>)
 8002f36:	f001 bd99 	b.w	8004a6c <HAL_SAI_IRQHandler>
 8002f3a:	bf00      	nop
 8002f3c:	20018a80 	.word	0x20018a80

08002f40 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 8002f40:	2001      	movs	r0, #1
 8002f42:	4770      	bx	lr

08002f44 <_kill>:

int _kill(int pid, int sig)
{
 8002f44:	b508      	push	{r3, lr}
	errno = EINVAL;
 8002f46:	f010 f8c5 	bl	80130d4 <__errno>
 8002f4a:	2216      	movs	r2, #22
 8002f4c:	4603      	mov	r3, r0
	return -1;
}
 8002f4e:	f04f 30ff 	mov.w	r0, #4294967295
	errno = EINVAL;
 8002f52:	601a      	str	r2, [r3, #0]
}
 8002f54:	bd08      	pop	{r3, pc}
 8002f56:	bf00      	nop

08002f58 <_exit>:

void _exit (int status)
{
 8002f58:	b508      	push	{r3, lr}
	errno = EINVAL;
 8002f5a:	f010 f8bb 	bl	80130d4 <__errno>
 8002f5e:	2316      	movs	r3, #22
 8002f60:	6003      	str	r3, [r0, #0]
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
 8002f62:	e7fe      	b.n	8002f62 <_exit+0xa>

08002f64 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8002f64:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8002f66:	1e16      	subs	r6, r2, #0
 8002f68:	dd07      	ble.n	8002f7a <_read+0x16>
 8002f6a:	460c      	mov	r4, r1
 8002f6c:	198d      	adds	r5, r1, r6
	{
		*ptr++ = __io_getchar();
 8002f6e:	f3af 8000 	nop.w
 8002f72:	f804 0b01 	strb.w	r0, [r4], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8002f76:	42a5      	cmp	r5, r4
 8002f78:	d1f9      	bne.n	8002f6e <_read+0xa>
	}

return len;
}
 8002f7a:	4630      	mov	r0, r6
 8002f7c:	bd70      	pop	{r4, r5, r6, pc}
 8002f7e:	bf00      	nop

08002f80 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8002f80:	b570      	push	{r4, r5, r6, lr}
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8002f82:	1e16      	subs	r6, r2, #0
 8002f84:	dd07      	ble.n	8002f96 <_write+0x16>
 8002f86:	460c      	mov	r4, r1
 8002f88:	198d      	adds	r5, r1, r6
	{
		__io_putchar(*ptr++);
 8002f8a:	f814 0b01 	ldrb.w	r0, [r4], #1
 8002f8e:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8002f92:	42ac      	cmp	r4, r5
 8002f94:	d1f9      	bne.n	8002f8a <_write+0xa>
	}
	return len;
}
 8002f96:	4630      	mov	r0, r6
 8002f98:	bd70      	pop	{r4, r5, r6, pc}
 8002f9a:	bf00      	nop

08002f9c <_close>:

int _close(int file)
{
	return -1;
}
 8002f9c:	f04f 30ff 	mov.w	r0, #4294967295
 8002fa0:	4770      	bx	lr
 8002fa2:	bf00      	nop

08002fa4 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8002fa4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	return 0;
}
 8002fa8:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
 8002faa:	604b      	str	r3, [r1, #4]
}
 8002fac:	4770      	bx	lr
 8002fae:	bf00      	nop

08002fb0 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8002fb0:	2001      	movs	r0, #1
 8002fb2:	4770      	bx	lr

08002fb4 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8002fb4:	2000      	movs	r0, #0
 8002fb6:	4770      	bx	lr

08002fb8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8002fb8:	b538      	push	{r3, r4, r5, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8002fba:	4c0d      	ldr	r4, [pc, #52]	; (8002ff0 <_sbrk+0x38>)
{
 8002fbc:	4603      	mov	r3, r0
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8002fbe:	490d      	ldr	r1, [pc, #52]	; (8002ff4 <_sbrk+0x3c>)
 8002fc0:	4d0d      	ldr	r5, [pc, #52]	; (8002ff8 <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 8002fc2:	6822      	ldr	r2, [r4, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8002fc4:	1b49      	subs	r1, r1, r5
  if (NULL == __sbrk_heap_end)
 8002fc6:	b12a      	cbz	r2, 8002fd4 <_sbrk+0x1c>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8002fc8:	4413      	add	r3, r2
 8002fca:	428b      	cmp	r3, r1
 8002fcc:	d808      	bhi.n	8002fe0 <_sbrk+0x28>

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 8002fce:	4610      	mov	r0, r2
  __sbrk_heap_end += incr;
 8002fd0:	6023      	str	r3, [r4, #0]
}
 8002fd2:	bd38      	pop	{r3, r4, r5, pc}
    __sbrk_heap_end = &_end;
 8002fd4:	4809      	ldr	r0, [pc, #36]	; (8002ffc <_sbrk+0x44>)
 8002fd6:	4602      	mov	r2, r0
 8002fd8:	6020      	str	r0, [r4, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8002fda:	4413      	add	r3, r2
 8002fdc:	428b      	cmp	r3, r1
 8002fde:	d9f6      	bls.n	8002fce <_sbrk+0x16>
    errno = ENOMEM;
 8002fe0:	f010 f878 	bl	80130d4 <__errno>
 8002fe4:	230c      	movs	r3, #12
    return (void *)-1;
 8002fe6:	f04f 32ff 	mov.w	r2, #4294967295
    errno = ENOMEM;
 8002fea:	6003      	str	r3, [r0, #0]
}
 8002fec:	4610      	mov	r0, r2
 8002fee:	bd38      	pop	{r3, r4, r5, pc}
 8002ff0:	200194c0 	.word	0x200194c0
 8002ff4:	20050000 	.word	0x20050000
 8002ff8:	00000a00 	.word	0x00000a00
 8002ffc:	2004ee68 	.word	0x2004ee68

08003000 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003000:	4a03      	ldr	r2, [pc, #12]	; (8003010 <SystemInit+0x10>)
 8003002:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8003006:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800300a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 800300e:	4770      	bx	lr
 8003010:	e000ed00 	.word	0xe000ed00

08003014 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8003014:	f8df d034 	ldr.w	sp, [pc, #52]	; 800304c <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8003018:	480d      	ldr	r0, [pc, #52]	; (8003050 <LoopFillZerobss+0x16>)
  ldr r1, =_edata
 800301a:	490e      	ldr	r1, [pc, #56]	; (8003054 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
 800301c:	4a0e      	ldr	r2, [pc, #56]	; (8003058 <LoopFillZerobss+0x1e>)
  movs r3, #0
 800301e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8003020:	e002      	b.n	8003028 <LoopCopyDataInit>

08003022 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8003022:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8003024:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8003026:	3304      	adds	r3, #4

08003028 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8003028:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800302a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800302c:	d3f9      	bcc.n	8003022 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800302e:	4a0b      	ldr	r2, [pc, #44]	; (800305c <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
 8003030:	4c0b      	ldr	r4, [pc, #44]	; (8003060 <LoopFillZerobss+0x26>)
  movs r3, #0
 8003032:	2300      	movs	r3, #0
  b LoopFillZerobss
 8003034:	e001      	b.n	800303a <LoopFillZerobss>

08003036 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8003036:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8003038:	3204      	adds	r2, #4

0800303a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800303a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800303c:	d3fb      	bcc.n	8003036 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800303e:	f7ff ffdf 	bl	8003000 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8003042:	f010 f84d 	bl	80130e0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8003046:	f7ff fbc7 	bl	80027d8 <main>
  bx  lr    
 800304a:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 800304c:	20050000 	.word	0x20050000
  ldr r0, =_sdata
 8003050:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8003054:	20000864 	.word	0x20000864
  ldr r2, =_sidata
 8003058:	0801a6ec 	.word	0x0801a6ec
  ldr r2, =_sbss
 800305c:	20000880 	.word	0x20000880
  ldr r4, =_ebss
 8003060:	2004ee68 	.word	0x2004ee68

08003064 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8003064:	e7fe      	b.n	8003064 <ADC_IRQHandler>
	...

08003068 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8003068:	490e      	ldr	r1, [pc, #56]	; (80030a4 <HAL_InitTick+0x3c>)
 800306a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800306e:	4a0e      	ldr	r2, [pc, #56]	; (80030a8 <HAL_InitTick+0x40>)
{
 8003070:	b510      	push	{r4, lr}
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8003072:	7809      	ldrb	r1, [r1, #0]
{
 8003074:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8003076:	6812      	ldr	r2, [r2, #0]
 8003078:	fbb3 f3f1 	udiv	r3, r3, r1
 800307c:	fbb2 f0f3 	udiv	r0, r2, r3
 8003080:	f000 f8ae 	bl	80031e0 <HAL_SYSTICK_Config>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8003084:	b908      	cbnz	r0, 800308a <HAL_InitTick+0x22>
 8003086:	2c0f      	cmp	r4, #15
 8003088:	d901      	bls.n	800308e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800308a:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 800308c:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800308e:	2200      	movs	r2, #0
 8003090:	4621      	mov	r1, r4
 8003092:	f04f 30ff 	mov.w	r0, #4294967295
 8003096:	f000 f857 	bl	8003148 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800309a:	4b04      	ldr	r3, [pc, #16]	; (80030ac <HAL_InitTick+0x44>)
 800309c:	2000      	movs	r0, #0
 800309e:	601c      	str	r4, [r3, #0]
}
 80030a0:	bd10      	pop	{r4, pc}
 80030a2:	bf00      	nop
 80030a4:	20000684 	.word	0x20000684
 80030a8:	20000680 	.word	0x20000680
 80030ac:	20000688 	.word	0x20000688

080030b0 <HAL_Init>:
{
 80030b0:	b508      	push	{r3, lr}
  __HAL_FLASH_ART_ENABLE();
 80030b2:	4b09      	ldr	r3, [pc, #36]	; (80030d8 <HAL_Init+0x28>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80030b4:	2003      	movs	r0, #3
  __HAL_FLASH_ART_ENABLE();
 80030b6:	681a      	ldr	r2, [r3, #0]
 80030b8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80030bc:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80030be:	681a      	ldr	r2, [r3, #0]
 80030c0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80030c4:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80030c6:	f000 f82d 	bl	8003124 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80030ca:	200f      	movs	r0, #15
 80030cc:	f7ff ffcc 	bl	8003068 <HAL_InitTick>
  HAL_MspInit();
 80030d0:	f7ff fcec 	bl	8002aac <HAL_MspInit>
}
 80030d4:	2000      	movs	r0, #0
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	40023c00 	.word	0x40023c00

080030dc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80030dc:	4a03      	ldr	r2, [pc, #12]	; (80030ec <HAL_IncTick+0x10>)
 80030de:	4b04      	ldr	r3, [pc, #16]	; (80030f0 <HAL_IncTick+0x14>)
 80030e0:	6811      	ldr	r1, [r2, #0]
 80030e2:	781b      	ldrb	r3, [r3, #0]
 80030e4:	440b      	add	r3, r1
 80030e6:	6013      	str	r3, [r2, #0]
}
 80030e8:	4770      	bx	lr
 80030ea:	bf00      	nop
 80030ec:	200194c4 	.word	0x200194c4
 80030f0:	20000684 	.word	0x20000684

080030f4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80030f4:	4b01      	ldr	r3, [pc, #4]	; (80030fc <HAL_GetTick+0x8>)
 80030f6:	6818      	ldr	r0, [r3, #0]
}
 80030f8:	4770      	bx	lr
 80030fa:	bf00      	nop
 80030fc:	200194c4 	.word	0x200194c4

08003100 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8003100:	b538      	push	{r3, r4, r5, lr}
 8003102:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8003104:	f7ff fff6 	bl	80030f4 <HAL_GetTick>
 8003108:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800310a:	1c63      	adds	r3, r4, #1
 800310c:	d002      	beq.n	8003114 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800310e:	4b04      	ldr	r3, [pc, #16]	; (8003120 <HAL_Delay+0x20>)
 8003110:	781b      	ldrb	r3, [r3, #0]
 8003112:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8003114:	f7ff ffee 	bl	80030f4 <HAL_GetTick>
 8003118:	1b43      	subs	r3, r0, r5
 800311a:	42a3      	cmp	r3, r4
 800311c:	d3fa      	bcc.n	8003114 <HAL_Delay+0x14>
  {
  }
}
 800311e:	bd38      	pop	{r3, r4, r5, pc}
 8003120:	20000684 	.word	0x20000684

08003124 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003124:	4906      	ldr	r1, [pc, #24]	; (8003140 <HAL_NVIC_SetPriorityGrouping+0x1c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003126:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800312a:	0200      	lsls	r0, r0, #8
  reg_value  =  (reg_value                                   |
 800312c:	4b05      	ldr	r3, [pc, #20]	; (8003144 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800312e:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8003130:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003134:	ea02 020c 	and.w	r2, r2, ip
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003138:	4310      	orrs	r0, r2
  reg_value  =  (reg_value                                   |
 800313a:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 800313c:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800313e:	4770      	bx	lr
 8003140:	e000ed00 	.word	0xe000ed00
 8003144:	05fa0000 	.word	0x05fa0000

08003148 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8003148:	4b1b      	ldr	r3, [pc, #108]	; (80031b8 <HAL_NVIC_SetPriority+0x70>)
 800314a:	68db      	ldr	r3, [r3, #12]
 800314c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8003150:	b500      	push	{lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003152:	f1c3 0e07 	rsb	lr, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003156:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800315a:	f1be 0f04 	cmp.w	lr, #4
 800315e:	bf28      	it	cs
 8003160:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003164:	f1bc 0f06 	cmp.w	ip, #6
 8003168:	d91a      	bls.n	80031a0 <HAL_NVIC_SetPriority+0x58>
 800316a:	3b03      	subs	r3, #3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800316c:	f04f 3cff 	mov.w	ip, #4294967295
 8003170:	fa0c fc03 	lsl.w	ip, ip, r3
 8003174:	ea22 020c 	bic.w	r2, r2, ip
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003178:	f04f 3cff 	mov.w	ip, #4294967295
  if ((int32_t)(IRQn) >= 0)
 800317c:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800317e:	fa0c fc0e 	lsl.w	ip, ip, lr
 8003182:	ea21 010c 	bic.w	r1, r1, ip
 8003186:	fa01 f103 	lsl.w	r1, r1, r3
 800318a:	ea41 0102 	orr.w	r1, r1, r2
  if ((int32_t)(IRQn) >= 0)
 800318e:	db0a      	blt.n	80031a6 <HAL_NVIC_SetPriority+0x5e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003190:	0109      	lsls	r1, r1, #4
 8003192:	4b0a      	ldr	r3, [pc, #40]	; (80031bc <HAL_NVIC_SetPriority+0x74>)
 8003194:	b2c9      	uxtb	r1, r1
 8003196:	4403      	add	r3, r0
 8003198:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800319c:	f85d fb04 	ldr.w	pc, [sp], #4
 80031a0:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80031a2:	4613      	mov	r3, r2
 80031a4:	e7e8      	b.n	8003178 <HAL_NVIC_SetPriority+0x30>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80031a6:	f000 000f 	and.w	r0, r0, #15
 80031aa:	0109      	lsls	r1, r1, #4
 80031ac:	4b04      	ldr	r3, [pc, #16]	; (80031c0 <HAL_NVIC_SetPriority+0x78>)
 80031ae:	b2c9      	uxtb	r1, r1
 80031b0:	4403      	add	r3, r0
 80031b2:	7619      	strb	r1, [r3, #24]
 80031b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031b8:	e000ed00 	.word	0xe000ed00
 80031bc:	e000e100 	.word	0xe000e100
 80031c0:	e000ecfc 	.word	0xe000ecfc

080031c4 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80031c4:	2800      	cmp	r0, #0
 80031c6:	db07      	blt.n	80031d8 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80031c8:	f000 011f 	and.w	r1, r0, #31
 80031cc:	2301      	movs	r3, #1
 80031ce:	0940      	lsrs	r0, r0, #5
 80031d0:	4a02      	ldr	r2, [pc, #8]	; (80031dc <HAL_NVIC_EnableIRQ+0x18>)
 80031d2:	408b      	lsls	r3, r1
 80031d4:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80031d8:	4770      	bx	lr
 80031da:	bf00      	nop
 80031dc:	e000e100 	.word	0xe000e100

080031e0 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80031e0:	1e43      	subs	r3, r0, #1
 80031e2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80031e6:	d20c      	bcs.n	8003202 <HAL_SYSTICK_Config+0x22>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80031e8:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80031ec:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80031ee:	4906      	ldr	r1, [pc, #24]	; (8003208 <HAL_SYSTICK_Config+0x28>)
 80031f0:	f04f 0cf0 	mov.w	ip, #240	; 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80031f4:	6153      	str	r3, [r2, #20]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80031f6:	2307      	movs	r3, #7
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80031f8:	f881 c023 	strb.w	ip, [r1, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80031fc:	6190      	str	r0, [r2, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80031fe:	6113      	str	r3, [r2, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8003200:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8003202:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8003204:	4770      	bx	lr
 8003206:	bf00      	nop
 8003208:	e000ed00 	.word	0xe000ed00

0800320c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800320c:	b538      	push	{r3, r4, r5, lr}
 800320e:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8003210:	f7ff ff70 	bl	80030f4 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8003214:	2c00      	cmp	r4, #0
 8003216:	d054      	beq.n	80032c2 <HAL_DMA_Init+0xb6>
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8003218:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 800321a:	2200      	movs	r2, #0
  hdma->State = HAL_DMA_STATE_BUSY;
 800321c:	2102      	movs	r1, #2
 800321e:	4605      	mov	r5, r0
  __HAL_UNLOCK(hdma);
 8003220:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 8003224:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8003228:	681a      	ldr	r2, [r3, #0]
 800322a:	f022 0201 	bic.w	r2, r2, #1
 800322e:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8003230:	e005      	b.n	800323e <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8003232:	f7ff ff5f 	bl	80030f4 <HAL_GetTick>
 8003236:	1b43      	subs	r3, r0, r5
 8003238:	2b05      	cmp	r3, #5
 800323a:	d83b      	bhi.n	80032b4 <HAL_DMA_Init+0xa8>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800323c:	6823      	ldr	r3, [r4, #0]
 800323e:	681a      	ldr	r2, [r3, #0]
 8003240:	07d1      	lsls	r1, r2, #31
 8003242:	d4f6      	bmi.n	8003232 <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8003244:	e9d4 2501 	ldrd	r2, r5, [r4, #4]
 8003248:	68e1      	ldr	r1, [r4, #12]
 800324a:	432a      	orrs	r2, r5
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800324c:	69a0      	ldr	r0, [r4, #24]
  tmp = hdma->Instance->CR;
 800324e:	681d      	ldr	r5, [r3, #0]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8003250:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8003252:	6921      	ldr	r1, [r4, #16]
 8003254:	430a      	orrs	r2, r1
 8003256:	6961      	ldr	r1, [r4, #20]
 8003258:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800325a:	69e1      	ldr	r1, [r4, #28]
 800325c:	4302      	orrs	r2, r0
 800325e:	430a      	orrs	r2, r1
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8003260:	4934      	ldr	r1, [pc, #208]	; (8003334 <HAL_DMA_Init+0x128>)
 8003262:	4029      	ands	r1, r5
          hdma->Init.Mode                | hdma->Init.Priority;
 8003264:	6a25      	ldr	r5, [r4, #32]
 8003266:	432a      	orrs	r2, r5
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8003268:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800326a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800326c:	2904      	cmp	r1, #4
 800326e:	d02a      	beq.n	80032c6 <HAL_DMA_Init+0xba>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8003270:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8003272:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8003274:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8003278:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800327a:	b2da      	uxtb	r2, r3
  hdma->Instance->FCR = tmp;
 800327c:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800327e:	492e      	ldr	r1, [pc, #184]	; (8003338 <HAL_DMA_Init+0x12c>)
 8003280:	3a10      	subs	r2, #16
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8003282:	482e      	ldr	r0, [pc, #184]	; (800333c <HAL_DMA_Init+0x130>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8003284:	fba1 5102 	umull	r5, r1, r1, r2
  
  if (stream_number > 3U)
 8003288:	2a5f      	cmp	r2, #95	; 0x5f
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800328a:	4a2d      	ldr	r2, [pc, #180]	; (8003340 <HAL_DMA_Init+0x134>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800328c:	ea4f 1111 	mov.w	r1, r1, lsr #4
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8003290:	ea02 0203 	and.w	r2, r2, r3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8003294:	f04f 033f 	mov.w	r3, #63	; 0x3f
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8003298:	5c41      	ldrb	r1, [r0, r1]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800329a:	f04f 0000 	mov.w	r0, #0
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800329e:	bf88      	it	hi
 80032a0:	3204      	addhi	r2, #4
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80032a2:	408b      	lsls	r3, r1
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80032a4:	65e1      	str	r1, [r4, #92]	; 0x5c
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80032a6:	65a2      	str	r2, [r4, #88]	; 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80032a8:	6093      	str	r3, [r2, #8]
  hdma->State = HAL_DMA_STATE_READY;
 80032aa:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80032ac:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 80032ae:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80032b2:	bd38      	pop	{r3, r4, r5, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80032b4:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80032b6:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 80032b8:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80032ba:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 80032bc:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 80032c0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 80032c2:	2001      	movs	r0, #1
}
 80032c4:	bd38      	pop	{r3, r4, r5, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80032c6:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	; 0x2c
 80032ca:	4329      	orrs	r1, r5
 80032cc:	430a      	orrs	r2, r1
  hdma->Instance->CR = tmp;  
 80032ce:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 80032d0:	6959      	ldr	r1, [r3, #20]
    tmp |= hdma->Init.FIFOThreshold;
 80032d2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 80032d4:	f021 0107 	bic.w	r1, r1, #7
 80032d8:	4311      	orrs	r1, r2
    tmp |= hdma->Init.FIFOThreshold;
 80032da:	f041 0104 	orr.w	r1, r1, #4
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 80032de:	2d00      	cmp	r5, #0
 80032e0:	d0cb      	beq.n	800327a <HAL_DMA_Init+0x6e>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80032e2:	b178      	cbz	r0, 8003304 <HAL_DMA_Init+0xf8>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80032e4:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 80032e8:	d016      	beq.n	8003318 <HAL_DMA_Init+0x10c>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 80032ea:	2a02      	cmp	r2, #2
 80032ec:	d903      	bls.n	80032f6 <HAL_DMA_Init+0xea>
 80032ee:	2a03      	cmp	r2, #3
 80032f0:	d1c3      	bne.n	800327a <HAL_DMA_Init+0x6e>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80032f2:	01ea      	lsls	r2, r5, #7
 80032f4:	d5c1      	bpl.n	800327a <HAL_DMA_Init+0x6e>
        hdma->State = HAL_DMA_STATE_READY;
 80032f6:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80032f8:	2240      	movs	r2, #64	; 0x40
        return HAL_ERROR; 
 80032fa:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80032fc:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 80032fe:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 8003302:	bd38      	pop	{r3, r4, r5, pc}
    switch (tmp)
 8003304:	2a01      	cmp	r2, #1
 8003306:	d003      	beq.n	8003310 <HAL_DMA_Init+0x104>
 8003308:	f032 0202 	bics.w	r2, r2, #2
 800330c:	d1b5      	bne.n	800327a <HAL_DMA_Init+0x6e>
 800330e:	e7f0      	b.n	80032f2 <HAL_DMA_Init+0xe6>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8003310:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 8003314:	d1b1      	bne.n	800327a <HAL_DMA_Init+0x6e>
 8003316:	e7ee      	b.n	80032f6 <HAL_DMA_Init+0xea>
    switch (tmp)
 8003318:	2a03      	cmp	r2, #3
 800331a:	d8ae      	bhi.n	800327a <HAL_DMA_Init+0x6e>
 800331c:	a001      	add	r0, pc, #4	; (adr r0, 8003324 <HAL_DMA_Init+0x118>)
 800331e:	f850 f022 	ldr.w	pc, [r0, r2, lsl #2]
 8003322:	bf00      	nop
 8003324:	080032f7 	.word	0x080032f7
 8003328:	080032f3 	.word	0x080032f3
 800332c:	080032f7 	.word	0x080032f7
 8003330:	08003311 	.word	0x08003311
 8003334:	f010803f 	.word	0xf010803f
 8003338:	aaaaaaab 	.word	0xaaaaaaab
 800333c:	08016aec 	.word	0x08016aec
 8003340:	fffffc00 	.word	0xfffffc00

08003344 <HAL_DMA_Start_IT>:
{
 8003344:	b430      	push	{r4, r5}
 8003346:	4684      	mov	ip, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8003348:	6d85      	ldr	r5, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 800334a:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 800334e:	2801      	cmp	r0, #1
 8003350:	d03d      	beq.n	80033ce <HAL_DMA_Start_IT+0x8a>
 8003352:	2001      	movs	r0, #1
 8003354:	f88c 0034 	strb.w	r0, [ip, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8003358:	f89c 0035 	ldrb.w	r0, [ip, #53]	; 0x35
 800335c:	2801      	cmp	r0, #1
 800335e:	d005      	beq.n	800336c <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8003360:	2300      	movs	r3, #0
    status = HAL_BUSY;
 8003362:	2002      	movs	r0, #2
    __HAL_UNLOCK(hdma);	  
 8003364:	f88c 3034 	strb.w	r3, [ip, #52]	; 0x34
}
 8003368:	bc30      	pop	{r4, r5}
 800336a:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_BUSY;
 800336c:	2002      	movs	r0, #2
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800336e:	f8dc 4000 	ldr.w	r4, [ip]
    hdma->State = HAL_DMA_STATE_BUSY;
 8003372:	f88c 0035 	strb.w	r0, [ip, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003376:	2000      	movs	r0, #0
 8003378:	f8cc 0054 	str.w	r0, [ip, #84]	; 0x54
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 800337c:	6820      	ldr	r0, [r4, #0]
 800337e:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
 8003382:	6020      	str	r0, [r4, #0]
  hdma->Instance->NDTR = DataLength;
 8003384:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003386:	f8dc 3008 	ldr.w	r3, [ip, #8]
 800338a:	2b40      	cmp	r3, #64	; 0x40
 800338c:	d01c      	beq.n	80033c8 <HAL_DMA_Start_IT+0x84>
    hdma->Instance->PAR = SrcAddress;
 800338e:	60a1      	str	r1, [r4, #8]
    hdma->Instance->M0AR = DstAddress;
 8003390:	60e2      	str	r2, [r4, #12]
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8003392:	f8dc 105c 	ldr.w	r1, [ip, #92]	; 0x5c
 8003396:	233f      	movs	r3, #63	; 0x3f
    if(hdma->XferHalfCpltCallback != NULL)
 8003398:	f8dc 2040 	ldr.w	r2, [ip, #64]	; 0x40
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800339c:	408b      	lsls	r3, r1
 800339e:	60ab      	str	r3, [r5, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80033a0:	6823      	ldr	r3, [r4, #0]
 80033a2:	f043 0316 	orr.w	r3, r3, #22
 80033a6:	6023      	str	r3, [r4, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 80033a8:	6963      	ldr	r3, [r4, #20]
 80033aa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80033ae:	6163      	str	r3, [r4, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 80033b0:	b11a      	cbz	r2, 80033ba <HAL_DMA_Start_IT+0x76>
      hdma->Instance->CR  |= DMA_IT_HT;
 80033b2:	6823      	ldr	r3, [r4, #0]
 80033b4:	f043 0308 	orr.w	r3, r3, #8
 80033b8:	6023      	str	r3, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 80033ba:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80033bc:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80033be:	f043 0301 	orr.w	r3, r3, #1
 80033c2:	6023      	str	r3, [r4, #0]
}
 80033c4:	bc30      	pop	{r4, r5}
 80033c6:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 80033c8:	60a2      	str	r2, [r4, #8]
    hdma->Instance->M0AR = SrcAddress;
 80033ca:	60e1      	str	r1, [r4, #12]
 80033cc:	e7e1      	b.n	8003392 <HAL_DMA_Start_IT+0x4e>
  __HAL_LOCK(hdma);
 80033ce:	2002      	movs	r0, #2
}
 80033d0:	bc30      	pop	{r4, r5}
 80033d2:	4770      	bx	lr

080033d4 <HAL_DMA_Abort>:
{
 80033d4:	b570      	push	{r4, r5, r6, lr}
 80033d6:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80033d8:	6d86      	ldr	r6, [r0, #88]	; 0x58
  uint32_t tickstart = HAL_GetTick();
 80033da:	f7ff fe8b 	bl	80030f4 <HAL_GetTick>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80033de:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 80033e2:	2b02      	cmp	r3, #2
 80033e4:	d006      	beq.n	80033f4 <HAL_DMA_Abort+0x20>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80033e6:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 80033e8:	2300      	movs	r3, #0
    return HAL_ERROR;
 80033ea:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80033ec:	6562      	str	r2, [r4, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 80033ee:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 80033f2:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 80033f4:	6823      	ldr	r3, [r4, #0]
 80033f6:	4605      	mov	r5, r0
 80033f8:	681a      	ldr	r2, [r3, #0]
 80033fa:	f022 0216 	bic.w	r2, r2, #22
 80033fe:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8003400:	695a      	ldr	r2, [r3, #20]
 8003402:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003406:	615a      	str	r2, [r3, #20]
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8003408:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800340a:	b33a      	cbz	r2, 800345c <HAL_DMA_Abort+0x88>
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 800340c:	681a      	ldr	r2, [r3, #0]
 800340e:	f022 0208 	bic.w	r2, r2, #8
 8003412:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8003414:	681a      	ldr	r2, [r3, #0]
 8003416:	f022 0201 	bic.w	r2, r2, #1
 800341a:	601a      	str	r2, [r3, #0]
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800341c:	e005      	b.n	800342a <HAL_DMA_Abort+0x56>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800341e:	f7ff fe69 	bl	80030f4 <HAL_GetTick>
 8003422:	1b43      	subs	r3, r0, r5
 8003424:	2b05      	cmp	r3, #5
 8003426:	d80f      	bhi.n	8003448 <HAL_DMA_Abort+0x74>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8003428:	6823      	ldr	r3, [r4, #0]
 800342a:	681b      	ldr	r3, [r3, #0]
 800342c:	f013 0301 	ands.w	r3, r3, #1
 8003430:	d1f5      	bne.n	800341e <HAL_DMA_Abort+0x4a>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8003432:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8003434:	223f      	movs	r2, #63	; 0x3f
  return HAL_OK;
 8003436:	4618      	mov	r0, r3
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8003438:	408a      	lsls	r2, r1
    hdma->State = HAL_DMA_STATE_READY;
 800343a:	2101      	movs	r1, #1
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 800343c:	60b2      	str	r2, [r6, #8]
    hdma->State = HAL_DMA_STATE_READY;
 800343e:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
    __HAL_UNLOCK(hdma);
 8003442:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8003446:	bd70      	pop	{r4, r5, r6, pc}
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8003448:	2303      	movs	r3, #3
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800344a:	2120      	movs	r1, #32
        __HAL_UNLOCK(hdma);
 800344c:	2200      	movs	r2, #0
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800344e:	6561      	str	r1, [r4, #84]	; 0x54
        return HAL_TIMEOUT;
 8003450:	4618      	mov	r0, r3
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 8003452:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 8003456:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
}
 800345a:	bd70      	pop	{r4, r5, r6, pc}
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800345c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800345e:	2a00      	cmp	r2, #0
 8003460:	d1d4      	bne.n	800340c <HAL_DMA_Abort+0x38>
 8003462:	e7d7      	b.n	8003414 <HAL_DMA_Abort+0x40>

08003464 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8003464:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
{
 8003468:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800346a:	2a02      	cmp	r2, #2
 800346c:	d003      	beq.n	8003476 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800346e:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8003470:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003472:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 8003474:	4770      	bx	lr
    __HAL_DMA_DISABLE(hdma);
 8003476:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8003478:	2105      	movs	r1, #5
  return HAL_OK;
 800347a:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 800347c:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8003480:	6813      	ldr	r3, [r2, #0]
 8003482:	f023 0301 	bic.w	r3, r3, #1
 8003486:	6013      	str	r3, [r2, #0]
}
 8003488:	4770      	bx	lr
 800348a:	bf00      	nop

0800348c <HAL_DMA_IRQHandler>:
{
 800348c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __IO uint32_t count = 0;
 8003490:	2200      	movs	r2, #0
  uint32_t timeout = SystemCoreClock / 9600;
 8003492:	4b74      	ldr	r3, [pc, #464]	; (8003664 <HAL_DMA_IRQHandler+0x1d8>)
{
 8003494:	b082      	sub	sp, #8
 8003496:	4680      	mov	r8, r0
  uint32_t timeout = SystemCoreClock / 9600;
 8003498:	681d      	ldr	r5, [r3, #0]
  __IO uint32_t count = 0;
 800349a:	9201      	str	r2, [sp, #4]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800349c:	2208      	movs	r2, #8
 800349e:	e9d0 6316 	ldrd	r6, r3, [r0, #88]	; 0x58
  tmpisr = regs->ISR;
 80034a2:	6834      	ldr	r4, [r6, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 80034a4:	409a      	lsls	r2, r3
 80034a6:	4222      	tst	r2, r4
 80034a8:	d004      	beq.n	80034b4 <HAL_DMA_IRQHandler+0x28>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 80034aa:	6801      	ldr	r1, [r0, #0]
 80034ac:	680f      	ldr	r7, [r1, #0]
 80034ae:	0778      	lsls	r0, r7, #29
 80034b0:	f100 80ab 	bmi.w	800360a <HAL_DMA_IRQHandler+0x17e>
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 80034b4:	2201      	movs	r2, #1
 80034b6:	409a      	lsls	r2, r3
 80034b8:	4222      	tst	r2, r4
 80034ba:	d005      	beq.n	80034c8 <HAL_DMA_IRQHandler+0x3c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 80034bc:	f8d8 1000 	ldr.w	r1, [r8]
 80034c0:	6949      	ldr	r1, [r1, #20]
 80034c2:	0609      	lsls	r1, r1, #24
 80034c4:	f100 8099 	bmi.w	80035fa <HAL_DMA_IRQHandler+0x16e>
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80034c8:	2204      	movs	r2, #4
 80034ca:	409a      	lsls	r2, r3
 80034cc:	4222      	tst	r2, r4
 80034ce:	d005      	beq.n	80034dc <HAL_DMA_IRQHandler+0x50>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 80034d0:	f8d8 1000 	ldr.w	r1, [r8]
 80034d4:	6809      	ldr	r1, [r1, #0]
 80034d6:	078f      	lsls	r7, r1, #30
 80034d8:	f100 8087 	bmi.w	80035ea <HAL_DMA_IRQHandler+0x15e>
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 80034dc:	2210      	movs	r2, #16
 80034de:	409a      	lsls	r2, r3
 80034e0:	4222      	tst	r2, r4
 80034e2:	d004      	beq.n	80034ee <HAL_DMA_IRQHandler+0x62>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80034e4:	f8d8 1000 	ldr.w	r1, [r8]
 80034e8:	680f      	ldr	r7, [r1, #0]
 80034ea:	0738      	lsls	r0, r7, #28
 80034ec:	d468      	bmi.n	80035c0 <HAL_DMA_IRQHandler+0x134>
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80034ee:	2220      	movs	r2, #32
 80034f0:	409a      	lsls	r2, r3
 80034f2:	4222      	tst	r2, r4
 80034f4:	d017      	beq.n	8003526 <HAL_DMA_IRQHandler+0x9a>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80034f6:	f8d8 1000 	ldr.w	r1, [r8]
 80034fa:	680c      	ldr	r4, [r1, #0]
 80034fc:	06e0      	lsls	r0, r4, #27
 80034fe:	d512      	bpl.n	8003526 <HAL_DMA_IRQHandler+0x9a>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8003500:	60b2      	str	r2, [r6, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8003502:	f898 2035 	ldrb.w	r2, [r8, #53]	; 0x35
 8003506:	2a05      	cmp	r2, #5
 8003508:	d039      	beq.n	800357e <HAL_DMA_IRQHandler+0xf2>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800350a:	680b      	ldr	r3, [r1, #0]
 800350c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8003510:	680b      	ldr	r3, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8003512:	f000 808d 	beq.w	8003630 <HAL_DMA_IRQHandler+0x1a4>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8003516:	0319      	lsls	r1, r3, #12
 8003518:	f140 8098 	bpl.w	800364c <HAL_DMA_IRQHandler+0x1c0>
        if(hdma->XferCpltCallback != NULL)
 800351c:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8003520:	b10b      	cbz	r3, 8003526 <HAL_DMA_IRQHandler+0x9a>
          hdma->XferCpltCallback(hdma);
 8003522:	4640      	mov	r0, r8
 8003524:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8003526:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 800352a:	2b00      	cmp	r3, #0
 800352c:	d045      	beq.n	80035ba <HAL_DMA_IRQHandler+0x12e>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800352e:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8003532:	07da      	lsls	r2, r3, #31
 8003534:	d51b      	bpl.n	800356e <HAL_DMA_IRQHandler+0xe2>
      __HAL_DMA_DISABLE(hdma);
 8003536:	f8d8 2000 	ldr.w	r2, [r8]
      hdma->State = HAL_DMA_STATE_ABORT;
 800353a:	2305      	movs	r3, #5
  uint32_t timeout = SystemCoreClock / 9600;
 800353c:	494a      	ldr	r1, [pc, #296]	; (8003668 <HAL_DMA_IRQHandler+0x1dc>)
      hdma->State = HAL_DMA_STATE_ABORT;
 800353e:	f888 3035 	strb.w	r3, [r8, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8003542:	6813      	ldr	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600;
 8003544:	fba1 1505 	umull	r1, r5, r1, r5
      __HAL_DMA_DISABLE(hdma);
 8003548:	f023 0301 	bic.w	r3, r3, #1
  uint32_t timeout = SystemCoreClock / 9600;
 800354c:	0aad      	lsrs	r5, r5, #10
      __HAL_DMA_DISABLE(hdma);
 800354e:	6013      	str	r3, [r2, #0]
 8003550:	e002      	b.n	8003558 <HAL_DMA_IRQHandler+0xcc>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8003552:	6813      	ldr	r3, [r2, #0]
 8003554:	07db      	lsls	r3, r3, #31
 8003556:	d504      	bpl.n	8003562 <HAL_DMA_IRQHandler+0xd6>
        if (++count > timeout)
 8003558:	9b01      	ldr	r3, [sp, #4]
 800355a:	3301      	adds	r3, #1
 800355c:	42ab      	cmp	r3, r5
 800355e:	9301      	str	r3, [sp, #4]
 8003560:	d9f7      	bls.n	8003552 <HAL_DMA_IRQHandler+0xc6>
      hdma->State = HAL_DMA_STATE_READY;
 8003562:	2201      	movs	r2, #1
      __HAL_UNLOCK(hdma);
 8003564:	2300      	movs	r3, #0
      hdma->State = HAL_DMA_STATE_READY;
 8003566:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
      __HAL_UNLOCK(hdma);
 800356a:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
    if(hdma->XferErrorCallback != NULL)
 800356e:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 8003572:	b313      	cbz	r3, 80035ba <HAL_DMA_IRQHandler+0x12e>
      hdma->XferErrorCallback(hdma);
 8003574:	4640      	mov	r0, r8
}
 8003576:	b002      	add	sp, #8
 8003578:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      hdma->XferErrorCallback(hdma);
 800357c:	4718      	bx	r3
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800357e:	680a      	ldr	r2, [r1, #0]
 8003580:	f022 0216 	bic.w	r2, r2, #22
 8003584:	600a      	str	r2, [r1, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8003586:	694a      	ldr	r2, [r1, #20]
 8003588:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800358c:	614a      	str	r2, [r1, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800358e:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 8003592:	2a00      	cmp	r2, #0
 8003594:	d060      	beq.n	8003658 <HAL_DMA_IRQHandler+0x1cc>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8003596:	680a      	ldr	r2, [r1, #0]
 8003598:	f022 0208 	bic.w	r2, r2, #8
 800359c:	600a      	str	r2, [r1, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 800359e:	223f      	movs	r2, #63	; 0x3f
        hdma->State = HAL_DMA_STATE_READY;
 80035a0:	2101      	movs	r1, #1
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80035a2:	fa02 f303 	lsl.w	r3, r2, r3
        __HAL_UNLOCK(hdma);
 80035a6:	2200      	movs	r2, #0
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80035a8:	60b3      	str	r3, [r6, #8]
        if(hdma->XferAbortCallback != NULL)
 80035aa:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
        hdma->State = HAL_DMA_STATE_READY;
 80035ae:	f888 1035 	strb.w	r1, [r8, #53]	; 0x35
        __HAL_UNLOCK(hdma);
 80035b2:	f888 2034 	strb.w	r2, [r8, #52]	; 0x34
        if(hdma->XferAbortCallback != NULL)
 80035b6:	2b00      	cmp	r3, #0
 80035b8:	d1dc      	bne.n	8003574 <HAL_DMA_IRQHandler+0xe8>
}
 80035ba:	b002      	add	sp, #8
 80035bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80035c0:	60b2      	str	r2, [r6, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80035c2:	680a      	ldr	r2, [r1, #0]
 80035c4:	f412 2f80 	tst.w	r2, #262144	; 0x40000
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80035c8:	680a      	ldr	r2, [r1, #0]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80035ca:	d12a      	bne.n	8003622 <HAL_DMA_IRQHandler+0x196>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80035cc:	05d7      	lsls	r7, r2, #23
 80035ce:	d403      	bmi.n	80035d8 <HAL_DMA_IRQHandler+0x14c>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80035d0:	680a      	ldr	r2, [r1, #0]
 80035d2:	f022 0208 	bic.w	r2, r2, #8
 80035d6:	600a      	str	r2, [r1, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 80035d8:	f8d8 2040 	ldr.w	r2, [r8, #64]	; 0x40
 80035dc:	2a00      	cmp	r2, #0
 80035de:	d086      	beq.n	80034ee <HAL_DMA_IRQHandler+0x62>
          hdma->XferHalfCpltCallback(hdma);
 80035e0:	4640      	mov	r0, r8
 80035e2:	4790      	blx	r2
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80035e4:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 80035e8:	e781      	b.n	80034ee <HAL_DMA_IRQHandler+0x62>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80035ea:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80035ec:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 80035f0:	f042 0204 	orr.w	r2, r2, #4
 80035f4:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 80035f8:	e770      	b.n	80034dc <HAL_DMA_IRQHandler+0x50>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 80035fa:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80035fc:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8003600:	f042 0202 	orr.w	r2, r2, #2
 8003604:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8003608:	e75e      	b.n	80034c8 <HAL_DMA_IRQHandler+0x3c>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 800360a:	680f      	ldr	r7, [r1, #0]
 800360c:	f027 0704 	bic.w	r7, r7, #4
 8003610:	600f      	str	r7, [r1, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8003612:	60b2      	str	r2, [r6, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8003614:	f8d8 2054 	ldr.w	r2, [r8, #84]	; 0x54
 8003618:	f042 0201 	orr.w	r2, r2, #1
 800361c:	f8c8 2054 	str.w	r2, [r8, #84]	; 0x54
 8003620:	e748      	b.n	80034b4 <HAL_DMA_IRQHandler+0x28>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8003622:	0312      	lsls	r2, r2, #12
 8003624:	d5d8      	bpl.n	80035d8 <HAL_DMA_IRQHandler+0x14c>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8003626:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 800362a:	2a00      	cmp	r2, #0
 800362c:	d1d8      	bne.n	80035e0 <HAL_DMA_IRQHandler+0x154>
 800362e:	e75e      	b.n	80034ee <HAL_DMA_IRQHandler+0x62>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8003630:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 8003634:	f47f af72 	bne.w	800351c <HAL_DMA_IRQHandler+0x90>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8003638:	680a      	ldr	r2, [r1, #0]
 800363a:	f022 0210 	bic.w	r2, r2, #16
 800363e:	600a      	str	r2, [r1, #0]
          hdma->State = HAL_DMA_STATE_READY;
 8003640:	2201      	movs	r2, #1
          __HAL_UNLOCK(hdma);
 8003642:	f888 3034 	strb.w	r3, [r8, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8003646:	f888 2035 	strb.w	r2, [r8, #53]	; 0x35
          __HAL_UNLOCK(hdma);
 800364a:	e767      	b.n	800351c <HAL_DMA_IRQHandler+0x90>
          if(hdma->XferM1CpltCallback != NULL)
 800364c:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
 8003650:	2b00      	cmp	r3, #0
 8003652:	f47f af66 	bne.w	8003522 <HAL_DMA_IRQHandler+0x96>
 8003656:	e766      	b.n	8003526 <HAL_DMA_IRQHandler+0x9a>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8003658:	f8d8 2048 	ldr.w	r2, [r8, #72]	; 0x48
 800365c:	2a00      	cmp	r2, #0
 800365e:	d19a      	bne.n	8003596 <HAL_DMA_IRQHandler+0x10a>
 8003660:	e79d      	b.n	800359e <HAL_DMA_IRQHandler+0x112>
 8003662:	bf00      	nop
 8003664:	20000680 	.word	0x20000680
 8003668:	1b4e81b5 	.word	0x1b4e81b5

0800366c <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 800366c:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
 800366e:	4770      	bx	lr

08003670 <HAL_GPIO_Init>:
  for(position = 0; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8003670:	2200      	movs	r2, #0
{
 8003672:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  for(position = 0; position < GPIO_NUMBER; position++)
 8003676:	4613      	mov	r3, r2
{
 8003678:	b083      	sub	sp, #12
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800367a:	f8df b248 	ldr.w	fp, [pc, #584]	; 80038c4 <HAL_GPIO_Init+0x254>

        temp = SYSCFG->EXTICR[position >> 2];
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800367e:	4689      	mov	r9, r1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8003680:	680c      	ldr	r4, [r1, #0]
 8003682:	e004      	b.n	800368e <HAL_GPIO_Init+0x1e>
  for(position = 0; position < GPIO_NUMBER; position++)
 8003684:	3301      	adds	r3, #1
 8003686:	3202      	adds	r2, #2
 8003688:	2b10      	cmp	r3, #16
 800368a:	f000 809a 	beq.w	80037c2 <HAL_GPIO_Init+0x152>
    ioposition = ((uint32_t)0x01) << position;
 800368e:	2101      	movs	r1, #1
 8003690:	4099      	lsls	r1, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8003692:	ea01 0e04 	and.w	lr, r1, r4
    if(iocurrent == ioposition)
 8003696:	43a1      	bics	r1, r4
 8003698:	d1f4      	bne.n	8003684 <HAL_GPIO_Init+0x14>
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800369a:	f8d9 c004 	ldr.w	ip, [r9, #4]
 800369e:	f00c 0103 	and.w	r1, ip, #3
 80036a2:	1e4d      	subs	r5, r1, #1
 80036a4:	2d01      	cmp	r5, #1
 80036a6:	f240 808f 	bls.w	80037c8 <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80036aa:	2903      	cmp	r1, #3
 80036ac:	f040 80c9 	bne.w	8003842 <HAL_GPIO_Init+0x1d2>
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80036b0:	4091      	lsls	r1, r2
 80036b2:	43cd      	mvns	r5, r1
      temp = GPIOx->MODER;
 80036b4:	6806      	ldr	r6, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80036b6:	f41c 3f40 	tst.w	ip, #196608	; 0x30000
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80036ba:	ea05 0506 	and.w	r5, r5, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80036be:	ea41 0105 	orr.w	r1, r1, r5
      GPIOx->MODER = temp;
 80036c2:	6001      	str	r1, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80036c4:	d0de      	beq.n	8003684 <HAL_GPIO_Init+0x14>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80036c6:	f8db 1044 	ldr.w	r1, [fp, #68]	; 0x44
 80036ca:	f023 0503 	bic.w	r5, r3, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036ce:	f003 0603 	and.w	r6, r3, #3
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80036d2:	4f76      	ldr	r7, [pc, #472]	; (80038ac <HAL_GPIO_Init+0x23c>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80036d4:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 80036d8:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036dc:	00b6      	lsls	r6, r6, #2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80036de:	42b8      	cmp	r0, r7
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80036e0:	f8cb 1044 	str.w	r1, [fp, #68]	; 0x44
 80036e4:	f505 359c 	add.w	r5, r5, #79872	; 0x13800
 80036e8:	f8db 1044 	ldr.w	r1, [fp, #68]	; 0x44
 80036ec:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
 80036f0:	9101      	str	r1, [sp, #4]
 80036f2:	9901      	ldr	r1, [sp, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036f4:	f04f 010f 	mov.w	r1, #15
        temp = SYSCFG->EXTICR[position >> 2];
 80036f8:	f8d5 8008 	ldr.w	r8, [r5, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80036fc:	fa01 f106 	lsl.w	r1, r1, r6
 8003700:	ea28 0101 	bic.w	r1, r8, r1
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8003704:	d02e      	beq.n	8003764 <HAL_GPIO_Init+0xf4>
 8003706:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800370a:	42b8      	cmp	r0, r7
 800370c:	f000 809d 	beq.w	800384a <HAL_GPIO_Init+0x1da>
 8003710:	4f67      	ldr	r7, [pc, #412]	; (80038b0 <HAL_GPIO_Init+0x240>)
 8003712:	42b8      	cmp	r0, r7
 8003714:	f000 809f 	beq.w	8003856 <HAL_GPIO_Init+0x1e6>
 8003718:	4f66      	ldr	r7, [pc, #408]	; (80038b4 <HAL_GPIO_Init+0x244>)
 800371a:	42b8      	cmp	r0, r7
 800371c:	f000 80a1 	beq.w	8003862 <HAL_GPIO_Init+0x1f2>
 8003720:	4f65      	ldr	r7, [pc, #404]	; (80038b8 <HAL_GPIO_Init+0x248>)
 8003722:	42b8      	cmp	r0, r7
 8003724:	f000 80a3 	beq.w	800386e <HAL_GPIO_Init+0x1fe>
 8003728:	4f64      	ldr	r7, [pc, #400]	; (80038bc <HAL_GPIO_Init+0x24c>)
 800372a:	42b8      	cmp	r0, r7
 800372c:	f000 80ab 	beq.w	8003886 <HAL_GPIO_Init+0x216>
 8003730:	f8df 8194 	ldr.w	r8, [pc, #404]	; 80038c8 <HAL_GPIO_Init+0x258>
 8003734:	4540      	cmp	r0, r8
 8003736:	f000 80ac 	beq.w	8003892 <HAL_GPIO_Init+0x222>
 800373a:	f8df 8190 	ldr.w	r8, [pc, #400]	; 80038cc <HAL_GPIO_Init+0x25c>
 800373e:	4540      	cmp	r0, r8
 8003740:	f000 809b 	beq.w	800387a <HAL_GPIO_Init+0x20a>
 8003744:	f8df 8188 	ldr.w	r8, [pc, #392]	; 80038d0 <HAL_GPIO_Init+0x260>
 8003748:	4540      	cmp	r0, r8
 800374a:	f000 80a8 	beq.w	800389e <HAL_GPIO_Init+0x22e>
 800374e:	f8df 8184 	ldr.w	r8, [pc, #388]	; 80038d4 <HAL_GPIO_Init+0x264>
 8003752:	4540      	cmp	r0, r8
 8003754:	bf0c      	ite	eq
 8003756:	f04f 0809 	moveq.w	r8, #9
 800375a:	f04f 080a 	movne.w	r8, #10
 800375e:	fa08 f606 	lsl.w	r6, r8, r6
 8003762:	4331      	orrs	r1, r6
        SYSCFG->EXTICR[position >> 2] = temp;
 8003764:	60a9      	str	r1, [r5, #8]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8003766:	ea6f 060e 	mvn.w	r6, lr
        temp = EXTI->RTSR;
 800376a:	4955      	ldr	r1, [pc, #340]	; (80038c0 <HAL_GPIO_Init+0x250>)
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 800376c:	f41c 1f80 	tst.w	ip, #1048576	; 0x100000
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8003770:	4d53      	ldr	r5, [pc, #332]	; (80038c0 <HAL_GPIO_Init+0x250>)
  for(position = 0; position < GPIO_NUMBER; position++)
 8003772:	f103 0301 	add.w	r3, r3, #1
        temp = EXTI->RTSR;
 8003776:	6889      	ldr	r1, [r1, #8]
  for(position = 0; position < GPIO_NUMBER; position++)
 8003778:	f102 0202 	add.w	r2, r2, #2
        temp &= ~((uint32_t)iocurrent);
 800377c:	bf0c      	ite	eq
 800377e:	4031      	andeq	r1, r6
          temp |= iocurrent;
 8003780:	ea4e 0101 	orrne.w	r1, lr, r1

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8003784:	f41c 1f00 	tst.w	ip, #2097152	; 0x200000
        EXTI->RTSR = temp;
 8003788:	60a9      	str	r1, [r5, #8]
        temp = EXTI->FTSR;
 800378a:	68ed      	ldr	r5, [r5, #12]
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 800378c:	494c      	ldr	r1, [pc, #304]	; (80038c0 <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 800378e:	bf0c      	ite	eq
 8003790:	4035      	andeq	r5, r6
          temp |= iocurrent;
 8003792:	ea4e 0505 	orrne.w	r5, lr, r5

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8003796:	f41c 3f00 	tst.w	ip, #131072	; 0x20000
        EXTI->FTSR = temp;
 800379a:	60cd      	str	r5, [r1, #12]
        temp = EXTI->EMR;
 800379c:	684d      	ldr	r5, [r1, #4]
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 800379e:	4948      	ldr	r1, [pc, #288]	; (80038c0 <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 80037a0:	bf0c      	ite	eq
 80037a2:	4035      	andeq	r5, r6
          temp |= iocurrent;
 80037a4:	ea4e 0505 	orrne.w	r5, lr, r5

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 80037a8:	f41c 3f80 	tst.w	ip, #65536	; 0x10000
        EXTI->EMR = temp;
 80037ac:	604d      	str	r5, [r1, #4]
        temp = EXTI->IMR;
 80037ae:	6809      	ldr	r1, [r1, #0]
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 80037b0:	4d43      	ldr	r5, [pc, #268]	; (80038c0 <HAL_GPIO_Init+0x250>)
        temp &= ~((uint32_t)iocurrent);
 80037b2:	bf0c      	ite	eq
 80037b4:	4031      	andeq	r1, r6
          temp |= iocurrent;
 80037b6:	ea4e 0101 	orrne.w	r1, lr, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 80037ba:	2b10      	cmp	r3, #16
        EXTI->IMR = temp;
 80037bc:	6029      	str	r1, [r5, #0]
  for(position = 0; position < GPIO_NUMBER; position++)
 80037be:	f47f af66 	bne.w	800368e <HAL_GPIO_Init+0x1e>
      }
    }
  }
}
 80037c2:	b003      	add	sp, #12
 80037c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80037c8:	2503      	movs	r5, #3
        temp = GPIOx->OSPEEDR; 
 80037ca:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80037cc:	4095      	lsls	r5, r2
 80037ce:	ea26 0805 	bic.w	r8, r6, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 80037d2:	f8d9 600c 	ldr.w	r6, [r9, #12]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 80037d6:	43ed      	mvns	r5, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 80037d8:	4096      	lsls	r6, r2
 80037da:	ea46 0608 	orr.w	r6, r6, r8
        GPIOx->OSPEEDR = temp;
 80037de:	6086      	str	r6, [r0, #8]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80037e0:	f3cc 1600 	ubfx	r6, ip, #4, #1
        temp = GPIOx->OTYPER;
 80037e4:	f8d0 8004 	ldr.w	r8, [r0, #4]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80037e8:	409e      	lsls	r6, r3
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80037ea:	ea28 080e 	bic.w	r8, r8, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80037ee:	ea46 0608 	orr.w	r6, r6, r8
        GPIOx->OTYPER = temp;
 80037f2:	6046      	str	r6, [r0, #4]
        temp = GPIOx->PUPDR;
 80037f4:	68c6      	ldr	r6, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80037f6:	2902      	cmp	r1, #2
 80037f8:	fa01 f102 	lsl.w	r1, r1, r2
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 80037fc:	ea06 0805 	and.w	r8, r6, r5
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8003800:	f8d9 6008 	ldr.w	r6, [r9, #8]
 8003804:	fa06 f602 	lsl.w	r6, r6, r2
 8003808:	ea46 0608 	orr.w	r6, r6, r8
        GPIOx->PUPDR = temp;
 800380c:	60c6      	str	r6, [r0, #12]
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800380e:	f47f af51 	bne.w	80036b4 <HAL_GPIO_Init+0x44>
        temp = GPIOx->AFR[position >> 3];
 8003812:	ea4f 08d3 	mov.w	r8, r3, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8003816:	f003 0607 	and.w	r6, r3, #7
 800381a:	f04f 0a0f 	mov.w	sl, #15
 800381e:	eb00 0888 	add.w	r8, r0, r8, lsl #2
 8003822:	00b6      	lsls	r6, r6, #2
        temp = GPIOx->AFR[position >> 3];
 8003824:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8003828:	fa0a fa06 	lsl.w	sl, sl, r6
 800382c:	ea27 0a0a 	bic.w	sl, r7, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8003830:	f8d9 7010 	ldr.w	r7, [r9, #16]
 8003834:	fa07 f606 	lsl.w	r6, r7, r6
 8003838:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->AFR[position >> 3] = temp;
 800383c:	f8c8 6020 	str.w	r6, [r8, #32]
 8003840:	e738      	b.n	80036b4 <HAL_GPIO_Init+0x44>
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8003842:	2503      	movs	r5, #3
 8003844:	4095      	lsls	r5, r2
 8003846:	43ed      	mvns	r5, r5
 8003848:	e7d4      	b.n	80037f4 <HAL_GPIO_Init+0x184>
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800384a:	f04f 0801 	mov.w	r8, #1
 800384e:	fa08 f606 	lsl.w	r6, r8, r6
 8003852:	4331      	orrs	r1, r6
 8003854:	e786      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 8003856:	f04f 0802 	mov.w	r8, #2
 800385a:	fa08 f606 	lsl.w	r6, r8, r6
 800385e:	4331      	orrs	r1, r6
 8003860:	e780      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 8003862:	f04f 0803 	mov.w	r8, #3
 8003866:	fa08 f606 	lsl.w	r6, r8, r6
 800386a:	4331      	orrs	r1, r6
 800386c:	e77a      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 800386e:	f04f 0804 	mov.w	r8, #4
 8003872:	fa08 f606 	lsl.w	r6, r8, r6
 8003876:	4331      	orrs	r1, r6
 8003878:	e774      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 800387a:	f04f 0807 	mov.w	r8, #7
 800387e:	fa08 f606 	lsl.w	r6, r8, r6
 8003882:	4331      	orrs	r1, r6
 8003884:	e76e      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 8003886:	f04f 0805 	mov.w	r8, #5
 800388a:	fa08 f606 	lsl.w	r6, r8, r6
 800388e:	4331      	orrs	r1, r6
 8003890:	e768      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 8003892:	f04f 0806 	mov.w	r8, #6
 8003896:	fa08 f606 	lsl.w	r6, r8, r6
 800389a:	4331      	orrs	r1, r6
 800389c:	e762      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 800389e:	f04f 0808 	mov.w	r8, #8
 80038a2:	fa08 f606 	lsl.w	r6, r8, r6
 80038a6:	4331      	orrs	r1, r6
 80038a8:	e75c      	b.n	8003764 <HAL_GPIO_Init+0xf4>
 80038aa:	bf00      	nop
 80038ac:	40020000 	.word	0x40020000
 80038b0:	40020800 	.word	0x40020800
 80038b4:	40020c00 	.word	0x40020c00
 80038b8:	40021000 	.word	0x40021000
 80038bc:	40021400 	.word	0x40021400
 80038c0:	40013c00 	.word	0x40013c00
 80038c4:	40023800 	.word	0x40023800
 80038c8:	40021800 	.word	0x40021800
 80038cc:	40021c00 	.word	0x40021c00
 80038d0:	40022000 	.word	0x40022000
 80038d4:	40022400 	.word	0x40022400

080038d8 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80038d8:	6903      	ldr	r3, [r0, #16]
 80038da:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 80038dc:	bf14      	ite	ne
 80038de:	2001      	movne	r0, #1
 80038e0:	2000      	moveq	r0, #0
 80038e2:	4770      	bx	lr

080038e4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80038e4:	b902      	cbnz	r2, 80038e8 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80038e6:	0409      	lsls	r1, r1, #16
 80038e8:	6181      	str	r1, [r0, #24]
  }
}
 80038ea:	4770      	bx	lr

080038ec <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 80038ec:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 80038ee:	ea01 0203 	and.w	r2, r1, r3
 80038f2:	ea21 0103 	bic.w	r1, r1, r3
 80038f6:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 80038fa:	6181      	str	r1, [r0, #24]
}
 80038fc:	4770      	bx	lr
 80038fe:	bf00      	nop

08003900 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8003900:	4b1a      	ldr	r3, [pc, #104]	; (800396c <HAL_PWREx_EnableOverDrive+0x6c>)
 8003902:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003904:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
{
 8003908:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 800390a:	641a      	str	r2, [r3, #64]	; 0x40
{
 800390c:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 800390e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8003910:	4c17      	ldr	r4, [pc, #92]	; (8003970 <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8003912:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003916:	9301      	str	r3, [sp, #4]
 8003918:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 800391a:	6823      	ldr	r3, [r4, #0]
 800391c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003920:	6023      	str	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8003922:	f7ff fbe7 	bl	80030f4 <HAL_GetTick>
 8003926:	4605      	mov	r5, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8003928:	e005      	b.n	8003936 <HAL_PWREx_EnableOverDrive+0x36>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800392a:	f7ff fbe3 	bl	80030f4 <HAL_GetTick>
 800392e:	1b40      	subs	r0, r0, r5
 8003930:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003934:	d817      	bhi.n	8003966 <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8003936:	6863      	ldr	r3, [r4, #4]
 8003938:	03da      	lsls	r2, r3, #15
 800393a:	d5f6      	bpl.n	800392a <HAL_PWREx_EnableOverDrive+0x2a>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800393c:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800393e:	4d0c      	ldr	r5, [pc, #48]	; (8003970 <HAL_PWREx_EnableOverDrive+0x70>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8003940:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003944:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8003946:	f7ff fbd5 	bl	80030f4 <HAL_GetTick>
 800394a:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800394c:	e005      	b.n	800395a <HAL_PWREx_EnableOverDrive+0x5a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800394e:	f7ff fbd1 	bl	80030f4 <HAL_GetTick>
 8003952:	1b00      	subs	r0, r0, r4
 8003954:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003958:	d805      	bhi.n	8003966 <HAL_PWREx_EnableOverDrive+0x66>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800395a:	686b      	ldr	r3, [r5, #4]
 800395c:	039b      	lsls	r3, r3, #14
 800395e:	d5f6      	bpl.n	800394e <HAL_PWREx_EnableOverDrive+0x4e>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8003960:	2000      	movs	r0, #0
}
 8003962:	b003      	add	sp, #12
 8003964:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 8003966:	2003      	movs	r0, #3
}
 8003968:	b003      	add	sp, #12
 800396a:	bd30      	pop	{r4, r5, pc}
 800396c:	40023800 	.word	0x40023800
 8003970:	40007000 	.word	0x40007000

08003974 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8003974:	2800      	cmp	r0, #0
 8003976:	f000 81b6 	beq.w	8003ce6 <HAL_RCC_OscConfig+0x372>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800397a:	6803      	ldr	r3, [r0, #0]
{
 800397c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003980:	07dd      	lsls	r5, r3, #31
{
 8003982:	b082      	sub	sp, #8
 8003984:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003986:	d535      	bpl.n	80039f4 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8003988:	499a      	ldr	r1, [pc, #616]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 800398a:	688a      	ldr	r2, [r1, #8]
 800398c:	f002 020c 	and.w	r2, r2, #12
 8003990:	2a04      	cmp	r2, #4
 8003992:	f000 80e0 	beq.w	8003b56 <HAL_RCC_OscConfig+0x1e2>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003996:	688a      	ldr	r2, [r1, #8]
 8003998:	f002 020c 	and.w	r2, r2, #12
 800399c:	2a08      	cmp	r2, #8
 800399e:	f000 80d6 	beq.w	8003b4e <HAL_RCC_OscConfig+0x1da>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80039a2:	6863      	ldr	r3, [r4, #4]
 80039a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80039a8:	d010      	beq.n	80039cc <HAL_RCC_OscConfig+0x58>
 80039aa:	2b00      	cmp	r3, #0
 80039ac:	f000 80fd 	beq.w	8003baa <HAL_RCC_OscConfig+0x236>
 80039b0:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80039b4:	4b8f      	ldr	r3, [pc, #572]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 80039b6:	681a      	ldr	r2, [r3, #0]
 80039b8:	f000 8185 	beq.w	8003cc6 <HAL_RCC_OscConfig+0x352>
 80039bc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80039c0:	601a      	str	r2, [r3, #0]
 80039c2:	681a      	ldr	r2, [r3, #0]
 80039c4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80039c8:	601a      	str	r2, [r3, #0]
 80039ca:	e004      	b.n	80039d6 <HAL_RCC_OscConfig+0x62>
 80039cc:	4a89      	ldr	r2, [pc, #548]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 80039ce:	6813      	ldr	r3, [r2, #0]
 80039d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80039d4:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80039d6:	f7ff fb8d 	bl	80030f4 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80039da:	4e86      	ldr	r6, [pc, #536]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
        tickstart = HAL_GetTick();
 80039dc:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80039de:	e005      	b.n	80039ec <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80039e0:	f7ff fb88 	bl	80030f4 <HAL_GetTick>
 80039e4:	1b40      	subs	r0, r0, r5
 80039e6:	2864      	cmp	r0, #100	; 0x64
 80039e8:	f200 80db 	bhi.w	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80039ec:	6833      	ldr	r3, [r6, #0]
 80039ee:	039a      	lsls	r2, r3, #14
 80039f0:	d5f6      	bpl.n	80039e0 <HAL_RCC_OscConfig+0x6c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80039f2:	6823      	ldr	r3, [r4, #0]
 80039f4:	079f      	lsls	r7, r3, #30
 80039f6:	d527      	bpl.n	8003a48 <HAL_RCC_OscConfig+0xd4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80039f8:	4a7e      	ldr	r2, [pc, #504]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 80039fa:	6891      	ldr	r1, [r2, #8]
 80039fc:	f011 0f0c 	tst.w	r1, #12
 8003a00:	d07e      	beq.n	8003b00 <HAL_RCC_OscConfig+0x18c>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003a02:	6891      	ldr	r1, [r2, #8]
 8003a04:	f001 010c 	and.w	r1, r1, #12
 8003a08:	2908      	cmp	r1, #8
 8003a0a:	d076      	beq.n	8003afa <HAL_RCC_OscConfig+0x186>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8003a0c:	68e3      	ldr	r3, [r4, #12]
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8003a0e:	4d79      	ldr	r5, [pc, #484]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	f000 8104 	beq.w	8003c1e <HAL_RCC_OscConfig+0x2aa>
        __HAL_RCC_HSI_ENABLE();
 8003a16:	682b      	ldr	r3, [r5, #0]
 8003a18:	f043 0301 	orr.w	r3, r3, #1
 8003a1c:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003a1e:	f7ff fb69 	bl	80030f4 <HAL_GetTick>
 8003a22:	4606      	mov	r6, r0

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003a24:	e005      	b.n	8003a32 <HAL_RCC_OscConfig+0xbe>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003a26:	f7ff fb65 	bl	80030f4 <HAL_GetTick>
 8003a2a:	1b80      	subs	r0, r0, r6
 8003a2c:	2802      	cmp	r0, #2
 8003a2e:	f200 80b8 	bhi.w	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003a32:	682b      	ldr	r3, [r5, #0]
 8003a34:	0798      	lsls	r0, r3, #30
 8003a36:	d5f6      	bpl.n	8003a26 <HAL_RCC_OscConfig+0xb2>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003a38:	682b      	ldr	r3, [r5, #0]
 8003a3a:	6922      	ldr	r2, [r4, #16]
 8003a3c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8003a40:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8003a44:	602b      	str	r3, [r5, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003a46:	6823      	ldr	r3, [r4, #0]
 8003a48:	071a      	lsls	r2, r3, #28
 8003a4a:	d41f      	bmi.n	8003a8c <HAL_RCC_OscConfig+0x118>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003a4c:	075d      	lsls	r5, r3, #29
 8003a4e:	d534      	bpl.n	8003aba <HAL_RCC_OscConfig+0x146>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8003a50:	4b68      	ldr	r3, [pc, #416]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003a52:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8003a54:	00d0      	lsls	r0, r2, #3
 8003a56:	d56f      	bpl.n	8003b38 <HAL_RCC_OscConfig+0x1c4>
  FlagStatus pwrclkchanged = RESET;
 8003a58:	2500      	movs	r5, #0
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8003a5a:	4e67      	ldr	r6, [pc, #412]	; (8003bf8 <HAL_RCC_OscConfig+0x284>)
 8003a5c:	6833      	ldr	r3, [r6, #0]
 8003a5e:	05d9      	lsls	r1, r3, #23
 8003a60:	f140 808f 	bpl.w	8003b82 <HAL_RCC_OscConfig+0x20e>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003a64:	68a3      	ldr	r3, [r4, #8]
 8003a66:	2b01      	cmp	r3, #1
 8003a68:	f000 80eb 	beq.w	8003c42 <HAL_RCC_OscConfig+0x2ce>
 8003a6c:	2b00      	cmp	r3, #0
 8003a6e:	f000 80b2 	beq.w	8003bd6 <HAL_RCC_OscConfig+0x262>
 8003a72:	2b05      	cmp	r3, #5
 8003a74:	4b5f      	ldr	r3, [pc, #380]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003a76:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8003a78:	f000 812d 	beq.w	8003cd6 <HAL_RCC_OscConfig+0x362>
 8003a7c:	f022 0201 	bic.w	r2, r2, #1
 8003a80:	671a      	str	r2, [r3, #112]	; 0x70
 8003a82:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8003a84:	f022 0204 	bic.w	r2, r2, #4
 8003a88:	671a      	str	r2, [r3, #112]	; 0x70
 8003a8a:	e0df      	b.n	8003c4c <HAL_RCC_OscConfig+0x2d8>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8003a8c:	6963      	ldr	r3, [r4, #20]
      __HAL_RCC_LSI_ENABLE();
 8003a8e:	4d59      	ldr	r5, [pc, #356]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8003a90:	2b00      	cmp	r3, #0
 8003a92:	d040      	beq.n	8003b16 <HAL_RCC_OscConfig+0x1a2>
      __HAL_RCC_LSI_ENABLE();
 8003a94:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8003a96:	f043 0301 	orr.w	r3, r3, #1
 8003a9a:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8003a9c:	f7ff fb2a 	bl	80030f4 <HAL_GetTick>
 8003aa0:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003aa2:	e004      	b.n	8003aae <HAL_RCC_OscConfig+0x13a>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003aa4:	f7ff fb26 	bl	80030f4 <HAL_GetTick>
 8003aa8:	1b80      	subs	r0, r0, r6
 8003aaa:	2802      	cmp	r0, #2
 8003aac:	d879      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003aae:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8003ab0:	079b      	lsls	r3, r3, #30
 8003ab2:	d5f7      	bpl.n	8003aa4 <HAL_RCC_OscConfig+0x130>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8003ab4:	6823      	ldr	r3, [r4, #0]
 8003ab6:	075d      	lsls	r5, r3, #29
 8003ab8:	d4ca      	bmi.n	8003a50 <HAL_RCC_OscConfig+0xdc>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8003aba:	69a0      	ldr	r0, [r4, #24]
 8003abc:	b1c8      	cbz	r0, 8003af2 <HAL_RCC_OscConfig+0x17e>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003abe:	4d4d      	ldr	r5, [pc, #308]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003ac0:	68ab      	ldr	r3, [r5, #8]
 8003ac2:	f003 030c 	and.w	r3, r3, #12
 8003ac6:	2b08      	cmp	r3, #8
 8003ac8:	f000 80d3 	beq.w	8003c72 <HAL_RCC_OscConfig+0x2fe>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003acc:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003ace:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8003ad0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003ad4:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003ad6:	f000 8108 	beq.w	8003cea <HAL_RCC_OscConfig+0x376>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003ada:	f7ff fb0b 	bl	80030f4 <HAL_GetTick>
 8003ade:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003ae0:	e004      	b.n	8003aec <HAL_RCC_OscConfig+0x178>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003ae2:	f7ff fb07 	bl	80030f4 <HAL_GetTick>
 8003ae6:	1b00      	subs	r0, r0, r4
 8003ae8:	2802      	cmp	r0, #2
 8003aea:	d85a      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003aec:	682b      	ldr	r3, [r5, #0]
 8003aee:	019b      	lsls	r3, r3, #6
 8003af0:	d4f7      	bmi.n	8003ae2 <HAL_RCC_OscConfig+0x16e>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 8003af2:	2000      	movs	r0, #0
}
 8003af4:	b002      	add	sp, #8
 8003af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003afa:	6852      	ldr	r2, [r2, #4]
 8003afc:	0256      	lsls	r6, r2, #9
 8003afe:	d485      	bmi.n	8003a0c <HAL_RCC_OscConfig+0x98>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8003b00:	4a3c      	ldr	r2, [pc, #240]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003b02:	6812      	ldr	r2, [r2, #0]
 8003b04:	0795      	lsls	r5, r2, #30
 8003b06:	d530      	bpl.n	8003b6a <HAL_RCC_OscConfig+0x1f6>
 8003b08:	68e2      	ldr	r2, [r4, #12]
 8003b0a:	2a01      	cmp	r2, #1
 8003b0c:	d02d      	beq.n	8003b6a <HAL_RCC_OscConfig+0x1f6>
        return HAL_ERROR;
 8003b0e:	2001      	movs	r0, #1
}
 8003b10:	b002      	add	sp, #8
 8003b12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8003b16:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8003b18:	f023 0301 	bic.w	r3, r3, #1
 8003b1c:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8003b1e:	f7ff fae9 	bl	80030f4 <HAL_GetTick>
 8003b22:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003b24:	e004      	b.n	8003b30 <HAL_RCC_OscConfig+0x1bc>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003b26:	f7ff fae5 	bl	80030f4 <HAL_GetTick>
 8003b2a:	1b80      	subs	r0, r0, r6
 8003b2c:	2802      	cmp	r0, #2
 8003b2e:	d838      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003b30:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8003b32:	079f      	lsls	r7, r3, #30
 8003b34:	d4f7      	bmi.n	8003b26 <HAL_RCC_OscConfig+0x1b2>
 8003b36:	e7bd      	b.n	8003ab4 <HAL_RCC_OscConfig+0x140>
      __HAL_RCC_PWR_CLK_ENABLE();
 8003b38:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 8003b3a:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8003b3c:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003b40:	641a      	str	r2, [r3, #64]	; 0x40
 8003b42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003b44:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003b48:	9301      	str	r3, [sp, #4]
 8003b4a:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8003b4c:	e785      	b.n	8003a5a <HAL_RCC_OscConfig+0xe6>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8003b4e:	684a      	ldr	r2, [r1, #4]
 8003b50:	0250      	lsls	r0, r2, #9
 8003b52:	f57f af26 	bpl.w	80039a2 <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003b56:	4a27      	ldr	r2, [pc, #156]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003b58:	6812      	ldr	r2, [r2, #0]
 8003b5a:	0391      	lsls	r1, r2, #14
 8003b5c:	f57f af4a 	bpl.w	80039f4 <HAL_RCC_OscConfig+0x80>
 8003b60:	6862      	ldr	r2, [r4, #4]
 8003b62:	2a00      	cmp	r2, #0
 8003b64:	f47f af46 	bne.w	80039f4 <HAL_RCC_OscConfig+0x80>
 8003b68:	e7d1      	b.n	8003b0e <HAL_RCC_OscConfig+0x19a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003b6a:	4922      	ldr	r1, [pc, #136]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003b6c:	6920      	ldr	r0, [r4, #16]
 8003b6e:	680a      	ldr	r2, [r1, #0]
 8003b70:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8003b74:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8003b78:	600a      	str	r2, [r1, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003b7a:	071a      	lsls	r2, r3, #28
 8003b7c:	f57f af66 	bpl.w	8003a4c <HAL_RCC_OscConfig+0xd8>
 8003b80:	e784      	b.n	8003a8c <HAL_RCC_OscConfig+0x118>
      PWR->CR1 |= PWR_CR1_DBP;
 8003b82:	6833      	ldr	r3, [r6, #0]
 8003b84:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003b88:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8003b8a:	f7ff fab3 	bl	80030f4 <HAL_GetTick>
 8003b8e:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8003b90:	6833      	ldr	r3, [r6, #0]
 8003b92:	05da      	lsls	r2, r3, #23
 8003b94:	f53f af66 	bmi.w	8003a64 <HAL_RCC_OscConfig+0xf0>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003b98:	f7ff faac 	bl	80030f4 <HAL_GetTick>
 8003b9c:	1bc0      	subs	r0, r0, r7
 8003b9e:	2864      	cmp	r0, #100	; 0x64
 8003ba0:	d9f6      	bls.n	8003b90 <HAL_RCC_OscConfig+0x21c>
            return HAL_TIMEOUT;
 8003ba2:	2003      	movs	r0, #3
}
 8003ba4:	b002      	add	sp, #8
 8003ba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003baa:	4d12      	ldr	r5, [pc, #72]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
 8003bac:	682b      	ldr	r3, [r5, #0]
 8003bae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003bb2:	602b      	str	r3, [r5, #0]
 8003bb4:	682b      	ldr	r3, [r5, #0]
 8003bb6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003bba:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8003bbc:	f7ff fa9a 	bl	80030f4 <HAL_GetTick>
 8003bc0:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003bc2:	e004      	b.n	8003bce <HAL_RCC_OscConfig+0x25a>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8003bc4:	f7ff fa96 	bl	80030f4 <HAL_GetTick>
 8003bc8:	1b80      	subs	r0, r0, r6
 8003bca:	2864      	cmp	r0, #100	; 0x64
 8003bcc:	d8e9      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8003bce:	682b      	ldr	r3, [r5, #0]
 8003bd0:	039b      	lsls	r3, r3, #14
 8003bd2:	d4f7      	bmi.n	8003bc4 <HAL_RCC_OscConfig+0x250>
 8003bd4:	e70d      	b.n	80039f2 <HAL_RCC_OscConfig+0x7e>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003bd6:	4e07      	ldr	r6, [pc, #28]	; (8003bf4 <HAL_RCC_OscConfig+0x280>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003bd8:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003bdc:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8003bde:	f023 0301 	bic.w	r3, r3, #1
 8003be2:	6733      	str	r3, [r6, #112]	; 0x70
 8003be4:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8003be6:	f023 0304 	bic.w	r3, r3, #4
 8003bea:	6733      	str	r3, [r6, #112]	; 0x70
      tickstart = HAL_GetTick();
 8003bec:	f7ff fa82 	bl	80030f4 <HAL_GetTick>
 8003bf0:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003bf2:	e008      	b.n	8003c06 <HAL_RCC_OscConfig+0x292>
 8003bf4:	40023800 	.word	0x40023800
 8003bf8:	40007000 	.word	0x40007000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003bfc:	f7ff fa7a 	bl	80030f4 <HAL_GetTick>
 8003c00:	1bc0      	subs	r0, r0, r7
 8003c02:	4540      	cmp	r0, r8
 8003c04:	d8cd      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003c06:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8003c08:	0798      	lsls	r0, r3, #30
 8003c0a:	d4f7      	bmi.n	8003bfc <HAL_RCC_OscConfig+0x288>
    if (pwrclkchanged == SET)
 8003c0c:	2d00      	cmp	r5, #0
 8003c0e:	f43f af54 	beq.w	8003aba <HAL_RCC_OscConfig+0x146>
      __HAL_RCC_PWR_CLK_DISABLE();
 8003c12:	4a4e      	ldr	r2, [pc, #312]	; (8003d4c <HAL_RCC_OscConfig+0x3d8>)
 8003c14:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8003c16:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003c1a:	6413      	str	r3, [r2, #64]	; 0x40
 8003c1c:	e74d      	b.n	8003aba <HAL_RCC_OscConfig+0x146>
        __HAL_RCC_HSI_DISABLE();
 8003c1e:	682b      	ldr	r3, [r5, #0]
 8003c20:	f023 0301 	bic.w	r3, r3, #1
 8003c24:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8003c26:	f7ff fa65 	bl	80030f4 <HAL_GetTick>
 8003c2a:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003c2c:	e004      	b.n	8003c38 <HAL_RCC_OscConfig+0x2c4>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8003c2e:	f7ff fa61 	bl	80030f4 <HAL_GetTick>
 8003c32:	1b80      	subs	r0, r0, r6
 8003c34:	2802      	cmp	r0, #2
 8003c36:	d8b4      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003c38:	682b      	ldr	r3, [r5, #0]
 8003c3a:	0799      	lsls	r1, r3, #30
 8003c3c:	d4f7      	bmi.n	8003c2e <HAL_RCC_OscConfig+0x2ba>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003c3e:	6823      	ldr	r3, [r4, #0]
 8003c40:	e702      	b.n	8003a48 <HAL_RCC_OscConfig+0xd4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003c42:	4a42      	ldr	r2, [pc, #264]	; (8003d4c <HAL_RCC_OscConfig+0x3d8>)
 8003c44:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8003c46:	f043 0301 	orr.w	r3, r3, #1
 8003c4a:	6713      	str	r3, [r2, #112]	; 0x70
      tickstart = HAL_GetTick();
 8003c4c:	f7ff fa52 	bl	80030f4 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003c50:	4f3e      	ldr	r7, [pc, #248]	; (8003d4c <HAL_RCC_OscConfig+0x3d8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003c52:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8003c56:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003c58:	e004      	b.n	8003c64 <HAL_RCC_OscConfig+0x2f0>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003c5a:	f7ff fa4b 	bl	80030f4 <HAL_GetTick>
 8003c5e:	1b80      	subs	r0, r0, r6
 8003c60:	4540      	cmp	r0, r8
 8003c62:	d89e      	bhi.n	8003ba2 <HAL_RCC_OscConfig+0x22e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003c64:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8003c66:	079b      	lsls	r3, r3, #30
 8003c68:	d5f7      	bpl.n	8003c5a <HAL_RCC_OscConfig+0x2e6>
    if (pwrclkchanged == SET)
 8003c6a:	2d00      	cmp	r5, #0
 8003c6c:	f43f af25 	beq.w	8003aba <HAL_RCC_OscConfig+0x146>
 8003c70:	e7cf      	b.n	8003c12 <HAL_RCC_OscConfig+0x29e>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8003c72:	2801      	cmp	r0, #1
      pll_config = RCC->PLLCFGR;
 8003c74:	686a      	ldr	r2, [r5, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8003c76:	f43f af3d 	beq.w	8003af4 <HAL_RCC_OscConfig+0x180>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003c7a:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8003c7e:	69e1      	ldr	r1, [r4, #28]
 8003c80:	428b      	cmp	r3, r1
 8003c82:	f47f af44 	bne.w	8003b0e <HAL_RCC_OscConfig+0x19a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8003c86:	f002 033f 	and.w	r3, r2, #63	; 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003c8a:	6a21      	ldr	r1, [r4, #32]
 8003c8c:	428b      	cmp	r3, r1
 8003c8e:	f47f af3e 	bne.w	8003b0e <HAL_RCC_OscConfig+0x19a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8003c92:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8003c96:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003c98:	4013      	ands	r3, r2
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8003c9a:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 8003c9e:	f47f af36 	bne.w	8003b0e <HAL_RCC_OscConfig+0x19a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 8003ca2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003ca4:	f402 3140 	and.w	r1, r2, #196608	; 0x30000
 8003ca8:	085b      	lsrs	r3, r3, #1
 8003caa:	3b01      	subs	r3, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8003cac:	ebb1 4f03 	cmp.w	r1, r3, lsl #16
 8003cb0:	f47f af2d 	bne.w	8003b0e <HAL_RCC_OscConfig+0x19a>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8003cb4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003cb6:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 8003cba:	ebb2 6f03 	cmp.w	r2, r3, lsl #24
  return HAL_OK;
 8003cbe:	bf14      	ite	ne
 8003cc0:	2001      	movne	r0, #1
 8003cc2:	2000      	moveq	r0, #0
 8003cc4:	e716      	b.n	8003af4 <HAL_RCC_OscConfig+0x180>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003cc6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8003cca:	601a      	str	r2, [r3, #0]
 8003ccc:	681a      	ldr	r2, [r3, #0]
 8003cce:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003cd2:	601a      	str	r2, [r3, #0]
 8003cd4:	e67f      	b.n	80039d6 <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003cd6:	f042 0204 	orr.w	r2, r2, #4
 8003cda:	671a      	str	r2, [r3, #112]	; 0x70
 8003cdc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8003cde:	f042 0201 	orr.w	r2, r2, #1
 8003ce2:	671a      	str	r2, [r3, #112]	; 0x70
 8003ce4:	e7b2      	b.n	8003c4c <HAL_RCC_OscConfig+0x2d8>
    return HAL_ERROR;
 8003ce6:	2001      	movs	r0, #1
}
 8003ce8:	4770      	bx	lr
        tickstart = HAL_GetTick();
 8003cea:	f7ff fa03 	bl	80030f4 <HAL_GetTick>
 8003cee:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003cf0:	e005      	b.n	8003cfe <HAL_RCC_OscConfig+0x38a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003cf2:	f7ff f9ff 	bl	80030f4 <HAL_GetTick>
 8003cf6:	1b80      	subs	r0, r0, r6
 8003cf8:	2802      	cmp	r0, #2
 8003cfa:	f63f af52 	bhi.w	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003cfe:	682b      	ldr	r3, [r5, #0]
 8003d00:	0199      	lsls	r1, r3, #6
 8003d02:	d4f6      	bmi.n	8003cf2 <HAL_RCC_OscConfig+0x37e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8003d04:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003d06:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8003d08:	0852      	lsrs	r2, r2, #1
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003d0a:	4e10      	ldr	r6, [pc, #64]	; (8003d4c <HAL_RCC_OscConfig+0x3d8>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8003d0c:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 8003d10:	3a01      	subs	r2, #1
 8003d12:	430b      	orrs	r3, r1
 8003d14:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8003d16:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8003d1a:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8003d1e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8003d22:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003d26:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8003d28:	682b      	ldr	r3, [r5, #0]
 8003d2a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003d2e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8003d30:	f7ff f9e0 	bl	80030f4 <HAL_GetTick>
 8003d34:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003d36:	e005      	b.n	8003d44 <HAL_RCC_OscConfig+0x3d0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003d38:	f7ff f9dc 	bl	80030f4 <HAL_GetTick>
 8003d3c:	1b00      	subs	r0, r0, r4
 8003d3e:	2802      	cmp	r0, #2
 8003d40:	f63f af2f 	bhi.w	8003ba2 <HAL_RCC_OscConfig+0x22e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003d44:	6833      	ldr	r3, [r6, #0]
 8003d46:	019a      	lsls	r2, r3, #6
 8003d48:	d5f6      	bpl.n	8003d38 <HAL_RCC_OscConfig+0x3c4>
 8003d4a:	e6d2      	b.n	8003af2 <HAL_RCC_OscConfig+0x17e>
 8003d4c:	40023800 	.word	0x40023800

08003d50 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8003d50:	2800      	cmp	r0, #0
 8003d52:	f000 80a9 	beq.w	8003ea8 <HAL_RCC_ClockConfig+0x158>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8003d56:	4a58      	ldr	r2, [pc, #352]	; (8003eb8 <HAL_RCC_ClockConfig+0x168>)
 8003d58:	6813      	ldr	r3, [r2, #0]
 8003d5a:	f003 030f 	and.w	r3, r3, #15
 8003d5e:	428b      	cmp	r3, r1
{
 8003d60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003d64:	4604      	mov	r4, r0
 8003d66:	460d      	mov	r5, r1
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8003d68:	d20c      	bcs.n	8003d84 <HAL_RCC_ClockConfig+0x34>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003d6a:	6813      	ldr	r3, [r2, #0]
 8003d6c:	f023 030f 	bic.w	r3, r3, #15
 8003d70:	430b      	orrs	r3, r1
 8003d72:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003d74:	6813      	ldr	r3, [r2, #0]
 8003d76:	f003 030f 	and.w	r3, r3, #15
 8003d7a:	428b      	cmp	r3, r1
 8003d7c:	d002      	beq.n	8003d84 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8003d7e:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);

  return HAL_OK;
}
 8003d80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003d84:	6823      	ldr	r3, [r4, #0]
 8003d86:	0798      	lsls	r0, r3, #30
 8003d88:	d514      	bpl.n	8003db4 <HAL_RCC_ClockConfig+0x64>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003d8a:	0759      	lsls	r1, r3, #29
 8003d8c:	d504      	bpl.n	8003d98 <HAL_RCC_ClockConfig+0x48>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8003d8e:	494b      	ldr	r1, [pc, #300]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003d90:	688a      	ldr	r2, [r1, #8]
 8003d92:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 8003d96:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003d98:	071a      	lsls	r2, r3, #28
 8003d9a:	d504      	bpl.n	8003da6 <HAL_RCC_ClockConfig+0x56>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8003d9c:	4947      	ldr	r1, [pc, #284]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003d9e:	688a      	ldr	r2, [r1, #8]
 8003da0:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 8003da4:	608a      	str	r2, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003da6:	4945      	ldr	r1, [pc, #276]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003da8:	68a0      	ldr	r0, [r4, #8]
 8003daa:	688a      	ldr	r2, [r1, #8]
 8003dac:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8003db0:	4302      	orrs	r2, r0
 8003db2:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003db4:	07df      	lsls	r7, r3, #31
 8003db6:	d520      	bpl.n	8003dfa <HAL_RCC_ClockConfig+0xaa>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003db8:	6862      	ldr	r2, [r4, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003dba:	4b40      	ldr	r3, [pc, #256]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003dbc:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003dbe:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003dc0:	d074      	beq.n	8003eac <HAL_RCC_ClockConfig+0x15c>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8003dc2:	2a02      	cmp	r2, #2
 8003dc4:	d06d      	beq.n	8003ea2 <HAL_RCC_ClockConfig+0x152>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003dc6:	0799      	lsls	r1, r3, #30
 8003dc8:	d5d9      	bpl.n	8003d7e <HAL_RCC_ClockConfig+0x2e>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003dca:	4e3c      	ldr	r6, [pc, #240]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003dcc:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003dd0:	68b3      	ldr	r3, [r6, #8]
 8003dd2:	f023 0303 	bic.w	r3, r3, #3
 8003dd6:	4313      	orrs	r3, r2
 8003dd8:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 8003dda:	f7ff f98b 	bl	80030f4 <HAL_GetTick>
 8003dde:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003de0:	e004      	b.n	8003dec <HAL_RCC_ClockConfig+0x9c>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003de2:	f7ff f987 	bl	80030f4 <HAL_GetTick>
 8003de6:	1bc0      	subs	r0, r0, r7
 8003de8:	4540      	cmp	r0, r8
 8003dea:	d862      	bhi.n	8003eb2 <HAL_RCC_ClockConfig+0x162>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003dec:	68b3      	ldr	r3, [r6, #8]
 8003dee:	6862      	ldr	r2, [r4, #4]
 8003df0:	f003 030c 	and.w	r3, r3, #12
 8003df4:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8003df8:	d1f3      	bne.n	8003de2 <HAL_RCC_ClockConfig+0x92>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8003dfa:	4a2f      	ldr	r2, [pc, #188]	; (8003eb8 <HAL_RCC_ClockConfig+0x168>)
 8003dfc:	6813      	ldr	r3, [r2, #0]
 8003dfe:	f003 030f 	and.w	r3, r3, #15
 8003e02:	42ab      	cmp	r3, r5
 8003e04:	d909      	bls.n	8003e1a <HAL_RCC_ClockConfig+0xca>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003e06:	6813      	ldr	r3, [r2, #0]
 8003e08:	f023 030f 	bic.w	r3, r3, #15
 8003e0c:	432b      	orrs	r3, r5
 8003e0e:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8003e10:	6813      	ldr	r3, [r2, #0]
 8003e12:	f003 030f 	and.w	r3, r3, #15
 8003e16:	42ab      	cmp	r3, r5
 8003e18:	d1b1      	bne.n	8003d7e <HAL_RCC_ClockConfig+0x2e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003e1a:	6823      	ldr	r3, [r4, #0]
 8003e1c:	075a      	lsls	r2, r3, #29
 8003e1e:	d506      	bpl.n	8003e2e <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003e20:	4926      	ldr	r1, [pc, #152]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003e22:	68e0      	ldr	r0, [r4, #12]
 8003e24:	688a      	ldr	r2, [r1, #8]
 8003e26:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 8003e2a:	4302      	orrs	r2, r0
 8003e2c:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003e2e:	071b      	lsls	r3, r3, #28
 8003e30:	d507      	bpl.n	8003e42 <HAL_RCC_ClockConfig+0xf2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8003e32:	4a22      	ldr	r2, [pc, #136]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003e34:	6921      	ldr	r1, [r4, #16]
 8003e36:	6893      	ldr	r3, [r2, #8]
 8003e38:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8003e3c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8003e40:	6093      	str	r3, [r2, #8]
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003e42:	491e      	ldr	r1, [pc, #120]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003e44:	688b      	ldr	r3, [r1, #8]
 8003e46:	f003 030c 	and.w	r3, r3, #12
 8003e4a:	2b08      	cmp	r3, #8
 8003e4c:	d010      	beq.n	8003e70 <HAL_RCC_ClockConfig+0x120>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8003e4e:	4b1c      	ldr	r3, [pc, #112]	; (8003ec0 <HAL_RCC_ClockConfig+0x170>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8003e50:	4a1a      	ldr	r2, [pc, #104]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003e52:	4c1c      	ldr	r4, [pc, #112]	; (8003ec4 <HAL_RCC_ClockConfig+0x174>)
 8003e54:	6892      	ldr	r2, [r2, #8]
  HAL_InitTick(uwTickPrio);
 8003e56:	481c      	ldr	r0, [pc, #112]	; (8003ec8 <HAL_RCC_ClockConfig+0x178>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8003e58:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8003e5c:	491b      	ldr	r1, [pc, #108]	; (8003ecc <HAL_RCC_ClockConfig+0x17c>)
  HAL_InitTick(uwTickPrio);
 8003e5e:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8003e60:	5ca2      	ldrb	r2, [r4, r2]
 8003e62:	40d3      	lsrs	r3, r2
 8003e64:	600b      	str	r3, [r1, #0]
  HAL_InitTick(uwTickPrio);
 8003e66:	f7ff f8ff 	bl	8003068 <HAL_InitTick>
  return HAL_OK;
 8003e6a:	2000      	movs	r0, #0
}
 8003e6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003e70:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8003e72:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e74:	6849      	ldr	r1, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003e76:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8003e7a:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e7e:	4810      	ldr	r0, [pc, #64]	; (8003ec0 <HAL_RCC_ClockConfig+0x170>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e80:	f3c1 1188 	ubfx	r1, r1, #6, #9
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e84:	bf18      	it	ne
 8003e86:	2300      	movne	r3, #0
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e88:	fba1 0100 	umull	r0, r1, r1, r0
 8003e8c:	f7fd fa84 	bl	8001398 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8003e90:	4b0a      	ldr	r3, [pc, #40]	; (8003ebc <HAL_RCC_ClockConfig+0x16c>)
 8003e92:	685b      	ldr	r3, [r3, #4]
 8003e94:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8003e98:	3301      	adds	r3, #1
 8003e9a:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 8003e9c:	fbb0 f3f3 	udiv	r3, r0, r3
    {
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
 8003ea0:	e7d6      	b.n	8003e50 <HAL_RCC_ClockConfig+0x100>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003ea2:	0198      	lsls	r0, r3, #6
 8003ea4:	d491      	bmi.n	8003dca <HAL_RCC_ClockConfig+0x7a>
 8003ea6:	e76a      	b.n	8003d7e <HAL_RCC_ClockConfig+0x2e>
    return HAL_ERROR;
 8003ea8:	2001      	movs	r0, #1
}
 8003eaa:	4770      	bx	lr
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003eac:	039e      	lsls	r6, r3, #14
 8003eae:	d48c      	bmi.n	8003dca <HAL_RCC_ClockConfig+0x7a>
 8003eb0:	e765      	b.n	8003d7e <HAL_RCC_ClockConfig+0x2e>
        return HAL_TIMEOUT;
 8003eb2:	2003      	movs	r0, #3
 8003eb4:	e764      	b.n	8003d80 <HAL_RCC_ClockConfig+0x30>
 8003eb6:	bf00      	nop
 8003eb8:	40023c00 	.word	0x40023c00
 8003ebc:	40023800 	.word	0x40023800
 8003ec0:	00f42400 	.word	0x00f42400
 8003ec4:	08016ad4 	.word	0x08016ad4
 8003ec8:	20000688 	.word	0x20000688
 8003ecc:	20000680 	.word	0x20000680

08003ed0 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003ed0:	4910      	ldr	r1, [pc, #64]	; (8003f14 <HAL_RCC_GetSysClockFreq+0x44>)
{
 8003ed2:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003ed4:	688b      	ldr	r3, [r1, #8]
 8003ed6:	f003 030c 	and.w	r3, r3, #12
 8003eda:	2b08      	cmp	r3, #8
 8003edc:	d001      	beq.n	8003ee2 <HAL_RCC_GetSysClockFreq+0x12>
      sysclockfreq = HSI_VALUE;
 8003ede:	480e      	ldr	r0, [pc, #56]	; (8003f18 <HAL_RCC_GetSysClockFreq+0x48>)
}
 8003ee0:	bd08      	pop	{r3, pc}
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003ee2:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8003ee4:	684b      	ldr	r3, [r1, #4]
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003ee6:	6849      	ldr	r1, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003ee8:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8003eec:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003ef0:	4809      	ldr	r0, [pc, #36]	; (8003f18 <HAL_RCC_GetSysClockFreq+0x48>)
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003ef2:	f3c1 1188 	ubfx	r1, r1, #6, #9
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003ef6:	bf18      	it	ne
 8003ef8:	2300      	movne	r3, #0
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003efa:	fba1 0100 	umull	r0, r1, r1, r0
 8003efe:	f7fd fa4b 	bl	8001398 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8003f02:	4b04      	ldr	r3, [pc, #16]	; (8003f14 <HAL_RCC_GetSysClockFreq+0x44>)
 8003f04:	685b      	ldr	r3, [r3, #4]
 8003f06:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8003f0a:	3301      	adds	r3, #1
 8003f0c:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco / pllp;
 8003f0e:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8003f12:	bd08      	pop	{r3, pc}
 8003f14:	40023800 	.word	0x40023800
 8003f18:	00f42400 	.word	0x00f42400

08003f1c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8003f1c:	4b04      	ldr	r3, [pc, #16]	; (8003f30 <HAL_RCC_GetPCLK1Freq+0x14>)
  return SystemCoreClock;
 8003f1e:	4905      	ldr	r1, [pc, #20]	; (8003f34 <HAL_RCC_GetPCLK1Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8003f20:	689b      	ldr	r3, [r3, #8]
 8003f22:	4a05      	ldr	r2, [pc, #20]	; (8003f38 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8003f24:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8003f28:	6808      	ldr	r0, [r1, #0]
 8003f2a:	5cd3      	ldrb	r3, [r2, r3]
}
 8003f2c:	40d8      	lsrs	r0, r3
 8003f2e:	4770      	bx	lr
 8003f30:	40023800 	.word	0x40023800
 8003f34:	20000680 	.word	0x20000680
 8003f38:	08016ae4 	.word	0x08016ae4

08003f3c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8003f3c:	4b04      	ldr	r3, [pc, #16]	; (8003f50 <HAL_RCC_GetPCLK2Freq+0x14>)
  return SystemCoreClock;
 8003f3e:	4905      	ldr	r1, [pc, #20]	; (8003f54 <HAL_RCC_GetPCLK2Freq+0x18>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8003f40:	689b      	ldr	r3, [r3, #8]
 8003f42:	4a05      	ldr	r2, [pc, #20]	; (8003f58 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8003f44:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8003f48:	6808      	ldr	r0, [r1, #0]
 8003f4a:	5cd3      	ldrb	r3, [r2, r3]
}
 8003f4c:	40d8      	lsrs	r0, r3
 8003f4e:	4770      	bx	lr
 8003f50:	40023800 	.word	0x40023800
 8003f54:	20000680 	.word	0x20000680
 8003f58:	08016ae4 	.word	0x08016ae4

08003f5c <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8003f5c:	6803      	ldr	r3, [r0, #0]
{
 8003f5e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8003f62:	f013 0601 	ands.w	r6, r3, #1
{
 8003f66:	b083      	sub	sp, #12
 8003f68:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8003f6a:	d00b      	beq.n	8003f84 <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8003f6c:	4aa8      	ldr	r2, [pc, #672]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003f6e:	6891      	ldr	r1, [r2, #8]
 8003f70:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 8003f74:	6091      	str	r1, [r2, #8]
 8003f76:	6b46      	ldr	r6, [r0, #52]	; 0x34
 8003f78:	6891      	ldr	r1, [r2, #8]
 8003f7a:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8003f7c:	fab6 f686 	clz	r6, r6
 8003f80:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8003f82:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8003f84:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8003f88:	d010      	beq.n	8003fac <HAL_RCCEx_PeriphCLKConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8003f8a:	49a1      	ldr	r1, [pc, #644]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003f8c:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8003f8e:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8003f92:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8003f96:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8003f9a:	ea42 0205 	orr.w	r2, r2, r5
 8003f9e:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8003fa2:	f000 8214 	beq.w	80043ce <HAL_RCCEx_PeriphCLKConfig+0x472>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8003fa6:	fab5 f585 	clz	r5, r5
 8003faa:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8003fac:	02df      	lsls	r7, r3, #11
 8003fae:	d510      	bpl.n	8003fd2 <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8003fb0:	4897      	ldr	r0, [pc, #604]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003fb2:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8003fb4:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8003fb8:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8003fbc:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8003fc0:	ea42 0201 	orr.w	r2, r2, r1
 8003fc4:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8003fc8:	f000 8204 	beq.w	80043d4 <HAL_RCCEx_PeriphCLKConfig+0x478>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8003fcc:	2900      	cmp	r1, #0
 8003fce:	bf08      	it	eq
 8003fd0:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 8003fd2:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8003fd6:	bf18      	it	ne
 8003fd8:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8003fda:	0698      	lsls	r0, r3, #26
 8003fdc:	f100 81b2 	bmi.w	8004344 <HAL_RCCEx_PeriphCLKConfig+0x3e8>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8003fe0:	06d9      	lsls	r1, r3, #27
 8003fe2:	d50c      	bpl.n	8003ffe <HAL_RCCEx_PeriphCLKConfig+0xa2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8003fe4:	4a8a      	ldr	r2, [pc, #552]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003fe6:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8003fea:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 8003fee:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 8003ff2:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8003ff6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8003ff8:	4301      	orrs	r1, r0
 8003ffa:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8003ffe:	045a      	lsls	r2, r3, #17
 8004000:	d508      	bpl.n	8004014 <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004002:	4983      	ldr	r1, [pc, #524]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004004:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8004006:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800400a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800400e:	4302      	orrs	r2, r0
 8004010:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004014:	041f      	lsls	r7, r3, #16
 8004016:	d508      	bpl.n	800402a <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004018:	497d      	ldr	r1, [pc, #500]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800401a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800401c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8004020:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8004024:	4302      	orrs	r2, r0
 8004026:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800402a:	03d8      	lsls	r0, r3, #15
 800402c:	d508      	bpl.n	8004040 <HAL_RCCEx_PeriphCLKConfig+0xe4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800402e:	4978      	ldr	r1, [pc, #480]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004030:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8004032:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8004036:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 800403a:	4302      	orrs	r2, r0
 800403c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004040:	0399      	lsls	r1, r3, #14
 8004042:	d508      	bpl.n	8004056 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004044:	4972      	ldr	r1, [pc, #456]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004046:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8004048:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800404c:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8004050:	4302      	orrs	r2, r0
 8004052:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004056:	065a      	lsls	r2, r3, #25
 8004058:	d508      	bpl.n	800406c <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800405a:	496d      	ldr	r1, [pc, #436]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800405c:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800405e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8004062:	f022 0203 	bic.w	r2, r2, #3
 8004066:	4302      	orrs	r2, r0
 8004068:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800406c:	061f      	lsls	r7, r3, #24
 800406e:	d508      	bpl.n	8004082 <HAL_RCCEx_PeriphCLKConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8004070:	4967      	ldr	r1, [pc, #412]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004072:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8004074:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8004078:	f022 020c 	bic.w	r2, r2, #12
 800407c:	4302      	orrs	r2, r0
 800407e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8004082:	05d8      	lsls	r0, r3, #23
 8004084:	d508      	bpl.n	8004098 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8004086:	4962      	ldr	r1, [pc, #392]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004088:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800408a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800408e:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8004092:	4302      	orrs	r2, r0
 8004094:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8004098:	0599      	lsls	r1, r3, #22
 800409a:	d508      	bpl.n	80040ae <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800409c:	495c      	ldr	r1, [pc, #368]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800409e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80040a0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80040a4:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 80040a8:	4302      	orrs	r2, r0
 80040aa:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 80040ae:	055a      	lsls	r2, r3, #21
 80040b0:	d508      	bpl.n	80040c4 <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 80040b2:	4957      	ldr	r1, [pc, #348]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80040b4:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80040b6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80040ba:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 80040be:	4302      	orrs	r2, r0
 80040c0:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 80040c4:	051f      	lsls	r7, r3, #20
 80040c6:	d508      	bpl.n	80040da <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 80040c8:	4951      	ldr	r1, [pc, #324]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80040ca:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80040cc:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80040d0:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 80040d4:	4302      	orrs	r2, r0
 80040d6:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 80040da:	04d8      	lsls	r0, r3, #19
 80040dc:	d508      	bpl.n	80040f0 <HAL_RCCEx_PeriphCLKConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 80040de:	494c      	ldr	r1, [pc, #304]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80040e0:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 80040e2:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80040e6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 80040ea:	4302      	orrs	r2, r0
 80040ec:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 80040f0:	0499      	lsls	r1, r3, #18
 80040f2:	d508      	bpl.n	8004106 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 80040f4:	4946      	ldr	r1, [pc, #280]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80040f6:	6e20      	ldr	r0, [r4, #96]	; 0x60
 80040f8:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80040fc:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8004100:	4302      	orrs	r2, r0
 8004102:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8004106:	025a      	lsls	r2, r3, #9
 8004108:	d508      	bpl.n	800411c <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800410a:	4941      	ldr	r1, [pc, #260]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800410c:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800410e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8004112:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8004116:	4302      	orrs	r2, r0
 8004118:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 800411c:	029f      	lsls	r7, r3, #10
 800411e:	d50c      	bpl.n	800413a <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8004120:	493b      	ldr	r1, [pc, #236]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004122:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8004124:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 8004128:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800412c:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
 8004130:	bf08      	it	eq
 8004132:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8004134:	4302      	orrs	r2, r0
 8004136:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 800413a:	f013 0f08 	tst.w	r3, #8
 800413e:	bf18      	it	ne
 8004140:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8004142:	0358      	lsls	r0, r3, #13
 8004144:	d508      	bpl.n	8004158 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004146:	4932      	ldr	r1, [pc, #200]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004148:	6f60      	ldr	r0, [r4, #116]	; 0x74
 800414a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800414e:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 8004152:	4302      	orrs	r2, r0
 8004154:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8004158:	0219      	lsls	r1, r3, #8
 800415a:	d46a      	bmi.n	8004232 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 800415c:	2e01      	cmp	r6, #1
 800415e:	d001      	beq.n	8004164 <HAL_RCCEx_PeriphCLKConfig+0x208>
 8004160:	019a      	lsls	r2, r3, #6
 8004162:	d560      	bpl.n	8004226 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 8004164:	4e2a      	ldr	r6, [pc, #168]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004166:	6833      	ldr	r3, [r6, #0]
 8004168:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800416c:	6033      	str	r3, [r6, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800416e:	f7fe ffc1 	bl	80030f4 <HAL_GetTick>
 8004172:	4607      	mov	r7, r0

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004174:	e005      	b.n	8004182 <HAL_RCCEx_PeriphCLKConfig+0x226>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004176:	f7fe ffbd 	bl	80030f4 <HAL_GetTick>
 800417a:	1bc3      	subs	r3, r0, r7
 800417c:	2b64      	cmp	r3, #100	; 0x64
 800417e:	f200 80dd 	bhi.w	800433c <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004182:	6833      	ldr	r3, [r6, #0]
 8004184:	011b      	lsls	r3, r3, #4
 8004186:	d4f6      	bmi.n	8004176 <HAL_RCCEx_PeriphCLKConfig+0x21a>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8004188:	6823      	ldr	r3, [r4, #0]
 800418a:	07df      	lsls	r7, r3, #31
 800418c:	d512      	bpl.n	80041b4 <HAL_RCCEx_PeriphCLKConfig+0x258>
 800418e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004190:	b982      	cbnz	r2, 80041b4 <HAL_RCCEx_PeriphCLKConfig+0x258>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8004192:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8004196:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 800419a:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800419e:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 80041a2:	430a      	orrs	r2, r1
 80041a4:	6861      	ldr	r1, [r4, #4]
 80041a6:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 80041aa:	68a1      	ldr	r1, [r4, #8]
 80041ac:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 80041b0:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 80041b4:	031e      	lsls	r6, r3, #12
 80041b6:	d504      	bpl.n	80041c2 <HAL_RCCEx_PeriphCLKConfig+0x266>
 80041b8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80041ba:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80041be:	f000 811a 	beq.w	80043f6 <HAL_RCCEx_PeriphCLKConfig+0x49a>
 80041c2:	02d8      	lsls	r0, r3, #11
 80041c4:	d504      	bpl.n	80041d0 <HAL_RCCEx_PeriphCLKConfig+0x274>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 80041c6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80041c8:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 80041cc:	f000 8113 	beq.w	80043f6 <HAL_RCCEx_PeriphCLKConfig+0x49a>
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 80041d0:	01d9      	lsls	r1, r3, #7
 80041d2:	d511      	bpl.n	80041f8 <HAL_RCCEx_PeriphCLKConfig+0x29c>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 80041d4:	490e      	ldr	r1, [pc, #56]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 80041d6:	f8d1 2084 	ldr.w	r2, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80041da:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 80041de:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 80041e2:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 80041e6:	4302      	orrs	r2, r0
 80041e8:	6860      	ldr	r0, [r4, #4]
 80041ea:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80041ee:	6920      	ldr	r0, [r4, #16]
 80041f0:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80041f4:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80041f8:	019a      	lsls	r2, r3, #6
 80041fa:	f100 80ed 	bmi.w	80043d8 <HAL_RCCEx_PeriphCLKConfig+0x47c>
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 80041fe:	4e04      	ldr	r6, [pc, #16]	; (8004210 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8004200:	6833      	ldr	r3, [r6, #0]
 8004202:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8004206:	6033      	str	r3, [r6, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004208:	f7fe ff74 	bl	80030f4 <HAL_GetTick>
 800420c:	4607      	mov	r7, r0

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800420e:	e007      	b.n	8004220 <HAL_RCCEx_PeriphCLKConfig+0x2c4>
 8004210:	40023800 	.word	0x40023800
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8004214:	f7fe ff6e 	bl	80030f4 <HAL_GetTick>
 8004218:	1bc0      	subs	r0, r0, r7
 800421a:	2864      	cmp	r0, #100	; 0x64
 800421c:	f200 808e 	bhi.w	800433c <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8004220:	6833      	ldr	r3, [r6, #0]
 8004222:	011b      	lsls	r3, r3, #4
 8004224:	d5f6      	bpl.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8004226:	2d01      	cmp	r5, #1
 8004228:	d00e      	beq.n	8004248 <HAL_RCCEx_PeriphCLKConfig+0x2ec>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 800422a:	2000      	movs	r0, #0
}
 800422c:	b003      	add	sp, #12
 800422e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8004232:	4991      	ldr	r1, [pc, #580]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8004234:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8004238:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800423c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8004240:	4302      	orrs	r2, r0
 8004242:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
 8004246:	e789      	b.n	800415c <HAL_RCCEx_PeriphCLKConfig+0x200>
    __HAL_RCC_PLLSAI_DISABLE();
 8004248:	4d8b      	ldr	r5, [pc, #556]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 800424a:	682b      	ldr	r3, [r5, #0]
 800424c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004250:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 8004252:	f7fe ff4f 	bl	80030f4 <HAL_GetTick>
 8004256:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8004258:	e004      	b.n	8004264 <HAL_RCCEx_PeriphCLKConfig+0x308>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800425a:	f7fe ff4b 	bl	80030f4 <HAL_GetTick>
 800425e:	1b80      	subs	r0, r0, r6
 8004260:	2864      	cmp	r0, #100	; 0x64
 8004262:	d86b      	bhi.n	800433c <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8004264:	682b      	ldr	r3, [r5, #0]
 8004266:	009f      	lsls	r7, r3, #2
 8004268:	d4f7      	bmi.n	800425a <HAL_RCCEx_PeriphCLKConfig+0x2fe>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800426a:	6823      	ldr	r3, [r4, #0]
 800426c:	031d      	lsls	r5, r3, #12
 800426e:	f140 80fb 	bpl.w	8004468 <HAL_RCCEx_PeriphCLKConfig+0x50c>
 8004272:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8004274:	2a00      	cmp	r2, #0
 8004276:	f040 80f7 	bne.w	8004468 <HAL_RCCEx_PeriphCLKConfig+0x50c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 800427a:	497f      	ldr	r1, [pc, #508]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 800427c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8004280:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8004284:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8004288:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 800428c:	4302      	orrs	r2, r0
 800428e:	6960      	ldr	r0, [r4, #20]
 8004290:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8004294:	69a0      	ldr	r0, [r4, #24]
 8004296:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 800429a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 800429e:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 80042a2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80042a4:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 80042a8:	3801      	subs	r0, #1
 80042aa:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80042ae:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 80042b2:	0299      	lsls	r1, r3, #10
 80042b4:	d515      	bpl.n	80042e2 <HAL_RCCEx_PeriphCLKConfig+0x386>
 80042b6:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80042b8:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 80042bc:	d111      	bne.n	80042e2 <HAL_RCCEx_PeriphCLKConfig+0x386>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80042be:	496e      	ldr	r1, [pc, #440]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80042c0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 80042c4:	f8d1 0088 	ldr.w	r0, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80042c8:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 80042cc:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 80042d0:	4302      	orrs	r2, r0
 80042d2:	6960      	ldr	r0, [r4, #20]
 80042d4:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80042d8:	6a20      	ldr	r0, [r4, #32]
 80042da:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80042de:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 80042e2:	071a      	lsls	r2, r3, #28
 80042e4:	d519      	bpl.n	800431a <HAL_RCCEx_PeriphCLKConfig+0x3be>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80042e6:	4a64      	ldr	r2, [pc, #400]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80042e8:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80042ea:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80042ee:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80042f2:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 80042f6:	69e0      	ldr	r0, [r4, #28]
 80042f8:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 80042fc:	430b      	orrs	r3, r1
 80042fe:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8004302:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8004306:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 800430a:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 800430e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8004310:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8004314:	430b      	orrs	r3, r1
 8004316:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 800431a:	4c57      	ldr	r4, [pc, #348]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 800431c:	6823      	ldr	r3, [r4, #0]
 800431e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004322:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8004324:	f7fe fee6 	bl	80030f4 <HAL_GetTick>
 8004328:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800432a:	6823      	ldr	r3, [r4, #0]
 800432c:	009b      	lsls	r3, r3, #2
 800432e:	f53f af7c 	bmi.w	800422a <HAL_RCCEx_PeriphCLKConfig+0x2ce>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8004332:	f7fe fedf 	bl	80030f4 <HAL_GetTick>
 8004336:	1b40      	subs	r0, r0, r5
 8004338:	2864      	cmp	r0, #100	; 0x64
 800433a:	d9f6      	bls.n	800432a <HAL_RCCEx_PeriphCLKConfig+0x3ce>
        return HAL_TIMEOUT;
 800433c:	2003      	movs	r0, #3
}
 800433e:	b003      	add	sp, #12
 8004340:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8004344:	4b4c      	ldr	r3, [pc, #304]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
    PWR->CR1 |= PWR_CR1_DBP;
 8004346:	4f4d      	ldr	r7, [pc, #308]	; (800447c <HAL_RCCEx_PeriphCLKConfig+0x520>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8004348:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800434a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800434e:	641a      	str	r2, [r3, #64]	; 0x40
 8004350:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004352:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004356:	9301      	str	r3, [sp, #4]
 8004358:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 800435a:	683b      	ldr	r3, [r7, #0]
 800435c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004360:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8004362:	f7fe fec7 	bl	80030f4 <HAL_GetTick>
 8004366:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004368:	e005      	b.n	8004376 <HAL_RCCEx_PeriphCLKConfig+0x41a>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800436a:	f7fe fec3 	bl	80030f4 <HAL_GetTick>
 800436e:	eba0 0008 	sub.w	r0, r0, r8
 8004372:	2864      	cmp	r0, #100	; 0x64
 8004374:	d8e2      	bhi.n	800433c <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004376:	683b      	ldr	r3, [r7, #0]
 8004378:	05d9      	lsls	r1, r3, #23
 800437a:	d5f6      	bpl.n	800436a <HAL_RCCEx_PeriphCLKConfig+0x40e>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800437c:	4f3e      	ldr	r7, [pc, #248]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800437e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004380:	6f3a      	ldr	r2, [r7, #112]	; 0x70
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004382:	f403 7140 	and.w	r1, r3, #768	; 0x300
 8004386:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 800438a:	d010      	beq.n	80043ae <HAL_RCCEx_PeriphCLKConfig+0x452>
 800438c:	4291      	cmp	r1, r2
 800438e:	d00e      	beq.n	80043ae <HAL_RCCEx_PeriphCLKConfig+0x452>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004390:	6f3a      	ldr	r2, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8004392:	6f38      	ldr	r0, [r7, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004394:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8004398:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 800439c:	6738      	str	r0, [r7, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 800439e:	6f38      	ldr	r0, [r7, #112]	; 0x70
 80043a0:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 80043a4:	6738      	str	r0, [r7, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 80043a6:	673a      	str	r2, [r7, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80043a8:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80043aa:	07d2      	lsls	r2, r2, #31
 80043ac:	d448      	bmi.n	8004440 <HAL_RCCEx_PeriphCLKConfig+0x4e4>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80043ae:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 80043b2:	d03c      	beq.n	800442e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 80043b4:	4930      	ldr	r1, [pc, #192]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80043b6:	688a      	ldr	r2, [r1, #8]
 80043b8:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80043bc:	608a      	str	r2, [r1, #8]
 80043be:	4a2e      	ldr	r2, [pc, #184]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80043c0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80043c4:	6f11      	ldr	r1, [r2, #112]	; 0x70
 80043c6:	430b      	orrs	r3, r1
 80043c8:	6713      	str	r3, [r2, #112]	; 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80043ca:	6823      	ldr	r3, [r4, #0]
 80043cc:	e608      	b.n	8003fe0 <HAL_RCCEx_PeriphCLKConfig+0x84>
  uint32_t pllsaiused = 0;
 80043ce:	2500      	movs	r5, #0
      plli2sused = 1;
 80043d0:	2601      	movs	r6, #1
 80043d2:	e5eb      	b.n	8003fac <HAL_RCCEx_PeriphCLKConfig+0x50>
      plli2sused = 1;
 80043d4:	2601      	movs	r6, #1
 80043d6:	e5fc      	b.n	8003fd2 <HAL_RCCEx_PeriphCLKConfig+0x76>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80043d8:	6923      	ldr	r3, [r4, #16]
 80043da:	6861      	ldr	r1, [r4, #4]
 80043dc:	041b      	lsls	r3, r3, #16
 80043de:	68e2      	ldr	r2, [r4, #12]
 80043e0:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 80043e4:	68a1      	ldr	r1, [r4, #8]
 80043e6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80043ea:	4a23      	ldr	r2, [pc, #140]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80043ec:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 80043f0:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 80043f4:	e703      	b.n	80041fe <HAL_RCCEx_PeriphCLKConfig+0x2a2>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 80043f6:	4920      	ldr	r1, [pc, #128]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 80043f8:	f8d1 2084 	ldr.w	r2, [r1, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80043fc:	f8d1 0084 	ldr.w	r0, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8004400:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8004404:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
 8004408:	4302      	orrs	r2, r0
 800440a:	6860      	ldr	r0, [r4, #4]
 800440c:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8004410:	68e0      	ldr	r0, [r4, #12]
 8004412:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8004416:	f8c1 2084 	str.w	r2, [r1, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 800441a:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
 800441e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004420:	f020 001f 	bic.w	r0, r0, #31
 8004424:	3a01      	subs	r2, #1
 8004426:	4302      	orrs	r2, r0
 8004428:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
 800442c:	e6d0      	b.n	80041d0 <HAL_RCCEx_PeriphCLKConfig+0x274>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800442e:	4812      	ldr	r0, [pc, #72]	; (8004478 <HAL_RCCEx_PeriphCLKConfig+0x51c>)
 8004430:	4913      	ldr	r1, [pc, #76]	; (8004480 <HAL_RCCEx_PeriphCLKConfig+0x524>)
 8004432:	6882      	ldr	r2, [r0, #8]
 8004434:	4019      	ands	r1, r3
 8004436:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 800443a:	430a      	orrs	r2, r1
 800443c:	6082      	str	r2, [r0, #8]
 800443e:	e7be      	b.n	80043be <HAL_RCCEx_PeriphCLKConfig+0x462>
        tickstart = HAL_GetTick();
 8004440:	f7fe fe58 	bl	80030f4 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004444:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8004448:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800444a:	e006      	b.n	800445a <HAL_RCCEx_PeriphCLKConfig+0x4fe>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800444c:	f7fe fe52 	bl	80030f4 <HAL_GetTick>
 8004450:	eba0 0008 	sub.w	r0, r0, r8
 8004454:	4548      	cmp	r0, r9
 8004456:	f63f af71 	bhi.w	800433c <HAL_RCCEx_PeriphCLKConfig+0x3e0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800445a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800445c:	0798      	lsls	r0, r3, #30
 800445e:	d5f5      	bpl.n	800444c <HAL_RCCEx_PeriphCLKConfig+0x4f0>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004460:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004462:	f403 7140 	and.w	r1, r3, #768	; 0x300
 8004466:	e7a2      	b.n	80043ae <HAL_RCCEx_PeriphCLKConfig+0x452>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8004468:	02d8      	lsls	r0, r3, #11
 800446a:	f57f af22 	bpl.w	80042b2 <HAL_RCCEx_PeriphCLKConfig+0x356>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 800446e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8004470:	2a00      	cmp	r2, #0
 8004472:	f47f af1e 	bne.w	80042b2 <HAL_RCCEx_PeriphCLKConfig+0x356>
 8004476:	e700      	b.n	800427a <HAL_RCCEx_PeriphCLKConfig+0x31e>
 8004478:	40023800 	.word	0x40023800
 800447c:	40007000 	.word	0x40007000
 8004480:	0ffffcff 	.word	0x0ffffcff

08004484 <HAL_RCCEx_GetPeriphCLKFreq>:
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8004484:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8004488:	d010      	beq.n	80044ac <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        break;
      }
    }
  }

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
 800448a:	f5b0 1f80 	cmp.w	r0, #1048576	; 0x100000
 800448e:	d10b      	bne.n	80044a8 <HAL_RCCEx_GetPeriphCLKFreq+0x24>
  {
    saiclocksource = RCC->DCKCFGR1;
 8004490:	4a32      	ldr	r2, [pc, #200]	; (800455c <HAL_RCCEx_GetPeriphCLKFreq+0xd8>)
 8004492:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
 8004496:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
    switch (saiclocksource)
 800449a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800449e:	d054      	beq.n	800454a <HAL_RCCEx_GetPeriphCLKFreq+0xc6>
 80044a0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80044a4:	d02b      	beq.n	80044fe <HAL_RCCEx_GetPeriphCLKFreq+0x7a>
 80044a6:	b363      	cbz	r3, 8004502 <HAL_RCCEx_GetPeriphCLKFreq+0x7e>
 80044a8:	2000      	movs	r0, #0
      }
    }
  }

  return frequency;
}
 80044aa:	4770      	bx	lr
    saiclocksource = RCC->DCKCFGR1;
 80044ac:	4a2b      	ldr	r2, [pc, #172]	; (800455c <HAL_RCCEx_GetPeriphCLKFreq+0xd8>)
 80044ae:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
 80044b2:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
    switch (saiclocksource)
 80044b6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80044ba:	d02a      	beq.n	8004512 <HAL_RCCEx_GetPeriphCLKFreq+0x8e>
 80044bc:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 80044c0:	d01d      	beq.n	80044fe <HAL_RCCEx_GetPeriphCLKFreq+0x7a>
 80044c2:	2b00      	cmp	r3, #0
 80044c4:	d1f0      	bne.n	80044a8 <HAL_RCCEx_GetPeriphCLKFreq+0x24>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 80044c6:	6853      	ldr	r3, [r2, #4]
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 80044c8:	6851      	ldr	r1, [r2, #4]
 80044ca:	4825      	ldr	r0, [pc, #148]	; (8004560 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>)
 80044cc:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 80044d0:	fbb0 f1f1 	udiv	r1, r0, r1
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80044d4:	4b21      	ldr	r3, [pc, #132]	; (800455c <HAL_RCCEx_GetPeriphCLKFreq+0xd8>)
 80044d6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80044da:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80044de:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80044e2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80044e6:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80044ea:	f3c3 2304 	ubfx	r3, r3, #8, #5
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80044ee:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80044f2:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80044f4:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 80044f8:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 80044fc:	4770      	bx	lr
        frequency = EXTERNAL_CLOCK_VALUE;
 80044fe:	4819      	ldr	r0, [pc, #100]	; (8004564 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 8004500:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8004502:	6853      	ldr	r3, [r2, #4]
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004504:	6851      	ldr	r1, [r2, #4]
 8004506:	4816      	ldr	r0, [pc, #88]	; (8004560 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>)
 8004508:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 800450c:	fbb0 f1f1 	udiv	r1, r0, r1
 8004510:	e7e0      	b.n	80044d4 <HAL_RCCEx_GetPeriphCLKFreq+0x50>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8004512:	6853      	ldr	r3, [r2, #4]
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8004514:	6851      	ldr	r1, [r2, #4]
 8004516:	4812      	ldr	r0, [pc, #72]	; (8004560 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>)
 8004518:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 800451c:	fbb0 f1f1 	udiv	r1, r0, r1
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8004520:	4b0e      	ldr	r3, [pc, #56]	; (800455c <HAL_RCCEx_GetPeriphCLKFreq+0xd8>)
 8004522:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8004526:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 800452a:	f3c2 6203 	ubfx	r2, r2, #24, #4
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 800452e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8004532:	f3c0 1088 	ubfx	r0, r0, #6, #9
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 8004536:	f003 031f 	and.w	r3, r3, #31
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 800453a:	fb01 f000 	mul.w	r0, r1, r0
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 800453e:	3301      	adds	r3, #1
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8004540:	fbb0 f0f2 	udiv	r0, r0, r2
        frequency = frequency/(tmpreg);
 8004544:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 8004548:	4770      	bx	lr
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 800454a:	6853      	ldr	r3, [r2, #4]
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 800454c:	6851      	ldr	r1, [r2, #4]
 800454e:	4804      	ldr	r0, [pc, #16]	; (8004560 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>)
 8004550:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 8004554:	fbb0 f1f1 	udiv	r1, r0, r1
 8004558:	e7e2      	b.n	8004520 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
 800455a:	bf00      	nop
 800455c:	40023800 	.word	0x40023800
 8004560:	00f42400 	.word	0x00f42400
 8004564:	00bb8000 	.word	0x00bb8000

08004568 <HAL_SAI_Init>:
  uint32_t tmpregisterGCR = 0;
  uint32_t ckstr_bits = 0;
  uint32_t syncen_bits = 0;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
 8004568:	2800      	cmp	r0, #0
 800456a:	f000 80f5 	beq.w	8004758 <HAL_SAI_Init+0x1f0>
{
 800456e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  if (hsai->State == HAL_SAI_STATE_RESET)
 8004570:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 8004574:	4604      	mov	r4, r0
 8004576:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800457a:	2b00      	cmp	r3, #0
 800457c:	f000 80c3 	beq.w	8004706 <HAL_SAI_Init+0x19e>
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004580:	4b76      	ldr	r3, [pc, #472]	; (800475c <HAL_SAI_Init+0x1f4>)
  hsai->State = HAL_SAI_STATE_BUSY;
 8004582:	2002      	movs	r0, #2
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004584:	4976      	ldr	r1, [pc, #472]	; (8004760 <HAL_SAI_Init+0x1f8>)
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 8004586:	6822      	ldr	r2, [r4, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004588:	681b      	ldr	r3, [r3, #0]
  hsai->State = HAL_SAI_STATE_BUSY;
 800458a:	f884 007d 	strb.w	r0, [r4, #125]	; 0x7d
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 800458e:	fba1 1303 	umull	r1, r3, r1, r3
  __HAL_SAI_DISABLE(hsai);
 8004592:	6811      	ldr	r1, [r2, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004594:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8004596:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 800459a:	4083      	lsls	r3, r0
  __HAL_SAI_DISABLE(hsai);
 800459c:	6011      	str	r1, [r2, #0]
 800459e:	e002      	b.n	80045a6 <HAL_SAI_Init+0x3e>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
      status = HAL_TIMEOUT;
      break;
    }
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 80045a0:	6811      	ldr	r1, [r2, #0]
 80045a2:	03ce      	lsls	r6, r1, #15
 80045a4:	d507      	bpl.n	80045b6 <HAL_SAI_Init+0x4e>
    if (count-- == 0)
 80045a6:	3b01      	subs	r3, #1
 80045a8:	d2fa      	bcs.n	80045a0 <HAL_SAI_Init+0x38>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 80045aa:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80045ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80045b2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  switch (hsai->Init.SynchroExt)
 80045b6:	68e3      	ldr	r3, [r4, #12]
 80045b8:	2b01      	cmp	r3, #1
 80045ba:	f000 80a1 	beq.w	8004700 <HAL_SAI_Init+0x198>
 80045be:	2b02      	cmp	r3, #2
 80045c0:	bf15      	itete	ne
 80045c2:	2001      	movne	r0, #1
 80045c4:	2021      	moveq	r0, #33	; 0x21
 80045c6:	2100      	movne	r1, #0
 80045c8:	2120      	moveq	r1, #32
  switch (hsai->Init.Synchro)
 80045ca:	68a3      	ldr	r3, [r4, #8]
 80045cc:	2b02      	cmp	r3, #2
 80045ce:	f000 8094 	beq.w	80046fa <HAL_SAI_Init+0x192>
 80045d2:	2b03      	cmp	r3, #3
 80045d4:	f000 8090 	beq.w	80046f8 <HAL_SAI_Init+0x190>
 80045d8:	2b01      	cmp	r3, #1
 80045da:	bf14      	ite	ne
 80045dc:	2500      	movne	r5, #0
 80045de:	f44f 6580 	moveq.w	r5, #1024	; 0x400
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 80045e2:	4b60      	ldr	r3, [pc, #384]	; (8004764 <HAL_SAI_Init+0x1fc>)
 80045e4:	429a      	cmp	r2, r3
 80045e6:	d025      	beq.n	8004634 <HAL_SAI_Init+0xcc>
 80045e8:	3320      	adds	r3, #32
 80045ea:	429a      	cmp	r2, r3
 80045ec:	d022      	beq.n	8004634 <HAL_SAI_Init+0xcc>
    SAI2->GCR = tmpregisterGCR;
 80045ee:	4b5e      	ldr	r3, [pc, #376]	; (8004768 <HAL_SAI_Init+0x200>)
 80045f0:	f8c3 1c00 	str.w	r1, [r3, #3072]	; 0xc00
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 80045f4:	69e3      	ldr	r3, [r4, #28]
 80045f6:	b31b      	cbz	r3, 8004640 <HAL_SAI_Init+0xd8>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 80045f8:	4b5c      	ldr	r3, [pc, #368]	; (800476c <HAL_SAI_Init+0x204>)
 80045fa:	429a      	cmp	r2, r3
 80045fc:	f000 8093 	beq.w	8004726 <HAL_SAI_Init+0x1be>
 8004600:	3320      	adds	r3, #32
 8004602:	1ad3      	subs	r3, r2, r3
 8004604:	fab3 f383 	clz	r3, r3
 8004608:	095b      	lsrs	r3, r3, #5
 800460a:	2b00      	cmp	r3, #0
 800460c:	f040 808b 	bne.w	8004726 <HAL_SAI_Init+0x1be>
    hsai->Init.Mckdiv = tmpval / 10;
 8004610:	4619      	mov	r1, r3
 8004612:	6223      	str	r3, [r4, #32]
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 8004614:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8004616:	2e04      	cmp	r6, #4
 8004618:	d114      	bne.n	8004644 <HAL_SAI_Init+0xdc>
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800461a:	6863      	ldr	r3, [r4, #4]
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 800461c:	0849      	lsrs	r1, r1, #1
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800461e:	f033 0002 	bics.w	r0, r3, #2
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 8004622:	6221      	str	r1, [r4, #32]
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8004624:	d012      	beq.n	800464c <HAL_SAI_Init+0xe4>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 8004626:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8004628:	2801      	cmp	r0, #1
 800462a:	bf14      	ite	ne
 800462c:	2000      	movne	r0, #0
 800462e:	f44f 7000 	moveq.w	r0, #512	; 0x200
 8004632:	e010      	b.n	8004656 <HAL_SAI_Init+0xee>
    SAI1->GCR = tmpregisterGCR;
 8004634:	4b4c      	ldr	r3, [pc, #304]	; (8004768 <HAL_SAI_Init+0x200>)
 8004636:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 800463a:	69e3      	ldr	r3, [r4, #28]
 800463c:	2b00      	cmp	r3, #0
 800463e:	d167      	bne.n	8004710 <HAL_SAI_Init+0x1a8>
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8004640:	6b26      	ldr	r6, [r4, #48]	; 0x30
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 8004642:	6a21      	ldr	r1, [r4, #32]
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8004644:	6863      	ldr	r3, [r4, #4]
 8004646:	f033 0002 	bics.w	r0, r3, #2
 800464a:	d1ec      	bne.n	8004626 <HAL_SAI_Init+0xbe>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 800464c:	6be7      	ldr	r7, [r4, #60]	; 0x3c
 800464e:	2f01      	cmp	r7, #1
 8004650:	bf18      	it	ne
 8004652:	f44f 7000 	movne.w	r0, #512	; 0x200
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8004656:	6b67      	ldr	r7, [r4, #52]	; 0x34
 8004658:	433b      	orrs	r3, r7
 800465a:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 800465c:	433b      	orrs	r3, r7
 800465e:	6a67      	ldr	r7, [r4, #36]	; 0x24
 8004660:	433b      	orrs	r3, r7
 8004662:	6927      	ldr	r7, [r4, #16]
 8004664:	433b      	orrs	r3, r7
 8004666:	6967      	ldr	r7, [r4, #20]
 8004668:	433b      	orrs	r3, r7
 800466a:	432b      	orrs	r3, r5
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800466c:	4d40      	ldr	r5, [pc, #256]	; (8004770 <HAL_SAI_Init+0x208>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800466e:	4333      	orrs	r3, r6
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8004670:	6816      	ldr	r6, [r2, #0]
 8004672:	4035      	ands	r5, r6
 8004674:	6015      	str	r5, [r2, #0]
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8004676:	6815      	ldr	r5, [r2, #0]
 8004678:	432b      	orrs	r3, r5
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800467a:	4d3e      	ldr	r5, [pc, #248]	; (8004774 <HAL_SAI_Init+0x20c>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800467c:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8004680:	69a1      	ldr	r1, [r4, #24]
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8004682:	4303      	orrs	r3, r0
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8004684:	483c      	ldr	r0, [pc, #240]	; (8004778 <HAL_SAI_Init+0x210>)
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8004686:	6013      	str	r3, [r2, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8004688:	6853      	ldr	r3, [r2, #4]
 800468a:	401d      	ands	r5, r3
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800468c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800468e:	4319      	orrs	r1, r3
 8004690:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 8004692:	6055      	str	r5, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 8004694:	4319      	orrs	r1, r3
 8004696:	6855      	ldr	r5, [r2, #4]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 8004698:	6d23      	ldr	r3, [r4, #80]	; 0x50
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800469a:	4329      	orrs	r1, r5
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 800469c:	f24f 0520 	movw	r5, #61472	; 0xf020
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 80046a0:	6051      	str	r1, [r2, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80046a2:	6891      	ldr	r1, [r2, #8]
 80046a4:	4008      	ands	r0, r1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 80046a6:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80046a8:	430b      	orrs	r3, r1
 80046aa:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 80046ac:	6090      	str	r0, [r2, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 80046ae:	430b      	orrs	r3, r1
 80046b0:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80046b2:	6890      	ldr	r0, [r2, #8]
 80046b4:	3901      	subs	r1, #1
 80046b6:	430b      	orrs	r3, r1
                           ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
 80046b8:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80046ba:	3901      	subs	r1, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 80046bc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046c0:	6d61      	ldr	r1, [r4, #84]	; 0x54
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1) |
 80046c2:	4303      	orrs	r3, r0
 80046c4:	6093      	str	r3, [r2, #8]
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046c6:	6da3      	ldr	r3, [r4, #88]	; 0x58
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 80046c8:	68d0      	ldr	r0, [r2, #12]
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046ca:	430b      	orrs	r3, r1
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 80046cc:	6e21      	ldr	r1, [r4, #96]	; 0x60
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 80046ce:	4028      	ands	r0, r5
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046d0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 80046d4:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 80046d6:	60d0      	str	r0, [r2, #12]
                            | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 80046d8:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046da:	68d0      	ldr	r0, [r2, #12]
 80046dc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 80046e0:	2100      	movs	r1, #0
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046e2:	4303      	orrs	r3, r0
  return HAL_OK;
 80046e4:	4608      	mov	r0, r1
  hsai->Instance->SLOTR |=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80046e6:	60d3      	str	r3, [r2, #12]
  hsai->State = HAL_SAI_STATE_READY;
 80046e8:	2301      	movs	r3, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 80046ea:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
  __HAL_UNLOCK(hsai);
 80046ee:	f884 107c 	strb.w	r1, [r4, #124]	; 0x7c
  hsai->State = HAL_SAI_STATE_READY;
 80046f2:	f884 307d 	strb.w	r3, [r4, #125]	; 0x7d
}
 80046f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 80046f8:	4601      	mov	r1, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
 80046fa:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80046fe:	e770      	b.n	80045e2 <HAL_SAI_Init+0x7a>
  switch (hsai->Init.SynchroExt)
 8004700:	2011      	movs	r0, #17
 8004702:	2110      	movs	r1, #16
 8004704:	e761      	b.n	80045ca <HAL_SAI_Init+0x62>
    hsai->Lock = HAL_UNLOCKED;
 8004706:	f880 207c 	strb.w	r2, [r0, #124]	; 0x7c
    HAL_SAI_MspInit(hsai);
 800470a:	f7fe fb51 	bl	8002db0 <HAL_SAI_MspInit>
 800470e:	e737      	b.n	8004580 <HAL_SAI_Init+0x18>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 8004710:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8004714:	f7ff feb6 	bl	8004484 <HAL_RCCEx_GetPeriphCLKFreq>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 8004718:	6822      	ldr	r2, [r4, #0]
 800471a:	4b14      	ldr	r3, [pc, #80]	; (800476c <HAL_SAI_Init+0x204>)
 800471c:	429a      	cmp	r2, r3
 800471e:	d002      	beq.n	8004726 <HAL_SAI_Init+0x1be>
 8004720:	3320      	adds	r3, #32
 8004722:	429a      	cmp	r2, r3
 8004724:	d104      	bne.n	8004730 <HAL_SAI_Init+0x1c8>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 8004726:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800472a:	f7ff feab 	bl	8004484 <HAL_RCCEx_GetPeriphCLKFreq>
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800472e:	6822      	ldr	r2, [r4, #0]
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 8004730:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8004734:	69e3      	ldr	r3, [r4, #28]
 8004736:	0040      	lsls	r0, r0, #1
 8004738:	025b      	lsls	r3, r3, #9
 800473a:	fbb0 f0f3 	udiv	r0, r0, r3
    hsai->Init.Mckdiv = tmpval / 10;
 800473e:	4b0f      	ldr	r3, [pc, #60]	; (800477c <HAL_SAI_Init+0x214>)
 8004740:	fba3 1300 	umull	r1, r3, r3, r0
 8004744:	08d9      	lsrs	r1, r3, #3
    if ((tmpval % 10) > 8)
 8004746:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 800474a:	eba0 0043 	sub.w	r0, r0, r3, lsl #1
 800474e:	2809      	cmp	r0, #9
      hsai->Init.Mckdiv += 1;
 8004750:	bf08      	it	eq
 8004752:	3101      	addeq	r1, #1
 8004754:	6221      	str	r1, [r4, #32]
 8004756:	e75d      	b.n	8004614 <HAL_SAI_Init+0xac>
    return HAL_ERROR;
 8004758:	2001      	movs	r0, #1
}
 800475a:	4770      	bx	lr
 800475c:	20000680 	.word	0x20000680
 8004760:	95cbec1b 	.word	0x95cbec1b
 8004764:	40015804 	.word	0x40015804
 8004768:	40015000 	.word	0x40015000
 800476c:	40015c04 	.word	0x40015c04
 8004770:	ff05c010 	.word	0xff05c010
 8004774:	ffff1ff0 	.word	0xffff1ff0
 8004778:	fff88000 	.word	0xfff88000
 800477c:	cccccccd 	.word	0xcccccccd

08004780 <HAL_SAI_Abort>:
{
 8004780:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hsai);
 8004782:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8004786:	2b01      	cmp	r3, #1
 8004788:	d042      	beq.n	8004810 <HAL_SAI_Abort+0x90>
 800478a:	2601      	movs	r6, #1
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800478c:	6802      	ldr	r2, [r0, #0]
 800478e:	4604      	mov	r4, r0
  __HAL_LOCK(hsai);
 8004790:	f880 607c 	strb.w	r6, [r0, #124]	; 0x7c
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 8004794:	6815      	ldr	r5, [r2, #0]
 8004796:	f415 3500 	ands.w	r5, r5, #131072	; 0x20000
 800479a:	d011      	beq.n	80047c0 <HAL_SAI_Abort+0x40>
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800479c:	6813      	ldr	r3, [r2, #0]
    if ((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 800479e:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 80047a0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80047a4:	6013      	str	r3, [r2, #0]
    if ((hsai->hdmatx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_TX))
 80047a6:	b118      	cbz	r0, 80047b0 <HAL_SAI_Abort+0x30>
 80047a8:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 80047ac:	2b12      	cmp	r3, #18
 80047ae:	d043      	beq.n	8004838 <HAL_SAI_Abort+0xb8>
  HAL_StatusTypeDef status = HAL_OK;
 80047b0:	2500      	movs	r5, #0
    if ((hsai->hdmarx != NULL) && (hsai->State == HAL_SAI_STATE_BUSY_RX))
 80047b2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80047b4:	b118      	cbz	r0, 80047be <HAL_SAI_Abort+0x3e>
 80047b6:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 80047ba:	2b22      	cmp	r3, #34	; 0x22
 80047bc:	d02b      	beq.n	8004816 <HAL_SAI_Abort+0x96>
  hsai->Instance->IMR = 0;
 80047be:	6822      	ldr	r2, [r4, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 80047c0:	4b25      	ldr	r3, [pc, #148]	; (8004858 <HAL_SAI_Abort+0xd8>)
  hsai->Instance->IMR = 0;
 80047c2:	2000      	movs	r0, #0
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 80047c4:	4925      	ldr	r1, [pc, #148]	; (800485c <HAL_SAI_Abort+0xdc>)
 80047c6:	681b      	ldr	r3, [r3, #0]
  hsai->Instance->IMR = 0;
 80047c8:	6110      	str	r0, [r2, #16]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 80047ca:	fba1 1303 	umull	r1, r3, r1, r3
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 80047ce:	f04f 31ff 	mov.w	r1, #4294967295
 80047d2:	6191      	str	r1, [r2, #24]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 80047d4:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 80047d6:	6811      	ldr	r1, [r2, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 80047d8:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 80047da:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80047de:	6011      	str	r1, [r2, #0]
 80047e0:	e002      	b.n	80047e8 <HAL_SAI_Abort+0x68>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 80047e2:	6811      	ldr	r1, [r2, #0]
 80047e4:	03c9      	lsls	r1, r1, #15
 80047e6:	d507      	bpl.n	80047f8 <HAL_SAI_Abort+0x78>
    if (count-- == 0)
 80047e8:	3b01      	subs	r3, #1
 80047ea:	d2fa      	bcs.n	80047e2 <HAL_SAI_Abort+0x62>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 80047ec:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 80047f0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80047f4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 80047f8:	6853      	ldr	r3, [r2, #4]
  hsai->State = HAL_SAI_STATE_READY;
 80047fa:	2101      	movs	r1, #1
}
 80047fc:	4628      	mov	r0, r5
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 80047fe:	f043 0308 	orr.w	r3, r3, #8
 8004802:	6053      	str	r3, [r2, #4]
  __HAL_UNLOCK(hsai);
 8004804:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
 8004806:	f884 107d 	strb.w	r1, [r4, #125]	; 0x7d
  __HAL_UNLOCK(hsai);
 800480a:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 800480e:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hsai);
 8004810:	2502      	movs	r5, #2
}
 8004812:	4628      	mov	r0, r5
 8004814:	bd70      	pop	{r4, r5, r6, pc}
      if (HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
 8004816:	f7fe fddd 	bl	80033d4 <HAL_DMA_Abort>
 800481a:	2800      	cmp	r0, #0
 800481c:	d0cf      	beq.n	80047be <HAL_SAI_Abort+0x3e>
        if (hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 800481e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8004820:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004822:	2b80      	cmp	r3, #128	; 0x80
 8004824:	d0cb      	beq.n	80047be <HAL_SAI_Abort+0x3e>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8004826:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
          status = HAL_ERROR;
 800482a:	2501      	movs	r5, #1
  hsai->Instance->IMR = 0;
 800482c:	6822      	ldr	r2, [r4, #0]
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800482e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004832:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8004836:	e7c3      	b.n	80047c0 <HAL_SAI_Abort+0x40>
      if (HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
 8004838:	f7fe fdcc 	bl	80033d4 <HAL_DMA_Abort>
 800483c:	2800      	cmp	r0, #0
 800483e:	d0b7      	beq.n	80047b0 <HAL_SAI_Abort+0x30>
        if (hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 8004840:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8004842:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004844:	2b80      	cmp	r3, #128	; 0x80
 8004846:	d0b3      	beq.n	80047b0 <HAL_SAI_Abort+0x30>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8004848:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
          status = HAL_ERROR;
 800484c:	4635      	mov	r5, r6
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800484e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004852:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
 8004856:	e7ac      	b.n	80047b2 <HAL_SAI_Abort+0x32>
 8004858:	20000680 	.word	0x20000680
 800485c:	95cbec1b 	.word	0x95cbec1b

08004860 <HAL_SAI_Transmit_DMA>:
{
 8004860:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004864:	460f      	mov	r7, r1
 8004866:	4604      	mov	r4, r0
 8004868:	4615      	mov	r5, r2
  uint32_t tickstart = HAL_GetTick();
 800486a:	f7fe fc43 	bl	80030f4 <HAL_GetTick>
  if ((pData == NULL) || (Size == 0))
 800486e:	2f00      	cmp	r7, #0
 8004870:	d060      	beq.n	8004934 <HAL_SAI_Transmit_DMA+0xd4>
 8004872:	fab5 f885 	clz	r8, r5
 8004876:	ea4f 1858 	mov.w	r8, r8, lsr #5
 800487a:	2d00      	cmp	r5, #0
 800487c:	d05a      	beq.n	8004934 <HAL_SAI_Transmit_DMA+0xd4>
  if (hsai->State == HAL_SAI_STATE_READY)
 800487e:	f894 307d 	ldrb.w	r3, [r4, #125]	; 0x7d
 8004882:	2b01      	cmp	r3, #1
 8004884:	fa5f f983 	uxtb.w	r9, r3
 8004888:	d14f      	bne.n	800492a <HAL_SAI_Transmit_DMA+0xca>
    __HAL_LOCK(hsai);
 800488a:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
 800488e:	2b01      	cmp	r3, #1
 8004890:	d04b      	beq.n	800492a <HAL_SAI_Transmit_DMA+0xca>
    hsai->XferSize = Size;
 8004892:	4643      	mov	r3, r8
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 8004894:	f8c4 8080 	str.w	r8, [r4, #128]	; 0x80
 8004898:	4606      	mov	r6, r0
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800489a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    hsai->XferSize = Size;
 800489c:	f365 030f 	bfi	r3, r5, #0, #16
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 80048a0:	6822      	ldr	r2, [r4, #0]
    __HAL_LOCK(hsai);
 80048a2:	f884 907c 	strb.w	r9, [r4, #124]	; 0x7c
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 80048a6:	4639      	mov	r1, r7
    hsai->XferSize = Size;
 80048a8:	f365 431f 	bfi	r3, r5, #16, #16
    hsai->pBuffPtr = pData;
 80048ac:	6667      	str	r7, [r4, #100]	; 0x64
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 80048ae:	321c      	adds	r2, #28
    hsai->XferSize = Size;
 80048b0:	66a3      	str	r3, [r4, #104]	; 0x68
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 80048b2:	462b      	mov	r3, r5
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 80048b4:	2512      	movs	r5, #18
 80048b6:	f884 507d 	strb.w	r5, [r4, #125]	; 0x7d
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 80048ba:	4d2e      	ldr	r5, [pc, #184]	; (8004974 <HAL_SAI_Transmit_DMA+0x114>)
    hsai->hdmatx->XferAbortCallback = NULL;
 80048bc:	f8c0 8050 	str.w	r8, [r0, #80]	; 0x50
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 80048c0:	6405      	str	r5, [r0, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 80048c2:	4d2d      	ldr	r5, [pc, #180]	; (8004978 <HAL_SAI_Transmit_DMA+0x118>)
 80048c4:	63c5      	str	r5, [r0, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 80048c6:	4d2d      	ldr	r5, [pc, #180]	; (800497c <HAL_SAI_Transmit_DMA+0x11c>)
 80048c8:	64c5      	str	r5, [r0, #76]	; 0x4c
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 80048ca:	f7fe fd3b 	bl	8003344 <HAL_DMA_Start_IT>
 80048ce:	2800      	cmp	r0, #0
 80048d0:	d13e      	bne.n	8004950 <HAL_SAI_Transmit_DMA+0xf0>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 80048d2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80048d4:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 80048d6:	6863      	ldr	r3, [r4, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 80048d8:	d031      	beq.n	800493e <HAL_SAI_Transmit_DMA+0xde>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 80048da:	2105      	movs	r1, #5
 80048dc:	2261      	movs	r2, #97	; 0x61
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 80048de:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_AFSDET | SAI_IT_LFSDET;
 80048e0:	2b01      	cmp	r3, #1
 80048e2:	bf98      	it	ls
 80048e4:	4611      	movls	r1, r2
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 80048e6:	6822      	ldr	r2, [r4, #0]
 80048e8:	6913      	ldr	r3, [r2, #16]
 80048ea:	430b      	orrs	r3, r1
 80048ec:	6113      	str	r3, [r2, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 80048ee:	6813      	ldr	r3, [r2, #0]
 80048f0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80048f4:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 80048f6:	e006      	b.n	8004906 <HAL_SAI_Transmit_DMA+0xa6>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
 80048f8:	f7fe fbfc 	bl	80030f4 <HAL_GetTick>
 80048fc:	1b83      	subs	r3, r0, r6
 80048fe:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8004902:	d82a      	bhi.n	800495a <HAL_SAI_Transmit_DMA+0xfa>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 8004904:	6822      	ldr	r2, [r4, #0]
 8004906:	6955      	ldr	r5, [r2, #20]
 8004908:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
 800490c:	d0f4      	beq.n	80048f8 <HAL_SAI_Transmit_DMA+0x98>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800490e:	6813      	ldr	r3, [r2, #0]
 8004910:	03db      	lsls	r3, r3, #15
 8004912:	d403      	bmi.n	800491c <HAL_SAI_Transmit_DMA+0xbc>
      __HAL_SAI_ENABLE(hsai);
 8004914:	6813      	ldr	r3, [r2, #0]
 8004916:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800491a:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
 800491c:	2300      	movs	r3, #0
    return HAL_OK;
 800491e:	4699      	mov	r9, r3
    __HAL_UNLOCK(hsai);
 8004920:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
}
 8004924:	4648      	mov	r0, r9
 8004926:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return HAL_BUSY;
 800492a:	f04f 0902 	mov.w	r9, #2
}
 800492e:	4648      	mov	r0, r9
 8004930:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
 8004934:	f04f 0901 	mov.w	r9, #1
}
 8004938:	4648      	mov	r0, r9
 800493a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800493e:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8004942:	2a01      	cmp	r2, #1
 8004944:	bf0b      	itete	eq
 8004946:	2115      	moveq	r1, #21
 8004948:	2105      	movne	r1, #5
 800494a:	2271      	moveq	r2, #113	; 0x71
 800494c:	2261      	movne	r2, #97	; 0x61
 800494e:	e7c6      	b.n	80048de <HAL_SAI_Transmit_DMA+0x7e>
}
 8004950:	4648      	mov	r0, r9
      __HAL_UNLOCK(hsai);
 8004952:	f884 807c 	strb.w	r8, [r4, #124]	; 0x7c
}
 8004956:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800495a:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        return HAL_TIMEOUT;
 800495e:	f04f 0903 	mov.w	r9, #3
        __HAL_UNLOCK(hsai);
 8004962:	f884 507c 	strb.w	r5, [r4, #124]	; 0x7c
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8004966:	f043 0340 	orr.w	r3, r3, #64	; 0x40
}
 800496a:	4648      	mov	r0, r9
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800496c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
}
 8004970:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004974:	080049e5 	.word	0x080049e5
 8004978:	08004981 	.word	0x08004981
 800497c:	080049f5 	.word	0x080049f5

08004980 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 8004980:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
 8004982:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8004984:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 8004986:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800498a:	d01b      	beq.n	80049c4 <SAI_DMATxCplt+0x44>
  {
    hsai->XferCount = 0;

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800498c:	6803      	ldr	r3, [r0, #0]
    hsai->XferCount = 0;
 800498e:	f04f 0c00 	mov.w	ip, #0
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8004992:	6b01      	ldr	r1, [r0, #48]	; 0x30
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 8004994:	681a      	ldr	r2, [r3, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 8004996:	2908      	cmp	r1, #8
    hsai->XferCount = 0;
 8004998:	f8a0 c06a 	strh.w	ip, [r0, #106]	; 0x6a
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800499c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80049a0:	601a      	str	r2, [r3, #0]
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 80049a2:	6842      	ldr	r2, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 80049a4:	d011      	beq.n	80049ca <SAI_DMATxCplt+0x4a>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 80049a6:	f06f 0c61 	mvn.w	ip, #97	; 0x61
 80049aa:	f06f 0105 	mvn.w	r1, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 80049ae:	3a02      	subs	r2, #2
 80049b0:	2a01      	cmp	r2, #1
 80049b2:	bf98      	it	ls
 80049b4:	4661      	movls	r1, ip

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 80049b6:	691a      	ldr	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
 80049b8:	f04f 0c01 	mov.w	ip, #1
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 80049bc:	400a      	ands	r2, r1
 80049be:	611a      	str	r2, [r3, #16]
    hsai->State = HAL_SAI_STATE_READY;
 80049c0:	f880 c07d 	strb.w	ip, [r0, #125]	; 0x7d
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
 80049c4:	f7fd fe90 	bl	80026e8 <HAL_SAI_TxCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 80049c8:	bd08      	pop	{r3, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 80049ca:	f022 0102 	bic.w	r1, r2, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 80049ce:	2901      	cmp	r1, #1
 80049d0:	bf0b      	itete	eq
 80049d2:	f06f 0c71 	mvneq.w	ip, #113	; 0x71
 80049d6:	f06f 0c61 	mvnne.w	ip, #97	; 0x61
 80049da:	f06f 0115 	mvneq.w	r1, #21
 80049de:	f06f 0105 	mvnne.w	r1, #5
 80049e2:	e7e4      	b.n	80049ae <SAI_DMATxCplt+0x2e>

080049e4 <SAI_DMATxHalfCplt>:
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
 80049e4:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 80049e6:	b508      	push	{r3, lr}
  HAL_SAI_TxHalfCpltCallback(hsai);
 80049e8:	f7fd fe84 	bl	80026f4 <HAL_SAI_TxHalfCpltCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 80049ec:	bd08      	pop	{r3, pc}
 80049ee:	bf00      	nop

080049f0 <HAL_SAI_ErrorCallback>:
 80049f0:	4770      	bx	lr
 80049f2:	bf00      	nop

080049f4 <SAI_DMAError>:
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80049f4:	6b80      	ldr	r0, [r0, #56]	; 0x38

  /* Set SAI error code */
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 80049f6:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  if ((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 80049fa:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 80049fc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
{
 8004a00:	b510      	push	{r4, lr}
  hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 8004a02:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  if ((hsai->hdmatx->ErrorCode == HAL_DMA_ERROR_TE) || (hsai->hdmarx->ErrorCode == HAL_DMA_ERROR_TE))
 8004a06:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004a08:	2b01      	cmp	r3, #1
 8004a0a:	d006      	beq.n	8004a1a <SAI_DMAError+0x26>
 8004a0c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8004a0e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004a10:	2b01      	cmp	r3, #1
 8004a12:	d002      	beq.n	8004a1a <SAI_DMAError+0x26>
  }
  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
 8004a14:	f7ff ffec 	bl	80049f0 <HAL_SAI_ErrorCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 8004a18:	bd10      	pop	{r4, pc}
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004a1a:	6801      	ldr	r1, [r0, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a1c:	4b11      	ldr	r3, [pc, #68]	; (8004a64 <SAI_DMAError+0x70>)
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004a1e:	680a      	ldr	r2, [r1, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a20:	681b      	ldr	r3, [r3, #0]
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004a22:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a26:	4c10      	ldr	r4, [pc, #64]	; (8004a68 <SAI_DMAError+0x74>)
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004a28:	600a      	str	r2, [r1, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a2a:	fba4 4303 	umull	r4, r3, r4, r3
  __HAL_SAI_DISABLE(hsai);
 8004a2e:	680a      	ldr	r2, [r1, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a30:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8004a32:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004a36:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 8004a38:	600a      	str	r2, [r1, #0]
 8004a3a:	e002      	b.n	8004a42 <SAI_DMAError+0x4e>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8004a3c:	680a      	ldr	r2, [r1, #0]
 8004a3e:	03d2      	lsls	r2, r2, #15
 8004a40:	d507      	bpl.n	8004a52 <SAI_DMAError+0x5e>
    if (count-- == 0)
 8004a42:	3b01      	subs	r3, #1
 8004a44:	d2fa      	bcs.n	8004a3c <SAI_DMAError+0x48>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8004a46:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8004a4a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004a4e:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_READY;
 8004a52:	2201      	movs	r2, #1
    hsai->XferCount = 0U;
 8004a54:	2300      	movs	r3, #0
    hsai->State = HAL_SAI_STATE_READY;
 8004a56:	f880 207d 	strb.w	r2, [r0, #125]	; 0x7d
    hsai->XferCount = 0U;
 8004a5a:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
  HAL_SAI_ErrorCallback(hsai);
 8004a5e:	f7ff ffc7 	bl	80049f0 <HAL_SAI_ErrorCallback>
}
 8004a62:	bd10      	pop	{r4, pc}
 8004a64:	20000680 	.word	0x20000680
 8004a68:	95cbec1b 	.word	0x95cbec1b

08004a6c <HAL_SAI_IRQHandler>:
  if (hsai->State != HAL_SAI_STATE_RESET)
 8004a6c:	f890 307d 	ldrb.w	r3, [r0, #125]	; 0x7d
 8004a70:	b903      	cbnz	r3, 8004a74 <HAL_SAI_IRQHandler+0x8>
 8004a72:	4770      	bx	lr
    uint32_t itflags = hsai->Instance->SR;
 8004a74:	6803      	ldr	r3, [r0, #0]
 8004a76:	695a      	ldr	r2, [r3, #20]
    uint32_t itsources = hsai->Instance->IMR;
 8004a78:	6919      	ldr	r1, [r3, #16]
{
 8004a7a:	b570      	push	{r4, r5, r6, lr}
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 8004a7c:	0716      	lsls	r6, r2, #28
 8004a7e:	4604      	mov	r4, r0
    uint32_t cr1config = hsai->Instance->CR1;
 8004a80:	681d      	ldr	r5, [r3, #0]
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 8004a82:	d505      	bpl.n	8004a90 <HAL_SAI_IRQHandler+0x24>
 8004a84:	070e      	lsls	r6, r1, #28
 8004a86:	d503      	bpl.n	8004a90 <HAL_SAI_IRQHandler+0x24>
      hsai->InterruptServiceRoutine(hsai);
 8004a88:	6f83      	ldr	r3, [r0, #120]	; 0x78
}
 8004a8a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      hsai->InterruptServiceRoutine(hsai);
 8004a8e:	4718      	bx	r3
    else if (((itflags & SAI_FLAG_OVRUDR) == SAI_FLAG_OVRUDR) && ((itsources & SAI_IT_OVRUDR) == SAI_IT_OVRUDR))
 8004a90:	07d0      	lsls	r0, r2, #31
 8004a92:	d514      	bpl.n	8004abe <HAL_SAI_IRQHandler+0x52>
 8004a94:	f011 0c01 	ands.w	ip, r1, #1
 8004a98:	d011      	beq.n	8004abe <HAL_SAI_IRQHandler+0x52>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 8004a9a:	2201      	movs	r2, #1
      HAL_SAI_ErrorCallback(hsai);
 8004a9c:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 8004a9e:	619a      	str	r2, [r3, #24]
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 8004aa0:	f894 207d 	ldrb.w	r2, [r4, #125]	; 0x7d
      hsai->ErrorCode |= tmperror;
 8004aa4:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 8004aa8:	2a22      	cmp	r2, #34	; 0x22
 8004aaa:	bf18      	it	ne
 8004aac:	f04f 0c02 	movne.w	ip, #2
      hsai->ErrorCode |= tmperror;
 8004ab0:	ea43 030c 	orr.w	r3, r3, ip
 8004ab4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
      HAL_SAI_ErrorCallback(hsai);
 8004ab8:	f7ff ff9a 	bl	80049f0 <HAL_SAI_ErrorCallback>
}
 8004abc:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_MUTEDET) == SAI_FLAG_MUTEDET) && ((itsources & SAI_IT_MUTEDET) == SAI_IT_MUTEDET))
 8004abe:	0796      	lsls	r6, r2, #30
 8004ac0:	d509      	bpl.n	8004ad6 <HAL_SAI_IRQHandler+0x6a>
 8004ac2:	0788      	lsls	r0, r1, #30
 8004ac4:	d507      	bpl.n	8004ad6 <HAL_SAI_IRQHandler+0x6a>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
 8004ac6:	2102      	movs	r1, #2
      if (hsai->mutecallback != (SAIcallback)NULL)
 8004ac8:	6f62      	ldr	r2, [r4, #116]	; 0x74
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
 8004aca:	6199      	str	r1, [r3, #24]
      if (hsai->mutecallback != (SAIcallback)NULL)
 8004acc:	2a00      	cmp	r2, #0
 8004ace:	d0f5      	beq.n	8004abc <HAL_SAI_IRQHandler+0x50>
}
 8004ad0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hsai->mutecallback();
 8004ad4:	4710      	bx	r2
    else if (((itflags & SAI_FLAG_AFSDET) == SAI_FLAG_AFSDET) && ((itsources & SAI_IT_AFSDET) == SAI_IT_AFSDET))
 8004ad6:	0696      	lsls	r6, r2, #26
 8004ad8:	d514      	bpl.n	8004b04 <HAL_SAI_IRQHandler+0x98>
 8004ada:	0688      	lsls	r0, r1, #26
 8004adc:	d512      	bpl.n	8004b04 <HAL_SAI_IRQHandler+0x98>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_AFSDET);
 8004ade:	2220      	movs	r2, #32
 8004ae0:	619a      	str	r2, [r3, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_AFSDET;
 8004ae2:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8004ae6:	f043 0304 	orr.w	r3, r3, #4
 8004aea:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 8004aee:	03ab      	lsls	r3, r5, #14
 8004af0:	d516      	bpl.n	8004b20 <HAL_SAI_IRQHandler+0xb4>
        if (hsai->hdmatx != NULL)
 8004af2:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8004af4:	2800      	cmp	r0, #0
 8004af6:	d041      	beq.n	8004b7c <HAL_SAI_IRQHandler+0x110>
        hsai->hdmatx->XferAbortCallback = SAI_DMAAbort;
 8004af8:	4b29      	ldr	r3, [pc, #164]	; (8004ba0 <HAL_SAI_IRQHandler+0x134>)
}
 8004afa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hsai->hdmatx->XferAbortCallback = SAI_DMAAbort;
 8004afe:	6503      	str	r3, [r0, #80]	; 0x50
        HAL_DMA_Abort_IT(hsai->hdmatx);
 8004b00:	f7fe bcb0 	b.w	8003464 <HAL_DMA_Abort_IT>
    else if (((itflags & SAI_FLAG_LFSDET) == SAI_FLAG_LFSDET) && ((itsources & SAI_IT_LFSDET) == SAI_IT_LFSDET))
 8004b04:	0656      	lsls	r6, r2, #25
 8004b06:	d512      	bpl.n	8004b2e <HAL_SAI_IRQHandler+0xc2>
 8004b08:	0648      	lsls	r0, r1, #25
 8004b0a:	d510      	bpl.n	8004b2e <HAL_SAI_IRQHandler+0xc2>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_LFSDET);
 8004b0c:	2240      	movs	r2, #64	; 0x40
 8004b0e:	619a      	str	r2, [r3, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_LFSDET;
 8004b10:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8004b14:	f043 0308 	orr.w	r3, r3, #8
 8004b18:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 8004b1c:	03ab      	lsls	r3, r5, #14
 8004b1e:	d4e8      	bmi.n	8004af2 <HAL_SAI_IRQHandler+0x86>
        HAL_SAI_Abort(hsai);
 8004b20:	4620      	mov	r0, r4
 8004b22:	f7ff fe2d 	bl	8004780 <HAL_SAI_Abort>
        HAL_SAI_ErrorCallback(hsai);
 8004b26:	4620      	mov	r0, r4
 8004b28:	f7ff ff62 	bl	80049f0 <HAL_SAI_ErrorCallback>
}
 8004b2c:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_WCKCFG) == SAI_FLAG_WCKCFG) && ((itsources & SAI_IT_WCKCFG) == SAI_IT_WCKCFG))
 8004b2e:	0756      	lsls	r6, r2, #29
 8004b30:	d515      	bpl.n	8004b5e <HAL_SAI_IRQHandler+0xf2>
 8004b32:	074d      	lsls	r5, r1, #29
 8004b34:	d513      	bpl.n	8004b5e <HAL_SAI_IRQHandler+0xf2>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 8004b36:	2204      	movs	r2, #4
      if (hsai->hdmatx != NULL)
 8004b38:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 8004b3a:	619a      	str	r2, [r3, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_WCKCFG;
 8004b3c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8004b40:	f042 0220 	orr.w	r2, r2, #32
 8004b44:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
      if (hsai->hdmatx != NULL)
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	d1d5      	bne.n	8004af8 <HAL_SAI_IRQHandler+0x8c>
      else if (hsai->hdmarx != NULL)
 8004b4c:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8004b4e:	b1ca      	cbz	r2, 8004b84 <HAL_SAI_IRQHandler+0x118>
        hsai->hdmarx->XferAbortCallback = SAI_DMAAbort;
 8004b50:	4b13      	ldr	r3, [pc, #76]	; (8004ba0 <HAL_SAI_IRQHandler+0x134>)
        HAL_DMA_Abort_IT(hsai->hdmarx);
 8004b52:	4610      	mov	r0, r2
}
 8004b54:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hsai->hdmarx->XferAbortCallback = SAI_DMAAbort;
 8004b58:	6513      	str	r3, [r2, #80]	; 0x50
        HAL_DMA_Abort_IT(hsai->hdmarx);
 8004b5a:	f7fe bc83 	b.w	8003464 <HAL_DMA_Abort_IT>
    else if (((itflags & SAI_FLAG_CNRDY) == SAI_FLAG_CNRDY) && ((itsources & SAI_IT_CNRDY) == SAI_IT_CNRDY))
 8004b5e:	06d0      	lsls	r0, r2, #27
 8004b60:	d5ac      	bpl.n	8004abc <HAL_SAI_IRQHandler+0x50>
 8004b62:	06ca      	lsls	r2, r1, #27
 8004b64:	d5aa      	bpl.n	8004abc <HAL_SAI_IRQHandler+0x50>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 8004b66:	2210      	movs	r2, #16
      HAL_SAI_ErrorCallback(hsai);
 8004b68:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 8004b6a:	619a      	str	r2, [r3, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_CNREADY;
 8004b6c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 8004b70:	4313      	orrs	r3, r2
 8004b72:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
      HAL_SAI_ErrorCallback(hsai);
 8004b76:	f7ff ff3b 	bl	80049f0 <HAL_SAI_ErrorCallback>
}
 8004b7a:	bd70      	pop	{r4, r5, r6, pc}
        else if (hsai->hdmarx != NULL)
 8004b7c:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8004b7e:	2800      	cmp	r0, #0
 8004b80:	d1ba      	bne.n	8004af8 <HAL_SAI_IRQHandler+0x8c>
 8004b82:	e79b      	b.n	8004abc <HAL_SAI_IRQHandler+0x50>
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 8004b84:	f04f 30ff 	mov.w	r0, #4294967295
        hsai->State = HAL_SAI_STATE_READY;
 8004b88:	2101      	movs	r1, #1
        hsai->Instance->IMR = 0U;
 8004b8a:	611a      	str	r2, [r3, #16]
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 8004b8c:	6198      	str	r0, [r3, #24]
        HAL_SAI_ErrorCallback(hsai);
 8004b8e:	4620      	mov	r0, r4
        hsai->State = HAL_SAI_STATE_READY;
 8004b90:	f884 107d 	strb.w	r1, [r4, #125]	; 0x7d
        hsai->XferCount = 0U;
 8004b94:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
        HAL_SAI_ErrorCallback(hsai);
 8004b98:	f7ff ff2a 	bl	80049f0 <HAL_SAI_ErrorCallback>
}
 8004b9c:	bd70      	pop	{r4, r5, r6, pc}
 8004b9e:	bf00      	nop
 8004ba0:	08004ba5 	.word	0x08004ba5

08004ba4 <SAI_DMAAbort>:
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAAbort(DMA_HandleTypeDef *hdma)
{
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8004ba4:	6b80      	ldr	r0, [r0, #56]	; 0x38
  /* Disable DMA request */
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;

  /* Disable all interrupts and clear all flags */
  hsai->Instance->IMR = 0U;
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 8004ba6:	f04f 31ff 	mov.w	r1, #4294967295
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004baa:	6802      	ldr	r2, [r0, #0]
 8004bac:	6813      	ldr	r3, [r2, #0]
{
 8004bae:	b510      	push	{r4, lr}
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004bb0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  hsai->Instance->IMR = 0U;
 8004bb4:	2400      	movs	r4, #0
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 8004bb6:	6013      	str	r3, [r2, #0]
  hsai->Instance->IMR = 0U;
 8004bb8:	6114      	str	r4, [r2, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 8004bba:	6191      	str	r1, [r2, #24]

  if (hsai->ErrorCode != HAL_SAI_ERROR_WCKCFG)
 8004bbc:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8004bc0:	2b20      	cmp	r3, #32
 8004bc2:	d01a      	beq.n	8004bfa <SAI_DMAAbort+0x56>
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004bc4:	4b11      	ldr	r3, [pc, #68]	; (8004c0c <SAI_DMAAbort+0x68>)
 8004bc6:	4c12      	ldr	r4, [pc, #72]	; (8004c10 <SAI_DMAAbort+0x6c>)
 8004bc8:	681b      	ldr	r3, [r3, #0]
  __HAL_SAI_DISABLE(hsai);
 8004bca:	6811      	ldr	r1, [r2, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004bcc:	fba4 4303 	umull	r4, r3, r4, r3
  __HAL_SAI_DISABLE(hsai);
 8004bd0:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004bd4:	0b1b      	lsrs	r3, r3, #12
  __HAL_SAI_DISABLE(hsai);
 8004bd6:	6011      	str	r1, [r2, #0]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7 / 1000);
 8004bd8:	009b      	lsls	r3, r3, #2
  __HAL_SAI_DISABLE(hsai);
 8004bda:	e002      	b.n	8004be2 <SAI_DMAAbort+0x3e>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8004bdc:	6811      	ldr	r1, [r2, #0]
 8004bde:	03c9      	lsls	r1, r1, #15
 8004be0:	d507      	bpl.n	8004bf2 <SAI_DMAAbort+0x4e>
    if (count-- == 0)
 8004be2:	3b01      	subs	r3, #1
 8004be4:	d2fa      	bcs.n	8004bdc <SAI_DMAAbort+0x38>
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8004be6:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8004bea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004bee:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  {
    /* Disable SAI peripheral */
    SAI_Disable(hsai);

    /* Flush the fifo */
    SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 8004bf2:	6853      	ldr	r3, [r2, #4]
 8004bf4:	f043 0308 	orr.w	r3, r3, #8
 8004bf8:	6053      	str	r3, [r2, #4]
  }
  /* Set the SAI state to ready to be able to start again the process */
  hsai->State = HAL_SAI_STATE_READY;
 8004bfa:	2201      	movs	r2, #1

  /* Initialize XferCount */
  hsai->XferCount = 0U;
 8004bfc:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
 8004bfe:	f880 207d 	strb.w	r2, [r0, #125]	; 0x7d
  hsai->XferCount = 0U;
 8004c02:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a

  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
 8004c06:	f7ff fef3 	bl	80049f0 <HAL_SAI_ErrorCallback>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
}
 8004c0a:	bd10      	pop	{r4, pc}
 8004c0c:	20000680 	.word	0x20000680
 8004c10:	95cbec1b 	.word	0x95cbec1b

08004c14 <SD_DMATransmitCplt>:
static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);

  /* Enable DATAEND Interrupt */
  __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DATAEND));
 8004c14:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8004c16:	681a      	ldr	r2, [r3, #0]
 8004c18:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8004c1a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004c1e:	63d3      	str	r3, [r2, #60]	; 0x3c
}
 8004c20:	4770      	bx	lr
 8004c22:	bf00      	nop

08004c24 <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8004c24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c26:	4605      	mov	r5, r0
 8004c28:	b089      	sub	sp, #36	; 0x24
 8004c2a:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8004c2c:	f7fe fa62 	bl	80030f4 <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0U, 0U};
 8004c30:	2200      	movs	r2, #0
 8004c32:	2300      	movs	r3, #0
  uint32_t tickstart = HAL_GetTick();
 8004c34:	4606      	mov	r6, r0
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8004c36:	2108      	movs	r1, #8
 8004c38:	6828      	ldr	r0, [r5, #0]
  uint32_t tempscr[2U] = {0U, 0U};
 8004c3a:	e9cd 2300 	strd	r2, r3, [sp]
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8004c3e:	f001 fde9 	bl	8006814 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8004c42:	4604      	mov	r4, r0
 8004c44:	b110      	cbz	r0, 8004c4c <SD_FindSCR+0x28>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 8004c46:	4620      	mov	r0, r4
 8004c48:	b009      	add	sp, #36	; 0x24
 8004c4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8004c4c:	6d29      	ldr	r1, [r5, #80]	; 0x50
 8004c4e:	6828      	ldr	r0, [r5, #0]
 8004c50:	0409      	lsls	r1, r1, #16
 8004c52:	f002 fab3 	bl	80071bc <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 8004c56:	4604      	mov	r4, r0
 8004c58:	2800      	cmp	r0, #0
 8004c5a:	d1f4      	bne.n	8004c46 <SD_FindSCR+0x22>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8004c5c:	f04f 32ff 	mov.w	r2, #4294967295
 8004c60:	2308      	movs	r3, #8
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004c62:	a902      	add	r1, sp, #8
 8004c64:	6828      	ldr	r0, [r5, #0]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8004c66:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8004c6a:	2230      	movs	r2, #48	; 0x30
 8004c6c:	2302      	movs	r3, #2
 8004c6e:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004c72:	2200      	movs	r2, #0
 8004c74:	2301      	movs	r3, #1
 8004c76:	e9cd 2306 	strd	r2, r3, [sp, #24]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004c7a:	f001 fdb5 	bl	80067e8 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 8004c7e:	6828      	ldr	r0, [r5, #0]
 8004c80:	f002 fc1a 	bl	80074b8 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8004c84:	4604      	mov	r4, r0
 8004c86:	b140      	cbz	r0, 8004c9a <SD_FindSCR+0x76>
 8004c88:	e7dd      	b.n	8004c46 <SD_FindSCR+0x22>
    else if(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXACT))
 8004c8a:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004c8c:	0491      	lsls	r1, r2, #18
 8004c8e:	d515      	bpl.n	8004cbc <SD_FindSCR+0x98>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 8004c90:	f7fe fa30 	bl	80030f4 <HAL_GetTick>
 8004c94:	1b83      	subs	r3, r0, r6
 8004c96:	3301      	adds	r3, #1
 8004c98:	d024      	beq.n	8004ce4 <SD_FindSCR+0xc0>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT))
 8004c9a:	6828      	ldr	r0, [r5, #0]
 8004c9c:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004c9e:	f012 0f2a 	tst.w	r2, #42	; 0x2a
 8004ca2:	d10b      	bne.n	8004cbc <SD_FindSCR+0x98>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
 8004ca4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004ca6:	0293      	lsls	r3, r2, #10
 8004ca8:	d5ef      	bpl.n	8004c8a <SD_FindSCR+0x66>
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
 8004caa:	f001 fd85 	bl	80067b8 <SDMMC_ReadFIFO>
 8004cae:	ab08      	add	r3, sp, #32
 8004cb0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8004cb4:	3401      	adds	r4, #1
 8004cb6:	f843 0c20 	str.w	r0, [r3, #-32]
 8004cba:	e7e9      	b.n	8004c90 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8004cbc:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004cbe:	0712      	lsls	r2, r2, #28
 8004cc0:	d417      	bmi.n	8004cf2 <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8004cc2:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004cc4:	0793      	lsls	r3, r2, #30
 8004cc6:	d418      	bmi.n	8004cfa <SD_FindSCR+0xd6>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8004cc8:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8004cca:	f014 0420 	ands.w	r4, r4, #32
 8004cce:	d10c      	bne.n	8004cea <SD_FindSCR+0xc6>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8004cd0:	f240 533a 	movw	r3, #1338	; 0x53a
 8004cd4:	e9dd 2100 	ldrd	r2, r1, [sp]
 8004cd8:	6383      	str	r3, [r0, #56]	; 0x38
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8004cda:	ba09      	rev	r1, r1
 8004cdc:	ba12      	rev	r2, r2
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8004cde:	e9c7 1200 	strd	r1, r2, [r7]
  return HAL_SD_ERROR_NONE;
 8004ce2:	e7b0      	b.n	8004c46 <SD_FindSCR+0x22>
      return HAL_SD_ERROR_TIMEOUT;
 8004ce4:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 8004ce8:	e7ad      	b.n	8004c46 <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8004cea:	2220      	movs	r2, #32
    return HAL_SD_ERROR_RX_OVERRUN;
 8004cec:	4614      	mov	r4, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 8004cee:	6382      	str	r2, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 8004cf0:	e7a9      	b.n	8004c46 <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8004cf2:	2208      	movs	r2, #8
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8004cf4:	4614      	mov	r4, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 8004cf6:	6382      	str	r2, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 8004cf8:	e7a5      	b.n	8004c46 <SD_FindSCR+0x22>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8004cfa:	2202      	movs	r2, #2
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8004cfc:	4614      	mov	r4, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 8004cfe:	6382      	str	r2, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8004d00:	e7a1      	b.n	8004c46 <SD_FindSCR+0x22>
 8004d02:	bf00      	nop

08004d04 <HAL_SD_ReadBlocks_DMA>:
{
 8004d04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004d08:	4604      	mov	r4, r0
 8004d0a:	b086      	sub	sp, #24
  if(NULL == pData)
 8004d0c:	2900      	cmp	r1, #0
 8004d0e:	f000 8082 	beq.w	8004e16 <HAL_SD_ReadBlocks_DMA+0x112>
  if(hsd->State == HAL_SD_STATE_READY)
 8004d12:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8004d16:	2801      	cmp	r0, #1
 8004d18:	b2c5      	uxtb	r5, r0
 8004d1a:	d169      	bne.n	8004df0 <HAL_SD_ReadBlocks_DMA+0xec>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004d1c:	18d0      	adds	r0, r2, r3
 8004d1e:	461f      	mov	r7, r3
 8004d20:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8004d22:	f04f 0c00 	mov.w	ip, #0
 8004d26:	4616      	mov	r6, r2
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004d28:	4298      	cmp	r0, r3
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8004d2a:	f8c4 c038 	str.w	ip, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004d2e:	d907      	bls.n	8004d40 <HAL_SD_ReadBlocks_DMA+0x3c>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8004d30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004d32:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8004d36:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8004d38:	4628      	mov	r0, r5
 8004d3a:	b006      	add	sp, #24
 8004d3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->State = HAL_SD_STATE_BUSY;
 8004d40:	2303      	movs	r3, #3
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004d42:	460a      	mov	r2, r1
    hsd->Instance->DCTRL = 0U;
 8004d44:	6821      	ldr	r1, [r4, #0]
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004d46:	ea4f 2847 	mov.w	r8, r7, lsl #9
    hsd->State = HAL_SD_STATE_BUSY;
 8004d4a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8004d4e:	f8c1 c02c 	str.w	ip, [r1, #44]	; 0x2c
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004d52:	3180      	adds	r1, #128	; 0x80
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8004d54:	f851 3c44 	ldr.w	r3, [r1, #-68]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8004d58:	6c20      	ldr	r0, [r4, #64]	; 0x40
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8004d5a:	f443 7395 	orr.w	r3, r3, #298	; 0x12a
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 8004d5e:	f8df e0e4 	ldr.w	lr, [pc, #228]	; 8004e44 <HAL_SD_ReadBlocks_DMA+0x140>
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8004d62:	f841 3c44 	str.w	r3, [r1, #-68]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8004d66:	4b35      	ldr	r3, [pc, #212]	; (8004e3c <HAL_SD_ReadBlocks_DMA+0x138>)
    hsd->hdmarx->XferAbortCallback = NULL;
 8004d68:	f8c0 c050 	str.w	ip, [r0, #80]	; 0x50
    hsd->hdmarx->Init.Direction = DMA_PERIPH_TO_MEMORY;
 8004d6c:	f8c0 c008 	str.w	ip, [r0, #8]
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8004d70:	f8d0 c000 	ldr.w	ip, [r0]
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 8004d74:	63c3      	str	r3, [r0, #60]	; 0x3c
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8004d76:	f8dc 3000 	ldr.w	r3, [ip]
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 8004d7a:	f8c0 e04c 	str.w	lr, [r0, #76]	; 0x4c
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 8004d7e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8004d82:	f8cc 3000 	str.w	r3, [ip]
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004d86:	ea4f 0398 	mov.w	r3, r8, lsr #2
 8004d8a:	f7fe fadb 	bl	8003344 <HAL_DMA_Start_IT>
 8004d8e:	2800      	cmp	r0, #0
 8004d90:	d133      	bne.n	8004dfa <HAL_SD_ReadBlocks_DMA+0xf6>
      __HAL_SD_DMA_ENABLE(hsd);
 8004d92:	6820      	ldr	r0, [r4, #0]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8004d94:	2190      	movs	r1, #144	; 0x90
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8004d96:	6c62      	ldr	r2, [r4, #68]	; 0x44
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8004d98:	f04f 0c00 	mov.w	ip, #0
      __HAL_SD_DMA_ENABLE(hsd);
 8004d9c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8004d9e:	2a01      	cmp	r2, #1
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8004da0:	f8cd 8004 	str.w	r8, [sp, #4]
      __HAL_SD_DMA_ENABLE(hsd);
 8004da4:	f043 0308 	orr.w	r3, r3, #8
        add *= 512U;
 8004da8:	bf18      	it	ne
 8004daa:	0276      	lslne	r6, r6, #9
      __HAL_SD_DMA_ENABLE(hsd);
 8004dac:	62c3      	str	r3, [r0, #44]	; 0x2c
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8004dae:	f04f 33ff 	mov.w	r3, #4294967295
 8004db2:	9300      	str	r3, [sp, #0]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8004db4:	2302      	movs	r3, #2
 8004db6:	e9cd 1302 	strd	r1, r3, [sp, #8]
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8004dba:	2301      	movs	r3, #1
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004dbc:	4669      	mov	r1, sp
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8004dbe:	e9cd c304 	strd	ip, r3, [sp, #16]
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004dc2:	f001 fd11 	bl	80067e8 <SDMMC_ConfigData>
      if(NumberOfBlocks > 1U)
 8004dc6:	2f01      	cmp	r7, #1
 8004dc8:	d930      	bls.n	8004e2c <HAL_SD_ReadBlocks_DMA+0x128>
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8004dca:	2382      	movs	r3, #130	; 0x82
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8004dcc:	4631      	mov	r1, r6
 8004dce:	6820      	ldr	r0, [r4, #0]
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8004dd0:	6323      	str	r3, [r4, #48]	; 0x30
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8004dd2:	f001 fe61 	bl	8006a98 <SDMMC_CmdReadMultiBlock>
      if(errorstate != HAL_SD_ERROR_NONE)
 8004dd6:	b338      	cbz	r0, 8004e28 <HAL_SD_ReadBlocks_DMA+0x124>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004dd8:	6823      	ldr	r3, [r4, #0]
 8004dda:	4a19      	ldr	r2, [pc, #100]	; (8004e40 <HAL_SD_ReadBlocks_DMA+0x13c>)
 8004ddc:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 8004dde:	2201      	movs	r2, #1
        hsd->ErrorCode |= errorstate;
 8004de0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004de2:	4318      	orrs	r0, r3
        hsd->Context = SD_CONTEXT_NONE;
 8004de4:	2300      	movs	r3, #0
        hsd->ErrorCode |= errorstate;
 8004de6:	63a0      	str	r0, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 8004de8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8004dec:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_ERROR;
 8004dee:	e7a3      	b.n	8004d38 <HAL_SD_ReadBlocks_DMA+0x34>
    return HAL_BUSY;
 8004df0:	2502      	movs	r5, #2
}
 8004df2:	4628      	mov	r0, r5
 8004df4:	b006      	add	sp, #24
 8004df6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8004dfa:	6823      	ldr	r3, [r4, #0]
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004dfc:	4910      	ldr	r1, [pc, #64]	; (8004e40 <HAL_SD_ReadBlocks_DMA+0x13c>)
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
 8004dfe:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004e00:	f422 7295 	bic.w	r2, r2, #298	; 0x12a
 8004e04:	63da      	str	r2, [r3, #60]	; 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004e06:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8004e08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004e0a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004e0e:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004e10:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
      return HAL_ERROR;
 8004e14:	e790      	b.n	8004d38 <HAL_SD_ReadBlocks_DMA+0x34>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8004e16:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8004e18:	2501      	movs	r5, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8004e1a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8004e1e:	6383      	str	r3, [r0, #56]	; 0x38
}
 8004e20:	4628      	mov	r0, r5
 8004e22:	b006      	add	sp, #24
 8004e24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return HAL_OK;
 8004e28:	4605      	mov	r5, r0
 8004e2a:	e785      	b.n	8004d38 <HAL_SD_ReadBlocks_DMA+0x34>
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8004e2c:	2381      	movs	r3, #129	; 0x81
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8004e2e:	4631      	mov	r1, r6
 8004e30:	6820      	ldr	r0, [r4, #0]
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8004e32:	6323      	str	r3, [r4, #48]	; 0x30
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8004e34:	f001 fd8e 	bl	8006954 <SDMMC_CmdReadSingleBlock>
 8004e38:	e7cd      	b.n	8004dd6 <HAL_SD_ReadBlocks_DMA+0xd2>
 8004e3a:	bf00      	nop
 8004e3c:	08004f9d 	.word	0x08004f9d
 8004e40:	004005ff 	.word	0x004005ff
 8004e44:	08004fe5 	.word	0x08004fe5

08004e48 <HAL_SD_WriteBlocks_DMA>:
{
 8004e48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004e4c:	4604      	mov	r4, r0
 8004e4e:	b088      	sub	sp, #32
  if(NULL == pData)
 8004e50:	2900      	cmp	r1, #0
 8004e52:	d078      	beq.n	8004f46 <HAL_SD_WriteBlocks_DMA+0xfe>
 8004e54:	461d      	mov	r5, r3
  if(hsd->State == HAL_SD_STATE_READY)
 8004e56:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8004e5a:	2b01      	cmp	r3, #1
 8004e5c:	b2df      	uxtb	r7, r3
 8004e5e:	d135      	bne.n	8004ecc <HAL_SD_WriteBlocks_DMA+0x84>
 8004e60:	460e      	mov	r6, r1
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004e62:	1953      	adds	r3, r2, r5
 8004e64:	6de1      	ldr	r1, [r4, #92]	; 0x5c
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8004e66:	2000      	movs	r0, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004e68:	428b      	cmp	r3, r1
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8004e6a:	63a0      	str	r0, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8004e6c:	d833      	bhi.n	8004ed6 <HAL_SD_WriteBlocks_DMA+0x8e>
    hsd->Instance->DCTRL = 0U;
 8004e6e:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 8004e70:	2103      	movs	r1, #3
 8004e72:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8004e76:	62d8      	str	r0, [r3, #44]	; 0x2c
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8004e78:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8004e7a:	f041 011a 	orr.w	r1, r1, #26
 8004e7e:	63d9      	str	r1, [r3, #60]	; 0x3c
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8004e80:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    hsd->hdmatx->XferAbortCallback = NULL;
 8004e82:	6508      	str	r0, [r1, #80]	; 0x50
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 8004e84:	4841      	ldr	r0, [pc, #260]	; (8004f8c <HAL_SD_WriteBlocks_DMA+0x144>)
 8004e86:	63c8      	str	r0, [r1, #60]	; 0x3c
    hsd->hdmatx->XferErrorCallback = SD_DMAError;
 8004e88:	4841      	ldr	r0, [pc, #260]	; (8004f90 <HAL_SD_WriteBlocks_DMA+0x148>)
 8004e8a:	64c8      	str	r0, [r1, #76]	; 0x4c
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8004e8c:	4618      	mov	r0, r3
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8004e8e:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8004e90:	2901      	cmp	r1, #1
      add *= 512U;
 8004e92:	bf18      	it	ne
 8004e94:	0252      	lslne	r2, r2, #9
    if(NumberOfBlocks > 1U)
 8004e96:	2d01      	cmp	r5, #1
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8004e98:	4611      	mov	r1, r2
    if(NumberOfBlocks > 1U)
 8004e9a:	d95d      	bls.n	8004f58 <HAL_SD_WriteBlocks_DMA+0x110>
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8004e9c:	23a0      	movs	r3, #160	; 0xa0
 8004e9e:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8004ea0:	f001 ff3c 	bl	8006d1c <SDMMC_CmdWriteMultiBlock>
 8004ea4:	4680      	mov	r8, r0
    if(errorstate != HAL_SD_ERROR_NONE)
 8004ea6:	f1b8 0f00 	cmp.w	r8, #0
 8004eaa:	d01c      	beq.n	8004ee6 <HAL_SD_WriteBlocks_DMA+0x9e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004eac:	6823      	ldr	r3, [r4, #0]
 8004eae:	4a39      	ldr	r2, [pc, #228]	; (8004f94 <HAL_SD_WriteBlocks_DMA+0x14c>)
 8004eb0:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004eb2:	2201      	movs	r2, #1
      hsd->ErrorCode |= errorstate;
 8004eb4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
      hsd->Context = SD_CONTEXT_NONE;
 8004eb6:	2300      	movs	r3, #0
      hsd->ErrorCode |= errorstate;
 8004eb8:	ea40 0008 	orr.w	r0, r0, r8
 8004ebc:	63a0      	str	r0, [r4, #56]	; 0x38
}
 8004ebe:	4638      	mov	r0, r7
      hsd->State = HAL_SD_STATE_READY;
 8004ec0:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8004ec4:	6323      	str	r3, [r4, #48]	; 0x30
}
 8004ec6:	b008      	add	sp, #32
 8004ec8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return HAL_BUSY;
 8004ecc:	2702      	movs	r7, #2
}
 8004ece:	4638      	mov	r0, r7
 8004ed0:	b008      	add	sp, #32
 8004ed2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8004ed6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
}
 8004ed8:	4638      	mov	r0, r7
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8004eda:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8004ede:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8004ee0:	b008      	add	sp, #32
 8004ee2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_SD_DMA_ENABLE(hsd);
 8004ee6:	6822      	ldr	r2, [r4, #0]
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004ee8:	4631      	mov	r1, r6
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 8004eea:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8004eec:	f04f 0c40 	mov.w	ip, #64	; 0x40
    __HAL_SD_DMA_ENABLE(hsd);
 8004ef0:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004ef2:	026d      	lsls	r5, r5, #9
 8004ef4:	3280      	adds	r2, #128	; 0x80
    __HAL_SD_DMA_ENABLE(hsd);
 8004ef6:	f046 0608 	orr.w	r6, r6, #8
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004efa:	08ab      	lsrs	r3, r5, #2
    __HAL_SD_DMA_ENABLE(hsd);
 8004efc:	f842 6c54 	str.w	r6, [r2, #-84]
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 8004f00:	f8c0 c008 	str.w	ip, [r0, #8]
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
 8004f04:	f8d0 c000 	ldr.w	ip, [r0]
 8004f08:	f8dc 6000 	ldr.w	r6, [ip]
 8004f0c:	f026 06c0 	bic.w	r6, r6, #192	; 0xc0
 8004f10:	f046 0640 	orr.w	r6, r6, #64	; 0x40
 8004f14:	f8cc 6000 	str.w	r6, [ip]
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 8004f18:	f7fe fa14 	bl	8003344 <HAL_DMA_Start_IT>
 8004f1c:	b330      	cbz	r0, 8004f6c <HAL_SD_WriteBlocks_DMA+0x124>
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8004f1e:	6823      	ldr	r3, [r4, #0]
}
 8004f20:	4638      	mov	r0, r7
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
 8004f22:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004f24:	f022 021a 	bic.w	r2, r2, #26
 8004f28:	63da      	str	r2, [r3, #60]	; 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004f2a:	4a1a      	ldr	r2, [pc, #104]	; (8004f94 <HAL_SD_WriteBlocks_DMA+0x14c>)
 8004f2c:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004f2e:	2201      	movs	r2, #1
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8004f30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004f32:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004f36:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004f38:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8004f3c:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
}
 8004f40:	b008      	add	sp, #32
 8004f42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8004f46:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return HAL_ERROR;
 8004f48:	2701      	movs	r7, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8004f4a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8004f4e:	6383      	str	r3, [r0, #56]	; 0x38
}
 8004f50:	4638      	mov	r0, r7
 8004f52:	b008      	add	sp, #32
 8004f54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8004f58:	2390      	movs	r3, #144	; 0x90
 8004f5a:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 8004f5c:	f001 fe3e 	bl	8006bdc <SDMMC_CmdWriteSingleBlock>
 8004f60:	4680      	mov	r8, r0
 8004f62:	9001      	str	r0, [sp, #4]
    if(errorstate != HAL_SD_ERROR_NONE)
 8004f64:	f1b8 0f00 	cmp.w	r8, #0
 8004f68:	d1a0      	bne.n	8004eac <HAL_SD_WriteBlocks_DMA+0x64>
 8004f6a:	e7bc      	b.n	8004ee6 <HAL_SD_WriteBlocks_DMA+0x9e>
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8004f6c:	f04f 33ff 	mov.w	r3, #4294967295
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8004f70:	2290      	movs	r2, #144	; 0x90
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004f72:	6820      	ldr	r0, [r4, #0]
 8004f74:	a902      	add	r1, sp, #8
      return HAL_OK;
 8004f76:	4647      	mov	r7, r8
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8004f78:	e9cd 3502 	strd	r3, r5, [sp, #8]
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8004f7c:	2301      	movs	r3, #1
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 8004f7e:	e9cd 2804 	strd	r2, r8, [sp, #16]
      config.DPSM          = SDMMC_DPSM_ENABLE;
 8004f82:	e9cd 8306 	strd	r8, r3, [sp, #24]
      (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004f86:	f001 fc2f 	bl	80067e8 <SDMMC_ConfigData>
      return HAL_OK;
 8004f8a:	e7a0      	b.n	8004ece <HAL_SD_WriteBlocks_DMA+0x86>
 8004f8c:	08004c15 	.word	0x08004c15
 8004f90:	08004fe5 	.word	0x08004fe5
 8004f94:	004005ff 	.word	0x004005ff

08004f98 <HAL_SD_ErrorCallback>:
 8004f98:	4770      	bx	lr
 8004f9a:	bf00      	nop

08004f9c <SD_DMAReceiveCplt>:
{
 8004f9c:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8004f9e:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
 8004fa0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004fa2:	2b82      	cmp	r3, #130	; 0x82
 8004fa4:	d011      	beq.n	8004fca <SD_DMAReceiveCplt+0x2e>
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 8004fa6:	6823      	ldr	r3, [r4, #0]
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8004fa8:	f240 503a 	movw	r0, #1338	; 0x53a
  hsd->State = HAL_SD_STATE_READY;
 8004fac:	f04f 0c01 	mov.w	ip, #1
  hsd->Context = SD_CONTEXT_NONE;
 8004fb0:	2100      	movs	r1, #0
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 8004fb2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004fb4:	f022 0208 	bic.w	r2, r2, #8
 8004fb8:	62da      	str	r2, [r3, #44]	; 0x2c
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8004fba:	6398      	str	r0, [r3, #56]	; 0x38
  HAL_SD_RxCpltCallback(hsd);
 8004fbc:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_READY;
 8004fbe:	f884 c034 	strb.w	ip, [r4, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8004fc2:	6321      	str	r1, [r4, #48]	; 0x30
  HAL_SD_RxCpltCallback(hsd);
 8004fc4:	f002 fd18 	bl	80079f8 <HAL_SD_RxCpltCallback>
}
 8004fc8:	bd10      	pop	{r4, pc}
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8004fca:	6820      	ldr	r0, [r4, #0]
 8004fcc:	f001 ff48 	bl	8006e60 <SDMMC_CmdStopTransfer>
    if(errorstate != HAL_SD_ERROR_NONE)
 8004fd0:	4603      	mov	r3, r0
 8004fd2:	2800      	cmp	r0, #0
 8004fd4:	d0e7      	beq.n	8004fa6 <SD_DMAReceiveCplt+0xa>
      hsd->ErrorCode |= errorstate;
 8004fd6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      HAL_SD_ErrorCallback(hsd);
 8004fd8:	4620      	mov	r0, r4
      hsd->ErrorCode |= errorstate;
 8004fda:	4313      	orrs	r3, r2
 8004fdc:	63a3      	str	r3, [r4, #56]	; 0x38
      HAL_SD_ErrorCallback(hsd);
 8004fde:	f7ff ffdb 	bl	8004f98 <HAL_SD_ErrorCallback>
 8004fe2:	e7e0      	b.n	8004fa6 <SD_DMAReceiveCplt+0xa>

08004fe4 <SD_DMAError>:
{
 8004fe4:	b510      	push	{r4, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8004fe6:	6b84      	ldr	r4, [r0, #56]	; 0x38
  if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 8004fe8:	f7fe fb40 	bl	800366c <HAL_DMA_GetError>
 8004fec:	2802      	cmp	r0, #2
 8004fee:	d00a      	beq.n	8005006 <SD_DMAError+0x22>
    TxErrorCode = hsd->hdmatx->ErrorCode;  
 8004ff0:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
    RxErrorCode = hsd->hdmarx->ErrorCode;
 8004ff4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    TxErrorCode = hsd->hdmatx->ErrorCode;  
 8004ff6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    if((RxErrorCode == HAL_DMA_ERROR_TE) || (TxErrorCode == HAL_DMA_ERROR_TE))
 8004ff8:	2b01      	cmp	r3, #1
 8004ffa:	d005      	beq.n	8005008 <SD_DMAError+0x24>
 8004ffc:	2a01      	cmp	r2, #1
 8004ffe:	d003      	beq.n	8005008 <SD_DMAError+0x24>
    HAL_SD_ErrorCallback(hsd);
 8005000:	4620      	mov	r0, r4
 8005002:	f7ff ffc9 	bl	8004f98 <HAL_SD_ErrorCallback>
}
 8005006:	bd10      	pop	{r4, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005008:	6820      	ldr	r0, [r4, #0]
 800500a:	4b14      	ldr	r3, [pc, #80]	; (800505c <SD_DMAError+0x78>)
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800500c:	6d21      	ldr	r1, [r4, #80]	; 0x50
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800500e:	6383      	str	r3, [r0, #56]	; 0x38
      __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 8005010:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8005012:	0409      	lsls	r1, r1, #16
      __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 8005014:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
 8005018:	63c3      	str	r3, [r0, #60]	; 0x3c
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 800501a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800501c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8005020:	63a3      	str	r3, [r4, #56]	; 0x38
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8005022:	f002 fbbd 	bl	80077a0 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005026:	b158      	cbz	r0, 8005040 <SD_DMAError+0x5c>
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8005028:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800502a:	4318      	orrs	r0, r3
 800502c:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
 800502e:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 8005030:	2300      	movs	r3, #0
    HAL_SD_ErrorCallback(hsd);
 8005032:	4620      	mov	r0, r4
      hsd->State= HAL_SD_STATE_READY;
 8005034:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8005038:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_SD_ErrorCallback(hsd);
 800503a:	f7ff ffad 	bl	8004f98 <HAL_SD_ErrorCallback>
 800503e:	e7e2      	b.n	8005006 <SD_DMAError+0x22>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8005040:	4601      	mov	r1, r0
 8005042:	6820      	ldr	r0, [r4, #0]
 8005044:	f001 fbcc 	bl	80067e0 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 8005048:	f3c0 2043 	ubfx	r0, r0, #9, #4
      if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 800504c:	3805      	subs	r0, #5
 800504e:	2801      	cmp	r0, #1
 8005050:	d8ed      	bhi.n	800502e <SD_DMAError+0x4a>
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8005052:	6820      	ldr	r0, [r4, #0]
 8005054:	f001 ff04 	bl	8006e60 <SDMMC_CmdStopTransfer>
 8005058:	e7e6      	b.n	8005028 <SD_DMAError+0x44>
 800505a:	bf00      	nop
 800505c:	004005ff 	.word	0x004005ff

08005060 <SD_DMATxAbort>:
{
 8005060:	b538      	push	{r3, r4, r5, lr}
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8005062:	6b84      	ldr	r4, [r0, #56]	; 0x38
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8005064:	f240 533a 	movw	r3, #1338	; 0x53a
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8005068:	6d21      	ldr	r1, [r4, #80]	; 0x50
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800506a:	6820      	ldr	r0, [r4, #0]
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800506c:	0409      	lsls	r1, r1, #16
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800506e:	6383      	str	r3, [r0, #56]	; 0x38
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8005070:	f002 fb96 	bl	80077a0 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005074:	4605      	mov	r5, r0
 8005076:	b180      	cbz	r0, 800509a <SD_DMATxAbort+0x3a>
    hsd->ErrorCode |= errorstate;
 8005078:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 800507a:	2201      	movs	r2, #1
  hsd->Context = SD_CONTEXT_NONE;
 800507c:	2300      	movs	r3, #0
    hsd->ErrorCode |= errorstate;
 800507e:	4328      	orrs	r0, r5
 8005080:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 8005082:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8005086:	6323      	str	r3, [r4, #48]	; 0x30
  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
 8005088:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    HAL_SD_AbortCallback(hsd);
 800508a:	4620      	mov	r0, r4
  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
 800508c:	b913      	cbnz	r3, 8005094 <SD_DMATxAbort+0x34>
    HAL_SD_AbortCallback(hsd);
 800508e:	f002 fcab 	bl	80079e8 <HAL_SD_AbortCallback>
}
 8005092:	bd38      	pop	{r3, r4, r5, pc}
    HAL_SD_ErrorCallback(hsd);
 8005094:	f7ff ff80 	bl	8004f98 <HAL_SD_ErrorCallback>
}
 8005098:	bd38      	pop	{r3, r4, r5, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800509a:	4601      	mov	r1, r0
 800509c:	6820      	ldr	r0, [r4, #0]
 800509e:	f001 fb9f 	bl	80067e0 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 80050a2:	f3c0 2043 	ubfx	r0, r0, #9, #4
  hsd->State = HAL_SD_STATE_READY;
 80050a6:	2301      	movs	r3, #1
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80050a8:	3805      	subs	r0, #5
  hsd->State = HAL_SD_STATE_READY;
 80050aa:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80050ae:	4298      	cmp	r0, r3
  hsd->Context = SD_CONTEXT_NONE;
 80050b0:	6325      	str	r5, [r4, #48]	; 0x30
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 80050b2:	d8e9      	bhi.n	8005088 <SD_DMATxAbort+0x28>
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 80050b4:	6820      	ldr	r0, [r4, #0]
 80050b6:	f001 fed3 	bl	8006e60 <SDMMC_CmdStopTransfer>
 80050ba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80050bc:	4318      	orrs	r0, r3
 80050be:	63a0      	str	r0, [r4, #56]	; 0x38
 80050c0:	e7e2      	b.n	8005088 <SD_DMATxAbort+0x28>
 80050c2:	bf00      	nop

080050c4 <HAL_SD_IRQHandler>:
{
 80050c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80050c8:	4604      	mov	r4, r0
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 80050ca:	6800      	ldr	r0, [r0, #0]
{
 80050cc:	b082      	sub	sp, #8
  uint32_t context = hsd->Context;
 80050ce:	6b25      	ldr	r5, [r4, #48]	; 0x30
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 80050d0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80050d2:	041a      	lsls	r2, r3, #16
 80050d4:	d51b      	bpl.n	800510e <HAL_SD_IRQHandler+0x4a>
 80050d6:	072b      	lsls	r3, r5, #28
 80050d8:	f100 80b4 	bmi.w	8005244 <HAL_SD_IRQHandler+0x180>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
 80050dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80050de:	05db      	lsls	r3, r3, #23
 80050e0:	d569      	bpl.n	80051b6 <HAL_SD_IRQHandler+0xf2>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 80050e2:	f44f 7280 	mov.w	r2, #256	; 0x100
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 80050e6:	4b8a      	ldr	r3, [pc, #552]	; (8005310 <HAL_SD_IRQHandler+0x24c>)
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 80050e8:	6382      	str	r2, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 80050ea:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80050ec:	4013      	ands	r3, r2
 80050ee:	63c3      	str	r3, [r0, #60]	; 0x3c
    hsd->Instance->DCTRL &= ~(SDMMC_DCTRL_DTEN);
 80050f0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80050f2:	f023 0301 	bic.w	r3, r3, #1
 80050f6:	62c3      	str	r3, [r0, #44]	; 0x2c
    else if((context & SD_CONTEXT_DMA) != 0U)
 80050f8:	062a      	lsls	r2, r5, #24
 80050fa:	d505      	bpl.n	8005108 <HAL_SD_IRQHandler+0x44>
      if((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 80050fc:	06ab      	lsls	r3, r5, #26
 80050fe:	f100 80f1 	bmi.w	80052e4 <HAL_SD_IRQHandler+0x220>
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) == 0U) && ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == 0U))
 8005102:	07af      	lsls	r7, r5, #30
 8005104:	f000 80c0 	beq.w	8005288 <HAL_SD_IRQHandler+0x1c4>
}
 8005108:	b002      	add	sp, #8
 800510a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
 800510e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8005110:	05df      	lsls	r7, r3, #23
 8005112:	d523      	bpl.n	800515c <HAL_SD_IRQHandler+0x98>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 8005114:	f44f 7280 	mov.w	r2, #256	; 0x100
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 8005118:	4b7d      	ldr	r3, [pc, #500]	; (8005310 <HAL_SD_IRQHandler+0x24c>)
    if((context & SD_CONTEXT_IT) != 0U)
 800511a:	072e      	lsls	r6, r5, #28
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
 800511c:	6382      	str	r2, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 800511e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8005120:	ea03 0302 	and.w	r3, r3, r2
 8005124:	63c3      	str	r3, [r0, #60]	; 0x3c
    hsd->Instance->DCTRL &= ~(SDMMC_DCTRL_DTEN);
 8005126:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005128:	f023 0301 	bic.w	r3, r3, #1
 800512c:	62c3      	str	r3, [r0, #44]	; 0x2c
    if((context & SD_CONTEXT_IT) != 0U)
 800512e:	d5e3      	bpl.n	80050f8 <HAL_SD_IRQHandler+0x34>
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 8005130:	f015 0f22 	tst.w	r5, #34	; 0x22
 8005134:	f040 80b6 	bne.w	80052a4 <HAL_SD_IRQHandler+0x1e0>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8005138:	f240 533a 	movw	r3, #1338	; 0x53a
      hsd->State = HAL_SD_STATE_READY;
 800513c:	2201      	movs	r2, #1
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 800513e:	07a9      	lsls	r1, r5, #30
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8005140:	6383      	str	r3, [r0, #56]	; 0x38
      hsd->Context = SD_CONTEXT_NONE;
 8005142:	f04f 0300 	mov.w	r3, #0
      hsd->State = HAL_SD_STATE_READY;
 8005146:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
        HAL_SD_RxCpltCallback(hsd);
 800514a:	4620      	mov	r0, r4
      hsd->Context = SD_CONTEXT_NONE;
 800514c:	6323      	str	r3, [r4, #48]	; 0x30
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 800514e:	f000 80a4 	beq.w	800529a <HAL_SD_IRQHandler+0x1d6>
        HAL_SD_RxCpltCallback(hsd);
 8005152:	f002 fc51 	bl	80079f8 <HAL_SD_RxCpltCallback>
}
 8005156:	b002      	add	sp, #8
 8005158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 800515c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800515e:	045e      	lsls	r6, r3, #17
 8005160:	d52a      	bpl.n	80051b8 <HAL_SD_IRQHandler+0xf4>
 8005162:	0729      	lsls	r1, r5, #28
 8005164:	d528      	bpl.n	80051b8 <HAL_SD_IRQHandler+0xf4>
{
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pTxBuffPtr;
  dataremaining = hsd->TxXferSize;
 8005166:	6a66      	ldr	r6, [r4, #36]	; 0x24

  if (dataremaining > 0U)
 8005168:	2e00      	cmp	r6, #0
 800516a:	d0cd      	beq.n	8005108 <HAL_SD_IRQHandler+0x44>
  tmp = hsd->pTxBuffPtr;
 800516c:	6a27      	ldr	r7, [r4, #32]
 800516e:	f107 0804 	add.w	r8, r7, #4
 8005172:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8005176:	e000      	b.n	800517a <HAL_SD_IRQHandler+0xb6>
      tmp++;
      dataremaining--;
      data |= ((uint32_t)(*tmp) << 24U);
      tmp++;
      dataremaining--;
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 8005178:	6820      	ldr	r0, [r4, #0]
      data = (uint32_t)(*tmp);
 800517a:	f818 3c04 	ldrb.w	r3, [r8, #-4]
    for(count = 0U; count < 8U; count++)
 800517e:	f108 0804 	add.w	r8, r8, #4
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 8005182:	a901      	add	r1, sp, #4
      data = (uint32_t)(*tmp);
 8005184:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 8U);
 8005186:	f818 2c07 	ldrb.w	r2, [r8, #-7]
 800518a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800518e:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 16U);
 8005190:	f818 2c06 	ldrb.w	r2, [r8, #-6]
 8005194:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8005198:	9301      	str	r3, [sp, #4]
      data |= ((uint32_t)(*tmp) << 24U);
 800519a:	f818 2c05 	ldrb.w	r2, [r8, #-5]
 800519e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80051a2:	9301      	str	r3, [sp, #4]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 80051a4:	f001 fb0c 	bl	80067c0 <SDMMC_WriteFIFO>
    for(count = 0U; count < 8U; count++)
 80051a8:	45a8      	cmp	r8, r5
 80051aa:	d1e5      	bne.n	8005178 <HAL_SD_IRQHandler+0xb4>
      tmp++;
 80051ac:	3720      	adds	r7, #32
      dataremaining--;
 80051ae:	3e20      	subs	r6, #32
    }

    hsd->pTxBuffPtr = tmp;
    hsd->TxXferSize = dataremaining;
 80051b0:	e9c4 7608 	strd	r7, r6, [r4, #32]
  }
}
 80051b4:	e7a8      	b.n	8005108 <HAL_SD_IRQHandler+0x44>
  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 80051b6:	6b43      	ldr	r3, [r0, #52]	; 0x34
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
 80051b8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80051ba:	f013 0f3a 	tst.w	r3, #58	; 0x3a
 80051be:	d0a3      	beq.n	8005108 <HAL_SD_IRQHandler+0x44>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL) != RESET)
 80051c0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80051c2:	079a      	lsls	r2, r3, #30
 80051c4:	d503      	bpl.n	80051ce <HAL_SD_IRQHandler+0x10a>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 80051c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80051c8:	f043 0302 	orr.w	r3, r3, #2
 80051cc:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT) != RESET)
 80051ce:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80051d0:	071b      	lsls	r3, r3, #28
 80051d2:	d503      	bpl.n	80051dc <HAL_SD_IRQHandler+0x118>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 80051d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80051d6:	f043 0308 	orr.w	r3, r3, #8
 80051da:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR) != RESET)
 80051dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80051de:	069f      	lsls	r7, r3, #26
 80051e0:	d503      	bpl.n	80051ea <HAL_SD_IRQHandler+0x126>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 80051e2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80051e4:	f043 0320 	orr.w	r3, r3, #32
 80051e8:	63a3      	str	r3, [r4, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR) != RESET)
 80051ea:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80051ec:	06de      	lsls	r6, r3, #27
 80051ee:	d503      	bpl.n	80051f8 <HAL_SD_IRQHandler+0x134>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 80051f0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80051f2:	f043 0310 	orr.w	r3, r3, #16
 80051f6:	63a3      	str	r3, [r4, #56]	; 0x38
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 80051f8:	f240 533a 	movw	r3, #1338	; 0x53a
 80051fc:	6383      	str	r3, [r0, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
 80051fe:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8005200:	f423 739d 	bic.w	r3, r3, #314	; 0x13a
 8005204:	63c3      	str	r3, [r0, #60]	; 0x3c
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8005206:	f001 fe2b 	bl	8006e60 <SDMMC_CmdStopTransfer>
 800520a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    if((context & SD_CONTEXT_IT) != 0U)
 800520c:	0729      	lsls	r1, r5, #28
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 800520e:	ea40 0003 	orr.w	r0, r0, r3
 8005212:	63a0      	str	r0, [r4, #56]	; 0x38
    if((context & SD_CONTEXT_IT) != 0U)
 8005214:	d44c      	bmi.n	80052b0 <HAL_SD_IRQHandler+0x1ec>
    else if((context & SD_CONTEXT_DMA) != 0U)
 8005216:	062a      	lsls	r2, r5, #24
 8005218:	f57f af76 	bpl.w	8005108 <HAL_SD_IRQHandler+0x44>
      if(((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 800521c:	f015 0f30 	tst.w	r5, #48	; 0x30
 8005220:	d156      	bne.n	80052d0 <HAL_SD_IRQHandler+0x20c>
      else if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 8005222:	f015 0503 	ands.w	r5, r5, #3
 8005226:	d06a      	beq.n	80052fe <HAL_SD_IRQHandler+0x23a>
        hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
 8005228:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800522a:	4b3a      	ldr	r3, [pc, #232]	; (8005314 <HAL_SD_IRQHandler+0x250>)
 800522c:	6503      	str	r3, [r0, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
 800522e:	f7fe f919 	bl	8003464 <HAL_DMA_Abort_IT>
 8005232:	2800      	cmp	r0, #0
 8005234:	f43f af68 	beq.w	8005108 <HAL_SD_IRQHandler+0x44>
          SD_DMARxAbort(hsd->hdmarx);
 8005238:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
 800523a:	b002      	add	sp, #8
 800523c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
          SD_DMARxAbort(hsd->hdmarx);
 8005240:	f7ff bf0e 	b.w	8005060 <SD_DMATxAbort>
  dataremaining = hsd->RxXferSize;
 8005244:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  if (dataremaining > 0U)
 8005246:	2e00      	cmp	r6, #0
 8005248:	f43f af5e 	beq.w	8005108 <HAL_SD_IRQHandler+0x44>
  tmp = hsd->pRxBuffPtr;
 800524c:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 800524e:	f107 0804 	add.w	r8, r7, #4
 8005252:	f107 0524 	add.w	r5, r7, #36	; 0x24
 8005256:	e000      	b.n	800525a <HAL_SD_IRQHandler+0x196>
      data = SDMMC_ReadFIFO(hsd->Instance);
 8005258:	6820      	ldr	r0, [r4, #0]
    for(count = 0U; count < 8U; count++)
 800525a:	f108 0804 	add.w	r8, r8, #4
      data = SDMMC_ReadFIFO(hsd->Instance);
 800525e:	f001 faab 	bl	80067b8 <SDMMC_ReadFIFO>
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8005262:	0a02      	lsrs	r2, r0, #8
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8005264:	0c03      	lsrs	r3, r0, #16
      *tmp = (uint8_t)(data & 0xFFU);
 8005266:	f808 0c08 	strb.w	r0, [r8, #-8]
    for(count = 0U; count < 8U; count++)
 800526a:	45a8      	cmp	r8, r5
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 800526c:	ea4f 6010 	mov.w	r0, r0, lsr #24
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 8005270:	f808 2c07 	strb.w	r2, [r8, #-7]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 8005274:	f808 3c06 	strb.w	r3, [r8, #-6]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 8005278:	f808 0c05 	strb.w	r0, [r8, #-5]
    for(count = 0U; count < 8U; count++)
 800527c:	d1ec      	bne.n	8005258 <HAL_SD_IRQHandler+0x194>
      tmp++;
 800527e:	3720      	adds	r7, #32
      dataremaining--;
 8005280:	3e20      	subs	r6, #32
    hsd->RxXferSize = dataremaining;
 8005282:	e9c4 760a 	strd	r7, r6, [r4, #40]	; 0x28
 8005286:	e73f      	b.n	8005108 <HAL_SD_IRQHandler+0x44>
        hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 8005288:	6822      	ldr	r2, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
 800528a:	2101      	movs	r1, #1
        HAL_SD_TxCpltCallback(hsd);
 800528c:	4620      	mov	r0, r4
        hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
 800528e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005290:	f023 0308 	bic.w	r3, r3, #8
 8005294:	62d3      	str	r3, [r2, #44]	; 0x2c
        hsd->State = HAL_SD_STATE_READY;
 8005296:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        HAL_SD_TxCpltCallback(hsd);
 800529a:	f002 fba9 	bl	80079f0 <HAL_SD_TxCpltCallback>
}
 800529e:	b002      	add	sp, #8
 80052a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80052a4:	f001 fddc 	bl	8006e60 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 80052a8:	4603      	mov	r3, r0
 80052aa:	b950      	cbnz	r0, 80052c2 <HAL_SD_IRQHandler+0x1fe>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 80052ac:	6820      	ldr	r0, [r4, #0]
 80052ae:	e743      	b.n	8005138 <HAL_SD_IRQHandler+0x74>
      hsd->State = HAL_SD_STATE_READY;
 80052b0:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 80052b2:	2300      	movs	r3, #0
      HAL_SD_ErrorCallback(hsd);
 80052b4:	4620      	mov	r0, r4
      hsd->State = HAL_SD_STATE_READY;
 80052b6:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80052ba:	6323      	str	r3, [r4, #48]	; 0x30
      HAL_SD_ErrorCallback(hsd);
 80052bc:	f7ff fe6c 	bl	8004f98 <HAL_SD_ErrorCallback>
 80052c0:	e722      	b.n	8005108 <HAL_SD_IRQHandler+0x44>
          hsd->ErrorCode |= errorstate;
 80052c2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 80052c4:	4620      	mov	r0, r4
          hsd->ErrorCode |= errorstate;
 80052c6:	4313      	orrs	r3, r2
 80052c8:	63a3      	str	r3, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 80052ca:	f7ff fe65 	bl	8004f98 <HAL_SD_ErrorCallback>
 80052ce:	e7ed      	b.n	80052ac <HAL_SD_IRQHandler+0x1e8>
        hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
 80052d0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80052d2:	4b11      	ldr	r3, [pc, #68]	; (8005318 <HAL_SD_IRQHandler+0x254>)
 80052d4:	6503      	str	r3, [r0, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
 80052d6:	f7fe f8c5 	bl	8003464 <HAL_DMA_Abort_IT>
 80052da:	2800      	cmp	r0, #0
 80052dc:	f43f af14 	beq.w	8005108 <HAL_SD_IRQHandler+0x44>
          SD_DMATxAbort(hsd->hdmatx);
 80052e0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80052e2:	e7aa      	b.n	800523a <HAL_SD_IRQHandler+0x176>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80052e4:	f001 fdbc 	bl	8006e60 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 80052e8:	4603      	mov	r3, r0
 80052ea:	2800      	cmp	r0, #0
 80052ec:	f43f af09 	beq.w	8005102 <HAL_SD_IRQHandler+0x3e>
          hsd->ErrorCode |= errorstate;
 80052f0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 80052f2:	4620      	mov	r0, r4
          hsd->ErrorCode |= errorstate;
 80052f4:	4313      	orrs	r3, r2
 80052f6:	63a3      	str	r3, [r4, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
 80052f8:	f7ff fe4e 	bl	8004f98 <HAL_SD_ErrorCallback>
 80052fc:	e701      	b.n	8005102 <HAL_SD_IRQHandler+0x3e>
        hsd->State = HAL_SD_STATE_READY;
 80052fe:	2301      	movs	r3, #1
        hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8005300:	63a5      	str	r5, [r4, #56]	; 0x38
        HAL_SD_AbortCallback(hsd);
 8005302:	4620      	mov	r0, r4
        hsd->State = HAL_SD_STATE_READY;
 8005304:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8005308:	6325      	str	r5, [r4, #48]	; 0x30
        HAL_SD_AbortCallback(hsd);
 800530a:	f002 fb6d 	bl	80079e8 <HAL_SD_AbortCallback>
}
 800530e:	e6fb      	b.n	8005108 <HAL_SD_IRQHandler+0x44>
 8005310:	ffff3ec5 	.word	0xffff3ec5
 8005314:	0800531d 	.word	0x0800531d
 8005318:	08005061 	.word	0x08005061

0800531c <SD_DMARxAbort>:
 800531c:	b538      	push	{r3, r4, r5, lr}
 800531e:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8005320:	f240 533a 	movw	r3, #1338	; 0x53a
 8005324:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8005326:	6820      	ldr	r0, [r4, #0]
 8005328:	0409      	lsls	r1, r1, #16
 800532a:	6383      	str	r3, [r0, #56]	; 0x38
 800532c:	f002 fa38 	bl	80077a0 <SDMMC_CmdSendStatus>
 8005330:	4605      	mov	r5, r0
 8005332:	b180      	cbz	r0, 8005356 <SD_DMARxAbort+0x3a>
 8005334:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8005336:	2201      	movs	r2, #1
 8005338:	2300      	movs	r3, #0
 800533a:	4328      	orrs	r0, r5
 800533c:	63a0      	str	r0, [r4, #56]	; 0x38
 800533e:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
 8005342:	6323      	str	r3, [r4, #48]	; 0x30
 8005344:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005346:	4620      	mov	r0, r4
 8005348:	b913      	cbnz	r3, 8005350 <SD_DMARxAbort+0x34>
 800534a:	f002 fb4d 	bl	80079e8 <HAL_SD_AbortCallback>
 800534e:	bd38      	pop	{r3, r4, r5, pc}
 8005350:	f7ff fe22 	bl	8004f98 <HAL_SD_ErrorCallback>
 8005354:	bd38      	pop	{r3, r4, r5, pc}
 8005356:	4601      	mov	r1, r0
 8005358:	6820      	ldr	r0, [r4, #0]
 800535a:	f001 fa41 	bl	80067e0 <SDMMC_GetResponse>
 800535e:	f3c0 2043 	ubfx	r0, r0, #9, #4
 8005362:	2301      	movs	r3, #1
 8005364:	3805      	subs	r0, #5
 8005366:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800536a:	4298      	cmp	r0, r3
 800536c:	6325      	str	r5, [r4, #48]	; 0x30
 800536e:	d8e9      	bhi.n	8005344 <SD_DMARxAbort+0x28>
 8005370:	6820      	ldr	r0, [r4, #0]
 8005372:	f001 fd75 	bl	8006e60 <SDMMC_CmdStopTransfer>
 8005376:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005378:	4318      	orrs	r0, r3
 800537a:	63a0      	str	r0, [r4, #56]	; 0x38
 800537c:	e7e2      	b.n	8005344 <SD_DMARxAbort+0x28>
 800537e:	bf00      	nop

08005380 <HAL_SD_GetCardCSD>:
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8005380:	6e42      	ldr	r2, [r0, #100]	; 0x64
{
 8005382:	4603      	mov	r3, r0
 8005384:	b410      	push	{r4}
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8005386:	f3c2 6083 	ubfx	r0, r2, #26, #4
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 800538a:	0f94      	lsrs	r4, r2, #30
 800538c:	700c      	strb	r4, [r1, #0]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 800538e:	f3c2 6401 	ubfx	r4, r2, #24, #2
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 8005392:	7048      	strb	r0, [r1, #1]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8005394:	f3c2 4007 	ubfx	r0, r2, #16, #8
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8005398:	708c      	strb	r4, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800539a:	70c8      	strb	r0, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800539c:	f3c2 2007 	ubfx	r0, r2, #8, #8
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 80053a0:	b2d2      	uxtb	r2, r2
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 80053a2:	7108      	strb	r0, [r1, #4]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 80053a4:	2000      	movs	r0, #0
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 80053a6:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 80053a8:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80053aa:	0d14      	lsrs	r4, r2, #20
 80053ac:	80cc      	strh	r4, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 80053ae:	f3c2 4403 	ubfx	r4, r2, #16, #4
 80053b2:	720c      	strb	r4, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 80053b4:	f3c2 34c0 	ubfx	r4, r2, #15, #1
 80053b8:	724c      	strb	r4, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 80053ba:	f3c2 3480 	ubfx	r4, r2, #14, #1
 80053be:	728c      	strb	r4, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 80053c0:	f3c2 3440 	ubfx	r4, r2, #13, #1
 80053c4:	72cc      	strb	r4, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 80053c6:	f3c2 3400 	ubfx	r4, r2, #12, #1
 80053ca:	730c      	strb	r4, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 80053cc:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 80053ce:	6c58      	ldr	r0, [r3, #68]	; 0x44
 80053d0:	2800      	cmp	r0, #0
 80053d2:	d170      	bne.n	80054b6 <HAL_SD_GetCardCSD+0x136>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 80053d4:	f640 74fc 	movw	r4, #4092	; 0xffc
 80053d8:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
 80053da:	ea04 0282 	and.w	r2, r4, r2, lsl #2
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 80053de:	f3c0 64c2 	ubfx	r4, r0, #27, #3
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 80053e2:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
 80053e6:	610a      	str	r2, [r1, #16]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 80053e8:	f3c0 5242 	ubfx	r2, r0, #21, #3
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 80053ec:	750c      	strb	r4, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 80053ee:	f3c0 6402 	ubfx	r4, r0, #24, #3
 80053f2:	754c      	strb	r4, [r1, #21]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80053f4:	f3c0 4482 	ubfx	r4, r0, #18, #3
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 80053f8:	758a      	strb	r2, [r1, #22]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80053fa:	f3c0 32c2 	ubfx	r2, r0, #15, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80053fe:	75cc      	strb	r4, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 8005400:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8005402:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 8005404:	7e0c      	ldrb	r4, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 8005406:	3201      	adds	r2, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 8005408:	f004 0407 	and.w	r4, r4, #7
 800540c:	3402      	adds	r4, #2
 800540e:	fa02 f404 	lsl.w	r4, r2, r4
 8005412:	655c      	str	r4, [r3, #84]	; 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 8005414:	7a0a      	ldrb	r2, [r1, #8]
 8005416:	f002 0c0f 	and.w	ip, r2, #15
 800541a:	2201      	movs	r2, #1
 800541c:	fa02 f20c 	lsl.w	r2, r2, ip
 8005420:	659a      	str	r2, [r3, #88]	; 0x58
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 8005422:	0a52      	lsrs	r2, r2, #9
 8005424:	fb04 f202 	mul.w	r2, r4, r2
    hsd->SdCard.LogBlockSize = 512U;
 8005428:	f44f 7400 	mov.w	r4, #512	; 0x200
 800542c:	e9c3 2417 	strd	r2, r4, [r3, #92]	; 0x5c
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8005430:	f3c0 14c6 	ubfx	r4, r0, #7, #7
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8005434:	f000 027f 	and.w	r2, r0, #127	; 0x7f
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 8005438:	f3c0 3c80 	ubfx	ip, r0, #14, #1
  pCSD->Reserved3 = 0;
 800543c:	2000      	movs	r0, #0
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800543e:	f881 c019 	strb.w	ip, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8005442:	768c      	strb	r4, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8005444:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 8005446:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005448:	0fdc      	lsrs	r4, r3, #31
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 800544a:	f3c3 7241 	ubfx	r2, r3, #29, #2
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800544e:	770c      	strb	r4, [r1, #28]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 8005450:	f3c3 6482 	ubfx	r4, r3, #26, #3
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8005454:	774a      	strb	r2, [r1, #29]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8005456:	f3c3 5283 	ubfx	r2, r3, #22, #4
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800545a:	778c      	strb	r4, [r1, #30]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800545c:	f3c3 5440 	ubfx	r4, r3, #21, #1
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8005460:	77ca      	strb	r2, [r1, #31]
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8005462:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8005466:	f881 4020 	strb.w	r4, [r1, #32]
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800546a:	f3c3 34c0 	ubfx	r4, r3, #15, #1
  pCSD->Reserved3 = 0;
 800546e:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8005472:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8005476:	f3c3 3280 	ubfx	r2, r3, #14, #1
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800547a:	f881 4023 	strb.w	r4, [r1, #35]	; 0x23
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800547e:	f3c3 3440 	ubfx	r4, r3, #13, #1
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8005482:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8005486:	f3c3 3200 	ubfx	r2, r3, #12, #1
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800548a:	f881 4025 	strb.w	r4, [r1, #37]	; 0x25
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800548e:	f3c3 2481 	ubfx	r4, r3, #10, #2
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8005492:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8005496:	f3c3 2201 	ubfx	r2, r3, #8, #2
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800549a:	f881 4027 	strb.w	r4, [r1, #39]	; 0x27
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800549e:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 80054a2:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->Reserved4 = 1;
 80054a6:	2201      	movs	r2, #1
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 80054a8:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 80054ac:	f881 202a 	strb.w	r2, [r1, #42]	; 0x2a
}
 80054b0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80054b4:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 80054b6:	2801      	cmp	r0, #1
 80054b8:	d110      	bne.n	80054dc <HAL_SD_GetCardCSD+0x15c>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 80054ba:	0412      	lsls	r2, r2, #16
 80054bc:	6ed8      	ldr	r0, [r3, #108]	; 0x6c
    hsd->SdCard.BlockSize = 512U;
 80054be:	f44f 7400 	mov.w	r4, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 80054c2:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 80054c6:	ea42 4210 	orr.w	r2, r2, r0, lsr #16
 80054ca:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 80054cc:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
 80054ce:	659c      	str	r4, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 80054d0:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 80054d2:	661c      	str	r4, [r3, #96]	; 0x60
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 80054d4:	0292      	lsls	r2, r2, #10
 80054d6:	655a      	str	r2, [r3, #84]	; 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 80054d8:	65da      	str	r2, [r3, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 80054da:	e7a9      	b.n	8005430 <HAL_SD_GetCardCSD+0xb0>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80054dc:	681a      	ldr	r2, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
 80054de:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 80054e0:	4805      	ldr	r0, [pc, #20]	; (80054f8 <HAL_SD_GetCardCSD+0x178>)
 80054e2:	6390      	str	r0, [r2, #56]	; 0x38
    return HAL_ERROR;
 80054e4:	4608      	mov	r0, r1
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80054e6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80054e8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80054ec:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80054ee:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
 80054f2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80054f6:	4770      	bx	lr
 80054f8:	004005ff 	.word	0x004005ff

080054fc <HAL_SD_InitCard>:
{
 80054fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 80054fe:	2200      	movs	r2, #0
{
 8005500:	b099      	sub	sp, #100	; 0x64
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8005502:	2376      	movs	r3, #118	; 0x76
 8005504:	2600      	movs	r6, #0
 8005506:	2700      	movs	r7, #0
{
 8005508:	4605      	mov	r5, r0
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800550a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  status = SDMMC_Init(hsd->Instance, Init);
 800550e:	aa09      	add	r2, sp, #36	; 0x24
 8005510:	ab06      	add	r3, sp, #24
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8005512:	e9cd 6708 	strd	r6, r7, [sp, #32]
  status = SDMMC_Init(hsd->Instance, Init);
 8005516:	ca07      	ldmia	r2, {r0, r1, r2}
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 8005518:	e9cd 6706 	strd	r6, r7, [sp, #24]
  status = SDMMC_Init(hsd->Instance, Init);
 800551c:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8005520:	cb0e      	ldmia	r3, {r1, r2, r3}
 8005522:	6828      	ldr	r0, [r5, #0]
 8005524:	f001 f92a 	bl	800677c <SDMMC_Init>
  if(status != HAL_OK)
 8005528:	b118      	cbz	r0, 8005532 <HAL_SD_InitCard+0x36>
    return HAL_ERROR;
 800552a:	2601      	movs	r6, #1
}
 800552c:	4630      	mov	r0, r6
 800552e:	b019      	add	sp, #100	; 0x64
 8005530:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_SD_DISABLE(hsd);
 8005532:	4604      	mov	r4, r0
 8005534:	6828      	ldr	r0, [r5, #0]
 8005536:	6843      	ldr	r3, [r0, #4]
 8005538:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800553c:	6043      	str	r3, [r0, #4]
  (void)SDMMC_PowerState_ON(hsd->Instance);
 800553e:	f001 f945 	bl	80067cc <SDMMC_PowerState_ON>
  __HAL_SD_ENABLE(hsd);
 8005542:	682a      	ldr	r2, [r5, #0]
  HAL_Delay(2);
 8005544:	2002      	movs	r0, #2
  __HAL_SD_ENABLE(hsd);
 8005546:	6853      	ldr	r3, [r2, #4]
 8005548:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800554c:	6053      	str	r3, [r2, #4]
  HAL_Delay(2);
 800554e:	f7fd fdd7 	bl	8003100 <HAL_Delay>
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8005552:	6828      	ldr	r0, [r5, #0]
  __IO uint32_t count = 0U;
 8005554:	9405      	str	r4, [sp, #20]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8005556:	f001 fdc9 	bl	80070ec <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 800555a:	4604      	mov	r4, r0
 800555c:	b960      	cbnz	r0, 8005578 <HAL_SD_InitCard+0x7c>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800555e:	6828      	ldr	r0, [r5, #0]
 8005560:	f001 fdee 	bl	8007140 <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005564:	b988      	cbnz	r0, 800558a <HAL_SD_InitCard+0x8e>
    hsd->SdCard.CardVersion = CARD_V2_X;
 8005566:	2301      	movs	r3, #1
 8005568:	64ab      	str	r3, [r5, #72]	; 0x48
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800556a:	2100      	movs	r1, #0
 800556c:	6828      	ldr	r0, [r5, #0]
 800556e:	f001 fe25 	bl	80071bc <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8005572:	b1a0      	cbz	r0, 800559e <HAL_SD_InitCard+0xa2>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8005574:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
    hsd->State = HAL_SD_STATE_READY;
 8005578:	2601      	movs	r6, #1
 800557a:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
 800557e:	4630      	mov	r0, r6
    hsd->ErrorCode |= errorstate;
 8005580:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8005582:	4314      	orrs	r4, r2
 8005584:	63ac      	str	r4, [r5, #56]	; 0x38
}
 8005586:	b019      	add	sp, #100	; 0x64
 8005588:	bdf0      	pop	{r4, r5, r6, r7, pc}
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800558a:	6828      	ldr	r0, [r5, #0]
    hsd->SdCard.CardVersion = CARD_V1_X;
 800558c:	64ac      	str	r4, [r5, #72]	; 0x48
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800558e:	f001 fdad 	bl	80070ec <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 8005592:	2800      	cmp	r0, #0
 8005594:	f040 80c6 	bne.w	8005724 <HAL_SD_InitCard+0x228>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 8005598:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800559a:	2b01      	cmp	r3, #1
 800559c:	d0e5      	beq.n	800556a <HAL_SD_InitCard+0x6e>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800559e:	9b05      	ldr	r3, [sp, #20]
 80055a0:	f64f 76fe 	movw	r6, #65534	; 0xfffe
 80055a4:	42b3      	cmp	r3, r6
 80055a6:	d81c      	bhi.n	80055e2 <HAL_SD_InitCard+0xe6>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 80055a8:	4f61      	ldr	r7, [pc, #388]	; (8005730 <HAL_SD_InitCard+0x234>)
 80055aa:	e011      	b.n	80055d0 <HAL_SD_InitCard+0xd4>
 80055ac:	6828      	ldr	r0, [r5, #0]
 80055ae:	f001 fea7 	bl	8007300 <SDMMC_CmdAppOperCommand>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80055b2:	4621      	mov	r1, r4
    if(errorstate != HAL_SD_ERROR_NONE)
 80055b4:	2800      	cmp	r0, #0
 80055b6:	d1dd      	bne.n	8005574 <HAL_SD_InitCard+0x78>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80055b8:	6828      	ldr	r0, [r5, #0]
 80055ba:	f001 f911 	bl	80067e0 <SDMMC_GetResponse>
    count++;
 80055be:	9b05      	ldr	r3, [sp, #20]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 80055c0:	1e04      	subs	r4, r0, #0
    count++;
 80055c2:	f103 0301 	add.w	r3, r3, #1
 80055c6:	9305      	str	r3, [sp, #20]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 80055c8:	9b05      	ldr	r3, [sp, #20]
 80055ca:	db0a      	blt.n	80055e2 <HAL_SD_InitCard+0xe6>
 80055cc:	42b3      	cmp	r3, r6
 80055ce:	d808      	bhi.n	80055e2 <HAL_SD_InitCard+0xe6>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 80055d0:	2100      	movs	r1, #0
 80055d2:	6828      	ldr	r0, [r5, #0]
 80055d4:	f001 fdf2 	bl	80071bc <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 80055d8:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
 80055da:	4604      	mov	r4, r0
 80055dc:	2800      	cmp	r0, #0
 80055de:	d0e5      	beq.n	80055ac <HAL_SD_InitCard+0xb0>
 80055e0:	e7ca      	b.n	8005578 <HAL_SD_InitCard+0x7c>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 80055e2:	9a05      	ldr	r2, [sp, #20]
 80055e4:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80055e8:	429a      	cmp	r2, r3
 80055ea:	f200 809d 	bhi.w	8005728 <HAL_SD_InitCard+0x22c>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 80055ee:	f3c4 7480 	ubfx	r4, r4, #30, #1
  uint16_t sd_rca = 1U;
 80055f2:	2301      	movs	r3, #1
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 80055f4:	6828      	ldr	r0, [r5, #0]
 80055f6:	646c      	str	r4, [r5, #68]	; 0x44
  uint16_t sd_rca = 1U;
 80055f8:	f8ad 3012 	strh.w	r3, [sp, #18]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 80055fc:	f001 f8ec 	bl	80067d8 <SDMMC_GetPowerState>
 8005600:	2800      	cmp	r0, #0
 8005602:	f000 8089 	beq.w	8005718 <HAL_SD_InitCard+0x21c>
  if(hsd->SdCard.CardType != CARD_SECURED)
 8005606:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8005608:	2b03      	cmp	r3, #3
 800560a:	d132      	bne.n	8005672 <HAL_SD_InitCard+0x176>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800560c:	2104      	movs	r1, #4
 800560e:	6828      	ldr	r0, [r5, #0]
 8005610:	f001 f8e6 	bl	80067e0 <SDMMC_GetResponse>
 8005614:	4603      	mov	r3, r0
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 8005616:	a90d      	add	r1, sp, #52	; 0x34
 8005618:	4628      	mov	r0, r5
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800561a:	0d1b      	lsrs	r3, r3, #20
 800561c:	64eb      	str	r3, [r5, #76]	; 0x4c
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800561e:	f7ff feaf 	bl	8005380 <HAL_SD_GetCardCSD>
 8005622:	4606      	mov	r6, r0
 8005624:	2800      	cmp	r0, #0
 8005626:	d17a      	bne.n	800571e <HAL_SD_InitCard+0x222>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 8005628:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 800562a:	4603      	mov	r3, r0
 800562c:	6828      	ldr	r0, [r5, #0]
 800562e:	0412      	lsls	r2, r2, #16
 8005630:	f001 fcba 	bl	8006fa8 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005634:	bb08      	cbnz	r0, 800567a <HAL_SD_InitCard+0x17e>
  (void)SDMMC_Init(hsd->Instance, hsd->Init);
 8005636:	462a      	mov	r2, r5
 8005638:	1d2b      	adds	r3, r5, #4
 800563a:	f852 4b10 	ldr.w	r4, [r2], #16
 800563e:	ca07      	ldmia	r2, {r0, r1, r2}
 8005640:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 8005644:	4620      	mov	r0, r4
 8005646:	cb0e      	ldmia	r3, {r1, r2, r3}
 8005648:	f001 f898 	bl	800677c <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800564c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8005650:	6828      	ldr	r0, [r5, #0]
 8005652:	f001 f8df 	bl	8006814 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005656:	2800      	cmp	r0, #0
 8005658:	f43f af68 	beq.w	800552c <HAL_SD_InitCard+0x30>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800565c:	682a      	ldr	r2, [r5, #0]
    hsd->State = HAL_SD_STATE_READY;
 800565e:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005660:	4934      	ldr	r1, [pc, #208]	; (8005734 <HAL_SD_InitCard+0x238>)
    return HAL_ERROR;
 8005662:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005664:	6391      	str	r1, [r2, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 8005666:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8005668:	4310      	orrs	r0, r2
 800566a:	63a8      	str	r0, [r5, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800566c:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    return HAL_ERROR;
 8005670:	e75c      	b.n	800552c <HAL_SD_InitCard+0x30>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8005672:	6828      	ldr	r0, [r5, #0]
 8005674:	f001 ffc4 	bl	8007600 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 8005678:	b140      	cbz	r0, 800568c <HAL_SD_InitCard+0x190>
    hsd->State = HAL_SD_STATE_READY;
 800567a:	2601      	movs	r6, #1
 800567c:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8005680:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8005682:	4318      	orrs	r0, r3
 8005684:	63a8      	str	r0, [r5, #56]	; 0x38
}
 8005686:	4630      	mov	r0, r6
 8005688:	b019      	add	sp, #100	; 0x64
 800568a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800568c:	4601      	mov	r1, r0
 800568e:	6828      	ldr	r0, [r5, #0]
 8005690:	f001 f8a6 	bl	80067e0 <SDMMC_GetResponse>
 8005694:	4603      	mov	r3, r0
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8005696:	2104      	movs	r1, #4
 8005698:	6828      	ldr	r0, [r5, #0]
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800569a:	676b      	str	r3, [r5, #116]	; 0x74
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800569c:	f001 f8a0 	bl	80067e0 <SDMMC_GetResponse>
 80056a0:	4603      	mov	r3, r0
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80056a2:	2108      	movs	r1, #8
 80056a4:	6828      	ldr	r0, [r5, #0]
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80056a6:	67ab      	str	r3, [r5, #120]	; 0x78
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80056a8:	f001 f89a 	bl	80067e0 <SDMMC_GetResponse>
 80056ac:	4603      	mov	r3, r0
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80056ae:	210c      	movs	r1, #12
 80056b0:	6828      	ldr	r0, [r5, #0]
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80056b2:	67eb      	str	r3, [r5, #124]	; 0x7c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80056b4:	f001 f894 	bl	80067e0 <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
 80056b8:	6c6b      	ldr	r3, [r5, #68]	; 0x44
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80056ba:	f8c5 0080 	str.w	r0, [r5, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED)
 80056be:	2b03      	cmp	r3, #3
 80056c0:	d0a4      	beq.n	800560c <HAL_SD_InitCard+0x110>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 80056c2:	f10d 0112 	add.w	r1, sp, #18
 80056c6:	6828      	ldr	r0, [r5, #0]
 80056c8:	f002 f814 	bl	80076f4 <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 80056cc:	2800      	cmp	r0, #0
 80056ce:	d1d4      	bne.n	800567a <HAL_SD_InitCard+0x17e>
  if(hsd->SdCard.CardType != CARD_SECURED)
 80056d0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80056d2:	2b03      	cmp	r3, #3
 80056d4:	d09a      	beq.n	800560c <HAL_SD_InitCard+0x110>
    hsd->SdCard.RelCardAdd = sd_rca;
 80056d6:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80056da:	6828      	ldr	r0, [r5, #0]
 80056dc:	0419      	lsls	r1, r3, #16
    hsd->SdCard.RelCardAdd = sd_rca;
 80056de:	652b      	str	r3, [r5, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80056e0:	f001 ffca 	bl	8007678 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 80056e4:	2800      	cmp	r0, #0
 80056e6:	d1c8      	bne.n	800567a <HAL_SD_InitCard+0x17e>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80056e8:	4601      	mov	r1, r0
 80056ea:	6828      	ldr	r0, [r5, #0]
 80056ec:	f001 f878 	bl	80067e0 <SDMMC_GetResponse>
 80056f0:	4603      	mov	r3, r0
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80056f2:	2104      	movs	r1, #4
 80056f4:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80056f6:	666b      	str	r3, [r5, #100]	; 0x64
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80056f8:	f001 f872 	bl	80067e0 <SDMMC_GetResponse>
 80056fc:	4603      	mov	r3, r0
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80056fe:	2108      	movs	r1, #8
 8005700:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 8005702:	66ab      	str	r3, [r5, #104]	; 0x68
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 8005704:	f001 f86c 	bl	80067e0 <SDMMC_GetResponse>
 8005708:	4603      	mov	r3, r0
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800570a:	210c      	movs	r1, #12
 800570c:	6828      	ldr	r0, [r5, #0]
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800570e:	66eb      	str	r3, [r5, #108]	; 0x6c
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 8005710:	f001 f866 	bl	80067e0 <SDMMC_GetResponse>
 8005714:	6728      	str	r0, [r5, #112]	; 0x70
 8005716:	e779      	b.n	800560c <HAL_SD_InitCard+0x110>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8005718:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800571c:	e7ad      	b.n	800567a <HAL_SD_InitCard+0x17e>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800571e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8005722:	e7aa      	b.n	800567a <HAL_SD_InitCard+0x17e>
 8005724:	4604      	mov	r4, r0
 8005726:	e727      	b.n	8005578 <HAL_SD_InitCard+0x7c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8005728:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
 800572c:	e724      	b.n	8005578 <HAL_SD_InitCard+0x7c>
 800572e:	bf00      	nop
 8005730:	c1100000 	.word	0xc1100000
 8005734:	004005ff 	.word	0x004005ff

08005738 <HAL_SD_Init>:
  if(hsd == NULL)
 8005738:	b1c8      	cbz	r0, 800576e <HAL_SD_Init+0x36>
{
 800573a:	b510      	push	{r4, lr}
  if(hsd->State == HAL_SD_STATE_RESET)
 800573c:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8005740:	4604      	mov	r4, r0
 8005742:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005746:	b173      	cbz	r3, 8005766 <HAL_SD_Init+0x2e>
  hsd->State = HAL_SD_STATE_BUSY;
 8005748:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800574a:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
 800574c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 8005750:	f7ff fed4 	bl	80054fc <HAL_SD_InitCard>
 8005754:	b928      	cbnz	r0, 8005762 <HAL_SD_Init+0x2a>
  hsd->State = HAL_SD_STATE_READY;
 8005756:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8005758:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 800575a:	6320      	str	r0, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 800575c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8005760:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8005762:	2001      	movs	r0, #1
}
 8005764:	bd10      	pop	{r4, pc}
    hsd->Lock = HAL_UNLOCKED;
 8005766:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 8005768:	f7fd f9c0 	bl	8002aec <HAL_SD_MspInit>
 800576c:	e7ec      	b.n	8005748 <HAL_SD_Init+0x10>
    return HAL_ERROR;
 800576e:	2001      	movs	r0, #1
}
 8005770:	4770      	bx	lr
 8005772:	bf00      	nop

08005774 <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8005774:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
 8005776:	b4f0      	push	{r4, r5, r6, r7}
 8005778:	e9d0 c712 	ldrd	ip, r7, [r0, #72]	; 0x48
 800577c:	e9d0 6514 	ldrd	r6, r5, [r0, #80]	; 0x50
 8005780:	e9d0 4216 	ldrd	r4, r2, [r0, #88]	; 0x58
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8005784:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8005786:	61cb      	str	r3, [r1, #28]
 8005788:	6008      	str	r0, [r1, #0]
}
 800578a:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 800578c:	e9c1 c701 	strd	ip, r7, [r1, #4]
 8005790:	e9c1 6503 	strd	r6, r5, [r1, #12]
 8005794:	e9c1 4205 	strd	r4, r2, [r1, #20]
}
 8005798:	bcf0      	pop	{r4, r5, r6, r7}
 800579a:	4770      	bx	lr

0800579c <HAL_SD_ConfigWideBusOperation>:
  hsd->State = HAL_SD_STATE_BUSY;
 800579c:	2203      	movs	r2, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
 800579e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80057a0:	4293      	cmp	r3, r2
{
 80057a2:	b570      	push	{r4, r5, r6, lr}
 80057a4:	4604      	mov	r4, r0
 80057a6:	b08a      	sub	sp, #40	; 0x28
 80057a8:	460e      	mov	r6, r1
  hsd->State = HAL_SD_STATE_BUSY;
 80057aa:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
 80057ae:	d024      	beq.n	80057fa <HAL_SD_ConfigWideBusOperation+0x5e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 80057b0:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80057b4:	d021      	beq.n	80057fa <HAL_SD_ConfigWideBusOperation+0x5e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 80057b6:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 80057ba:	d05d      	beq.n	8005878 <HAL_SD_ConfigWideBusOperation+0xdc>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 80057bc:	2900      	cmp	r1, #0
 80057be:	d03c      	beq.n	800583a <HAL_SD_ConfigWideBusOperation+0x9e>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 80057c0:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80057c2:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80057c6:	6383      	str	r3, [r0, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80057c8:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80057ca:	b9ed      	cbnz	r5, 8005808 <HAL_SD_ConfigWideBusOperation+0x6c>
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80057cc:	6863      	ldr	r3, [r4, #4]
    Init.BusWide             = WideMode;
 80057ce:	9607      	str	r6, [sp, #28]
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80057d0:	9304      	str	r3, [sp, #16]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 80057d2:	68a3      	ldr	r3, [r4, #8]
 80057d4:	9305      	str	r3, [sp, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80057d6:	68e3      	ldr	r3, [r4, #12]
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80057d8:	e9d4 1205 	ldrd	r1, r2, [r4, #20]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80057dc:	9306      	str	r3, [sp, #24]
    (void)SDMMC_Init(hsd->Instance, Init);
 80057de:	ab0a      	add	r3, sp, #40	; 0x28
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80057e0:	e9cd 1208 	strd	r1, r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
 80057e4:	e913 0007 	ldmdb	r3, {r0, r1, r2}
 80057e8:	ab04      	add	r3, sp, #16
 80057ea:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80057ee:	cb0e      	ldmia	r3, {r1, r2, r3}
 80057f0:	6820      	ldr	r0, [r4, #0]
 80057f2:	f000 ffc3 	bl	800677c <SDMMC_Init>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 80057f6:	6820      	ldr	r0, [r4, #0]
 80057f8:	e00d      	b.n	8005816 <HAL_SD_ConfigWideBusOperation+0x7a>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80057fa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80057fc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005800:	63a3      	str	r3, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 8005802:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8005804:	2d00      	cmp	r5, #0
 8005806:	d0e1      	beq.n	80057cc <HAL_SD_ConfigWideBusOperation+0x30>
    hsd->State = HAL_SD_STATE_READY;
 8005808:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800580a:	6820      	ldr	r0, [r4, #0]
 800580c:	4a2d      	ldr	r2, [pc, #180]	; (80058c4 <HAL_SD_ConfigWideBusOperation+0x128>)
    status = HAL_ERROR;
 800580e:	461d      	mov	r5, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005810:	6382      	str	r2, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8005812:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8005816:	f44f 7100 	mov.w	r1, #512	; 0x200
 800581a:	f000 fffb 	bl	8006814 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800581e:	b130      	cbz	r0, 800582e <HAL_SD_ConfigWideBusOperation+0x92>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005820:	6823      	ldr	r3, [r4, #0]
    status = HAL_ERROR;
 8005822:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8005824:	4a27      	ldr	r2, [pc, #156]	; (80058c4 <HAL_SD_ConfigWideBusOperation+0x128>)
 8005826:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 8005828:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800582a:	4318      	orrs	r0, r3
 800582c:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 800582e:	2301      	movs	r3, #1
}
 8005830:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 8005832:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8005836:	b00a      	add	sp, #40	; 0x28
 8005838:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t scr[2U] = {0U, 0U};
 800583a:	2200      	movs	r2, #0
 800583c:	2300      	movs	r3, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800583e:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0U, 0U};
 8005840:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8005844:	f000 ffcc 	bl	80067e0 <SDMMC_GetResponse>
 8005848:	0182      	lsls	r2, r0, #6
 800584a:	d434      	bmi.n	80058b6 <HAL_SD_ConfigWideBusOperation+0x11a>
  errorstate = SD_FindSCR(hsd, scr);
 800584c:	a904      	add	r1, sp, #16
 800584e:	4620      	mov	r0, r4
 8005850:	f7ff f9e8 	bl	8004c24 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005854:	b960      	cbnz	r0, 8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8005856:	9b05      	ldr	r3, [sp, #20]
 8005858:	03db      	lsls	r3, r3, #15
 800585a:	d52f      	bpl.n	80058bc <HAL_SD_ConfigWideBusOperation+0x120>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800585c:	6d21      	ldr	r1, [r4, #80]	; 0x50
 800585e:	6820      	ldr	r0, [r4, #0]
 8005860:	0409      	lsls	r1, r1, #16
 8005862:	f001 fcab 	bl	80071bc <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 8005866:	b918      	cbnz	r0, 8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 8005868:	4601      	mov	r1, r0
 800586a:	6820      	ldr	r0, [r4, #0]
 800586c:	f001 fd82 	bl	8007374 <SDMMC_CmdBusWidth>
      hsd->ErrorCode |= errorstate;
 8005870:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005872:	4318      	orrs	r0, r3
 8005874:	63a0      	str	r0, [r4, #56]	; 0x38
 8005876:	e7c4      	b.n	8005802 <HAL_SD_ConfigWideBusOperation+0x66>
  uint32_t scr[2U] = {0U, 0U};
 8005878:	2200      	movs	r2, #0
 800587a:	2300      	movs	r3, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800587c:	2100      	movs	r1, #0
 800587e:	6800      	ldr	r0, [r0, #0]
  uint32_t scr[2U] = {0U, 0U};
 8005880:	e9cd 2304 	strd	r2, r3, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8005884:	f000 ffac 	bl	80067e0 <SDMMC_GetResponse>
 8005888:	0180      	lsls	r0, r0, #6
 800588a:	d414      	bmi.n	80058b6 <HAL_SD_ConfigWideBusOperation+0x11a>
  errorstate = SD_FindSCR(hsd, scr);
 800588c:	a904      	add	r1, sp, #16
 800588e:	4620      	mov	r0, r4
 8005890:	f7ff f9c8 	bl	8004c24 <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 8005894:	2800      	cmp	r0, #0
 8005896:	d1eb      	bne.n	8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8005898:	9b05      	ldr	r3, [sp, #20]
 800589a:	0359      	lsls	r1, r3, #13
 800589c:	d50e      	bpl.n	80058bc <HAL_SD_ConfigWideBusOperation+0x120>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800589e:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80058a0:	6820      	ldr	r0, [r4, #0]
 80058a2:	0409      	lsls	r1, r1, #16
 80058a4:	f001 fc8a 	bl	80071bc <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 80058a8:	2800      	cmp	r0, #0
 80058aa:	d1e1      	bne.n	8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 80058ac:	2102      	movs	r1, #2
 80058ae:	6820      	ldr	r0, [r4, #0]
 80058b0:	f001 fd60 	bl	8007374 <SDMMC_CmdBusWidth>
    if(errorstate != HAL_SD_ERROR_NONE)
 80058b4:	e7dc      	b.n	8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 80058b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80058ba:	e7d9      	b.n	8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80058bc:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80058c0:	e7d6      	b.n	8005870 <HAL_SD_ConfigWideBusOperation+0xd4>
 80058c2:	bf00      	nop
 80058c4:	004005ff 	.word	0x004005ff

080058c8 <HAL_SD_GetCardState>:
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80058c8:	6d01      	ldr	r1, [r0, #80]	; 0x50
{
 80058ca:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80058cc:	0409      	lsls	r1, r1, #16
{
 80058ce:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 80058d0:	6800      	ldr	r0, [r0, #0]
 80058d2:	f001 ff65 	bl	80077a0 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 80058d6:	4601      	mov	r1, r0
 80058d8:	b120      	cbz	r0, 80058e4 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
 80058da:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80058dc:	2000      	movs	r0, #0
 80058de:	4319      	orrs	r1, r3
 80058e0:	63a1      	str	r1, [r4, #56]	; 0x38
}
 80058e2:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80058e4:	6820      	ldr	r0, [r4, #0]
 80058e6:	f000 ff7b 	bl	80067e0 <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 80058ea:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 80058ee:	bd10      	pop	{r4, pc}

080058f0 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80058f0:	2800      	cmp	r0, #0
 80058f2:	f000 809e 	beq.w	8005a32 <HAL_TIM_Base_Init+0x142>
{
 80058f6:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80058f8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80058fc:	4604      	mov	r4, r0
 80058fe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005902:	2b00      	cmp	r3, #0
 8005904:	d07c      	beq.n	8005a00 <HAL_TIM_Base_Init+0x110>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8005906:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8005908:	2302      	movs	r3, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800590a:	494c      	ldr	r1, [pc, #304]	; (8005a3c <HAL_TIM_Base_Init+0x14c>)
 800590c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
  htim->State = HAL_TIM_STATE_BUSY;
 8005910:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005914:	eba2 0101 	sub.w	r1, r2, r1
  tmpcr1 = TIMx->CR1;
 8005918:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800591a:	fab1 f181 	clz	r1, r1
 800591e:	ea4f 1151 	mov.w	r1, r1, lsr #5
 8005922:	d036      	beq.n	8005992 <HAL_TIM_Base_Init+0xa2>
 8005924:	2900      	cmp	r1, #0
 8005926:	d134      	bne.n	8005992 <HAL_TIM_Base_Init+0xa2>
 8005928:	4d45      	ldr	r5, [pc, #276]	; (8005a40 <HAL_TIM_Base_Init+0x150>)
 800592a:	4846      	ldr	r0, [pc, #280]	; (8005a44 <HAL_TIM_Base_Init+0x154>)
 800592c:	4282      	cmp	r2, r0
 800592e:	bf18      	it	ne
 8005930:	42aa      	cmpne	r2, r5
 8005932:	d06a      	beq.n	8005a0a <HAL_TIM_Base_Init+0x11a>
 8005934:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
 8005938:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800593c:	1b55      	subs	r5, r2, r5
 800593e:	4282      	cmp	r2, r0
 8005940:	fab5 f585 	clz	r5, r5
 8005944:	ea4f 1555 	mov.w	r5, r5, lsr #5
 8005948:	d069      	beq.n	8005a1e <HAL_TIM_Base_Init+0x12e>
 800594a:	2d00      	cmp	r5, #0
 800594c:	d167      	bne.n	8005a1e <HAL_TIM_Base_Init+0x12e>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800594e:	4d3e      	ldr	r5, [pc, #248]	; (8005a48 <HAL_TIM_Base_Init+0x158>)
 8005950:	483e      	ldr	r0, [pc, #248]	; (8005a4c <HAL_TIM_Base_Init+0x15c>)
 8005952:	4282      	cmp	r2, r0
 8005954:	bf18      	it	ne
 8005956:	42aa      	cmpne	r2, r5
 8005958:	bf0c      	ite	eq
 800595a:	2501      	moveq	r5, #1
 800595c:	2500      	movne	r5, #0
 800595e:	d06a      	beq.n	8005a36 <HAL_TIM_Base_Init+0x146>
 8005960:	4e3b      	ldr	r6, [pc, #236]	; (8005a50 <HAL_TIM_Base_Init+0x160>)
 8005962:	f5a0 3096 	sub.w	r0, r0, #76800	; 0x12c00
 8005966:	4282      	cmp	r2, r0
 8005968:	bf18      	it	ne
 800596a:	42b2      	cmpne	r2, r6
 800596c:	d01a      	beq.n	80059a4 <HAL_TIM_Base_Init+0xb4>
 800596e:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8005972:	4282      	cmp	r2, r0
 8005974:	d05f      	beq.n	8005a36 <HAL_TIM_Base_Init+0x146>
 8005976:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 800597a:	4282      	cmp	r2, r0
 800597c:	d05b      	beq.n	8005a36 <HAL_TIM_Base_Init+0x146>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800597e:	69a0      	ldr	r0, [r4, #24]
 8005980:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005984:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8005986:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 8005988:	6013      	str	r3, [r2, #0]

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800598a:	6863      	ldr	r3, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800598c:	62d1      	str	r1, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800598e:	6293      	str	r3, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005990:	e017      	b.n	80059c2 <HAL_TIM_Base_Init+0xd2>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005992:	4d30      	ldr	r5, [pc, #192]	; (8005a54 <HAL_TIM_Base_Init+0x164>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005994:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005998:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800599a:	1b55      	subs	r5, r2, r5
    tmpcr1 |= Structure->CounterMode;
 800599c:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800599e:	fab5 f585 	clz	r5, r5
 80059a2:	096d      	lsrs	r5, r5, #5
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80059a4:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~TIM_CR1_CKD;
 80059a6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80059aa:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80059ac:	69a0      	ldr	r0, [r4, #24]
 80059ae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80059b2:	4303      	orrs	r3, r0
  TIMx->CR1 = tmpcr1;
 80059b4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80059b6:	68e3      	ldr	r3, [r4, #12]
 80059b8:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80059ba:	6863      	ldr	r3, [r4, #4]
 80059bc:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80059be:	b9e1      	cbnz	r1, 80059fa <HAL_TIM_Base_Init+0x10a>
 80059c0:	b9dd      	cbnz	r5, 80059fa <HAL_TIM_Base_Init+0x10a>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80059c2:	2301      	movs	r3, #1
  return HAL_OK;
 80059c4:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 80059c6:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 80059c8:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80059cc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 80059d0:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 80059d4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 80059d8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 80059dc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80059e0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 80059e4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 80059e8:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80059ec:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 80059f0:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 80059f4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 80059f8:	bd70      	pop	{r4, r5, r6, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 80059fa:	6963      	ldr	r3, [r4, #20]
 80059fc:	6313      	str	r3, [r2, #48]	; 0x30
 80059fe:	e7e0      	b.n	80059c2 <HAL_TIM_Base_Init+0xd2>
    htim->Lock = HAL_UNLOCKED;
 8005a00:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8005a04:	f7fd f92e 	bl	8002c64 <HAL_TIM_Base_MspInit>
 8005a08:	e77d      	b.n	8005906 <HAL_TIM_Base_Init+0x16>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005a0a:	4d12      	ldr	r5, [pc, #72]	; (8005a54 <HAL_TIM_Base_Init+0x164>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005a0c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005a10:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005a12:	1b55      	subs	r5, r2, r5
    tmpcr1 |= Structure->CounterMode;
 8005a14:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005a16:	fab5 f585 	clz	r5, r5
 8005a1a:	096d      	lsrs	r5, r5, #5
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005a1c:	e7c2      	b.n	80059a4 <HAL_TIM_Base_Init+0xb4>
    tmpcr1 |= Structure->CounterMode;
 8005a1e:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005a20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8005a24:	4303      	orrs	r3, r0
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005a26:	480c      	ldr	r0, [pc, #48]	; (8005a58 <HAL_TIM_Base_Init+0x168>)
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005a28:	4282      	cmp	r2, r0
 8005a2a:	d0bb      	beq.n	80059a4 <HAL_TIM_Base_Init+0xb4>
 8005a2c:	2d00      	cmp	r5, #0
 8005a2e:	d1b9      	bne.n	80059a4 <HAL_TIM_Base_Init+0xb4>
 8005a30:	e78d      	b.n	800594e <HAL_TIM_Base_Init+0x5e>
    return HAL_ERROR;
 8005a32:	2001      	movs	r0, #1
}
 8005a34:	4770      	bx	lr
 8005a36:	2500      	movs	r5, #0
 8005a38:	e7b4      	b.n	80059a4 <HAL_TIM_Base_Init+0xb4>
 8005a3a:	bf00      	nop
 8005a3c:	40010000 	.word	0x40010000
 8005a40:	40000400 	.word	0x40000400
 8005a44:	40000800 	.word	0x40000800
 8005a48:	40014000 	.word	0x40014000
 8005a4c:	40014400 	.word	0x40014400
 8005a50:	40014800 	.word	0x40014800
 8005a54:	40010400 	.word	0x40010400
 8005a58:	40000c00 	.word	0x40000c00

08005a5c <HAL_TIM_ConfigClockSource>:
  __HAL_LOCK(htim);
 8005a5c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8005a60:	2b01      	cmp	r3, #1
 8005a62:	d073      	beq.n	8005b4c <HAL_TIM_ConfigClockSource+0xf0>
 8005a64:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8005a66:	2302      	movs	r3, #2
{
 8005a68:	b470      	push	{r4, r5, r6}
  tmpsmcr = htim->Instance->SMCR;
 8005a6a:	6804      	ldr	r4, [r0, #0]
  __HAL_LOCK(htim);
 8005a6c:	2001      	movs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8005a6e:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
  __HAL_LOCK(htim);
 8005a72:	f882 003c 	strb.w	r0, [r2, #60]	; 0x3c
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8005a76:	4b50      	ldr	r3, [pc, #320]	; (8005bb8 <HAL_TIM_ConfigClockSource+0x15c>)
  tmpsmcr = htim->Instance->SMCR;
 8005a78:	68a5      	ldr	r5, [r4, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8005a7a:	402b      	ands	r3, r5
  htim->Instance->SMCR = tmpsmcr;
 8005a7c:	60a3      	str	r3, [r4, #8]
  switch (sClockSourceConfig->ClockSource)
 8005a7e:	680b      	ldr	r3, [r1, #0]
 8005a80:	2b60      	cmp	r3, #96	; 0x60
 8005a82:	d065      	beq.n	8005b50 <HAL_TIM_ConfigClockSource+0xf4>
 8005a84:	d824      	bhi.n	8005ad0 <HAL_TIM_ConfigClockSource+0x74>
 8005a86:	2b40      	cmp	r3, #64	; 0x40
 8005a88:	d07c      	beq.n	8005b84 <HAL_TIM_ConfigClockSource+0x128>
 8005a8a:	d94b      	bls.n	8005b24 <HAL_TIM_ConfigClockSource+0xc8>
 8005a8c:	2b50      	cmp	r3, #80	; 0x50
 8005a8e:	d117      	bne.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8005a90:	6848      	ldr	r0, [r1, #4]
 8005a92:	68ce      	ldr	r6, [r1, #12]
{
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8005a94:	6a21      	ldr	r1, [r4, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005a96:	6a25      	ldr	r5, [r4, #32]
  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  tmpccmr1 |= (TIM_ICFilter << 4U);

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005a98:	f021 010a 	bic.w	r1, r1, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005a9c:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 8005aa0:	4301      	orrs	r1, r0
  HAL_StatusTypeDef status = HAL_OK;
 8005aa2:	2000      	movs	r0, #0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005aa4:	6225      	str	r5, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005aa6:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8005aa8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8005aac:	ea43 1306 	orr.w	r3, r3, r6, lsl #4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8005ab0:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8005ab2:	6221      	str	r1, [r4, #32]
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005ab4:	68a3      	ldr	r3, [r4, #8]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8005ab6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8005aba:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005abe:	60a3      	str	r3, [r4, #8]
  htim->State = HAL_TIM_STATE_READY;
 8005ac0:	2101      	movs	r1, #1
  __HAL_UNLOCK(htim);
 8005ac2:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8005ac4:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8005ac8:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8005acc:	bc70      	pop	{r4, r5, r6}
 8005ace:	4770      	bx	lr
  switch (sClockSourceConfig->ClockSource)
 8005ad0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005ad4:	d038      	beq.n	8005b48 <HAL_TIM_ConfigClockSource+0xec>
 8005ad6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005ada:	d110      	bne.n	8005afe <HAL_TIM_ConfigClockSource+0xa2>
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8005adc:	68a0      	ldr	r0, [r4, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8005ade:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
 8005ae2:	432b      	orrs	r3, r5
 8005ae4:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8005ae6:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  HAL_StatusTypeDef status = HAL_OK;
 8005aea:	2000      	movs	r0, #0
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8005aec:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8005af0:	430b      	orrs	r3, r1

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005af2:	60a3      	str	r3, [r4, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8005af4:	68a3      	ldr	r3, [r4, #8]
 8005af6:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005afa:	60a3      	str	r3, [r4, #8]
      break;
 8005afc:	e7e0      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  switch (sClockSourceConfig->ClockSource)
 8005afe:	2b70      	cmp	r3, #112	; 0x70
 8005b00:	d1de      	bne.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  tmpsmcr = TIMx->SMCR;
 8005b02:	68a0      	ldr	r0, [r4, #8]
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8005b04:	e9d1 5301 	ldrd	r5, r3, [r1, #4]
 8005b08:	432b      	orrs	r3, r5
 8005b0a:	68cd      	ldr	r5, [r1, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8005b0c:	f420 417f 	bic.w	r1, r0, #65280	; 0xff00
  HAL_StatusTypeDef status = HAL_OK;
 8005b10:	2000      	movs	r0, #0
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8005b12:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8005b16:	430b      	orrs	r3, r1
  TIMx->SMCR = tmpsmcr;
 8005b18:	60a3      	str	r3, [r4, #8]
      tmpsmcr = htim->Instance->SMCR;
 8005b1a:	68a3      	ldr	r3, [r4, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8005b1c:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 8005b20:	60a3      	str	r3, [r4, #8]
      break;
 8005b22:	e7cd      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  switch (sClockSourceConfig->ClockSource)
 8005b24:	2b20      	cmp	r3, #32
 8005b26:	d002      	beq.n	8005b2e <HAL_TIM_ConfigClockSource+0xd2>
 8005b28:	d90a      	bls.n	8005b40 <HAL_TIM_ConfigClockSource+0xe4>
 8005b2a:	2b30      	cmp	r3, #48	; 0x30
 8005b2c:	d1c8      	bne.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  tmpsmcr = TIMx->SMCR;
 8005b2e:	68a1      	ldr	r1, [r4, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8005b30:	2000      	movs	r0, #0
  tmpsmcr &= ~TIM_SMCR_TS;
 8005b32:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8005b36:	430b      	orrs	r3, r1
 8005b38:	f043 0307 	orr.w	r3, r3, #7
  TIMx->SMCR = tmpsmcr;
 8005b3c:	60a3      	str	r3, [r4, #8]
}
 8005b3e:	e7bf      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  switch (sClockSourceConfig->ClockSource)
 8005b40:	f033 0110 	bics.w	r1, r3, #16
 8005b44:	d1bc      	bne.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
 8005b46:	e7f2      	b.n	8005b2e <HAL_TIM_ConfigClockSource+0xd2>
  HAL_StatusTypeDef status = HAL_OK;
 8005b48:	2000      	movs	r0, #0
 8005b4a:	e7b9      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
  __HAL_LOCK(htim);
 8005b4c:	2002      	movs	r0, #2
}
 8005b4e:	4770      	bx	lr
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8005b50:	6a20      	ldr	r0, [r4, #32]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8005b52:	68cb      	ldr	r3, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8005b54:	f020 0010 	bic.w	r0, r0, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
 8005b58:	684d      	ldr	r5, [r1, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8005b5a:	6220      	str	r0, [r4, #32]
  HAL_StatusTypeDef status = HAL_OK;
 8005b5c:	2000      	movs	r0, #0
  tmpccmr1 = TIMx->CCMR1;
 8005b5e:	69a1      	ldr	r1, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8005b60:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8005b64:	ea41 3103 	orr.w	r1, r1, r3, lsl #12
  tmpccer = TIMx->CCER;
 8005b68:	6a23      	ldr	r3, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8005b6a:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  TIMx->CCMR1 = tmpccmr1 ;
 8005b6e:	61a1      	str	r1, [r4, #24]
  tmpccer |= (TIM_ICPolarity << 4U);
 8005b70:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  TIMx->CCER = tmpccer;
 8005b74:	6223      	str	r3, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8005b76:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8005b78:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8005b7c:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 8005b80:	60a3      	str	r3, [r4, #8]
}
 8005b82:	e79d      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8005b84:	6848      	ldr	r0, [r1, #4]
 8005b86:	68ce      	ldr	r6, [r1, #12]
  tmpccer = TIMx->CCER;
 8005b88:	6a21      	ldr	r1, [r4, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005b8a:	6a25      	ldr	r5, [r4, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005b8c:	f021 010a 	bic.w	r1, r1, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005b90:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 8005b94:	4301      	orrs	r1, r0
  HAL_StatusTypeDef status = HAL_OK;
 8005b96:	2000      	movs	r0, #0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8005b98:	6225      	str	r5, [r4, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005b9a:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8005b9c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8005ba0:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 8005ba4:	61a3      	str	r3, [r4, #24]
  TIMx->CCER = tmpccer;
 8005ba6:	6221      	str	r1, [r4, #32]
  tmpsmcr = TIMx->SMCR;
 8005ba8:	68a3      	ldr	r3, [r4, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8005baa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8005bae:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 8005bb2:	60a3      	str	r3, [r4, #8]
}
 8005bb4:	e784      	b.n	8005ac0 <HAL_TIM_ConfigClockSource+0x64>
 8005bb6:	bf00      	nop
 8005bb8:	fffe0088 	.word	0xfffe0088

08005bbc <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8005bbc:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8005bc0:	2b01      	cmp	r3, #1
 8005bc2:	d04b      	beq.n	8005c5c <HAL_TIMEx_MasterConfigSynchronization+0xa0>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8005bc4:	6803      	ldr	r3, [r0, #0]
 8005bc6:	4602      	mov	r2, r0
  htim->State = HAL_TIM_STATE_BUSY;
 8005bc8:	2002      	movs	r0, #2
{
 8005bca:	b430      	push	{r4, r5}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8005bcc:	4d24      	ldr	r5, [pc, #144]	; (8005c60 <HAL_TIMEx_MasterConfigSynchronization+0xa4>)
  htim->State = HAL_TIM_STATE_BUSY;
 8005bce:	f882 003d 	strb.w	r0, [r2, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8005bd2:	42ab      	cmp	r3, r5
  tmpcr2 = htim->Instance->CR2;
 8005bd4:	6858      	ldr	r0, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 8005bd6:	689c      	ldr	r4, [r3, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8005bd8:	d029      	beq.n	8005c2e <HAL_TIMEx_MasterConfigSynchronization+0x72>
 8005bda:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8005bde:	42ab      	cmp	r3, r5
 8005be0:	d025      	beq.n	8005c2e <HAL_TIMEx_MasterConfigSynchronization+0x72>
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005be2:	4d20      	ldr	r5, [pc, #128]	; (8005c64 <HAL_TIMEx_MasterConfigSynchronization+0xa8>)
  tmpcr2 &= ~TIM_CR2_MMS;
 8005be4:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005be8:	42ab      	cmp	r3, r5
 8005bea:	bf18      	it	ne
 8005bec:	f1b3 4f80 	cmpne.w	r3, #1073741824	; 0x40000000
 8005bf0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8005bf4:	bf0c      	ite	eq
 8005bf6:	f04f 0c01 	moveq.w	ip, #1
 8005bfa:	f04f 0c00 	movne.w	ip, #0
 8005bfe:	42ab      	cmp	r3, r5
 8005c00:	bf08      	it	eq
 8005c02:	f04c 0c01 	orreq.w	ip, ip, #1
 8005c06:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8005c0a:	42ab      	cmp	r3, r5
 8005c0c:	bf08      	it	eq
 8005c0e:	f04c 0c01 	orreq.w	ip, ip, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8005c12:	680d      	ldr	r5, [r1, #0]
 8005c14:	4328      	orrs	r0, r5
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005c16:	4d14      	ldr	r5, [pc, #80]	; (8005c68 <HAL_TIMEx_MasterConfigSynchronization+0xac>)
  htim->Instance->CR2 = tmpcr2;
 8005c18:	6058      	str	r0, [r3, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8005c1a:	42ab      	cmp	r3, r5
 8005c1c:	bf14      	ite	ne
 8005c1e:	4660      	movne	r0, ip
 8005c20:	f04c 0001 	orreq.w	r0, ip, #1
 8005c24:	b960      	cbnz	r0, 8005c40 <HAL_TIMEx_MasterConfigSynchronization+0x84>
 8005c26:	4811      	ldr	r0, [pc, #68]	; (8005c6c <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 8005c28:	4283      	cmp	r3, r0
 8005c2a:	d009      	beq.n	8005c40 <HAL_TIMEx_MasterConfigSynchronization+0x84>
 8005c2c:	e00d      	b.n	8005c4a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8005c2e:	684d      	ldr	r5, [r1, #4]
    tmpcr2 &= ~TIM_CR2_MMS2;
 8005c30:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8005c34:	4328      	orrs	r0, r5
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8005c36:	680d      	ldr	r5, [r1, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 8005c38:	f020 0070 	bic.w	r0, r0, #112	; 0x70
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8005c3c:	4328      	orrs	r0, r5
  htim->Instance->CR2 = tmpcr2;
 8005c3e:	6058      	str	r0, [r3, #4]
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8005c40:	6889      	ldr	r1, [r1, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 8005c42:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8005c46:	430c      	orrs	r4, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8005c48:	609c      	str	r4, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 8005c4a:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 8005c4c:	2101      	movs	r1, #1

  return HAL_OK;
 8005c4e:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 8005c50:	f882 103d 	strb.w	r1, [r2, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8005c54:	f882 303c 	strb.w	r3, [r2, #60]	; 0x3c
}
 8005c58:	bc30      	pop	{r4, r5}
 8005c5a:	4770      	bx	lr
  __HAL_LOCK(htim);
 8005c5c:	2002      	movs	r0, #2
}
 8005c5e:	4770      	bx	lr
 8005c60:	40010000 	.word	0x40010000
 8005c64:	40000400 	.word	0x40000400
 8005c68:	40014000 	.word	0x40014000
 8005c6c:	40001800 	.word	0x40001800

08005c70 <HAL_UART_Transmit_DMA>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
{
 8005c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 8005c72:	6f87      	ldr	r7, [r0, #120]	; 0x78
 8005c74:	2f20      	cmp	r7, #32
 8005c76:	d142      	bne.n	8005cfe <HAL_UART_Transmit_DMA+0x8e>
  {
    if ((pData == NULL) || (Size == 0U))
 8005c78:	2900      	cmp	r1, #0
 8005c7a:	d03e      	beq.n	8005cfa <HAL_UART_Transmit_DMA+0x8a>
 8005c7c:	fab2 f682 	clz	r6, r2
 8005c80:	0976      	lsrs	r6, r6, #5
 8005c82:	2a00      	cmp	r2, #0
 8005c84:	d039      	beq.n	8005cfa <HAL_UART_Transmit_DMA+0x8a>
 8005c86:	4604      	mov	r4, r0
    {
      return HAL_ERROR;
    }

    __HAL_LOCK(huart);
 8005c88:	f890 0074 	ldrb.w	r0, [r0, #116]	; 0x74
 8005c8c:	2801      	cmp	r0, #1
 8005c8e:	d036      	beq.n	8005cfe <HAL_UART_Transmit_DMA+0x8e>
 8005c90:	2501      	movs	r5, #1
    huart->pTxBuffPtr  = pData;
    huart->TxXferSize  = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005c92:	2321      	movs	r3, #33	; 0x21

    if (huart->hdmatx != NULL)
 8005c94:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
    huart->TxXferCount = Size;
 8005c96:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    huart->pTxBuffPtr  = pData;
 8005c9a:	64e1      	str	r1, [r4, #76]	; 0x4c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005c9c:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
    huart->TxXferSize  = Size;
 8005ca0:	f8a4 2050 	strh.w	r2, [r4, #80]	; 0x50
    __HAL_LOCK(huart);
 8005ca4:	f884 5074 	strb.w	r5, [r4, #116]	; 0x74
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005ca8:	67a3      	str	r3, [r4, #120]	; 0x78
    if (huart->hdmatx != NULL)
 8005caa:	b190      	cbz	r0, 8005cd2 <HAL_UART_Transmit_DMA+0x62>
    {
      /* Set the UART DMA transfer complete callback */
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005cac:	f8df c064 	ldr.w	ip, [pc, #100]	; 8005d14 <HAL_UART_Transmit_DMA+0xa4>

      /* Set the DMA abort callback */
      huart->hdmatx->XferAbortCallback = NULL;

      /* Enable the UART transmit DMA channel */
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8005cb0:	4613      	mov	r3, r2
 8005cb2:	6822      	ldr	r2, [r4, #0]
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005cb4:	f8c0 c03c 	str.w	ip, [r0, #60]	; 0x3c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8005cb8:	f8df c05c 	ldr.w	ip, [pc, #92]	; 8005d18 <HAL_UART_Transmit_DMA+0xa8>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8005cbc:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 8005cbe:	6506      	str	r6, [r0, #80]	; 0x50
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8005cc0:	f8c0 c040 	str.w	ip, [r0, #64]	; 0x40
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 8005cc4:	f8df c054 	ldr.w	ip, [pc, #84]	; 8005d1c <HAL_UART_Transmit_DMA+0xac>
 8005cc8:	f8c0 c04c 	str.w	ip, [r0, #76]	; 0x4c
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8005ccc:	f7fd fb3a 	bl	8003344 <HAL_DMA_Start_IT>
 8005cd0:	b9b8      	cbnz	r0, 8005d02 <HAL_UART_Transmit_DMA+0x92>

        return HAL_ERROR;
      }
    }
    /* Clear the TC flag in the ICR register */
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 8005cd2:	6822      	ldr	r2, [r4, #0]
 8005cd4:	2140      	movs	r1, #64	; 0x40

    __HAL_UNLOCK(huart);
 8005cd6:	2300      	movs	r3, #0
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 8005cd8:	6211      	str	r1, [r2, #32]
    __HAL_UNLOCK(huart);
 8005cda:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005cde:	f102 0308 	add.w	r3, r2, #8
 8005ce2:	e853 3f00 	ldrex	r3, [r3]

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
    in the UART CR3 register */
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005ce6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005cea:	f102 0008 	add.w	r0, r2, #8
 8005cee:	e840 3100 	strex	r1, r3, [r0]
 8005cf2:	2900      	cmp	r1, #0
 8005cf4:	d1f3      	bne.n	8005cde <HAL_UART_Transmit_DMA+0x6e>

    return HAL_OK;
 8005cf6:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_BUSY;
  }
}
 8005cf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return HAL_ERROR;
 8005cfa:	2001      	movs	r0, #1
}
 8005cfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8005cfe:	2002      	movs	r0, #2
}
 8005d00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 8005d02:	2310      	movs	r3, #16
        return HAL_ERROR;
 8005d04:	4628      	mov	r0, r5
        __HAL_UNLOCK(huart);
 8005d06:	f884 6074 	strb.w	r6, [r4, #116]	; 0x74
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 8005d0a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 8005d0e:	67a7      	str	r7, [r4, #120]	; 0x78
}
 8005d10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005d12:	bf00      	nop
 8005d14:	08005d21 	.word	0x08005d21
 8005d18:	08005d69 	.word	0x08005d69
 8005d1c:	08005d81 	.word	0x08005d81

08005d20 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 8005d20:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);

  /* DMA Normal mode */
  if (hdma->Init.Mode != DMA_CIRCULAR)
 8005d22:	69c3      	ldr	r3, [r0, #28]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8005d24:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 8005d26:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005d2a:	d018      	beq.n	8005d5e <UART_DMATransmitCplt+0x3e>
  {
    huart->TxXferCount = 0U;
 8005d2c:	2300      	movs	r3, #0
 8005d2e:	6802      	ldr	r2, [r0, #0]
 8005d30:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005d34:	f102 0308 	add.w	r3, r2, #8
 8005d38:	e853 3f00 	ldrex	r3, [r3]

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005d3c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005d40:	f102 0008 	add.w	r0, r2, #8
 8005d44:	e840 3100 	strex	r1, r3, [r0]
 8005d48:	2900      	cmp	r1, #0
 8005d4a:	d1f3      	bne.n	8005d34 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005d4c:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005d50:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005d54:	e842 3100 	strex	r1, r3, [r2]
 8005d58:	2900      	cmp	r1, #0
 8005d5a:	d1f7      	bne.n	8005d4c <UART_DMATransmitCplt+0x2c>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 8005d5c:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 8005d5e:	f7fc fccf 	bl	8002700 <HAL_UART_TxCpltCallback>
}
 8005d62:	bd08      	pop	{r3, pc}

08005d64 <HAL_UART_TxHalfCpltCallback>:
 8005d64:	4770      	bx	lr
 8005d66:	bf00      	nop

08005d68 <UART_DMATxHalfCplt>:
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 8005d68:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 8005d6a:	b508      	push	{r3, lr}
  HAL_UART_TxHalfCpltCallback(huart);
 8005d6c:	f7ff fffa 	bl	8005d64 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005d70:	bd08      	pop	{r3, pc}
 8005d72:	bf00      	nop

08005d74 <HAL_UART_RxCpltCallback>:
 8005d74:	4770      	bx	lr
 8005d76:	bf00      	nop

08005d78 <HAL_UART_RxHalfCpltCallback>:
 8005d78:	4770      	bx	lr
 8005d7a:	bf00      	nop

08005d7c <HAL_UART_ErrorCallback>:
 8005d7c:	4770      	bx	lr
 8005d7e:	bf00      	nop

08005d80 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8005d80:	6b80      	ldr	r0, [r0, #56]	; 0x38

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8005d82:	6803      	ldr	r3, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 8005d84:	6f81      	ldr	r1, [r0, #120]	; 0x78
{
 8005d86:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 8005d88:	6fc4      	ldr	r4, [r0, #124]	; 0x7c
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8005d8a:	689a      	ldr	r2, [r3, #8]
 8005d8c:	0612      	lsls	r2, r2, #24
 8005d8e:	d501      	bpl.n	8005d94 <UART_DMAError+0x14>
 8005d90:	2921      	cmp	r1, #33	; 0x21
 8005d92:	d00d      	beq.n	8005db0 <UART_DMAError+0x30>
    huart->TxXferCount = 0U;
    UART_EndTxTransfer(huart);
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 8005d94:	689a      	ldr	r2, [r3, #8]
 8005d96:	0652      	lsls	r2, r2, #25
 8005d98:	d501      	bpl.n	8005d9e <UART_DMAError+0x1e>
 8005d9a:	2c22      	cmp	r4, #34	; 0x22
 8005d9c:	d016      	beq.n	8005dcc <UART_DMAError+0x4c>
  {
    huart->RxXferCount = 0U;
    UART_EndRxTransfer(huart);
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8005d9e:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8005da2:	f043 0310 	orr.w	r3, r3, #16
 8005da6:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8005daa:	f7ff ffe7 	bl	8005d7c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005dae:	bd10      	pop	{r4, pc}
    huart->TxXferCount = 0U;
 8005db0:	2200      	movs	r2, #0
 8005db2:	f8a0 2052 	strh.w	r2, [r0, #82]	; 0x52
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005db6:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8005dba:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005dbe:	e843 2100 	strex	r1, r2, [r3]
 8005dc2:	2900      	cmp	r1, #0
 8005dc4:	d1f7      	bne.n	8005db6 <UART_DMAError+0x36>
  huart->gState = HAL_UART_STATE_READY;
 8005dc6:	2220      	movs	r2, #32
 8005dc8:	6782      	str	r2, [r0, #120]	; 0x78
}
 8005dca:	e7e3      	b.n	8005d94 <UART_DMAError+0x14>
    huart->RxXferCount = 0U;
 8005dcc:	2200      	movs	r2, #0
 8005dce:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005dd2:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8005dd6:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005dda:	e843 2100 	strex	r1, r2, [r3]
 8005dde:	2900      	cmp	r1, #0
 8005de0:	d1f7      	bne.n	8005dd2 <UART_DMAError+0x52>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005de2:	f103 0208 	add.w	r2, r3, #8
 8005de6:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005dea:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005dee:	f103 0408 	add.w	r4, r3, #8
 8005df2:	e844 2100 	strex	r1, r2, [r4]
 8005df6:	2900      	cmp	r1, #0
 8005df8:	d1f3      	bne.n	8005de2 <UART_DMAError+0x62>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005dfa:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8005dfc:	2a01      	cmp	r2, #1
 8005dfe:	d005      	beq.n	8005e0c <UART_DMAError+0x8c>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005e00:	2300      	movs	r3, #0
  huart->RxState = HAL_UART_STATE_READY;
 8005e02:	2220      	movs	r2, #32
  huart->RxISR = NULL;
 8005e04:	6643      	str	r3, [r0, #100]	; 0x64
  huart->RxState = HAL_UART_STATE_READY;
 8005e06:	67c2      	str	r2, [r0, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005e08:	6603      	str	r3, [r0, #96]	; 0x60
}
 8005e0a:	e7c8      	b.n	8005d9e <UART_DMAError+0x1e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005e0c:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005e10:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005e14:	e843 2100 	strex	r1, r2, [r3]
 8005e18:	2900      	cmp	r1, #0
 8005e1a:	d0f1      	beq.n	8005e00 <UART_DMAError+0x80>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005e1c:	e853 2f00 	ldrex	r2, [r3]
 8005e20:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005e24:	e843 2100 	strex	r1, r2, [r3]
 8005e28:	2900      	cmp	r1, #0
 8005e2a:	d1ef      	bne.n	8005e0c <UART_DMAError+0x8c>
 8005e2c:	e7e8      	b.n	8005e00 <UART_DMAError+0x80>
 8005e2e:	bf00      	nop

08005e30 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8005e30:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8005e32:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 8005e34:	2300      	movs	r3, #0
 8005e36:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
  huart->TxXferCount = 0U;
 8005e3a:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8005e3e:	f7ff ff9d 	bl	8005d7c <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005e42:	bd08      	pop	{r3, pc}

08005e44 <HAL_UARTEx_RxEventCallback>:
}
 8005e44:	4770      	bx	lr
 8005e46:	bf00      	nop

08005e48 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8005e48:	6803      	ldr	r3, [r0, #0]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8005e4a:	f640 0c0f 	movw	ip, #2063	; 0x80f
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8005e4e:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8005e50:	6819      	ldr	r1, [r3, #0]
  if (errorflags == 0U)
 8005e52:	ea12 0f0c 	tst.w	r2, ip
{
 8005e56:	b570      	push	{r4, r5, r6, lr}
 8005e58:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8005e5a:	689d      	ldr	r5, [r3, #8]
  if (errorflags == 0U)
 8005e5c:	d178      	bne.n	8005f50 <HAL_UART_IRQHandler+0x108>
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8005e5e:	0696      	lsls	r6, r2, #26
 8005e60:	d502      	bpl.n	8005e68 <HAL_UART_IRQHandler+0x20>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8005e62:	068d      	lsls	r5, r1, #26
 8005e64:	f100 810c 	bmi.w	8006080 <HAL_UART_IRQHandler+0x238>
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005e68:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8005e6a:	2801      	cmp	r0, #1
 8005e6c:	d01f      	beq.n	8005eae <HAL_UART_IRQHandler+0x66>
  if (((isrflags & USART_ISR_TXE) != 0U)
 8005e6e:	0616      	lsls	r6, r2, #24
 8005e70:	d414      	bmi.n	8005e9c <HAL_UART_IRQHandler+0x54>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8005e72:	0650      	lsls	r0, r2, #25
 8005e74:	d501      	bpl.n	8005e7a <HAL_UART_IRQHandler+0x32>
 8005e76:	064a      	lsls	r2, r1, #25
 8005e78:	d400      	bmi.n	8005e7c <HAL_UART_IRQHandler+0x34>
}
 8005e7a:	bd70      	pop	{r4, r5, r6, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005e7c:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8005e80:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005e84:	e843 2100 	strex	r1, r2, [r3]
 8005e88:	2900      	cmp	r1, #0
 8005e8a:	d1f7      	bne.n	8005e7c <HAL_UART_IRQHandler+0x34>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8005e8c:	2220      	movs	r2, #32

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 8005e8e:	2300      	movs	r3, #0
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8005e90:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_READY;
 8005e92:	67a2      	str	r2, [r4, #120]	; 0x78
  huart->TxISR = NULL;
 8005e94:	66a3      	str	r3, [r4, #104]	; 0x68
  HAL_UART_TxCpltCallback(huart);
 8005e96:	f7fc fc33 	bl	8002700 <HAL_UART_TxCpltCallback>
}
 8005e9a:	bd70      	pop	{r4, r5, r6, pc}
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 8005e9c:	060d      	lsls	r5, r1, #24
 8005e9e:	d5e8      	bpl.n	8005e72 <HAL_UART_IRQHandler+0x2a>
    if (huart->TxISR != NULL)
 8005ea0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8005ea2:	2b00      	cmp	r3, #0
 8005ea4:	d0e9      	beq.n	8005e7a <HAL_UART_IRQHandler+0x32>
      huart->TxISR(huart);
 8005ea6:	4620      	mov	r0, r4
}
 8005ea8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 8005eac:	4718      	bx	r3
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8005eae:	06d5      	lsls	r5, r2, #27
 8005eb0:	d5dd      	bpl.n	8005e6e <HAL_UART_IRQHandler+0x26>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8005eb2:	06c8      	lsls	r0, r1, #27
 8005eb4:	d5db      	bpl.n	8005e6e <HAL_UART_IRQHandler+0x26>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8005eb6:	2210      	movs	r2, #16
 8005eb8:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8005eba:	689a      	ldr	r2, [r3, #8]
 8005ebc:	0652      	lsls	r2, r2, #25
 8005ebe:	f140 80f9 	bpl.w	80060b4 <HAL_UART_IRQHandler+0x26c>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8005ec2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8005ec4:	6802      	ldr	r2, [r0, #0]
 8005ec6:	6852      	ldr	r2, [r2, #4]
 8005ec8:	b292      	uxth	r2, r2
      if ((nb_remaining_rx_data > 0U)
 8005eca:	2a00      	cmp	r2, #0
 8005ecc:	d0d5      	beq.n	8005e7a <HAL_UART_IRQHandler+0x32>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8005ece:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
 8005ed2:	4291      	cmp	r1, r2
 8005ed4:	d9d1      	bls.n	8005e7a <HAL_UART_IRQHandler+0x32>
        huart->RxXferCount = nb_remaining_rx_data;
 8005ed6:	f8a4 205a 	strh.w	r2, [r4, #90]	; 0x5a
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8005eda:	69c2      	ldr	r2, [r0, #28]
 8005edc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8005ee0:	d02e      	beq.n	8005f40 <HAL_UART_IRQHandler+0xf8>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005ee2:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005ee6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005eea:	e843 2100 	strex	r1, r2, [r3]
 8005eee:	2900      	cmp	r1, #0
 8005ef0:	d1f7      	bne.n	8005ee2 <HAL_UART_IRQHandler+0x9a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005ef2:	f103 0208 	add.w	r2, r3, #8
 8005ef6:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005efa:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005efe:	f103 0508 	add.w	r5, r3, #8
 8005f02:	e845 2100 	strex	r1, r2, [r5]
 8005f06:	2900      	cmp	r1, #0
 8005f08:	d1f3      	bne.n	8005ef2 <HAL_UART_IRQHandler+0xaa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005f0a:	f103 0208 	add.w	r2, r3, #8
 8005f0e:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005f12:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005f16:	f103 0508 	add.w	r5, r3, #8
 8005f1a:	e845 2100 	strex	r1, r2, [r5]
 8005f1e:	2900      	cmp	r1, #0
 8005f20:	d1f3      	bne.n	8005f0a <HAL_UART_IRQHandler+0xc2>
          huart->RxState = HAL_UART_STATE_READY;
 8005f22:	2220      	movs	r2, #32
 8005f24:	67e2      	str	r2, [r4, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005f26:	6621      	str	r1, [r4, #96]	; 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005f28:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005f2c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005f30:	e843 2100 	strex	r1, r2, [r3]
 8005f34:	2900      	cmp	r1, #0
 8005f36:	d1f7      	bne.n	8005f28 <HAL_UART_IRQHandler+0xe0>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8005f38:	f7fd fa4c 	bl	80033d4 <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8005f3c:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
 8005f40:	f8b4 305a 	ldrh.w	r3, [r4, #90]	; 0x5a
 8005f44:	4620      	mov	r0, r4
 8005f46:	1ac9      	subs	r1, r1, r3
 8005f48:	b289      	uxth	r1, r1
 8005f4a:	f7ff ff7b 	bl	8005e44 <HAL_UARTEx_RxEventCallback>
}
 8005f4e:	bd70      	pop	{r4, r5, r6, pc}
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 8005f50:	4875      	ldr	r0, [pc, #468]	; (8006128 <HAL_UART_IRQHandler+0x2e0>)
      && (((cr3its & USART_CR3_EIE) != 0U)
 8005f52:	f005 0501 	and.w	r5, r5, #1
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 8005f56:	4008      	ands	r0, r1
 8005f58:	4328      	orrs	r0, r5
 8005f5a:	d085      	beq.n	8005e68 <HAL_UART_IRQHandler+0x20>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8005f5c:	07d6      	lsls	r6, r2, #31
 8005f5e:	d509      	bpl.n	8005f74 <HAL_UART_IRQHandler+0x12c>
 8005f60:	05c8      	lsls	r0, r1, #23
 8005f62:	d507      	bpl.n	8005f74 <HAL_UART_IRQHandler+0x12c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8005f64:	2001      	movs	r0, #1
 8005f66:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8005f68:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005f6c:	f040 0001 	orr.w	r0, r0, #1
 8005f70:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005f74:	0796      	lsls	r6, r2, #30
 8005f76:	d57e      	bpl.n	8006076 <HAL_UART_IRQHandler+0x22e>
 8005f78:	b18d      	cbz	r5, 8005f9e <HAL_UART_IRQHandler+0x156>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8005f7a:	2002      	movs	r0, #2
 8005f7c:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8005f7e:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005f82:	f040 0004 	orr.w	r0, r0, #4
 8005f86:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005f8a:	0750      	lsls	r0, r2, #29
 8005f8c:	d507      	bpl.n	8005f9e <HAL_UART_IRQHandler+0x156>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8005f8e:	2004      	movs	r0, #4
 8005f90:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8005f92:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005f96:	f040 0002 	orr.w	r0, r0, #2
 8005f9a:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    if (((isrflags & USART_ISR_ORE) != 0U)
 8005f9e:	0710      	lsls	r0, r2, #28
 8005fa0:	d50b      	bpl.n	8005fba <HAL_UART_IRQHandler+0x172>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 8005fa2:	f001 0020 	and.w	r0, r1, #32
 8005fa6:	4328      	orrs	r0, r5
 8005fa8:	d007      	beq.n	8005fba <HAL_UART_IRQHandler+0x172>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8005faa:	2008      	movs	r0, #8
 8005fac:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8005fae:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005fb2:	f040 0008 	orr.w	r0, r0, #8
 8005fb6:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8005fba:	0516      	lsls	r6, r2, #20
 8005fbc:	d50a      	bpl.n	8005fd4 <HAL_UART_IRQHandler+0x18c>
 8005fbe:	014d      	lsls	r5, r1, #5
 8005fc0:	d508      	bpl.n	8005fd4 <HAL_UART_IRQHandler+0x18c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8005fc2:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005fc6:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8005fc8:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005fcc:	f040 0020 	orr.w	r0, r0, #32
 8005fd0:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8005fd4:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 8005fd8:	2800      	cmp	r0, #0
 8005fda:	f43f af4e 	beq.w	8005e7a <HAL_UART_IRQHandler+0x32>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 8005fde:	0690      	lsls	r0, r2, #26
 8005fe0:	d506      	bpl.n	8005ff0 <HAL_UART_IRQHandler+0x1a8>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8005fe2:	068a      	lsls	r2, r1, #26
 8005fe4:	d504      	bpl.n	8005ff0 <HAL_UART_IRQHandler+0x1a8>
        if (huart->RxISR != NULL)
 8005fe6:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8005fe8:	b112      	cbz	r2, 8005ff0 <HAL_UART_IRQHandler+0x1a8>
          huart->RxISR(huart);
 8005fea:	4620      	mov	r0, r4
 8005fec:	4790      	blx	r2
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8005fee:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 8005ff0:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8005ff4:	689a      	ldr	r2, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8005ff6:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8005ffa:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8005ffe:	4315      	orrs	r5, r2
 8006000:	f000 808b 	beq.w	800611a <HAL_UART_IRQHandler+0x2d2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006004:	e853 2f00 	ldrex	r2, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8006008:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800600c:	e843 2100 	strex	r1, r2, [r3]
 8006010:	2900      	cmp	r1, #0
 8006012:	d1f7      	bne.n	8006004 <HAL_UART_IRQHandler+0x1bc>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006014:	f103 0208 	add.w	r2, r3, #8
 8006018:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800601c:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006020:	f103 0008 	add.w	r0, r3, #8
 8006024:	e840 2100 	strex	r1, r2, [r0]
 8006028:	2900      	cmp	r1, #0
 800602a:	d1f3      	bne.n	8006014 <HAL_UART_IRQHandler+0x1cc>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800602c:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800602e:	2a01      	cmp	r2, #1
 8006030:	d02b      	beq.n	800608a <HAL_UART_IRQHandler+0x242>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006032:	2200      	movs	r2, #0
  huart->RxState = HAL_UART_STATE_READY;
 8006034:	2120      	movs	r1, #32
 8006036:	67e1      	str	r1, [r4, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006038:	6622      	str	r2, [r4, #96]	; 0x60
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800603a:	6899      	ldr	r1, [r3, #8]
  huart->RxISR = NULL;
 800603c:	6662      	str	r2, [r4, #100]	; 0x64
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800603e:	064e      	lsls	r6, r1, #25
 8006040:	d534      	bpl.n	80060ac <HAL_UART_IRQHandler+0x264>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006042:	f103 0208 	add.w	r2, r3, #8
 8006046:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800604a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800604e:	f103 0008 	add.w	r0, r3, #8
 8006052:	e840 2100 	strex	r1, r2, [r0]
 8006056:	2900      	cmp	r1, #0
 8006058:	d1f3      	bne.n	8006042 <HAL_UART_IRQHandler+0x1fa>
          if (huart->hdmarx != NULL)
 800605a:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800605c:	b330      	cbz	r0, 80060ac <HAL_UART_IRQHandler+0x264>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800605e:	4b33      	ldr	r3, [pc, #204]	; (800612c <HAL_UART_IRQHandler+0x2e4>)
 8006060:	6503      	str	r3, [r0, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8006062:	f7fd f9ff 	bl	8003464 <HAL_DMA_Abort_IT>
 8006066:	2800      	cmp	r0, #0
 8006068:	f43f af07 	beq.w	8005e7a <HAL_UART_IRQHandler+0x32>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800606c:	6f20      	ldr	r0, [r4, #112]	; 0x70
}
 800606e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8006072:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8006074:	4718      	bx	r3
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8006076:	0756      	lsls	r6, r2, #29
 8006078:	d591      	bpl.n	8005f9e <HAL_UART_IRQHandler+0x156>
 800607a:	2d00      	cmp	r5, #0
 800607c:	d187      	bne.n	8005f8e <HAL_UART_IRQHandler+0x146>
 800607e:	e78e      	b.n	8005f9e <HAL_UART_IRQHandler+0x156>
      if (huart->RxISR != NULL)
 8006080:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8006082:	2b00      	cmp	r3, #0
 8006084:	f47f af10 	bne.w	8005ea8 <HAL_UART_IRQHandler+0x60>
 8006088:	e6f7      	b.n	8005e7a <HAL_UART_IRQHandler+0x32>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800608a:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800608e:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006092:	e843 2100 	strex	r1, r2, [r3]
 8006096:	2900      	cmp	r1, #0
 8006098:	d0cb      	beq.n	8006032 <HAL_UART_IRQHandler+0x1ea>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800609a:	e853 2f00 	ldrex	r2, [r3]
 800609e:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80060a2:	e843 2100 	strex	r1, r2, [r3]
 80060a6:	2900      	cmp	r1, #0
 80060a8:	d1ef      	bne.n	800608a <HAL_UART_IRQHandler+0x242>
 80060aa:	e7c2      	b.n	8006032 <HAL_UART_IRQHandler+0x1ea>
            HAL_UART_ErrorCallback(huart);
 80060ac:	4620      	mov	r0, r4
 80060ae:	f7ff fe65 	bl	8005d7c <HAL_UART_ErrorCallback>
}
 80060b2:	bd70      	pop	{r4, r5, r6, pc}
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80060b4:	f8b4 005a 	ldrh.w	r0, [r4, #90]	; 0x5a
 80060b8:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
      if ((huart->RxXferCount > 0U)
 80060bc:	f8b4 205a 	ldrh.w	r2, [r4, #90]	; 0x5a
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80060c0:	1a09      	subs	r1, r1, r0
      if ((huart->RxXferCount > 0U)
 80060c2:	b292      	uxth	r2, r2
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 80060c4:	b289      	uxth	r1, r1
          && (nb_rx_data > 0U))
 80060c6:	2a00      	cmp	r2, #0
 80060c8:	f43f aed7 	beq.w	8005e7a <HAL_UART_IRQHandler+0x32>
 80060cc:	2900      	cmp	r1, #0
 80060ce:	f43f aed4 	beq.w	8005e7a <HAL_UART_IRQHandler+0x32>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80060d2:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80060d6:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80060da:	e843 2000 	strex	r0, r2, [r3]
 80060de:	2800      	cmp	r0, #0
 80060e0:	d1f7      	bne.n	80060d2 <HAL_UART_IRQHandler+0x28a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80060e2:	f103 0208 	add.w	r2, r3, #8
 80060e6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80060ea:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80060ee:	f103 0508 	add.w	r5, r3, #8
 80060f2:	e845 2000 	strex	r0, r2, [r5]
 80060f6:	2800      	cmp	r0, #0
 80060f8:	d1f3      	bne.n	80060e2 <HAL_UART_IRQHandler+0x29a>
        huart->RxState = HAL_UART_STATE_READY;
 80060fa:	2220      	movs	r2, #32
        huart->RxISR = NULL;
 80060fc:	6660      	str	r0, [r4, #100]	; 0x64
        huart->RxState = HAL_UART_STATE_READY;
 80060fe:	67e2      	str	r2, [r4, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006100:	6620      	str	r0, [r4, #96]	; 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006102:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8006106:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800610a:	e843 2000 	strex	r0, r2, [r3]
 800610e:	2800      	cmp	r0, #0
 8006110:	d1f7      	bne.n	8006102 <HAL_UART_IRQHandler+0x2ba>
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8006112:	4620      	mov	r0, r4
 8006114:	f7ff fe96 	bl	8005e44 <HAL_UARTEx_RxEventCallback>
}
 8006118:	bd70      	pop	{r4, r5, r6, pc}
        HAL_UART_ErrorCallback(huart);
 800611a:	4620      	mov	r0, r4
 800611c:	f7ff fe2e 	bl	8005d7c <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006120:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
}
 8006124:	bd70      	pop	{r4, r5, r6, pc}
 8006126:	bf00      	nop
 8006128:	04000120 	.word	0x04000120
 800612c:	08005e31 	.word	0x08005e31

08006130 <UART_DMARxHalfCplt>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8006130:	6b80      	ldr	r0, [r0, #56]	; 0x38
{
 8006132:	b508      	push	{r3, lr}
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8006134:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8006136:	2b01      	cmp	r3, #1
 8006138:	d002      	beq.n	8006140 <UART_DMARxHalfCplt+0x10>
    HAL_UART_RxHalfCpltCallback(huart);
 800613a:	f7ff fe1d 	bl	8005d78 <HAL_UART_RxHalfCpltCallback>
}
 800613e:	bd08      	pop	{r3, pc}
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 8006140:	f8b0 1058 	ldrh.w	r1, [r0, #88]	; 0x58
 8006144:	0849      	lsrs	r1, r1, #1
 8006146:	f7ff fe7d 	bl	8005e44 <HAL_UARTEx_RxEventCallback>
}
 800614a:	bd08      	pop	{r3, pc}

0800614c <UART_DMAReceiveCplt>:
{
 800614c:	b508      	push	{r3, lr}
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800614e:	69c3      	ldr	r3, [r0, #28]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8006150:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 8006152:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006156:	d028      	beq.n	80061aa <UART_DMAReceiveCplt+0x5e>
    huart->RxXferCount = 0U;
 8006158:	2200      	movs	r2, #0
 800615a:	6803      	ldr	r3, [r0, #0]
 800615c:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006160:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8006164:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006168:	e843 2100 	strex	r1, r2, [r3]
 800616c:	2900      	cmp	r1, #0
 800616e:	d1f7      	bne.n	8006160 <UART_DMAReceiveCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006170:	f103 0208 	add.w	r2, r3, #8
 8006174:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006178:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800617c:	f103 0c08 	add.w	ip, r3, #8
 8006180:	e84c 2100 	strex	r1, r2, [ip]
 8006184:	2900      	cmp	r1, #0
 8006186:	d1f3      	bne.n	8006170 <UART_DMAReceiveCplt+0x24>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006188:	f103 0208 	add.w	r2, r3, #8
 800618c:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8006190:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006194:	f103 0c08 	add.w	ip, r3, #8
 8006198:	e84c 2100 	strex	r1, r2, [ip]
 800619c:	2900      	cmp	r1, #0
 800619e:	d1f3      	bne.n	8006188 <UART_DMAReceiveCplt+0x3c>
    huart->RxState = HAL_UART_STATE_READY;
 80061a0:	2220      	movs	r2, #32
 80061a2:	67c2      	str	r2, [r0, #124]	; 0x7c
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80061a4:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80061a6:	2a01      	cmp	r2, #1
 80061a8:	d005      	beq.n	80061b6 <UART_DMAReceiveCplt+0x6a>
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80061aa:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80061ac:	2b01      	cmp	r3, #1
 80061ae:	d013      	beq.n	80061d8 <UART_DMAReceiveCplt+0x8c>
    HAL_UART_RxCpltCallback(huart);
 80061b0:	f7ff fde0 	bl	8005d74 <HAL_UART_RxCpltCallback>
}
 80061b4:	bd08      	pop	{r3, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80061b6:	e853 2f00 	ldrex	r2, [r3]
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80061ba:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80061be:	e843 2100 	strex	r1, r2, [r3]
 80061c2:	2900      	cmp	r1, #0
 80061c4:	d0f1      	beq.n	80061aa <UART_DMAReceiveCplt+0x5e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80061c6:	e853 2f00 	ldrex	r2, [r3]
 80061ca:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80061ce:	e843 2100 	strex	r1, r2, [r3]
 80061d2:	2900      	cmp	r1, #0
 80061d4:	d1ef      	bne.n	80061b6 <UART_DMAReceiveCplt+0x6a>
 80061d6:	e7e8      	b.n	80061aa <UART_DMAReceiveCplt+0x5e>
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80061d8:	f8b0 1058 	ldrh.w	r1, [r0, #88]	; 0x58
 80061dc:	f7ff fe32 	bl	8005e44 <HAL_UARTEx_RxEventCallback>
}
 80061e0:	bd08      	pop	{r3, pc}
 80061e2:	bf00      	nop

080061e4 <UART_SetConfig>:
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80061e4:	6901      	ldr	r1, [r0, #16]
 80061e6:	6882      	ldr	r2, [r0, #8]
{
 80061e8:	b538      	push	{r3, r4, r5, lr}
 80061ea:	4604      	mov	r4, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80061ec:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80061ee:	430a      	orrs	r2, r1
 80061f0:	69c0      	ldr	r0, [r0, #28]
 80061f2:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80061f4:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80061f6:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80061f8:	49a1      	ldr	r1, [pc, #644]	; (8006480 <UART_SetConfig+0x29c>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80061fa:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80061fc:	4029      	ands	r1, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80061fe:	68e5      	ldr	r5, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8006200:	430a      	orrs	r2, r1
 8006202:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006204:	6859      	ldr	r1, [r3, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8006206:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8006208:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 800620c:	4329      	orrs	r1, r5
 800620e:	6059      	str	r1, [r3, #4]
  tmpreg |= huart->Init.OneBitSampling;
 8006210:	6a21      	ldr	r1, [r4, #32]
 8006212:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006214:	6899      	ldr	r1, [r3, #8]
 8006216:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 800621a:	430a      	orrs	r2, r1
  UART_GETCLOCKSOURCE(huart, clocksource);
 800621c:	4999      	ldr	r1, [pc, #612]	; (8006484 <UART_SetConfig+0x2a0>)
 800621e:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8006220:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006222:	d03f      	beq.n	80062a4 <UART_SetConfig+0xc0>
 8006224:	4a98      	ldr	r2, [pc, #608]	; (8006488 <UART_SetConfig+0x2a4>)
 8006226:	4293      	cmp	r3, r2
 8006228:	d01b      	beq.n	8006262 <UART_SetConfig+0x7e>
 800622a:	4a98      	ldr	r2, [pc, #608]	; (800648c <UART_SetConfig+0x2a8>)
 800622c:	4293      	cmp	r3, r2
 800622e:	f000 80c9 	beq.w	80063c4 <UART_SetConfig+0x1e0>
 8006232:	4a97      	ldr	r2, [pc, #604]	; (8006490 <UART_SetConfig+0x2ac>)
 8006234:	4293      	cmp	r3, r2
 8006236:	f000 80d5 	beq.w	80063e4 <UART_SetConfig+0x200>
 800623a:	4a96      	ldr	r2, [pc, #600]	; (8006494 <UART_SetConfig+0x2b0>)
 800623c:	4293      	cmp	r3, r2
 800623e:	d05f      	beq.n	8006300 <UART_SetConfig+0x11c>
 8006240:	4a95      	ldr	r2, [pc, #596]	; (8006498 <UART_SetConfig+0x2b4>)
 8006242:	4293      	cmp	r3, r2
 8006244:	f000 8090 	beq.w	8006368 <UART_SetConfig+0x184>
 8006248:	4a94      	ldr	r2, [pc, #592]	; (800649c <UART_SetConfig+0x2b8>)
 800624a:	4293      	cmp	r3, r2
 800624c:	f000 80eb 	beq.w	8006426 <UART_SetConfig+0x242>
 8006250:	4a93      	ldr	r2, [pc, #588]	; (80064a0 <UART_SetConfig+0x2bc>)
 8006252:	4293      	cmp	r3, r2
 8006254:	f000 80fd 	beq.w	8006452 <UART_SetConfig+0x26e>
    switch (clocksource)
 8006258:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 800625a:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 800625c:	e9c4 3319 	strd	r3, r3, [r4, #100]	; 0x64
}
 8006260:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006262:	4b90      	ldr	r3, [pc, #576]	; (80064a4 <UART_SetConfig+0x2c0>)
 8006264:	4a90      	ldr	r2, [pc, #576]	; (80064a8 <UART_SetConfig+0x2c4>)
 8006266:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800626a:	f003 030c 	and.w	r3, r3, #12
 800626e:	5cd3      	ldrb	r3, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006270:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8006274:	d02d      	beq.n	80062d2 <UART_SetConfig+0xee>
    switch (clocksource)
 8006276:	2b08      	cmp	r3, #8
 8006278:	d8ee      	bhi.n	8006258 <UART_SetConfig+0x74>
 800627a:	a201      	add	r2, pc, #4	; (adr r2, 8006280 <UART_SetConfig+0x9c>)
 800627c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006280:	0800632d 	.word	0x0800632d
 8006284:	080062bb 	.word	0x080062bb
 8006288:	0800637f 	.word	0x0800637f
 800628c:	08006259 	.word	0x08006259
 8006290:	08006321 	.word	0x08006321
 8006294:	08006259 	.word	0x08006259
 8006298:	08006259 	.word	0x08006259
 800629c:	08006259 	.word	0x08006259
 80062a0:	0800633f 	.word	0x0800633f
  UART_GETCLOCKSOURCE(huart, clocksource);
 80062a4:	4b7f      	ldr	r3, [pc, #508]	; (80064a4 <UART_SetConfig+0x2c0>)
 80062a6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80062aa:	f003 0303 	and.w	r3, r3, #3
 80062ae:	3b01      	subs	r3, #1
 80062b0:	2b02      	cmp	r3, #2
 80062b2:	d90b      	bls.n	80062cc <UART_SetConfig+0xe8>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80062b4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80062b8:	d063      	beq.n	8006382 <UART_SetConfig+0x19e>
        pclk = HAL_RCC_GetPCLK2Freq();
 80062ba:	f7fd fe3f 	bl	8003f3c <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 80062be:	2800      	cmp	r0, #0
 80062c0:	d13f      	bne.n	8006342 <UART_SetConfig+0x15e>
  huart->RxISR = NULL;
 80062c2:	2300      	movs	r3, #0
 80062c4:	2000      	movs	r0, #0
  huart->TxISR = NULL;
 80062c6:	e9c4 3319 	strd	r3, r3, [r4, #100]	; 0x64
}
 80062ca:	bd38      	pop	{r3, r4, r5, pc}
 80062cc:	4a77      	ldr	r2, [pc, #476]	; (80064ac <UART_SetConfig+0x2c8>)
 80062ce:	5cd3      	ldrb	r3, [r2, r3]
 80062d0:	e7ce      	b.n	8006270 <UART_SetConfig+0x8c>
    switch (clocksource)
 80062d2:	2b08      	cmp	r3, #8
 80062d4:	d8c0      	bhi.n	8006258 <UART_SetConfig+0x74>
 80062d6:	a201      	add	r2, pc, #4	; (adr r2, 80062dc <UART_SetConfig+0xf8>)
 80062d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80062dc:	080063bf 	.word	0x080063bf
 80062e0:	08006383 	.word	0x08006383
 80062e4:	0800641d 	.word	0x0800641d
 80062e8:	08006259 	.word	0x08006259
 80062ec:	080063b9 	.word	0x080063b9
 80062f0:	08006259 	.word	0x08006259
 80062f4:	08006259 	.word	0x08006259
 80062f8:	08006259 	.word	0x08006259
 80062fc:	08006421 	.word	0x08006421
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006300:	4b68      	ldr	r3, [pc, #416]	; (80064a4 <UART_SetConfig+0x2c0>)
 8006302:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8006306:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800630a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800630e:	d033      	beq.n	8006378 <UART_SetConfig+0x194>
 8006310:	d80f      	bhi.n	8006332 <UART_SetConfig+0x14e>
 8006312:	b143      	cbz	r3, 8006326 <UART_SetConfig+0x142>
 8006314:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006318:	d19e      	bne.n	8006258 <UART_SetConfig+0x74>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800631a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800631e:	d04b      	beq.n	80063b8 <UART_SetConfig+0x1d4>
        pclk = HAL_RCC_GetSysClockFreq();
 8006320:	f7fd fdd6 	bl	8003ed0 <HAL_RCC_GetSysClockFreq>
        break;
 8006324:	e7cb      	b.n	80062be <UART_SetConfig+0xda>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006326:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800632a:	d048      	beq.n	80063be <UART_SetConfig+0x1da>
        pclk = HAL_RCC_GetPCLK1Freq();
 800632c:	f7fd fdf6 	bl	8003f1c <HAL_RCC_GetPCLK1Freq>
        break;
 8006330:	e7c5      	b.n	80062be <UART_SetConfig+0xda>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006332:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006336:	d18f      	bne.n	8006258 <UART_SetConfig+0x74>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006338:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800633c:	d070      	beq.n	8006420 <UART_SetConfig+0x23c>
        pclk = (uint32_t) LSE_VALUE;
 800633e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8006342:	6863      	ldr	r3, [r4, #4]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006344:	f64f 72ef 	movw	r2, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8006348:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800634c:	fbb0 f3f3 	udiv	r3, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8006350:	f1a3 0110 	sub.w	r1, r3, #16
 8006354:	4291      	cmp	r1, r2
 8006356:	f63f af7f 	bhi.w	8006258 <UART_SetConfig+0x74>
        huart->Instance->BRR = (uint16_t)usartdiv;
 800635a:	6822      	ldr	r2, [r4, #0]
 800635c:	2000      	movs	r0, #0
 800635e:	60d3      	str	r3, [r2, #12]
  huart->RxISR = NULL;
 8006360:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8006362:	e9c4 3319 	strd	r3, r3, [r4, #100]	; 0x64
}
 8006366:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006368:	4b4e      	ldr	r3, [pc, #312]	; (80064a4 <UART_SetConfig+0x2c0>)
 800636a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800636e:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8006372:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8006376:	d145      	bne.n	8006404 <UART_SetConfig+0x220>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006378:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800637c:	d04e      	beq.n	800641c <UART_SetConfig+0x238>
    switch (clocksource)
 800637e:	484c      	ldr	r0, [pc, #304]	; (80064b0 <UART_SetConfig+0x2cc>)
 8006380:	e7df      	b.n	8006342 <UART_SetConfig+0x15e>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006382:	f7fd fddb 	bl	8003f3c <HAL_RCC_GetPCLK2Freq>
    if (pclk != 0U)
 8006386:	2800      	cmp	r0, #0
 8006388:	d09b      	beq.n	80062c2 <UART_SetConfig+0xde>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800638a:	0043      	lsls	r3, r0, #1
 800638c:	6862      	ldr	r2, [r4, #4]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800638e:	f64f 71ef 	movw	r1, #65519	; 0xffef
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8006392:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8006396:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800639a:	f1a3 0210 	sub.w	r2, r3, #16
 800639e:	428a      	cmp	r2, r1
 80063a0:	f63f af5a 	bhi.w	8006258 <UART_SetConfig+0x74>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80063a4:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80063a8:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 80063ac:	6821      	ldr	r1, [r4, #0]
 80063ae:	2000      	movs	r0, #0
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80063b0:	b292      	uxth	r2, r2
        huart->Instance->BRR = brrtemp;
 80063b2:	4313      	orrs	r3, r2
 80063b4:	60cb      	str	r3, [r1, #12]
 80063b6:	e750      	b.n	800625a <UART_SetConfig+0x76>
        pclk = HAL_RCC_GetSysClockFreq();
 80063b8:	f7fd fd8a 	bl	8003ed0 <HAL_RCC_GetSysClockFreq>
        break;
 80063bc:	e7e3      	b.n	8006386 <UART_SetConfig+0x1a2>
        pclk = HAL_RCC_GetPCLK1Freq();
 80063be:	f7fd fdad 	bl	8003f1c <HAL_RCC_GetPCLK1Freq>
        break;
 80063c2:	e7e0      	b.n	8006386 <UART_SetConfig+0x1a2>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80063c4:	4b37      	ldr	r3, [pc, #220]	; (80064a4 <UART_SetConfig+0x2c0>)
 80063c6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80063ca:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80063ce:	2b20      	cmp	r3, #32
 80063d0:	d0d2      	beq.n	8006378 <UART_SetConfig+0x194>
 80063d2:	d804      	bhi.n	80063de <UART_SetConfig+0x1fa>
 80063d4:	2b00      	cmp	r3, #0
 80063d6:	d0a6      	beq.n	8006326 <UART_SetConfig+0x142>
 80063d8:	2b10      	cmp	r3, #16
 80063da:	d09e      	beq.n	800631a <UART_SetConfig+0x136>
 80063dc:	e73c      	b.n	8006258 <UART_SetConfig+0x74>
 80063de:	2b30      	cmp	r3, #48	; 0x30
 80063e0:	d0aa      	beq.n	8006338 <UART_SetConfig+0x154>
 80063e2:	e739      	b.n	8006258 <UART_SetConfig+0x74>
 80063e4:	4b2f      	ldr	r3, [pc, #188]	; (80064a4 <UART_SetConfig+0x2c0>)
 80063e6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80063ea:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80063ee:	2b80      	cmp	r3, #128	; 0x80
 80063f0:	d0c2      	beq.n	8006378 <UART_SetConfig+0x194>
 80063f2:	d804      	bhi.n	80063fe <UART_SetConfig+0x21a>
 80063f4:	2b00      	cmp	r3, #0
 80063f6:	d096      	beq.n	8006326 <UART_SetConfig+0x142>
 80063f8:	2b40      	cmp	r3, #64	; 0x40
 80063fa:	d08e      	beq.n	800631a <UART_SetConfig+0x136>
 80063fc:	e72c      	b.n	8006258 <UART_SetConfig+0x74>
 80063fe:	2bc0      	cmp	r3, #192	; 0xc0
 8006400:	d09a      	beq.n	8006338 <UART_SetConfig+0x154>
 8006402:	e729      	b.n	8006258 <UART_SetConfig+0x74>
 8006404:	d806      	bhi.n	8006414 <UART_SetConfig+0x230>
 8006406:	2b00      	cmp	r3, #0
 8006408:	f43f af54 	beq.w	80062b4 <UART_SetConfig+0xd0>
 800640c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8006410:	d083      	beq.n	800631a <UART_SetConfig+0x136>
 8006412:	e721      	b.n	8006258 <UART_SetConfig+0x74>
 8006414:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8006418:	d08e      	beq.n	8006338 <UART_SetConfig+0x154>
 800641a:	e71d      	b.n	8006258 <UART_SetConfig+0x74>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800641c:	4b25      	ldr	r3, [pc, #148]	; (80064b4 <UART_SetConfig+0x2d0>)
 800641e:	e7b5      	b.n	800638c <UART_SetConfig+0x1a8>
    switch (clocksource)
 8006420:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8006424:	e7b2      	b.n	800638c <UART_SetConfig+0x1a8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8006426:	4b1f      	ldr	r3, [pc, #124]	; (80064a4 <UART_SetConfig+0x2c0>)
 8006428:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800642c:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8006430:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006434:	d0a0      	beq.n	8006378 <UART_SetConfig+0x194>
 8006436:	d807      	bhi.n	8006448 <UART_SetConfig+0x264>
 8006438:	2b00      	cmp	r3, #0
 800643a:	f43f af74 	beq.w	8006326 <UART_SetConfig+0x142>
 800643e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8006442:	f43f af6a 	beq.w	800631a <UART_SetConfig+0x136>
 8006446:	e707      	b.n	8006258 <UART_SetConfig+0x74>
 8006448:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800644c:	f43f af74 	beq.w	8006338 <UART_SetConfig+0x154>
 8006450:	e702      	b.n	8006258 <UART_SetConfig+0x74>
 8006452:	4b14      	ldr	r3, [pc, #80]	; (80064a4 <UART_SetConfig+0x2c0>)
 8006454:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8006458:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800645c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006460:	d08a      	beq.n	8006378 <UART_SetConfig+0x194>
 8006462:	d807      	bhi.n	8006474 <UART_SetConfig+0x290>
 8006464:	2b00      	cmp	r3, #0
 8006466:	f43f af5e 	beq.w	8006326 <UART_SetConfig+0x142>
 800646a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800646e:	f43f af54 	beq.w	800631a <UART_SetConfig+0x136>
 8006472:	e6f1      	b.n	8006258 <UART_SetConfig+0x74>
 8006474:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8006478:	f43f af5e 	beq.w	8006338 <UART_SetConfig+0x154>
 800647c:	e6ec      	b.n	8006258 <UART_SetConfig+0x74>
 800647e:	bf00      	nop
 8006480:	efff69f3 	.word	0xefff69f3
 8006484:	40011000 	.word	0x40011000
 8006488:	40004400 	.word	0x40004400
 800648c:	40004800 	.word	0x40004800
 8006490:	40004c00 	.word	0x40004c00
 8006494:	40005000 	.word	0x40005000
 8006498:	40011400 	.word	0x40011400
 800649c:	40007800 	.word	0x40007800
 80064a0:	40007c00 	.word	0x40007c00
 80064a4:	40023800 	.word	0x40023800
 80064a8:	08016af8 	.word	0x08016af8
 80064ac:	08016af4 	.word	0x08016af4
 80064b0:	00f42400 	.word	0x00f42400
 80064b4:	01e84800 	.word	0x01e84800

080064b8 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80064b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80064ba:	07da      	lsls	r2, r3, #31
{
 80064bc:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80064be:	d506      	bpl.n	80064ce <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80064c0:	6801      	ldr	r1, [r0, #0]
 80064c2:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80064c4:	684a      	ldr	r2, [r1, #4]
 80064c6:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80064ca:	4322      	orrs	r2, r4
 80064cc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80064ce:	079c      	lsls	r4, r3, #30
 80064d0:	d506      	bpl.n	80064e0 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80064d2:	6801      	ldr	r1, [r0, #0]
 80064d4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80064d6:	684a      	ldr	r2, [r1, #4]
 80064d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80064dc:	4322      	orrs	r2, r4
 80064de:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80064e0:	0759      	lsls	r1, r3, #29
 80064e2:	d506      	bpl.n	80064f2 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80064e4:	6801      	ldr	r1, [r0, #0]
 80064e6:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80064e8:	684a      	ldr	r2, [r1, #4]
 80064ea:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80064ee:	4322      	orrs	r2, r4
 80064f0:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80064f2:	071a      	lsls	r2, r3, #28
 80064f4:	d506      	bpl.n	8006504 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80064f6:	6801      	ldr	r1, [r0, #0]
 80064f8:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80064fa:	684a      	ldr	r2, [r1, #4]
 80064fc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006500:	4322      	orrs	r2, r4
 8006502:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8006504:	06dc      	lsls	r4, r3, #27
 8006506:	d506      	bpl.n	8006516 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8006508:	6801      	ldr	r1, [r0, #0]
 800650a:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800650c:	688a      	ldr	r2, [r1, #8]
 800650e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8006512:	4322      	orrs	r2, r4
 8006514:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006516:	0699      	lsls	r1, r3, #26
 8006518:	d506      	bpl.n	8006528 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800651a:	6801      	ldr	r1, [r0, #0]
 800651c:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800651e:	688a      	ldr	r2, [r1, #8]
 8006520:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8006524:	4322      	orrs	r2, r4
 8006526:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8006528:	065a      	lsls	r2, r3, #25
 800652a:	d50a      	bpl.n	8006542 <UART_AdvFeatureConfig+0x8a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800652c:	6801      	ldr	r1, [r0, #0]
 800652e:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8006530:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006532:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8006536:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800653a:	ea42 0204 	orr.w	r2, r2, r4
 800653e:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8006540:	d00b      	beq.n	800655a <UART_AdvFeatureConfig+0xa2>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8006542:	061b      	lsls	r3, r3, #24
 8006544:	d506      	bpl.n	8006554 <UART_AdvFeatureConfig+0x9c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006546:	6802      	ldr	r2, [r0, #0]
 8006548:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800654a:	6853      	ldr	r3, [r2, #4]
 800654c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8006550:	430b      	orrs	r3, r1
 8006552:	6053      	str	r3, [r2, #4]
}
 8006554:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006558:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800655a:	684a      	ldr	r2, [r1, #4]
 800655c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800655e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8006562:	4322      	orrs	r2, r4
 8006564:	604a      	str	r2, [r1, #4]
 8006566:	e7ec      	b.n	8006542 <UART_AdvFeatureConfig+0x8a>

08006568 <HAL_UART_Init>:
  if (huart == NULL)
 8006568:	2800      	cmp	r0, #0
 800656a:	f000 808a 	beq.w	8006682 <HAL_UART_Init+0x11a>
{
 800656e:	b538      	push	{r3, r4, r5, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 8006570:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8006572:	4604      	mov	r4, r0
 8006574:	2b00      	cmp	r3, #0
 8006576:	d07f      	beq.n	8006678 <HAL_UART_Init+0x110>
  __HAL_UART_DISABLE(huart);
 8006578:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800657a:	2324      	movs	r3, #36	; 0x24
  if (UART_SetConfig(huart) == HAL_ERROR)
 800657c:	4620      	mov	r0, r4
  huart->gState = HAL_UART_STATE_BUSY;
 800657e:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UART_DISABLE(huart);
 8006580:	6813      	ldr	r3, [r2, #0]
 8006582:	f023 0301 	bic.w	r3, r3, #1
 8006586:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8006588:	f7ff fe2c 	bl	80061e4 <UART_SetConfig>
 800658c:	2801      	cmp	r0, #1
 800658e:	d071      	beq.n	8006674 <HAL_UART_Init+0x10c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006590:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006592:	2b00      	cmp	r3, #0
 8006594:	d16a      	bne.n	800666c <HAL_UART_Init+0x104>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8006596:	6823      	ldr	r3, [r4, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006598:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800659a:	685a      	ldr	r2, [r3, #4]
 800659c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80065a0:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80065a2:	689a      	ldr	r2, [r3, #8]
 80065a4:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80065a8:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80065aa:	681a      	ldr	r2, [r3, #0]
 80065ac:	f042 0201 	orr.w	r2, r2, #1
 80065b0:	601a      	str	r2, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80065b2:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
  tickstart = HAL_GetTick();
 80065b6:	f7fc fd9d 	bl	80030f4 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80065ba:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 80065bc:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80065be:	681a      	ldr	r2, [r3, #0]
 80065c0:	0712      	lsls	r2, r2, #28
 80065c2:	d408      	bmi.n	80065d6 <HAL_UART_Init+0x6e>
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80065c4:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 80065c6:	2220      	movs	r2, #32
  return HAL_OK;
 80065c8:	4618      	mov	r0, r3
  huart->gState = HAL_UART_STATE_READY;
 80065ca:	67a2      	str	r2, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 80065cc:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 80065d0:	67e2      	str	r2, [r4, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80065d2:	6623      	str	r3, [r4, #96]	; 0x60
}
 80065d4:	bd38      	pop	{r3, r4, r5, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80065d6:	69db      	ldr	r3, [r3, #28]
 80065d8:	0298      	lsls	r0, r3, #10
 80065da:	d4f3      	bmi.n	80065c4 <HAL_UART_Init+0x5c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80065dc:	f7fc fd8a 	bl	80030f4 <HAL_GetTick>
 80065e0:	1b43      	subs	r3, r0, r5
 80065e2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80065e6:	6823      	ldr	r3, [r4, #0]
 80065e8:	d225      	bcs.n	8006636 <HAL_UART_Init+0xce>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80065ea:	681a      	ldr	r2, [r3, #0]
 80065ec:	0751      	lsls	r1, r2, #29
 80065ee:	d5f2      	bpl.n	80065d6 <HAL_UART_Init+0x6e>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80065f0:	69da      	ldr	r2, [r3, #28]
 80065f2:	0512      	lsls	r2, r2, #20
 80065f4:	d5ef      	bpl.n	80065d6 <HAL_UART_Init+0x6e>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80065f6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80065fa:	621a      	str	r2, [r3, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80065fc:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8006600:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006604:	e843 2100 	strex	r1, r2, [r3]
 8006608:	2900      	cmp	r1, #0
 800660a:	d1f7      	bne.n	80065fc <HAL_UART_Init+0x94>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800660c:	f103 0208 	add.w	r2, r3, #8
 8006610:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006614:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006618:	f103 0008 	add.w	r0, r3, #8
 800661c:	e840 2100 	strex	r1, r2, [r0]
 8006620:	2900      	cmp	r1, #0
 8006622:	d1f3      	bne.n	800660c <HAL_UART_Init+0xa4>
          huart->gState = HAL_UART_STATE_READY;
 8006624:	2320      	movs	r3, #32
      return HAL_TIMEOUT;
 8006626:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 8006628:	f884 1074 	strb.w	r1, [r4, #116]	; 0x74
          huart->gState = HAL_UART_STATE_READY;
 800662c:	67a3      	str	r3, [r4, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
 800662e:	67e3      	str	r3, [r4, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8006630:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
}
 8006634:	bd38      	pop	{r3, r4, r5, pc}
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006636:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800663a:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800663e:	e843 2100 	strex	r1, r2, [r3]
 8006642:	2900      	cmp	r1, #0
 8006644:	d1f7      	bne.n	8006636 <HAL_UART_Init+0xce>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006646:	f103 0208 	add.w	r2, r3, #8
 800664a:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800664e:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006652:	f103 0008 	add.w	r0, r3, #8
 8006656:	e840 2100 	strex	r1, r2, [r0]
 800665a:	2900      	cmp	r1, #0
 800665c:	d1f3      	bne.n	8006646 <HAL_UART_Init+0xde>
        huart->gState = HAL_UART_STATE_READY;
 800665e:	2320      	movs	r3, #32
      return HAL_TIMEOUT;
 8006660:	2003      	movs	r0, #3
        __HAL_UNLOCK(huart);
 8006662:	f884 1074 	strb.w	r1, [r4, #116]	; 0x74
        huart->gState = HAL_UART_STATE_READY;
 8006666:	67a3      	str	r3, [r4, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
 8006668:	67e3      	str	r3, [r4, #124]	; 0x7c
}
 800666a:	bd38      	pop	{r3, r4, r5, pc}
    UART_AdvFeatureConfig(huart);
 800666c:	4620      	mov	r0, r4
 800666e:	f7ff ff23 	bl	80064b8 <UART_AdvFeatureConfig>
 8006672:	e790      	b.n	8006596 <HAL_UART_Init+0x2e>
    return HAL_ERROR;
 8006674:	2001      	movs	r0, #1
}
 8006676:	bd38      	pop	{r3, r4, r5, pc}
    huart->Lock = HAL_UNLOCKED;
 8006678:	f880 3074 	strb.w	r3, [r0, #116]	; 0x74
    HAL_UART_MspInit(huart);
 800667c:	f7fc fb08 	bl	8002c90 <HAL_UART_MspInit>
 8006680:	e77a      	b.n	8006578 <HAL_UART_Init+0x10>
    return HAL_ERROR;
 8006682:	2001      	movs	r0, #1
}
 8006684:	4770      	bx	lr
 8006686:	bf00      	nop

08006688 <UART_Start_Receive_DMA>:
{
 8006688:	b570      	push	{r4, r5, r6, lr}
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800668a:	2322      	movs	r3, #34	; 0x22
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800668c:	2500      	movs	r5, #0
{
 800668e:	4604      	mov	r4, r0
  huart->pRxBuffPtr = pData;
 8006690:	6541      	str	r1, [r0, #84]	; 0x54
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8006692:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
  huart->RxXferSize = Size;
 8006696:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 800669a:	67c3      	str	r3, [r0, #124]	; 0x7c
  if (huart->hdmarx != NULL)
 800669c:	6f00      	ldr	r0, [r0, #112]	; 0x70
 800669e:	b168      	cbz	r0, 80066bc <UART_Start_Receive_DMA+0x34>
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 80066a0:	4e1f      	ldr	r6, [pc, #124]	; (8006720 <UART_Start_Receive_DMA+0x98>)
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 80066a2:	4613      	mov	r3, r2
 80066a4:	460a      	mov	r2, r1
 80066a6:	6821      	ldr	r1, [r4, #0]
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 80066a8:	63c6      	str	r6, [r0, #60]	; 0x3c
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 80066aa:	4e1e      	ldr	r6, [pc, #120]	; (8006724 <UART_Start_Receive_DMA+0x9c>)
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 80066ac:	3124      	adds	r1, #36	; 0x24
    huart->hdmarx->XferAbortCallback = NULL;
 80066ae:	6505      	str	r5, [r0, #80]	; 0x50
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 80066b0:	6406      	str	r6, [r0, #64]	; 0x40
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 80066b2:	4e1d      	ldr	r6, [pc, #116]	; (8006728 <UART_Start_Receive_DMA+0xa0>)
 80066b4:	64c6      	str	r6, [r0, #76]	; 0x4c
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 80066b6:	f7fc fe45 	bl	8003344 <HAL_DMA_Start_IT>
 80066ba:	bb40      	cbnz	r0, 800670e <UART_Start_Receive_DMA+0x86>
  __HAL_UNLOCK(huart);
 80066bc:	2200      	movs	r2, #0
  if (huart->Init.Parity != UART_PARITY_NONE)
 80066be:	6923      	ldr	r3, [r4, #16]
  __HAL_UNLOCK(huart);
 80066c0:	f884 2074 	strb.w	r2, [r4, #116]	; 0x74
  if (huart->Init.Parity != UART_PARITY_NONE)
 80066c4:	b14b      	cbz	r3, 80066da <UART_Start_Receive_DMA+0x52>
 80066c6:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80066c8:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80066cc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80066d0:	e843 2100 	strex	r1, r2, [r3]
 80066d4:	2900      	cmp	r1, #0
 80066d6:	d1f7      	bne.n	80066c8 <UART_Start_Receive_DMA+0x40>
 80066d8:	e000      	b.n	80066dc <UART_Start_Receive_DMA+0x54>
 80066da:	6823      	ldr	r3, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80066dc:	f103 0208 	add.w	r2, r3, #8
 80066e0:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80066e4:	f042 0201 	orr.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80066e8:	f103 0008 	add.w	r0, r3, #8
 80066ec:	e840 2100 	strex	r1, r2, [r0]
 80066f0:	2900      	cmp	r1, #0
 80066f2:	d1f3      	bne.n	80066dc <UART_Start_Receive_DMA+0x54>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80066f4:	f103 0208 	add.w	r2, r3, #8
 80066f8:	e852 2f00 	ldrex	r2, [r2]
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80066fc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006700:	f103 0108 	add.w	r1, r3, #8
 8006704:	e841 2000 	strex	r0, r2, [r1]
 8006708:	2800      	cmp	r0, #0
 800670a:	d1f3      	bne.n	80066f4 <UART_Start_Receive_DMA+0x6c>
}
 800670c:	bd70      	pop	{r4, r5, r6, pc}
      huart->ErrorCode = HAL_UART_ERROR_DMA;
 800670e:	2210      	movs	r2, #16
      huart->RxState = HAL_UART_STATE_READY;
 8006710:	2320      	movs	r3, #32
      return HAL_ERROR;
 8006712:	2001      	movs	r0, #1
      __HAL_UNLOCK(huart);
 8006714:	f884 5074 	strb.w	r5, [r4, #116]	; 0x74
      huart->ErrorCode = HAL_UART_ERROR_DMA;
 8006718:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
      huart->RxState = HAL_UART_STATE_READY;
 800671c:	67e3      	str	r3, [r4, #124]	; 0x7c
}
 800671e:	bd70      	pop	{r4, r5, r6, pc}
 8006720:	0800614d 	.word	0x0800614d
 8006724:	08006131 	.word	0x08006131
 8006728:	08005d81 	.word	0x08005d81

0800672c <HAL_UART_Receive_DMA>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800672c:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 800672e:	2b20      	cmp	r3, #32
 8006730:	d11e      	bne.n	8006770 <HAL_UART_Receive_DMA+0x44>
    if ((pData == NULL) || (Size == 0U))
 8006732:	b1d9      	cbz	r1, 800676c <HAL_UART_Receive_DMA+0x40>
 8006734:	fab2 f382 	clz	r3, r2
 8006738:	095b      	lsrs	r3, r3, #5
 800673a:	b1ba      	cbz	r2, 800676c <HAL_UART_Receive_DMA+0x40>
{
 800673c:	b430      	push	{r4, r5}
    __HAL_LOCK(huart);
 800673e:	f890 4074 	ldrb.w	r4, [r0, #116]	; 0x74
 8006742:	2c01      	cmp	r4, #1
 8006744:	d016      	beq.n	8006774 <HAL_UART_Receive_DMA+0x48>
 8006746:	2501      	movs	r5, #1
    if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8006748:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800674a:	6603      	str	r3, [r0, #96]	; 0x60
    __HAL_LOCK(huart);
 800674c:	f880 5074 	strb.w	r5, [r0, #116]	; 0x74
    if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8006750:	6863      	ldr	r3, [r4, #4]
 8006752:	021b      	lsls	r3, r3, #8
 8006754:	d507      	bpl.n	8006766 <HAL_UART_Receive_DMA+0x3a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006756:	e854 3f00 	ldrex	r3, [r4]
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 800675a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800675e:	e844 3500 	strex	r5, r3, [r4]
 8006762:	2d00      	cmp	r5, #0
 8006764:	d1f7      	bne.n	8006756 <HAL_UART_Receive_DMA+0x2a>
}
 8006766:	bc30      	pop	{r4, r5}
    return (UART_Start_Receive_DMA(huart, pData, Size));
 8006768:	f7ff bf8e 	b.w	8006688 <UART_Start_Receive_DMA>
      return HAL_ERROR;
 800676c:	2001      	movs	r0, #1
}
 800676e:	4770      	bx	lr
    return HAL_BUSY;
 8006770:	2002      	movs	r0, #2
 8006772:	4770      	bx	lr
 8006774:	2002      	movs	r0, #2
}
 8006776:	bc30      	pop	{r4, r5}
 8006778:	4770      	bx	lr
 800677a:	bf00      	nop

0800677c <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
 800677c:	b084      	sub	sp, #16
 800677e:	b410      	push	{r4}
 8006780:	f10d 0c08 	add.w	ip, sp, #8
 8006784:	e88c 000e 	stmia.w	ip, {r1, r2, r3}
 8006788:	4602      	mov	r2, r0
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
  
  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 800678a:	460b      	mov	r3, r1
 800678c:	9803      	ldr	r0, [sp, #12]
             Init.ClockBypass         |\
 800678e:	9904      	ldr	r1, [sp, #16]
  tmpreg |= (Init.ClockEdge           |\
 8006790:	4303      	orrs	r3, r0
             Init.HardwareFlowControl |\
             Init.ClockDiv
             ); 
  
  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8006792:	6850      	ldr	r0, [r2, #4]
             Init.ClockBypass         |\
 8006794:	430b      	orrs	r3, r1
             Init.ClockPowerSave      |\
 8006796:	e9dd 4105 	ldrd	r4, r1, [sp, #20]
 800679a:	4323      	orrs	r3, r4
             Init.HardwareFlowControl |\
 800679c:	9c07      	ldr	r4, [sp, #28]
             Init.BusWide             |\
 800679e:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80067a0:	4904      	ldr	r1, [pc, #16]	; (80067b4 <SDMMC_Init+0x38>)
             Init.HardwareFlowControl |\
 80067a2:	4323      	orrs	r3, r4
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80067a4:	4001      	ands	r1, r0

  return HAL_OK;
}
 80067a6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80067aa:	2000      	movs	r0, #0
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80067ac:	430b      	orrs	r3, r1
}
 80067ae:	b004      	add	sp, #16
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 80067b0:	6053      	str	r3, [r2, #4]
}
 80067b2:	4770      	bx	lr
 80067b4:	ffff8100 	.word	0xffff8100

080067b8 <SDMMC_ReadFIFO>:
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
  /* Read data from Rx FIFO */ 
  return (SDMMCx->FIFO);
 80067b8:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 80067bc:	4770      	bx	lr
 80067be:	bf00      	nop

080067c0 <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{ 
 80067c0:	4603      	mov	r3, r0
  /* Write data to FIFO */ 
  SDMMCx->FIFO = *pWriteData;
 80067c2:	680a      	ldr	r2, [r1, #0]

  return HAL_OK;
}
 80067c4:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
 80067c6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 80067ca:	4770      	bx	lr

080067cc <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON. 
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{  
 80067cc:	4603      	mov	r3, r0
  /* Set power state to ON */ 
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 80067ce:	2203      	movs	r2, #3

  return HAL_OK;
}
 80067d0:	2000      	movs	r0, #0
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 80067d2:	601a      	str	r2, [r3, #0]
}
 80067d4:	4770      	bx	lr
 80067d6:	bf00      	nop

080067d8 <SDMMC_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)  
{
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 80067d8:	6800      	ldr	r0, [r0, #0]
}
 80067da:	f000 0003 	and.w	r0, r0, #3
 80067de:	4770      	bx	lr

080067e0 <SDMMC_GetResponse>:

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));
  
  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 80067e0:	3014      	adds	r0, #20
  
  return (*(__IO uint32_t *) tmp);
 80067e2:	5840      	ldr	r0, [r0, r1]
}  
 80067e4:	4770      	bx	lr
 80067e6:	bf00      	nop

080067e8 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure 
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
 80067e8:	b430      	push	{r4, r5}

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80067ea:	e9d1 3402 	ldrd	r3, r4, [r1, #8]
                       Data->TransferDir   |\
 80067ee:	690d      	ldr	r5, [r1, #16]
{
 80067f0:	4602      	mov	r2, r0
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80067f2:	4323      	orrs	r3, r4
  SDMMCx->DTIMER = Data->DataTimeOut;
 80067f4:	6808      	ldr	r0, [r1, #0]
  SDMMCx->DLEN = Data->DataLength;
 80067f6:	684c      	ldr	r4, [r1, #4]
  SDMMCx->DTIMER = Data->DataTimeOut;
 80067f8:	6250      	str	r0, [r2, #36]	; 0x24
                       Data->TransferDir   |\
 80067fa:	432b      	orrs	r3, r5
                       Data->TransferMode  |\
 80067fc:	6948      	ldr	r0, [r1, #20]
  SDMMCx->DLEN = Data->DataLength;
 80067fe:	6294      	str	r4, [r2, #40]	; 0x28
                       Data->DPSM);
  
  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8006800:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
                       Data->TransferMode  |\
 8006802:	4303      	orrs	r3, r0

  return HAL_OK;

}
 8006804:	2000      	movs	r0, #0
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 8006806:	f021 01f7 	bic.w	r1, r1, #247	; 0xf7
 800680a:	430b      	orrs	r3, r1
}
 800680c:	bc30      	pop	{r4, r5}
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800680e:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 8006810:	4770      	bx	lr
 8006812:	bf00      	nop

08006814 <SDMMC_CmdBlockLength>:
  uint32_t response_r1;
  uint32_t sta_reg;
  
  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006814:	4b4b      	ldr	r3, [pc, #300]	; (8006944 <SDMMC_CmdBlockLength+0x130>)
{
 8006816:	b430      	push	{r4, r5}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006818:	681a      	ldr	r2, [r3, #0]
 800681a:	4d4b      	ldr	r5, [pc, #300]	; (8006948 <SDMMC_CmdBlockLength+0x134>)
  SDMMCx->ARG = Command->Argument;
 800681c:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800681e:	4b4b      	ldr	r3, [pc, #300]	; (800694c <SDMMC_CmdBlockLength+0x138>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006820:	fba5 1202 	umull	r1, r2, r5, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006824:	68c4      	ldr	r4, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006826:	f241 3188 	movw	r1, #5000	; 0x1388
 800682a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800682c:	4023      	ands	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800682e:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006832:	f443 638a 	orr.w	r3, r3, #1104	; 0x450
 8006836:	60c3      	str	r3, [r0, #12]
  
  do
  {
    if (count-- == 0U)
 8006838:	b14a      	cbz	r2, 800684e <SDMMC_CmdBlockLength+0x3a>
 800683a:	1e53      	subs	r3, r2, #1
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800683c:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 800683e:	3b01      	subs	r3, #1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006840:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006844:	d001      	beq.n	800684a <SDMMC_CmdBlockLength+0x36>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006846:	0512      	lsls	r2, r2, #20
 8006848:	d506      	bpl.n	8006858 <SDMMC_CmdBlockLength+0x44>
    if (count-- == 0U)
 800684a:	1c59      	adds	r1, r3, #1
 800684c:	d1f6      	bne.n	800683c <SDMMC_CmdBlockLength+0x28>
      return SDMMC_ERROR_TIMEOUT;
 800684e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006852:	4618      	mov	r0, r3
 8006854:	bc30      	pop	{r4, r5}
 8006856:	4770      	bx	lr
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006858:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800685a:	075b      	lsls	r3, r3, #29
 800685c:	d43d      	bmi.n	80068da <SDMMC_CmdBlockLength+0xc6>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800685e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006860:	f013 0301 	ands.w	r3, r3, #1
 8006864:	d134      	bne.n	80068d0 <SDMMC_CmdBlockLength+0xbc>
  {
    /* Nothing to do */
  }
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006866:	23c5      	movs	r3, #197	; 0xc5
 8006868:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800686a:	6903      	ldr	r3, [r0, #16]
  
  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800686c:	b2db      	uxtb	r3, r3
 800686e:	2b10      	cmp	r3, #16
 8006870:	d131      	bne.n	80068d6 <SDMMC_CmdBlockLength+0xc2>
  return (*(__IO uint32_t *) tmp);
 8006872:	6942      	ldr	r2, [r0, #20]
  }
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
  
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8006874:	4b36      	ldr	r3, [pc, #216]	; (8006950 <SDMMC_CmdBlockLength+0x13c>)
 8006876:	4013      	ands	r3, r2
 8006878:	2b00      	cmp	r3, #0
 800687a:	d0ea      	beq.n	8006852 <SDMMC_CmdBlockLength+0x3e>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800687c:	2a00      	cmp	r2, #0
 800687e:	db30      	blt.n	80068e2 <SDMMC_CmdBlockLength+0xce>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8006880:	0055      	lsls	r5, r2, #1
 8006882:	d431      	bmi.n	80068e8 <SDMMC_CmdBlockLength+0xd4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8006884:	0094      	lsls	r4, r2, #2
 8006886:	d431      	bmi.n	80068ec <SDMMC_CmdBlockLength+0xd8>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8006888:	00d0      	lsls	r0, r2, #3
 800688a:	d431      	bmi.n	80068f0 <SDMMC_CmdBlockLength+0xdc>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800688c:	0111      	lsls	r1, r2, #4
 800688e:	d432      	bmi.n	80068f6 <SDMMC_CmdBlockLength+0xe2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8006890:	0155      	lsls	r5, r2, #5
 8006892:	d433      	bmi.n	80068fc <SDMMC_CmdBlockLength+0xe8>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8006894:	01d4      	lsls	r4, r2, #7
 8006896:	d434      	bmi.n	8006902 <SDMMC_CmdBlockLength+0xee>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8006898:	0210      	lsls	r0, r2, #8
 800689a:	d435      	bmi.n	8006908 <SDMMC_CmdBlockLength+0xf4>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800689c:	0251      	lsls	r1, r2, #9
 800689e:	d436      	bmi.n	800690e <SDMMC_CmdBlockLength+0xfa>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 80068a0:	0295      	lsls	r5, r2, #10
 80068a2:	d440      	bmi.n	8006926 <SDMMC_CmdBlockLength+0x112>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 80068a4:	02d4      	lsls	r4, r2, #11
 80068a6:	d43b      	bmi.n	8006920 <SDMMC_CmdBlockLength+0x10c>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 80068a8:	0350      	lsls	r0, r2, #13
 80068aa:	d436      	bmi.n	800691a <SDMMC_CmdBlockLength+0x106>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 80068ac:	0391      	lsls	r1, r2, #14
 80068ae:	d431      	bmi.n	8006914 <SDMMC_CmdBlockLength+0x100>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 80068b0:	03d5      	lsls	r5, r2, #15
 80068b2:	d444      	bmi.n	800693e <SDMMC_CmdBlockLength+0x12a>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 80068b4:	0414      	lsls	r4, r2, #16
 80068b6:	d43f      	bmi.n	8006938 <SDMMC_CmdBlockLength+0x124>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 80068b8:	0450      	lsls	r0, r2, #17
 80068ba:	d43a      	bmi.n	8006932 <SDMMC_CmdBlockLength+0x11e>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 80068bc:	0491      	lsls	r1, r2, #18
 80068be:	d435      	bmi.n	800692c <SDMMC_CmdBlockLength+0x118>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 80068c0:	f012 0f08 	tst.w	r2, #8
 80068c4:	bf14      	ite	ne
 80068c6:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 80068ca:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 80068ce:	e7c0      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80068d0:	2201      	movs	r2, #1
 80068d2:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80068d4:	e7bd      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80068d6:	2301      	movs	r3, #1
 80068d8:	e7bb      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80068da:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80068dc:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80068de:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80068e0:	e7b7      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 80068e2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80068e6:	e7b4      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 80068e8:	2340      	movs	r3, #64	; 0x40
 80068ea:	e7b2      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 80068ec:	2380      	movs	r3, #128	; 0x80
 80068ee:	e7b0      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 80068f0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80068f4:	e7ad      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 80068f6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80068fa:	e7aa      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 80068fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006900:	e7a7      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006902:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006906:	e7a4      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006908:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800690c:	e7a1      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800690e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006912:	e79e      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006914:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006918:	e79b      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800691a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 800691e:	e798      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_CC_ERR;
 8006920:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006924:	e795      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006926:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800692a:	e792      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_ERASE_RESET;
 800692c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006930:	e78f      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006932:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006936:	e78c      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006938:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800693c:	e789      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800693e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006942:	e786      	b.n	8006852 <SDMMC_CmdBlockLength+0x3e>
 8006944:	20000680 	.word	0x20000680
 8006948:	10624dd3 	.word	0x10624dd3
 800694c:	fffff000 	.word	0xfffff000
 8006950:	fdffe008 	.word	0xfdffe008

08006954 <SDMMC_CmdReadSingleBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006954:	4a4c      	ldr	r2, [pc, #304]	; (8006a88 <SDMMC_CmdReadSingleBlock+0x134>)
 8006956:	4b4d      	ldr	r3, [pc, #308]	; (8006a8c <SDMMC_CmdReadSingleBlock+0x138>)
 8006958:	6812      	ldr	r2, [r2, #0]
{
 800695a:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800695c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006960:	4c4b      	ldr	r4, [pc, #300]	; (8006a90 <SDMMC_CmdReadSingleBlock+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8006962:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006964:	f240 4351 	movw	r3, #1105	; 0x451
 8006968:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800696a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800696c:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800696e:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006972:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006974:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006978:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800697a:	b14a      	cbz	r2, 8006990 <SDMMC_CmdReadSingleBlock+0x3c>
 800697c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800697e:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006980:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006982:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006986:	d001      	beq.n	800698c <SDMMC_CmdReadSingleBlock+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006988:	0512      	lsls	r2, r2, #20
 800698a:	d507      	bpl.n	800699c <SDMMC_CmdReadSingleBlock+0x48>
    if (count-- == 0U)
 800698c:	1c59      	adds	r1, r3, #1
 800698e:	d1f6      	bne.n	800697e <SDMMC_CmdReadSingleBlock+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8006990:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006994:	4618      	mov	r0, r3
 8006996:	f85d 4b04 	ldr.w	r4, [sp], #4
 800699a:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800699c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800699e:	075c      	lsls	r4, r3, #29
 80069a0:	d43d      	bmi.n	8006a1e <SDMMC_CmdReadSingleBlock+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80069a2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80069a4:	f013 0301 	ands.w	r3, r3, #1
 80069a8:	d134      	bne.n	8006a14 <SDMMC_CmdReadSingleBlock+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80069aa:	23c5      	movs	r3, #197	; 0xc5
 80069ac:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 80069ae:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80069b0:	b2db      	uxtb	r3, r3
 80069b2:	2b11      	cmp	r3, #17
 80069b4:	d131      	bne.n	8006a1a <SDMMC_CmdReadSingleBlock+0xc6>
  return (*(__IO uint32_t *) tmp);
 80069b6:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 80069b8:	4b36      	ldr	r3, [pc, #216]	; (8006a94 <SDMMC_CmdReadSingleBlock+0x140>)
 80069ba:	4013      	ands	r3, r2
 80069bc:	2b00      	cmp	r3, #0
 80069be:	d0e9      	beq.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 80069c0:	2a00      	cmp	r2, #0
 80069c2:	db30      	blt.n	8006a26 <SDMMC_CmdReadSingleBlock+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 80069c4:	0051      	lsls	r1, r2, #1
 80069c6:	d431      	bmi.n	8006a2c <SDMMC_CmdReadSingleBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 80069c8:	0094      	lsls	r4, r2, #2
 80069ca:	d431      	bmi.n	8006a30 <SDMMC_CmdReadSingleBlock+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 80069cc:	00d0      	lsls	r0, r2, #3
 80069ce:	d431      	bmi.n	8006a34 <SDMMC_CmdReadSingleBlock+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 80069d0:	0111      	lsls	r1, r2, #4
 80069d2:	d432      	bmi.n	8006a3a <SDMMC_CmdReadSingleBlock+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 80069d4:	0154      	lsls	r4, r2, #5
 80069d6:	d433      	bmi.n	8006a40 <SDMMC_CmdReadSingleBlock+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 80069d8:	01d0      	lsls	r0, r2, #7
 80069da:	d434      	bmi.n	8006a46 <SDMMC_CmdReadSingleBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 80069dc:	0211      	lsls	r1, r2, #8
 80069de:	d435      	bmi.n	8006a4c <SDMMC_CmdReadSingleBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 80069e0:	0254      	lsls	r4, r2, #9
 80069e2:	d436      	bmi.n	8006a52 <SDMMC_CmdReadSingleBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 80069e4:	0290      	lsls	r0, r2, #10
 80069e6:	d440      	bmi.n	8006a6a <SDMMC_CmdReadSingleBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 80069e8:	02d1      	lsls	r1, r2, #11
 80069ea:	d43b      	bmi.n	8006a64 <SDMMC_CmdReadSingleBlock+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 80069ec:	0354      	lsls	r4, r2, #13
 80069ee:	d436      	bmi.n	8006a5e <SDMMC_CmdReadSingleBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 80069f0:	0390      	lsls	r0, r2, #14
 80069f2:	d431      	bmi.n	8006a58 <SDMMC_CmdReadSingleBlock+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 80069f4:	03d1      	lsls	r1, r2, #15
 80069f6:	d444      	bmi.n	8006a82 <SDMMC_CmdReadSingleBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 80069f8:	0414      	lsls	r4, r2, #16
 80069fa:	d43f      	bmi.n	8006a7c <SDMMC_CmdReadSingleBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 80069fc:	0450      	lsls	r0, r2, #17
 80069fe:	d43a      	bmi.n	8006a76 <SDMMC_CmdReadSingleBlock+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8006a00:	0491      	lsls	r1, r2, #18
 8006a02:	d435      	bmi.n	8006a70 <SDMMC_CmdReadSingleBlock+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8006a04:	f012 0f08 	tst.w	r2, #8
 8006a08:	bf14      	ite	ne
 8006a0a:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8006a0e:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8006a12:	e7bf      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8006a14:	2201      	movs	r2, #1
 8006a16:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006a18:	e7bc      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006a1a:	2301      	movs	r3, #1
 8006a1c:	e7ba      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006a1e:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006a20:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006a22:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006a24:	e7b6      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8006a26:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006a2a:	e7b3      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8006a2c:	2340      	movs	r3, #64	; 0x40
 8006a2e:	e7b1      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8006a30:	2380      	movs	r3, #128	; 0x80
 8006a32:	e7af      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8006a34:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006a38:	e7ac      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8006a3a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006a3e:	e7a9      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8006a40:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006a44:	e7a6      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006a46:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006a4a:	e7a3      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006a4c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006a50:	e7a0      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8006a52:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006a56:	e79d      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006a58:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006a5c:	e79a      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8006a5e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006a62:	e797      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_CC_ERR;
 8006a64:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006a68:	e794      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006a6a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8006a6e:	e791      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 8006a70:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006a74:	e78e      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006a76:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006a7a:	e78b      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006a7c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006a80:	e788      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8006a82:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006a86:	e785      	b.n	8006994 <SDMMC_CmdReadSingleBlock+0x40>
 8006a88:	20000680 	.word	0x20000680
 8006a8c:	10624dd3 	.word	0x10624dd3
 8006a90:	fffff000 	.word	0xfffff000
 8006a94:	fdffe008 	.word	0xfdffe008

08006a98 <SDMMC_CmdReadMultiBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006a98:	4a4c      	ldr	r2, [pc, #304]	; (8006bcc <SDMMC_CmdReadMultiBlock+0x134>)
 8006a9a:	4b4d      	ldr	r3, [pc, #308]	; (8006bd0 <SDMMC_CmdReadMultiBlock+0x138>)
 8006a9c:	6812      	ldr	r2, [r2, #0]
{
 8006a9e:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006aa0:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006aa4:	4c4b      	ldr	r4, [pc, #300]	; (8006bd4 <SDMMC_CmdReadMultiBlock+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8006aa6:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006aa8:	f240 4352 	movw	r3, #1106	; 0x452
 8006aac:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006aae:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006ab0:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006ab2:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006ab6:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006ab8:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006abc:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 8006abe:	b14a      	cbz	r2, 8006ad4 <SDMMC_CmdReadMultiBlock+0x3c>
 8006ac0:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8006ac2:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006ac4:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006ac6:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006aca:	d001      	beq.n	8006ad0 <SDMMC_CmdReadMultiBlock+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006acc:	0512      	lsls	r2, r2, #20
 8006ace:	d507      	bpl.n	8006ae0 <SDMMC_CmdReadMultiBlock+0x48>
    if (count-- == 0U)
 8006ad0:	1c59      	adds	r1, r3, #1
 8006ad2:	d1f6      	bne.n	8006ac2 <SDMMC_CmdReadMultiBlock+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8006ad4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006ad8:	4618      	mov	r0, r3
 8006ada:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006ade:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006ae0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006ae2:	075c      	lsls	r4, r3, #29
 8006ae4:	d43d      	bmi.n	8006b62 <SDMMC_CmdReadMultiBlock+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8006ae6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006ae8:	f013 0301 	ands.w	r3, r3, #1
 8006aec:	d134      	bne.n	8006b58 <SDMMC_CmdReadMultiBlock+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006aee:	23c5      	movs	r3, #197	; 0xc5
 8006af0:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8006af2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8006af4:	b2db      	uxtb	r3, r3
 8006af6:	2b12      	cmp	r3, #18
 8006af8:	d131      	bne.n	8006b5e <SDMMC_CmdReadMultiBlock+0xc6>
  return (*(__IO uint32_t *) tmp);
 8006afa:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8006afc:	4b36      	ldr	r3, [pc, #216]	; (8006bd8 <SDMMC_CmdReadMultiBlock+0x140>)
 8006afe:	4013      	ands	r3, r2
 8006b00:	2b00      	cmp	r3, #0
 8006b02:	d0e9      	beq.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8006b04:	2a00      	cmp	r2, #0
 8006b06:	db30      	blt.n	8006b6a <SDMMC_CmdReadMultiBlock+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8006b08:	0051      	lsls	r1, r2, #1
 8006b0a:	d431      	bmi.n	8006b70 <SDMMC_CmdReadMultiBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8006b0c:	0094      	lsls	r4, r2, #2
 8006b0e:	d431      	bmi.n	8006b74 <SDMMC_CmdReadMultiBlock+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8006b10:	00d0      	lsls	r0, r2, #3
 8006b12:	d431      	bmi.n	8006b78 <SDMMC_CmdReadMultiBlock+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8006b14:	0111      	lsls	r1, r2, #4
 8006b16:	d432      	bmi.n	8006b7e <SDMMC_CmdReadMultiBlock+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8006b18:	0154      	lsls	r4, r2, #5
 8006b1a:	d433      	bmi.n	8006b84 <SDMMC_CmdReadMultiBlock+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8006b1c:	01d0      	lsls	r0, r2, #7
 8006b1e:	d434      	bmi.n	8006b8a <SDMMC_CmdReadMultiBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8006b20:	0211      	lsls	r1, r2, #8
 8006b22:	d435      	bmi.n	8006b90 <SDMMC_CmdReadMultiBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8006b24:	0254      	lsls	r4, r2, #9
 8006b26:	d436      	bmi.n	8006b96 <SDMMC_CmdReadMultiBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8006b28:	0290      	lsls	r0, r2, #10
 8006b2a:	d440      	bmi.n	8006bae <SDMMC_CmdReadMultiBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8006b2c:	02d1      	lsls	r1, r2, #11
 8006b2e:	d43b      	bmi.n	8006ba8 <SDMMC_CmdReadMultiBlock+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8006b30:	0354      	lsls	r4, r2, #13
 8006b32:	d436      	bmi.n	8006ba2 <SDMMC_CmdReadMultiBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8006b34:	0390      	lsls	r0, r2, #14
 8006b36:	d431      	bmi.n	8006b9c <SDMMC_CmdReadMultiBlock+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8006b38:	03d1      	lsls	r1, r2, #15
 8006b3a:	d444      	bmi.n	8006bc6 <SDMMC_CmdReadMultiBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8006b3c:	0414      	lsls	r4, r2, #16
 8006b3e:	d43f      	bmi.n	8006bc0 <SDMMC_CmdReadMultiBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8006b40:	0450      	lsls	r0, r2, #17
 8006b42:	d43a      	bmi.n	8006bba <SDMMC_CmdReadMultiBlock+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8006b44:	0491      	lsls	r1, r2, #18
 8006b46:	d435      	bmi.n	8006bb4 <SDMMC_CmdReadMultiBlock+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8006b48:	f012 0f08 	tst.w	r2, #8
 8006b4c:	bf14      	ite	ne
 8006b4e:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8006b52:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8006b56:	e7bf      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8006b58:	2201      	movs	r2, #1
 8006b5a:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006b5c:	e7bc      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006b5e:	2301      	movs	r3, #1
 8006b60:	e7ba      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006b62:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006b64:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006b66:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006b68:	e7b6      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8006b6a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006b6e:	e7b3      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8006b70:	2340      	movs	r3, #64	; 0x40
 8006b72:	e7b1      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8006b74:	2380      	movs	r3, #128	; 0x80
 8006b76:	e7af      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8006b78:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006b7c:	e7ac      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8006b7e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006b82:	e7a9      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8006b84:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006b88:	e7a6      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006b8a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006b8e:	e7a3      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006b90:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006b94:	e7a0      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8006b96:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006b9a:	e79d      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006b9c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006ba0:	e79a      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8006ba2:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006ba6:	e797      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_CC_ERR;
 8006ba8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006bac:	e794      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006bae:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8006bb2:	e791      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 8006bb4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006bb8:	e78e      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006bba:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006bbe:	e78b      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006bc0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006bc4:	e788      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8006bc6:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006bca:	e785      	b.n	8006ad8 <SDMMC_CmdReadMultiBlock+0x40>
 8006bcc:	20000680 	.word	0x20000680
 8006bd0:	10624dd3 	.word	0x10624dd3
 8006bd4:	fffff000 	.word	0xfffff000
 8006bd8:	fdffe008 	.word	0xfdffe008

08006bdc <SDMMC_CmdWriteSingleBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006bdc:	4b4b      	ldr	r3, [pc, #300]	; (8006d0c <SDMMC_CmdWriteSingleBlock+0x130>)
{
 8006bde:	b430      	push	{r4, r5}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006be0:	681a      	ldr	r2, [r3, #0]
 8006be2:	4d4b      	ldr	r5, [pc, #300]	; (8006d10 <SDMMC_CmdWriteSingleBlock+0x134>)
  SDMMCx->ARG = Command->Argument;
 8006be4:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006be6:	4b4b      	ldr	r3, [pc, #300]	; (8006d14 <SDMMC_CmdWriteSingleBlock+0x138>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006be8:	fba5 1202 	umull	r1, r2, r5, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006bec:	68c4      	ldr	r4, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006bee:	f241 3188 	movw	r1, #5000	; 0x1388
 8006bf2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006bf4:	4023      	ands	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006bf6:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006bfa:	f443 638b 	orr.w	r3, r3, #1112	; 0x458
 8006bfe:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 8006c00:	b14a      	cbz	r2, 8006c16 <SDMMC_CmdWriteSingleBlock+0x3a>
 8006c02:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8006c04:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006c06:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006c08:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006c0c:	d001      	beq.n	8006c12 <SDMMC_CmdWriteSingleBlock+0x36>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006c0e:	0512      	lsls	r2, r2, #20
 8006c10:	d506      	bpl.n	8006c20 <SDMMC_CmdWriteSingleBlock+0x44>
    if (count-- == 0U)
 8006c12:	1c59      	adds	r1, r3, #1
 8006c14:	d1f6      	bne.n	8006c04 <SDMMC_CmdWriteSingleBlock+0x28>
      return SDMMC_ERROR_TIMEOUT;
 8006c16:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006c1a:	4618      	mov	r0, r3
 8006c1c:	bc30      	pop	{r4, r5}
 8006c1e:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006c20:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006c22:	075b      	lsls	r3, r3, #29
 8006c24:	d43d      	bmi.n	8006ca2 <SDMMC_CmdWriteSingleBlock+0xc6>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8006c26:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006c28:	f013 0301 	ands.w	r3, r3, #1
 8006c2c:	d134      	bne.n	8006c98 <SDMMC_CmdWriteSingleBlock+0xbc>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006c2e:	23c5      	movs	r3, #197	; 0xc5
 8006c30:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8006c32:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8006c34:	b2db      	uxtb	r3, r3
 8006c36:	2b18      	cmp	r3, #24
 8006c38:	d131      	bne.n	8006c9e <SDMMC_CmdWriteSingleBlock+0xc2>
  return (*(__IO uint32_t *) tmp);
 8006c3a:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8006c3c:	4b36      	ldr	r3, [pc, #216]	; (8006d18 <SDMMC_CmdWriteSingleBlock+0x13c>)
 8006c3e:	4013      	ands	r3, r2
 8006c40:	2b00      	cmp	r3, #0
 8006c42:	d0ea      	beq.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8006c44:	2a00      	cmp	r2, #0
 8006c46:	db30      	blt.n	8006caa <SDMMC_CmdWriteSingleBlock+0xce>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8006c48:	0055      	lsls	r5, r2, #1
 8006c4a:	d431      	bmi.n	8006cb0 <SDMMC_CmdWriteSingleBlock+0xd4>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8006c4c:	0094      	lsls	r4, r2, #2
 8006c4e:	d431      	bmi.n	8006cb4 <SDMMC_CmdWriteSingleBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8006c50:	00d0      	lsls	r0, r2, #3
 8006c52:	d431      	bmi.n	8006cb8 <SDMMC_CmdWriteSingleBlock+0xdc>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8006c54:	0111      	lsls	r1, r2, #4
 8006c56:	d432      	bmi.n	8006cbe <SDMMC_CmdWriteSingleBlock+0xe2>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8006c58:	0155      	lsls	r5, r2, #5
 8006c5a:	d433      	bmi.n	8006cc4 <SDMMC_CmdWriteSingleBlock+0xe8>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8006c5c:	01d4      	lsls	r4, r2, #7
 8006c5e:	d434      	bmi.n	8006cca <SDMMC_CmdWriteSingleBlock+0xee>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8006c60:	0210      	lsls	r0, r2, #8
 8006c62:	d435      	bmi.n	8006cd0 <SDMMC_CmdWriteSingleBlock+0xf4>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8006c64:	0251      	lsls	r1, r2, #9
 8006c66:	d436      	bmi.n	8006cd6 <SDMMC_CmdWriteSingleBlock+0xfa>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8006c68:	0295      	lsls	r5, r2, #10
 8006c6a:	d440      	bmi.n	8006cee <SDMMC_CmdWriteSingleBlock+0x112>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8006c6c:	02d4      	lsls	r4, r2, #11
 8006c6e:	d43b      	bmi.n	8006ce8 <SDMMC_CmdWriteSingleBlock+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8006c70:	0350      	lsls	r0, r2, #13
 8006c72:	d436      	bmi.n	8006ce2 <SDMMC_CmdWriteSingleBlock+0x106>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8006c74:	0391      	lsls	r1, r2, #14
 8006c76:	d431      	bmi.n	8006cdc <SDMMC_CmdWriteSingleBlock+0x100>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8006c78:	03d5      	lsls	r5, r2, #15
 8006c7a:	d444      	bmi.n	8006d06 <SDMMC_CmdWriteSingleBlock+0x12a>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8006c7c:	0414      	lsls	r4, r2, #16
 8006c7e:	d43f      	bmi.n	8006d00 <SDMMC_CmdWriteSingleBlock+0x124>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8006c80:	0450      	lsls	r0, r2, #17
 8006c82:	d43a      	bmi.n	8006cfa <SDMMC_CmdWriteSingleBlock+0x11e>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8006c84:	0491      	lsls	r1, r2, #18
 8006c86:	d435      	bmi.n	8006cf4 <SDMMC_CmdWriteSingleBlock+0x118>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8006c88:	f012 0f08 	tst.w	r2, #8
 8006c8c:	bf14      	ite	ne
 8006c8e:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8006c92:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8006c96:	e7c0      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8006c98:	2201      	movs	r2, #1
 8006c9a:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006c9c:	e7bd      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006c9e:	2301      	movs	r3, #1
 8006ca0:	e7bb      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006ca2:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006ca4:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006ca6:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006ca8:	e7b7      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8006caa:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006cae:	e7b4      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8006cb0:	2340      	movs	r3, #64	; 0x40
 8006cb2:	e7b2      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8006cb4:	2380      	movs	r3, #128	; 0x80
 8006cb6:	e7b0      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8006cb8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006cbc:	e7ad      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8006cbe:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006cc2:	e7aa      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8006cc4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006cc8:	e7a7      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006cca:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006cce:	e7a4      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006cd0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006cd4:	e7a1      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8006cd6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006cda:	e79e      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006cdc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006ce0:	e79b      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8006ce2:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006ce6:	e798      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_CC_ERR;
 8006ce8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006cec:	e795      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006cee:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8006cf2:	e792      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_ERASE_RESET;
 8006cf4:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006cf8:	e78f      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006cfa:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006cfe:	e78c      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006d00:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006d04:	e789      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8006d06:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006d0a:	e786      	b.n	8006c1a <SDMMC_CmdWriteSingleBlock+0x3e>
 8006d0c:	20000680 	.word	0x20000680
 8006d10:	10624dd3 	.word	0x10624dd3
 8006d14:	fffff000 	.word	0xfffff000
 8006d18:	fdffe008 	.word	0xfdffe008

08006d1c <SDMMC_CmdWriteMultiBlock>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006d1c:	4a4c      	ldr	r2, [pc, #304]	; (8006e50 <SDMMC_CmdWriteMultiBlock+0x134>)
 8006d1e:	4b4d      	ldr	r3, [pc, #308]	; (8006e54 <SDMMC_CmdWriteMultiBlock+0x138>)
 8006d20:	6812      	ldr	r2, [r2, #0]
{
 8006d22:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006d24:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006d28:	4c4b      	ldr	r4, [pc, #300]	; (8006e58 <SDMMC_CmdWriteMultiBlock+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8006d2a:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006d2c:	f240 4359 	movw	r3, #1113	; 0x459
 8006d30:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006d32:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006d34:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006d36:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006d3a:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006d3c:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006d40:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 8006d42:	b14a      	cbz	r2, 8006d58 <SDMMC_CmdWriteMultiBlock+0x3c>
 8006d44:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8006d46:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006d48:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006d4a:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006d4e:	d001      	beq.n	8006d54 <SDMMC_CmdWriteMultiBlock+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006d50:	0512      	lsls	r2, r2, #20
 8006d52:	d507      	bpl.n	8006d64 <SDMMC_CmdWriteMultiBlock+0x48>
    if (count-- == 0U)
 8006d54:	1c59      	adds	r1, r3, #1
 8006d56:	d1f6      	bne.n	8006d46 <SDMMC_CmdWriteMultiBlock+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8006d58:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006d5c:	4618      	mov	r0, r3
 8006d5e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006d62:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006d64:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006d66:	075c      	lsls	r4, r3, #29
 8006d68:	d43d      	bmi.n	8006de6 <SDMMC_CmdWriteMultiBlock+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8006d6a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006d6c:	f013 0301 	ands.w	r3, r3, #1
 8006d70:	d134      	bne.n	8006ddc <SDMMC_CmdWriteMultiBlock+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006d72:	23c5      	movs	r3, #197	; 0xc5
 8006d74:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8006d76:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8006d78:	b2db      	uxtb	r3, r3
 8006d7a:	2b19      	cmp	r3, #25
 8006d7c:	d131      	bne.n	8006de2 <SDMMC_CmdWriteMultiBlock+0xc6>
  return (*(__IO uint32_t *) tmp);
 8006d7e:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8006d80:	4b36      	ldr	r3, [pc, #216]	; (8006e5c <SDMMC_CmdWriteMultiBlock+0x140>)
 8006d82:	4013      	ands	r3, r2
 8006d84:	2b00      	cmp	r3, #0
 8006d86:	d0e9      	beq.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8006d88:	2a00      	cmp	r2, #0
 8006d8a:	db30      	blt.n	8006dee <SDMMC_CmdWriteMultiBlock+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8006d8c:	0051      	lsls	r1, r2, #1
 8006d8e:	d431      	bmi.n	8006df4 <SDMMC_CmdWriteMultiBlock+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8006d90:	0094      	lsls	r4, r2, #2
 8006d92:	d431      	bmi.n	8006df8 <SDMMC_CmdWriteMultiBlock+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8006d94:	00d0      	lsls	r0, r2, #3
 8006d96:	d431      	bmi.n	8006dfc <SDMMC_CmdWriteMultiBlock+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8006d98:	0111      	lsls	r1, r2, #4
 8006d9a:	d432      	bmi.n	8006e02 <SDMMC_CmdWriteMultiBlock+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8006d9c:	0154      	lsls	r4, r2, #5
 8006d9e:	d433      	bmi.n	8006e08 <SDMMC_CmdWriteMultiBlock+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8006da0:	01d0      	lsls	r0, r2, #7
 8006da2:	d434      	bmi.n	8006e0e <SDMMC_CmdWriteMultiBlock+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8006da4:	0211      	lsls	r1, r2, #8
 8006da6:	d435      	bmi.n	8006e14 <SDMMC_CmdWriteMultiBlock+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8006da8:	0254      	lsls	r4, r2, #9
 8006daa:	d436      	bmi.n	8006e1a <SDMMC_CmdWriteMultiBlock+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8006dac:	0290      	lsls	r0, r2, #10
 8006dae:	d440      	bmi.n	8006e32 <SDMMC_CmdWriteMultiBlock+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8006db0:	02d1      	lsls	r1, r2, #11
 8006db2:	d43b      	bmi.n	8006e2c <SDMMC_CmdWriteMultiBlock+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8006db4:	0354      	lsls	r4, r2, #13
 8006db6:	d436      	bmi.n	8006e26 <SDMMC_CmdWriteMultiBlock+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8006db8:	0390      	lsls	r0, r2, #14
 8006dba:	d431      	bmi.n	8006e20 <SDMMC_CmdWriteMultiBlock+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8006dbc:	03d1      	lsls	r1, r2, #15
 8006dbe:	d444      	bmi.n	8006e4a <SDMMC_CmdWriteMultiBlock+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8006dc0:	0414      	lsls	r4, r2, #16
 8006dc2:	d43f      	bmi.n	8006e44 <SDMMC_CmdWriteMultiBlock+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8006dc4:	0450      	lsls	r0, r2, #17
 8006dc6:	d43a      	bmi.n	8006e3e <SDMMC_CmdWriteMultiBlock+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8006dc8:	0491      	lsls	r1, r2, #18
 8006dca:	d435      	bmi.n	8006e38 <SDMMC_CmdWriteMultiBlock+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8006dcc:	f012 0f08 	tst.w	r2, #8
 8006dd0:	bf14      	ite	ne
 8006dd2:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8006dd6:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8006dda:	e7bf      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8006ddc:	2201      	movs	r2, #1
 8006dde:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006de0:	e7bc      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006de2:	2301      	movs	r3, #1
 8006de4:	e7ba      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006de6:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006de8:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006dea:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006dec:	e7b6      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8006dee:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006df2:	e7b3      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8006df4:	2340      	movs	r3, #64	; 0x40
 8006df6:	e7b1      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8006df8:	2380      	movs	r3, #128	; 0x80
 8006dfa:	e7af      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8006dfc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006e00:	e7ac      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8006e02:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006e06:	e7a9      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8006e08:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006e0c:	e7a6      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006e0e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006e12:	e7a3      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006e14:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006e18:	e7a0      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8006e1a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006e1e:	e79d      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006e20:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006e24:	e79a      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8006e26:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006e2a:	e797      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_CC_ERR;
 8006e2c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006e30:	e794      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006e32:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8006e36:	e791      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 8006e38:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006e3c:	e78e      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006e3e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006e42:	e78b      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006e44:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006e48:	e788      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8006e4a:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006e4e:	e785      	b.n	8006d5c <SDMMC_CmdWriteMultiBlock+0x40>
 8006e50:	20000680 	.word	0x20000680
 8006e54:	10624dd3 	.word	0x10624dd3
 8006e58:	fffff000 	.word	0xfffff000
 8006e5c:	fdffe008 	.word	0xfdffe008

08006e60 <SDMMC_CmdStopTransfer>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e60:	4a4c      	ldr	r2, [pc, #304]	; (8006f94 <SDMMC_CmdStopTransfer+0x134>)
  SDMMCx->ARG = Command->Argument;
 8006e62:	2300      	movs	r3, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006e64:	494c      	ldr	r1, [pc, #304]	; (8006f98 <SDMMC_CmdStopTransfer+0x138>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e66:	6812      	ldr	r2, [r2, #0]
{
 8006e68:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e6a:	4c4c      	ldr	r4, [pc, #304]	; (8006f9c <SDMMC_CmdStopTransfer+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8006e6c:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006e6e:	f240 434c 	movw	r3, #1100	; 0x44c
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e72:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006e76:	68c4      	ldr	r4, [r0, #12]
 8006e78:	4021      	ands	r1, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e7a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006e7c:	430b      	orrs	r3, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006e7e:	4948      	ldr	r1, [pc, #288]	; (8006fa0 <SDMMC_CmdStopTransfer+0x140>)
 8006e80:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006e84:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 8006e86:	b14a      	cbz	r2, 8006e9c <SDMMC_CmdStopTransfer+0x3c>
 8006e88:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8006e8a:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006e8c:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006e8e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006e92:	d001      	beq.n	8006e98 <SDMMC_CmdStopTransfer+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006e94:	0512      	lsls	r2, r2, #20
 8006e96:	d507      	bpl.n	8006ea8 <SDMMC_CmdStopTransfer+0x48>
    if (count-- == 0U)
 8006e98:	1c59      	adds	r1, r3, #1
 8006e9a:	d1f6      	bne.n	8006e8a <SDMMC_CmdStopTransfer+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8006e9c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006ea0:	4618      	mov	r0, r3
 8006ea2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006ea6:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006ea8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006eaa:	075c      	lsls	r4, r3, #29
 8006eac:	d43d      	bmi.n	8006f2a <SDMMC_CmdStopTransfer+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8006eae:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006eb0:	f013 0301 	ands.w	r3, r3, #1
 8006eb4:	d134      	bne.n	8006f20 <SDMMC_CmdStopTransfer+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006eb6:	23c5      	movs	r3, #197	; 0xc5
 8006eb8:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8006eba:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8006ebc:	b2db      	uxtb	r3, r3
 8006ebe:	2b0c      	cmp	r3, #12
 8006ec0:	d131      	bne.n	8006f26 <SDMMC_CmdStopTransfer+0xc6>
  return (*(__IO uint32_t *) tmp);
 8006ec2:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8006ec4:	4b37      	ldr	r3, [pc, #220]	; (8006fa4 <SDMMC_CmdStopTransfer+0x144>)
 8006ec6:	4013      	ands	r3, r2
 8006ec8:	2b00      	cmp	r3, #0
 8006eca:	d0e9      	beq.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8006ecc:	2a00      	cmp	r2, #0
 8006ece:	db30      	blt.n	8006f32 <SDMMC_CmdStopTransfer+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8006ed0:	0051      	lsls	r1, r2, #1
 8006ed2:	d431      	bmi.n	8006f38 <SDMMC_CmdStopTransfer+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8006ed4:	0094      	lsls	r4, r2, #2
 8006ed6:	d431      	bmi.n	8006f3c <SDMMC_CmdStopTransfer+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8006ed8:	00d0      	lsls	r0, r2, #3
 8006eda:	d431      	bmi.n	8006f40 <SDMMC_CmdStopTransfer+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8006edc:	0111      	lsls	r1, r2, #4
 8006ede:	d432      	bmi.n	8006f46 <SDMMC_CmdStopTransfer+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8006ee0:	0154      	lsls	r4, r2, #5
 8006ee2:	d433      	bmi.n	8006f4c <SDMMC_CmdStopTransfer+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8006ee4:	01d0      	lsls	r0, r2, #7
 8006ee6:	d434      	bmi.n	8006f52 <SDMMC_CmdStopTransfer+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8006ee8:	0211      	lsls	r1, r2, #8
 8006eea:	d435      	bmi.n	8006f58 <SDMMC_CmdStopTransfer+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8006eec:	0254      	lsls	r4, r2, #9
 8006eee:	d436      	bmi.n	8006f5e <SDMMC_CmdStopTransfer+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8006ef0:	0290      	lsls	r0, r2, #10
 8006ef2:	d440      	bmi.n	8006f76 <SDMMC_CmdStopTransfer+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8006ef4:	02d1      	lsls	r1, r2, #11
 8006ef6:	d43b      	bmi.n	8006f70 <SDMMC_CmdStopTransfer+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8006ef8:	0354      	lsls	r4, r2, #13
 8006efa:	d436      	bmi.n	8006f6a <SDMMC_CmdStopTransfer+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8006efc:	0390      	lsls	r0, r2, #14
 8006efe:	d431      	bmi.n	8006f64 <SDMMC_CmdStopTransfer+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8006f00:	03d1      	lsls	r1, r2, #15
 8006f02:	d444      	bmi.n	8006f8e <SDMMC_CmdStopTransfer+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8006f04:	0414      	lsls	r4, r2, #16
 8006f06:	d43f      	bmi.n	8006f88 <SDMMC_CmdStopTransfer+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8006f08:	0450      	lsls	r0, r2, #17
 8006f0a:	d43a      	bmi.n	8006f82 <SDMMC_CmdStopTransfer+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8006f0c:	0491      	lsls	r1, r2, #18
 8006f0e:	d435      	bmi.n	8006f7c <SDMMC_CmdStopTransfer+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8006f10:	f012 0f08 	tst.w	r2, #8
 8006f14:	bf14      	ite	ne
 8006f16:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8006f1a:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8006f1e:	e7bf      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8006f20:	2201      	movs	r2, #1
 8006f22:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006f24:	e7bc      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8006f26:	2301      	movs	r3, #1
 8006f28:	e7ba      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006f2a:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006f2c:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8006f2e:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8006f30:	e7b6      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8006f32:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006f36:	e7b3      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8006f38:	2340      	movs	r3, #64	; 0x40
 8006f3a:	e7b1      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8006f3c:	2380      	movs	r3, #128	; 0x80
 8006f3e:	e7af      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8006f40:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006f44:	e7ac      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8006f46:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006f4a:	e7a9      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8006f4c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8006f50:	e7a6      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8006f52:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006f56:	e7a3      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8006f58:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006f5c:	e7a0      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8006f5e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006f62:	e79d      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8006f64:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8006f68:	e79a      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8006f6a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8006f6e:	e797      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_CC_ERR;
 8006f70:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006f74:	e794      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8006f76:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8006f7a:	e791      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 8006f7c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8006f80:	e78e      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8006f82:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8006f86:	e78b      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8006f88:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8006f8c:	e788      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 8006f8e:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8006f92:	e785      	b.n	8006ea0 <SDMMC_CmdStopTransfer+0x40>
 8006f94:	20000680 	.word	0x20000680
 8006f98:	fffff000 	.word	0xfffff000
 8006f9c:	10624dd3 	.word	0x10624dd3
 8006fa0:	05f5e100 	.word	0x05f5e100
 8006fa4:	fdffe008 	.word	0xfdffe008

08006fa8 <SDMMC_CmdSelDesel>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006fa8:	4b4c      	ldr	r3, [pc, #304]	; (80070dc <SDMMC_CmdSelDesel+0x134>)
 8006faa:	494d      	ldr	r1, [pc, #308]	; (80070e0 <SDMMC_CmdSelDesel+0x138>)
 8006fac:	681b      	ldr	r3, [r3, #0]
{
 8006fae:	b430      	push	{r4, r5}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006fb0:	fba1 1303 	umull	r1, r3, r1, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006fb4:	4c4b      	ldr	r4, [pc, #300]	; (80070e4 <SDMMC_CmdSelDesel+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8006fb6:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006fb8:	f240 4147 	movw	r1, #1095	; 0x447
 8006fbc:	68c5      	ldr	r5, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006fbe:	0a5a      	lsrs	r2, r3, #9
 8006fc0:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006fc4:	402c      	ands	r4, r5
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8006fc6:	fb03 f202 	mul.w	r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8006fca:	4321      	orrs	r1, r4
 8006fcc:	60c1      	str	r1, [r0, #12]
    if (count-- == 0U)
 8006fce:	b14a      	cbz	r2, 8006fe4 <SDMMC_CmdSelDesel+0x3c>
 8006fd0:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8006fd2:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8006fd4:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8006fd6:	f012 0f45 	tst.w	r2, #69	; 0x45
 8006fda:	d001      	beq.n	8006fe0 <SDMMC_CmdSelDesel+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8006fdc:	0512      	lsls	r2, r2, #20
 8006fde:	d506      	bpl.n	8006fee <SDMMC_CmdSelDesel+0x46>
    if (count-- == 0U)
 8006fe0:	1c59      	adds	r1, r3, #1
 8006fe2:	d1f6      	bne.n	8006fd2 <SDMMC_CmdSelDesel+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8006fe4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8006fe8:	4618      	mov	r0, r3
 8006fea:	bc30      	pop	{r4, r5}
 8006fec:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8006fee:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006ff0:	075b      	lsls	r3, r3, #29
 8006ff2:	d43d      	bmi.n	8007070 <SDMMC_CmdSelDesel+0xc8>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8006ff4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8006ff6:	f013 0301 	ands.w	r3, r3, #1
 8006ffa:	d134      	bne.n	8007066 <SDMMC_CmdSelDesel+0xbe>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8006ffc:	23c5      	movs	r3, #197	; 0xc5
 8006ffe:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8007000:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8007002:	b2db      	uxtb	r3, r3
 8007004:	2b07      	cmp	r3, #7
 8007006:	d131      	bne.n	800706c <SDMMC_CmdSelDesel+0xc4>
  return (*(__IO uint32_t *) tmp);
 8007008:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800700a:	4b37      	ldr	r3, [pc, #220]	; (80070e8 <SDMMC_CmdSelDesel+0x140>)
 800700c:	4013      	ands	r3, r2
 800700e:	2b00      	cmp	r3, #0
 8007010:	d0ea      	beq.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8007012:	2a00      	cmp	r2, #0
 8007014:	db30      	blt.n	8007078 <SDMMC_CmdSelDesel+0xd0>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8007016:	0055      	lsls	r5, r2, #1
 8007018:	d431      	bmi.n	800707e <SDMMC_CmdSelDesel+0xd6>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800701a:	0094      	lsls	r4, r2, #2
 800701c:	d431      	bmi.n	8007082 <SDMMC_CmdSelDesel+0xda>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800701e:	00d0      	lsls	r0, r2, #3
 8007020:	d431      	bmi.n	8007086 <SDMMC_CmdSelDesel+0xde>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8007022:	0111      	lsls	r1, r2, #4
 8007024:	d432      	bmi.n	800708c <SDMMC_CmdSelDesel+0xe4>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8007026:	0155      	lsls	r5, r2, #5
 8007028:	d433      	bmi.n	8007092 <SDMMC_CmdSelDesel+0xea>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800702a:	01d4      	lsls	r4, r2, #7
 800702c:	d434      	bmi.n	8007098 <SDMMC_CmdSelDesel+0xf0>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800702e:	0210      	lsls	r0, r2, #8
 8007030:	d435      	bmi.n	800709e <SDMMC_CmdSelDesel+0xf6>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8007032:	0251      	lsls	r1, r2, #9
 8007034:	d436      	bmi.n	80070a4 <SDMMC_CmdSelDesel+0xfc>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8007036:	0295      	lsls	r5, r2, #10
 8007038:	d440      	bmi.n	80070bc <SDMMC_CmdSelDesel+0x114>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800703a:	02d4      	lsls	r4, r2, #11
 800703c:	d43b      	bmi.n	80070b6 <SDMMC_CmdSelDesel+0x10e>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800703e:	0350      	lsls	r0, r2, #13
 8007040:	d436      	bmi.n	80070b0 <SDMMC_CmdSelDesel+0x108>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8007042:	0391      	lsls	r1, r2, #14
 8007044:	d431      	bmi.n	80070aa <SDMMC_CmdSelDesel+0x102>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8007046:	03d5      	lsls	r5, r2, #15
 8007048:	d444      	bmi.n	80070d4 <SDMMC_CmdSelDesel+0x12c>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800704a:	0414      	lsls	r4, r2, #16
 800704c:	d43f      	bmi.n	80070ce <SDMMC_CmdSelDesel+0x126>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800704e:	0450      	lsls	r0, r2, #17
 8007050:	d43a      	bmi.n	80070c8 <SDMMC_CmdSelDesel+0x120>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8007052:	0491      	lsls	r1, r2, #18
 8007054:	d435      	bmi.n	80070c2 <SDMMC_CmdSelDesel+0x11a>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8007056:	f012 0f08 	tst.w	r2, #8
 800705a:	bf14      	ite	ne
 800705c:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8007060:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8007064:	e7c0      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8007066:	2201      	movs	r2, #1
 8007068:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800706a:	e7bd      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800706c:	2301      	movs	r3, #1
 800706e:	e7bb      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007070:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007072:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007074:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007076:	e7b7      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8007078:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800707c:	e7b4      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800707e:	2340      	movs	r3, #64	; 0x40
 8007080:	e7b2      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8007082:	2380      	movs	r3, #128	; 0x80
 8007084:	e7b0      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8007086:	f44f 7380 	mov.w	r3, #256	; 0x100
 800708a:	e7ad      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800708c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007090:	e7aa      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8007092:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007096:	e7a7      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8007098:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800709c:	e7a4      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800709e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80070a2:	e7a1      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 80070a4:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80070a8:	e79e      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 80070aa:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80070ae:	e79b      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 80070b0:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80070b4:	e798      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_CC_ERR;
 80070b6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80070ba:	e795      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 80070bc:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80070c0:	e792      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 80070c2:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80070c6:	e78f      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 80070c8:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80070cc:	e78c      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 80070ce:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80070d2:	e789      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80070d4:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80070d8:	e786      	b.n	8006fe8 <SDMMC_CmdSelDesel+0x40>
 80070da:	bf00      	nop
 80070dc:	20000680 	.word	0x20000680
 80070e0:	10624dd3 	.word	0x10624dd3
 80070e4:	fffff000 	.word	0xfffff000
 80070e8:	fdffe008 	.word	0xfdffe008

080070ec <SDMMC_CmdGoIdleState>:
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80070ec:	4b11      	ldr	r3, [pc, #68]	; (8007134 <SDMMC_CmdGoIdleState+0x48>)
{
 80070ee:	4601      	mov	r1, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80070f0:	4a11      	ldr	r2, [pc, #68]	; (8007138 <SDMMC_CmdGoIdleState+0x4c>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80070f2:	681b      	ldr	r3, [r3, #0]
{
 80070f4:	b430      	push	{r4, r5}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80070f6:	4c11      	ldr	r4, [pc, #68]	; (800713c <SDMMC_CmdGoIdleState+0x50>)
  SDMMCx->ARG = Command->Argument;
 80070f8:	2500      	movs	r5, #0
 80070fa:	6085      	str	r5, [r0, #8]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80070fc:	fba4 0303 	umull	r0, r3, r4, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007100:	68cc      	ldr	r4, [r1, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007102:	f241 3088 	movw	r0, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007106:	4022      	ands	r2, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007108:	0a5b      	lsrs	r3, r3, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800710a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800710e:	fb00 f303 	mul.w	r3, r0, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007112:	60ca      	str	r2, [r1, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007114:	e002      	b.n	800711c <SDMMC_CmdGoIdleState+0x30>
    if (count-- == 0U)
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 8007116:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 8007118:	0612      	lsls	r2, r2, #24
 800711a:	d405      	bmi.n	8007128 <SDMMC_CmdGoIdleState+0x3c>
    if (count-- == 0U)
 800711c:	3b01      	subs	r3, #1
 800711e:	d2fa      	bcs.n	8007116 <SDMMC_CmdGoIdleState+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8007120:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8007124:	bc30      	pop	{r4, r5}
 8007126:	4770      	bx	lr
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007128:	23c5      	movs	r3, #197	; 0xc5
  
  return SDMMC_ERROR_NONE;
 800712a:	2000      	movs	r0, #0
}
 800712c:	bc30      	pop	{r4, r5}
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800712e:	638b      	str	r3, [r1, #56]	; 0x38
}
 8007130:	4770      	bx	lr
 8007132:	bf00      	nop
 8007134:	20000680 	.word	0x20000680
 8007138:	fffff000 	.word	0xfffff000
 800713c:	10624dd3 	.word	0x10624dd3

08007140 <SDMMC_CmdOperCond>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007140:	4b1b      	ldr	r3, [pc, #108]	; (80071b0 <SDMMC_CmdOperCond+0x70>)
{
 8007142:	4601      	mov	r1, r0
 8007144:	b430      	push	{r4, r5}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007146:	681a      	ldr	r2, [r3, #0]
  SDMMCx->ARG = Command->Argument;
 8007148:	f44f 75d5 	mov.w	r5, #426	; 0x1aa
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800714c:	4c19      	ldr	r4, [pc, #100]	; (80071b4 <SDMMC_CmdOperCond+0x74>)
  SDMMCx->ARG = Command->Argument;
 800714e:	6085      	str	r5, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007150:	4b19      	ldr	r3, [pc, #100]	; (80071b8 <SDMMC_CmdOperCond+0x78>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007152:	fba4 0202 	umull	r0, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007156:	68cc      	ldr	r4, [r1, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007158:	f241 3088 	movw	r0, #5000	; 0x1388
 800715c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800715e:	4023      	ands	r3, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007160:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007164:	f443 6089 	orr.w	r0, r3, #1096	; 0x448
 8007168:	60c8      	str	r0, [r1, #12]
    if (count-- == 0U)
 800716a:	b14a      	cbz	r2, 8007180 <SDMMC_CmdOperCond+0x40>
 800716c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800716e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
    if (count-- == 0U)
 8007170:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8007172:	f012 0f45 	tst.w	r2, #69	; 0x45
 8007176:	d001      	beq.n	800717c <SDMMC_CmdOperCond+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8007178:	0510      	lsls	r0, r2, #20
 800717a:	d505      	bpl.n	8007188 <SDMMC_CmdOperCond+0x48>
    if (count-- == 0U)
 800717c:	1c5c      	adds	r4, r3, #1
 800717e:	d1f6      	bne.n	800716e <SDMMC_CmdOperCond+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 8007180:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8007184:	bc30      	pop	{r4, r5}
 8007186:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8007188:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800718a:	075a      	lsls	r2, r3, #29
 800718c:	d40c      	bmi.n	80071a8 <SDMMC_CmdOperCond+0x68>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800718e:	6b48      	ldr	r0, [r1, #52]	; 0x34
 8007190:	f010 0001 	ands.w	r0, r0, #1
 8007194:	d105      	bne.n	80071a2 <SDMMC_CmdOperCond+0x62>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 8007196:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8007198:	065b      	lsls	r3, r3, #25
 800719a:	d5f3      	bpl.n	8007184 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800719c:	2340      	movs	r3, #64	; 0x40
 800719e:	638b      	str	r3, [r1, #56]	; 0x38
 80071a0:	e7f0      	b.n	8007184 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80071a2:	2301      	movs	r3, #1
 80071a4:	638b      	str	r3, [r1, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80071a6:	e7ed      	b.n	8007184 <SDMMC_CmdOperCond+0x44>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80071a8:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80071aa:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80071ac:	638b      	str	r3, [r1, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80071ae:	e7e9      	b.n	8007184 <SDMMC_CmdOperCond+0x44>
 80071b0:	20000680 	.word	0x20000680
 80071b4:	10624dd3 	.word	0x10624dd3
 80071b8:	fffff000 	.word	0xfffff000

080071bc <SDMMC_CmdAppCommand>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80071bc:	4a4c      	ldr	r2, [pc, #304]	; (80072f0 <SDMMC_CmdAppCommand+0x134>)
 80071be:	4b4d      	ldr	r3, [pc, #308]	; (80072f4 <SDMMC_CmdAppCommand+0x138>)
 80071c0:	6812      	ldr	r2, [r2, #0]
{
 80071c2:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80071c4:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80071c8:	4c4b      	ldr	r4, [pc, #300]	; (80072f8 <SDMMC_CmdAppCommand+0x13c>)
  SDMMCx->ARG = Command->Argument;
 80071ca:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80071cc:	f240 4377 	movw	r3, #1143	; 0x477
 80071d0:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80071d2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80071d4:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80071d6:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80071da:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80071dc:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80071e0:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 80071e2:	b14a      	cbz	r2, 80071f8 <SDMMC_CmdAppCommand+0x3c>
 80071e4:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 80071e6:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 80071e8:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80071ea:	f012 0f45 	tst.w	r2, #69	; 0x45
 80071ee:	d001      	beq.n	80071f4 <SDMMC_CmdAppCommand+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80071f0:	0512      	lsls	r2, r2, #20
 80071f2:	d507      	bpl.n	8007204 <SDMMC_CmdAppCommand+0x48>
    if (count-- == 0U)
 80071f4:	1c59      	adds	r1, r3, #1
 80071f6:	d1f6      	bne.n	80071e6 <SDMMC_CmdAppCommand+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 80071f8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 80071fc:	4618      	mov	r0, r3
 80071fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007202:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8007204:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8007206:	075c      	lsls	r4, r3, #29
 8007208:	d43d      	bmi.n	8007286 <SDMMC_CmdAppCommand+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800720a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800720c:	f013 0301 	ands.w	r3, r3, #1
 8007210:	d134      	bne.n	800727c <SDMMC_CmdAppCommand+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007212:	23c5      	movs	r3, #197	; 0xc5
 8007214:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8007216:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8007218:	b2db      	uxtb	r3, r3
 800721a:	2b37      	cmp	r3, #55	; 0x37
 800721c:	d131      	bne.n	8007282 <SDMMC_CmdAppCommand+0xc6>
  return (*(__IO uint32_t *) tmp);
 800721e:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8007220:	4b36      	ldr	r3, [pc, #216]	; (80072fc <SDMMC_CmdAppCommand+0x140>)
 8007222:	4013      	ands	r3, r2
 8007224:	2b00      	cmp	r3, #0
 8007226:	d0e9      	beq.n	80071fc <SDMMC_CmdAppCommand+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8007228:	2a00      	cmp	r2, #0
 800722a:	db30      	blt.n	800728e <SDMMC_CmdAppCommand+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800722c:	0051      	lsls	r1, r2, #1
 800722e:	d431      	bmi.n	8007294 <SDMMC_CmdAppCommand+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8007230:	0094      	lsls	r4, r2, #2
 8007232:	d431      	bmi.n	8007298 <SDMMC_CmdAppCommand+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8007234:	00d0      	lsls	r0, r2, #3
 8007236:	d431      	bmi.n	800729c <SDMMC_CmdAppCommand+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8007238:	0111      	lsls	r1, r2, #4
 800723a:	d432      	bmi.n	80072a2 <SDMMC_CmdAppCommand+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800723c:	0154      	lsls	r4, r2, #5
 800723e:	d433      	bmi.n	80072a8 <SDMMC_CmdAppCommand+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8007240:	01d0      	lsls	r0, r2, #7
 8007242:	d434      	bmi.n	80072ae <SDMMC_CmdAppCommand+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8007244:	0211      	lsls	r1, r2, #8
 8007246:	d435      	bmi.n	80072b4 <SDMMC_CmdAppCommand+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8007248:	0254      	lsls	r4, r2, #9
 800724a:	d436      	bmi.n	80072ba <SDMMC_CmdAppCommand+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800724c:	0290      	lsls	r0, r2, #10
 800724e:	d440      	bmi.n	80072d2 <SDMMC_CmdAppCommand+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8007250:	02d1      	lsls	r1, r2, #11
 8007252:	d43b      	bmi.n	80072cc <SDMMC_CmdAppCommand+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8007254:	0354      	lsls	r4, r2, #13
 8007256:	d436      	bmi.n	80072c6 <SDMMC_CmdAppCommand+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8007258:	0390      	lsls	r0, r2, #14
 800725a:	d431      	bmi.n	80072c0 <SDMMC_CmdAppCommand+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800725c:	03d1      	lsls	r1, r2, #15
 800725e:	d444      	bmi.n	80072ea <SDMMC_CmdAppCommand+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8007260:	0414      	lsls	r4, r2, #16
 8007262:	d43f      	bmi.n	80072e4 <SDMMC_CmdAppCommand+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8007264:	0450      	lsls	r0, r2, #17
 8007266:	d43a      	bmi.n	80072de <SDMMC_CmdAppCommand+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8007268:	0491      	lsls	r1, r2, #18
 800726a:	d435      	bmi.n	80072d8 <SDMMC_CmdAppCommand+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800726c:	f012 0f08 	tst.w	r2, #8
 8007270:	bf14      	ite	ne
 8007272:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8007276:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800727a:	e7bf      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800727c:	2201      	movs	r2, #1
 800727e:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007280:	e7bc      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007282:	2301      	movs	r3, #1
 8007284:	e7ba      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007286:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007288:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800728a:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800728c:	e7b6      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800728e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007292:	e7b3      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8007294:	2340      	movs	r3, #64	; 0x40
 8007296:	e7b1      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8007298:	2380      	movs	r3, #128	; 0x80
 800729a:	e7af      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800729c:	f44f 7380 	mov.w	r3, #256	; 0x100
 80072a0:	e7ac      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 80072a2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80072a6:	e7a9      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 80072a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80072ac:	e7a6      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 80072ae:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80072b2:	e7a3      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 80072b4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80072b8:	e7a0      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 80072ba:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80072be:	e79d      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 80072c0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80072c4:	e79a      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 80072c6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80072ca:	e797      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_CC_ERR;
 80072cc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80072d0:	e794      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 80072d2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80072d6:	e791      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 80072d8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80072dc:	e78e      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 80072de:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80072e2:	e78b      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 80072e4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80072e8:	e788      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80072ea:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80072ee:	e785      	b.n	80071fc <SDMMC_CmdAppCommand+0x40>
 80072f0:	20000680 	.word	0x20000680
 80072f4:	10624dd3 	.word	0x10624dd3
 80072f8:	fffff000 	.word	0xfffff000
 80072fc:	fdffe008 	.word	0xfdffe008

08007300 <SDMMC_CmdAppOperCommand>:
{
 8007300:	b430      	push	{r4, r5}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007302:	4b18      	ldr	r3, [pc, #96]	; (8007364 <SDMMC_CmdAppOperCommand+0x64>)
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 8007304:	4c18      	ldr	r4, [pc, #96]	; (8007368 <SDMMC_CmdAppOperCommand+0x68>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007306:	681a      	ldr	r2, [r3, #0]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 8007308:	430c      	orrs	r4, r1
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800730a:	4d18      	ldr	r5, [pc, #96]	; (800736c <SDMMC_CmdAppOperCommand+0x6c>)
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800730c:	4b18      	ldr	r3, [pc, #96]	; (8007370 <SDMMC_CmdAppOperCommand+0x70>)
  SDMMCx->ARG = Command->Argument;
 800730e:	6084      	str	r4, [r0, #8]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007310:	f241 3488 	movw	r4, #5000	; 0x1388
 8007314:	fba5 1202 	umull	r1, r2, r5, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007318:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800731a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800731c:	400b      	ands	r3, r1
 800731e:	f240 4169 	movw	r1, #1129	; 0x469
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007322:	fb04 f202 	mul.w	r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007326:	4319      	orrs	r1, r3
 8007328:	60c1      	str	r1, [r0, #12]
    if (count-- == 0U)
 800732a:	b14a      	cbz	r2, 8007340 <SDMMC_CmdAppOperCommand+0x40>
 800732c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800732e:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8007330:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8007332:	f012 0f45 	tst.w	r2, #69	; 0x45
 8007336:	d001      	beq.n	800733c <SDMMC_CmdAppOperCommand+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8007338:	0512      	lsls	r2, r2, #20
 800733a:	d506      	bpl.n	800734a <SDMMC_CmdAppOperCommand+0x4a>
    if (count-- == 0U)
 800733c:	1c59      	adds	r1, r3, #1
 800733e:	d1f6      	bne.n	800732e <SDMMC_CmdAppOperCommand+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 8007340:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8007344:	4618      	mov	r0, r3
 8007346:	bc30      	pop	{r4, r5}
 8007348:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800734a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800734c:	f013 0304 	ands.w	r3, r3, #4
 8007350:	d104      	bne.n	800735c <SDMMC_CmdAppOperCommand+0x5c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007352:	22c5      	movs	r2, #197	; 0xc5
}
 8007354:	bc30      	pop	{r4, r5}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007356:	6382      	str	r2, [r0, #56]	; 0x38
}
 8007358:	4618      	mov	r0, r3
 800735a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800735c:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800735e:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007360:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007362:	e7ef      	b.n	8007344 <SDMMC_CmdAppOperCommand+0x44>
 8007364:	20000680 	.word	0x20000680
 8007368:	80100000 	.word	0x80100000
 800736c:	10624dd3 	.word	0x10624dd3
 8007370:	fffff000 	.word	0xfffff000

08007374 <SDMMC_CmdBusWidth>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8007374:	4a4c      	ldr	r2, [pc, #304]	; (80074a8 <SDMMC_CmdBusWidth+0x134>)
 8007376:	4b4d      	ldr	r3, [pc, #308]	; (80074ac <SDMMC_CmdBusWidth+0x138>)
 8007378:	6812      	ldr	r2, [r2, #0]
{
 800737a:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800737c:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007380:	4c4b      	ldr	r4, [pc, #300]	; (80074b0 <SDMMC_CmdBusWidth+0x13c>)
  SDMMCx->ARG = Command->Argument;
 8007382:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007384:	f240 4346 	movw	r3, #1094	; 0x446
 8007388:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800738a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800738c:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800738e:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007392:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8007394:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007398:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 800739a:	b14a      	cbz	r2, 80073b0 <SDMMC_CmdBusWidth+0x3c>
 800739c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800739e:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 80073a0:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80073a2:	f012 0f45 	tst.w	r2, #69	; 0x45
 80073a6:	d001      	beq.n	80073ac <SDMMC_CmdBusWidth+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80073a8:	0512      	lsls	r2, r2, #20
 80073aa:	d507      	bpl.n	80073bc <SDMMC_CmdBusWidth+0x48>
    if (count-- == 0U)
 80073ac:	1c59      	adds	r1, r3, #1
 80073ae:	d1f6      	bne.n	800739e <SDMMC_CmdBusWidth+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 80073b0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 80073b4:	4618      	mov	r0, r3
 80073b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80073ba:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80073bc:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80073be:	075c      	lsls	r4, r3, #29
 80073c0:	d43d      	bmi.n	800743e <SDMMC_CmdBusWidth+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80073c2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80073c4:	f013 0301 	ands.w	r3, r3, #1
 80073c8:	d134      	bne.n	8007434 <SDMMC_CmdBusWidth+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80073ca:	23c5      	movs	r3, #197	; 0xc5
 80073cc:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 80073ce:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80073d0:	b2db      	uxtb	r3, r3
 80073d2:	2b06      	cmp	r3, #6
 80073d4:	d131      	bne.n	800743a <SDMMC_CmdBusWidth+0xc6>
  return (*(__IO uint32_t *) tmp);
 80073d6:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 80073d8:	4b36      	ldr	r3, [pc, #216]	; (80074b4 <SDMMC_CmdBusWidth+0x140>)
 80073da:	4013      	ands	r3, r2
 80073dc:	2b00      	cmp	r3, #0
 80073de:	d0e9      	beq.n	80073b4 <SDMMC_CmdBusWidth+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 80073e0:	2a00      	cmp	r2, #0
 80073e2:	db30      	blt.n	8007446 <SDMMC_CmdBusWidth+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 80073e4:	0051      	lsls	r1, r2, #1
 80073e6:	d431      	bmi.n	800744c <SDMMC_CmdBusWidth+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 80073e8:	0094      	lsls	r4, r2, #2
 80073ea:	d431      	bmi.n	8007450 <SDMMC_CmdBusWidth+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 80073ec:	00d0      	lsls	r0, r2, #3
 80073ee:	d431      	bmi.n	8007454 <SDMMC_CmdBusWidth+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 80073f0:	0111      	lsls	r1, r2, #4
 80073f2:	d432      	bmi.n	800745a <SDMMC_CmdBusWidth+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 80073f4:	0154      	lsls	r4, r2, #5
 80073f6:	d433      	bmi.n	8007460 <SDMMC_CmdBusWidth+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 80073f8:	01d0      	lsls	r0, r2, #7
 80073fa:	d434      	bmi.n	8007466 <SDMMC_CmdBusWidth+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 80073fc:	0211      	lsls	r1, r2, #8
 80073fe:	d435      	bmi.n	800746c <SDMMC_CmdBusWidth+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8007400:	0254      	lsls	r4, r2, #9
 8007402:	d436      	bmi.n	8007472 <SDMMC_CmdBusWidth+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8007404:	0290      	lsls	r0, r2, #10
 8007406:	d440      	bmi.n	800748a <SDMMC_CmdBusWidth+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8007408:	02d1      	lsls	r1, r2, #11
 800740a:	d43b      	bmi.n	8007484 <SDMMC_CmdBusWidth+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800740c:	0354      	lsls	r4, r2, #13
 800740e:	d436      	bmi.n	800747e <SDMMC_CmdBusWidth+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8007410:	0390      	lsls	r0, r2, #14
 8007412:	d431      	bmi.n	8007478 <SDMMC_CmdBusWidth+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8007414:	03d1      	lsls	r1, r2, #15
 8007416:	d444      	bmi.n	80074a2 <SDMMC_CmdBusWidth+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8007418:	0414      	lsls	r4, r2, #16
 800741a:	d43f      	bmi.n	800749c <SDMMC_CmdBusWidth+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800741c:	0450      	lsls	r0, r2, #17
 800741e:	d43a      	bmi.n	8007496 <SDMMC_CmdBusWidth+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8007420:	0491      	lsls	r1, r2, #18
 8007422:	d435      	bmi.n	8007490 <SDMMC_CmdBusWidth+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8007424:	f012 0f08 	tst.w	r2, #8
 8007428:	bf14      	ite	ne
 800742a:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800742e:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8007432:	e7bf      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8007434:	2201      	movs	r2, #1
 8007436:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007438:	e7bc      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800743a:	2301      	movs	r3, #1
 800743c:	e7ba      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800743e:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007440:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007442:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007444:	e7b6      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8007446:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800744a:	e7b3      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800744c:	2340      	movs	r3, #64	; 0x40
 800744e:	e7b1      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8007450:	2380      	movs	r3, #128	; 0x80
 8007452:	e7af      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8007454:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007458:	e7ac      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800745a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800745e:	e7a9      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 8007460:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007464:	e7a6      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8007466:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800746a:	e7a3      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 800746c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007470:	e7a0      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8007472:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8007476:	e79d      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8007478:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800747c:	e79a      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800747e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8007482:	e797      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_CC_ERR;
 8007484:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8007488:	e794      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800748a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800748e:	e791      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 8007490:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8007494:	e78e      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 8007496:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 800749a:	e78b      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800749c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80074a0:	e788      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80074a2:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80074a6:	e785      	b.n	80073b4 <SDMMC_CmdBusWidth+0x40>
 80074a8:	20000680 	.word	0x20000680
 80074ac:	10624dd3 	.word	0x10624dd3
 80074b0:	fffff000 	.word	0xfffff000
 80074b4:	fdffe008 	.word	0xfdffe008

080074b8 <SDMMC_CmdSendSCR>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074b8:	4a4d      	ldr	r2, [pc, #308]	; (80075f0 <SDMMC_CmdSendSCR+0x138>)
  SDMMCx->ARG = Command->Argument;
 80074ba:	2300      	movs	r3, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80074bc:	494d      	ldr	r1, [pc, #308]	; (80075f4 <SDMMC_CmdSendSCR+0x13c>)
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074be:	6812      	ldr	r2, [r2, #0]
{
 80074c0:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074c2:	4c4d      	ldr	r4, [pc, #308]	; (80075f8 <SDMMC_CmdSendSCR+0x140>)
  SDMMCx->ARG = Command->Argument;
 80074c4:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80074c6:	f240 4373 	movw	r3, #1139	; 0x473
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074ca:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80074ce:	68c4      	ldr	r4, [r0, #12]
 80074d0:	4021      	ands	r1, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074d2:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80074d4:	430b      	orrs	r3, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80074d6:	f241 3188 	movw	r1, #5000	; 0x1388
 80074da:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80074de:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 80074e0:	b14a      	cbz	r2, 80074f6 <SDMMC_CmdSendSCR+0x3e>
 80074e2:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 80074e4:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 80074e6:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80074e8:	f012 0f45 	tst.w	r2, #69	; 0x45
 80074ec:	d001      	beq.n	80074f2 <SDMMC_CmdSendSCR+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80074ee:	0512      	lsls	r2, r2, #20
 80074f0:	d507      	bpl.n	8007502 <SDMMC_CmdSendSCR+0x4a>
    if (count-- == 0U)
 80074f2:	1c59      	adds	r1, r3, #1
 80074f4:	d1f6      	bne.n	80074e4 <SDMMC_CmdSendSCR+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 80074f6:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 80074fa:	4618      	mov	r0, r3
 80074fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007500:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8007502:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8007504:	075c      	lsls	r4, r3, #29
 8007506:	d43d      	bmi.n	8007584 <SDMMC_CmdSendSCR+0xcc>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8007508:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800750a:	f013 0301 	ands.w	r3, r3, #1
 800750e:	d134      	bne.n	800757a <SDMMC_CmdSendSCR+0xc2>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007510:	23c5      	movs	r3, #197	; 0xc5
 8007512:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8007514:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8007516:	b2db      	uxtb	r3, r3
 8007518:	2b33      	cmp	r3, #51	; 0x33
 800751a:	d131      	bne.n	8007580 <SDMMC_CmdSendSCR+0xc8>
  return (*(__IO uint32_t *) tmp);
 800751c:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800751e:	4b37      	ldr	r3, [pc, #220]	; (80075fc <SDMMC_CmdSendSCR+0x144>)
 8007520:	4013      	ands	r3, r2
 8007522:	2b00      	cmp	r3, #0
 8007524:	d0e9      	beq.n	80074fa <SDMMC_CmdSendSCR+0x42>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8007526:	2a00      	cmp	r2, #0
 8007528:	db30      	blt.n	800758c <SDMMC_CmdSendSCR+0xd4>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800752a:	0051      	lsls	r1, r2, #1
 800752c:	d431      	bmi.n	8007592 <SDMMC_CmdSendSCR+0xda>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800752e:	0094      	lsls	r4, r2, #2
 8007530:	d431      	bmi.n	8007596 <SDMMC_CmdSendSCR+0xde>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8007532:	00d0      	lsls	r0, r2, #3
 8007534:	d431      	bmi.n	800759a <SDMMC_CmdSendSCR+0xe2>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8007536:	0111      	lsls	r1, r2, #4
 8007538:	d432      	bmi.n	80075a0 <SDMMC_CmdSendSCR+0xe8>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800753a:	0154      	lsls	r4, r2, #5
 800753c:	d433      	bmi.n	80075a6 <SDMMC_CmdSendSCR+0xee>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800753e:	01d0      	lsls	r0, r2, #7
 8007540:	d434      	bmi.n	80075ac <SDMMC_CmdSendSCR+0xf4>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8007542:	0211      	lsls	r1, r2, #8
 8007544:	d435      	bmi.n	80075b2 <SDMMC_CmdSendSCR+0xfa>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8007546:	0254      	lsls	r4, r2, #9
 8007548:	d436      	bmi.n	80075b8 <SDMMC_CmdSendSCR+0x100>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800754a:	0290      	lsls	r0, r2, #10
 800754c:	d440      	bmi.n	80075d0 <SDMMC_CmdSendSCR+0x118>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800754e:	02d1      	lsls	r1, r2, #11
 8007550:	d43b      	bmi.n	80075ca <SDMMC_CmdSendSCR+0x112>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8007552:	0354      	lsls	r4, r2, #13
 8007554:	d436      	bmi.n	80075c4 <SDMMC_CmdSendSCR+0x10c>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 8007556:	0390      	lsls	r0, r2, #14
 8007558:	d431      	bmi.n	80075be <SDMMC_CmdSendSCR+0x106>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800755a:	03d1      	lsls	r1, r2, #15
 800755c:	d444      	bmi.n	80075e8 <SDMMC_CmdSendSCR+0x130>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800755e:	0414      	lsls	r4, r2, #16
 8007560:	d43f      	bmi.n	80075e2 <SDMMC_CmdSendSCR+0x12a>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8007562:	0450      	lsls	r0, r2, #17
 8007564:	d43a      	bmi.n	80075dc <SDMMC_CmdSendSCR+0x124>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8007566:	0491      	lsls	r1, r2, #18
 8007568:	d435      	bmi.n	80075d6 <SDMMC_CmdSendSCR+0x11e>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800756a:	f012 0f08 	tst.w	r2, #8
 800756e:	bf14      	ite	ne
 8007570:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 8007574:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8007578:	e7bf      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800757a:	2201      	movs	r2, #1
 800757c:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800757e:	e7bc      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007580:	2301      	movs	r3, #1
 8007582:	e7ba      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007584:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007586:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007588:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800758a:	e7b6      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800758c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007590:	e7b3      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8007592:	2340      	movs	r3, #64	; 0x40
 8007594:	e7b1      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 8007596:	2380      	movs	r3, #128	; 0x80
 8007598:	e7af      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800759a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800759e:	e7ac      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 80075a0:	f44f 7300 	mov.w	r3, #512	; 0x200
 80075a4:	e7a9      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 80075a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80075aa:	e7a6      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 80075ac:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80075b0:	e7a3      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_COM_CRC_FAILED;
 80075b2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80075b6:	e7a0      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_ILLEGAL_CMD;
 80075b8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80075bc:	e79d      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 80075be:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80075c2:	e79a      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 80075c4:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80075c8:	e797      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_CC_ERR;
 80075ca:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80075ce:	e794      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 80075d0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80075d4:	e791      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_ERASE_RESET;
 80075d6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80075da:	e78e      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 80075dc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80075e0:	e78b      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 80075e2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80075e6:	e788      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80075e8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80075ec:	e785      	b.n	80074fa <SDMMC_CmdSendSCR+0x42>
 80075ee:	bf00      	nop
 80075f0:	20000680 	.word	0x20000680
 80075f4:	fffff000 	.word	0xfffff000
 80075f8:	10624dd3 	.word	0x10624dd3
 80075fc:	fdffe008 	.word	0xfdffe008

08007600 <SDMMC_CmdSendCID>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007600:	4a1a      	ldr	r2, [pc, #104]	; (800766c <SDMMC_CmdSendCID+0x6c>)
{
 8007602:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
 8007604:	2300      	movs	r3, #0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007606:	481a      	ldr	r0, [pc, #104]	; (8007670 <SDMMC_CmdSendCID+0x70>)
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007608:	6812      	ldr	r2, [r2, #0]
{
 800760a:	b410      	push	{r4}
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800760c:	4c19      	ldr	r4, [pc, #100]	; (8007674 <SDMMC_CmdSendCID+0x74>)
  SDMMCx->ARG = Command->Argument;
 800760e:	608b      	str	r3, [r1, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007610:	f240 43c2 	movw	r3, #1218	; 0x4c2
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007614:	fba4 4202 	umull	r4, r2, r4, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007618:	68cc      	ldr	r4, [r1, #12]
 800761a:	4020      	ands	r0, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800761c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800761e:	4303      	orrs	r3, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007620:	f241 3088 	movw	r0, #5000	; 0x1388
 8007624:	fb00 f202 	mul.w	r2, r0, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007628:	60cb      	str	r3, [r1, #12]
    if (count-- == 0U)
 800762a:	b14a      	cbz	r2, 8007640 <SDMMC_CmdSendCID+0x40>
 800762c:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 800762e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
    if (count-- == 0U)
 8007630:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8007632:	f012 0f45 	tst.w	r2, #69	; 0x45
 8007636:	d001      	beq.n	800763c <SDMMC_CmdSendCID+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8007638:	0512      	lsls	r2, r2, #20
 800763a:	d506      	bpl.n	800764a <SDMMC_CmdSendCID+0x4a>
    if (count-- == 0U)
 800763c:	1c58      	adds	r0, r3, #1
 800763e:	d1f6      	bne.n	800762e <SDMMC_CmdSendCID+0x2e>
      return SDMMC_ERROR_TIMEOUT;
 8007640:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8007644:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007648:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800764a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800764c:	075b      	lsls	r3, r3, #29
 800764e:	d409      	bmi.n	8007664 <SDMMC_CmdSendCID+0x64>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8007650:	6b48      	ldr	r0, [r1, #52]	; 0x34
}
 8007652:	f85d 4b04 	ldr.w	r4, [sp], #4
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8007656:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800765a:	bf14      	ite	ne
 800765c:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800765e:	23c5      	moveq	r3, #197	; 0xc5
 8007660:	638b      	str	r3, [r1, #56]	; 0x38
}
 8007662:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007664:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007666:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007668:	638b      	str	r3, [r1, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800766a:	e7eb      	b.n	8007644 <SDMMC_CmdSendCID+0x44>
 800766c:	20000680 	.word	0x20000680
 8007670:	fffff000 	.word	0xfffff000
 8007674:	10624dd3 	.word	0x10624dd3

08007678 <SDMMC_CmdSendCSD>:
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007678:	4a1b      	ldr	r2, [pc, #108]	; (80076e8 <SDMMC_CmdSendCSD+0x70>)
{
 800767a:	4684      	mov	ip, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800767c:	4b1b      	ldr	r3, [pc, #108]	; (80076ec <SDMMC_CmdSendCSD+0x74>)
 800767e:	6812      	ldr	r2, [r2, #0]
  SDMMCx->ARG = Command->Argument;
 8007680:	f8cc 1008 	str.w	r1, [ip, #8]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007684:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007688:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800768c:	4818      	ldr	r0, [pc, #96]	; (80076f0 <SDMMC_CmdSendCSD+0x78>)
 800768e:	f240 43c9 	movw	r3, #1225	; 0x4c9
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007692:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007694:	4008      	ands	r0, r1
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007696:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 800769a:	4303      	orrs	r3, r0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800769c:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80076a0:	f8cc 300c 	str.w	r3, [ip, #12]
    if (count-- == 0U)
 80076a4:	1e53      	subs	r3, r2, #1
 80076a6:	b14a      	cbz	r2, 80076bc <SDMMC_CmdSendCSD+0x44>
    sta_reg = SDMMCx->STA;
 80076a8:	f8dc 2034 	ldr.w	r2, [ip, #52]	; 0x34
    if (count-- == 0U)
 80076ac:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80076ae:	f012 0f45 	tst.w	r2, #69	; 0x45
 80076b2:	d001      	beq.n	80076b8 <SDMMC_CmdSendCSD+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80076b4:	0512      	lsls	r2, r2, #20
 80076b6:	d504      	bpl.n	80076c2 <SDMMC_CmdSendCSD+0x4a>
    if (count-- == 0U)
 80076b8:	1c59      	adds	r1, r3, #1
 80076ba:	d1f5      	bne.n	80076a8 <SDMMC_CmdSendCSD+0x30>
      return SDMMC_ERROR_TIMEOUT;
 80076bc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80076c0:	4770      	bx	lr
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80076c2:	f8dc 3034 	ldr.w	r3, [ip, #52]	; 0x34
 80076c6:	075b      	lsls	r3, r3, #29
 80076c8:	d409      	bmi.n	80076de <SDMMC_CmdSendCSD+0x66>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80076ca:	f8dc 0034 	ldr.w	r0, [ip, #52]	; 0x34
 80076ce:	f010 0001 	ands.w	r0, r0, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80076d2:	bf14      	ite	ne
 80076d4:	2301      	movne	r3, #1
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80076d6:	23c5      	moveq	r3, #197	; 0xc5
 80076d8:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
  return SDMMC_ERROR_NONE;
 80076dc:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80076de:	2304      	movs	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80076e0:	4618      	mov	r0, r3
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80076e2:	f8cc 3038 	str.w	r3, [ip, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80076e6:	4770      	bx	lr
 80076e8:	20000680 	.word	0x20000680
 80076ec:	10624dd3 	.word	0x10624dd3
 80076f0:	fffff000 	.word	0xfffff000

080076f4 <SDMMC_CmdSetRelAdd>:
  SDMMCx->ARG = Command->Argument;
 80076f4:	2300      	movs	r3, #0
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80076f6:	4a27      	ldr	r2, [pc, #156]	; (8007794 <SDMMC_CmdSetRelAdd+0xa0>)
{
 80076f8:	b410      	push	{r4}
  SDMMCx->ARG = Command->Argument;
 80076fa:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80076fc:	4c26      	ldr	r4, [pc, #152]	; (8007798 <SDMMC_CmdSetRelAdd+0xa4>)
 80076fe:	68c3      	ldr	r3, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007700:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007702:	401c      	ands	r4, r3
 8007704:	f240 4343 	movw	r3, #1091	; 0x443
 8007708:	4323      	orrs	r3, r4
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800770a:	4c24      	ldr	r4, [pc, #144]	; (800779c <SDMMC_CmdSetRelAdd+0xa8>)
 800770c:	fba4 4202 	umull	r4, r2, r4, r2
 8007710:	f241 3488 	movw	r4, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 8007714:	60c3      	str	r3, [r0, #12]
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8007716:	0a52      	lsrs	r2, r2, #9
 8007718:	fb04 f202 	mul.w	r2, r4, r2
    if (count-- == 0U)
 800771c:	b14a      	cbz	r2, 8007732 <SDMMC_CmdSetRelAdd+0x3e>
 800771e:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 8007720:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 8007722:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8007724:	f012 0f45 	tst.w	r2, #69	; 0x45
 8007728:	d001      	beq.n	800772e <SDMMC_CmdSetRelAdd+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800772a:	0512      	lsls	r2, r2, #20
 800772c:	d507      	bpl.n	800773e <SDMMC_CmdSetRelAdd+0x4a>
    if (count-- == 0U)
 800772e:	1c5c      	adds	r4, r3, #1
 8007730:	d1f6      	bne.n	8007720 <SDMMC_CmdSetRelAdd+0x2c>
      return SDMMC_ERROR_TIMEOUT;
 8007732:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 8007736:	4618      	mov	r0, r3
 8007738:	f85d 4b04 	ldr.w	r4, [sp], #4
 800773c:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800773e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8007740:	075c      	lsls	r4, r3, #29
 8007742:	d41c      	bmi.n	800777e <SDMMC_CmdSetRelAdd+0x8a>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8007744:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8007746:	f013 0301 	ands.w	r3, r3, #1
 800774a:	d113      	bne.n	8007774 <SDMMC_CmdSetRelAdd+0x80>
  return (uint8_t)(SDMMCx->RESPCMD);
 800774c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800774e:	b2db      	uxtb	r3, r3
 8007750:	2b03      	cmp	r3, #3
 8007752:	d112      	bne.n	800777a <SDMMC_CmdSetRelAdd+0x86>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8007754:	23c5      	movs	r3, #197	; 0xc5
 8007756:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 8007758:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 800775a:	f412 4360 	ands.w	r3, r2, #57344	; 0xe000
 800775e:	d015      	beq.n	800778c <SDMMC_CmdSetRelAdd+0x98>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 8007760:	0451      	lsls	r1, r2, #17
 8007762:	d410      	bmi.n	8007786 <SDMMC_CmdSetRelAdd+0x92>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8007764:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 8007768:	bf14      	ite	ne
 800776a:	f44f 5380 	movne.w	r3, #4096	; 0x1000
 800776e:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8007772:	e7e0      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8007774:	2201      	movs	r2, #1
 8007776:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007778:	e7dd      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800777a:	2301      	movs	r3, #1
 800777c:	e7db      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800777e:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007780:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8007782:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007784:	e7d7      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
    return SDMMC_ERROR_ILLEGAL_CMD;
 8007786:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800778a:	e7d4      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
    *pRCA = (uint16_t) (response_r1 >> 16);
 800778c:	0c12      	lsrs	r2, r2, #16
 800778e:	800a      	strh	r2, [r1, #0]
    return SDMMC_ERROR_NONE;
 8007790:	e7d1      	b.n	8007736 <SDMMC_CmdSetRelAdd+0x42>
 8007792:	bf00      	nop
 8007794:	20000680 	.word	0x20000680
 8007798:	fffff000 	.word	0xfffff000
 800779c:	10624dd3 	.word	0x10624dd3

080077a0 <SDMMC_CmdSendStatus>:
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80077a0:	4a4c      	ldr	r2, [pc, #304]	; (80078d4 <SDMMC_CmdSendStatus+0x134>)
 80077a2:	4b4d      	ldr	r3, [pc, #308]	; (80078d8 <SDMMC_CmdSendStatus+0x138>)
 80077a4:	6812      	ldr	r2, [r2, #0]
{
 80077a6:	b410      	push	{r4}
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80077a8:	fba3 3202 	umull	r3, r2, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80077ac:	4c4b      	ldr	r4, [pc, #300]	; (80078dc <SDMMC_CmdSendStatus+0x13c>)
  SDMMCx->ARG = Command->Argument;
 80077ae:	6081      	str	r1, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80077b0:	f240 434d 	movw	r3, #1101	; 0x44d
 80077b4:	68c1      	ldr	r1, [r0, #12]
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80077b6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80077b8:	400c      	ands	r4, r1
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80077ba:	f241 3188 	movw	r1, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80077be:	4323      	orrs	r3, r4
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80077c0:	fb01 f202 	mul.w	r2, r1, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
 80077c4:	60c3      	str	r3, [r0, #12]
    if (count-- == 0U)
 80077c6:	b14a      	cbz	r2, 80077dc <SDMMC_CmdSendStatus+0x3c>
 80077c8:	1e53      	subs	r3, r2, #1
    sta_reg = SDMMCx->STA;
 80077ca:	6b42      	ldr	r2, [r0, #52]	; 0x34
    if (count-- == 0U)
 80077cc:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80077ce:	f012 0f45 	tst.w	r2, #69	; 0x45
 80077d2:	d001      	beq.n	80077d8 <SDMMC_CmdSendStatus+0x38>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80077d4:	0512      	lsls	r2, r2, #20
 80077d6:	d507      	bpl.n	80077e8 <SDMMC_CmdSendStatus+0x48>
    if (count-- == 0U)
 80077d8:	1c59      	adds	r1, r3, #1
 80077da:	d1f6      	bne.n	80077ca <SDMMC_CmdSendStatus+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 80077dc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
}
 80077e0:	4618      	mov	r0, r3
 80077e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80077e6:	4770      	bx	lr
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80077e8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80077ea:	075c      	lsls	r4, r3, #29
 80077ec:	d43d      	bmi.n	800786a <SDMMC_CmdSendStatus+0xca>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80077ee:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80077f0:	f013 0301 	ands.w	r3, r3, #1
 80077f4:	d134      	bne.n	8007860 <SDMMC_CmdSendStatus+0xc0>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80077f6:	23c5      	movs	r3, #197	; 0xc5
 80077f8:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 80077fa:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80077fc:	b2db      	uxtb	r3, r3
 80077fe:	2b0d      	cmp	r3, #13
 8007800:	d131      	bne.n	8007866 <SDMMC_CmdSendStatus+0xc6>
  return (*(__IO uint32_t *) tmp);
 8007802:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8007804:	4b36      	ldr	r3, [pc, #216]	; (80078e0 <SDMMC_CmdSendStatus+0x140>)
 8007806:	4013      	ands	r3, r2
 8007808:	2b00      	cmp	r3, #0
 800780a:	d0e9      	beq.n	80077e0 <SDMMC_CmdSendStatus+0x40>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800780c:	2a00      	cmp	r2, #0
 800780e:	db30      	blt.n	8007872 <SDMMC_CmdSendStatus+0xd2>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8007810:	0051      	lsls	r1, r2, #1
 8007812:	d431      	bmi.n	8007878 <SDMMC_CmdSendStatus+0xd8>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8007814:	0094      	lsls	r4, r2, #2
 8007816:	d431      	bmi.n	800787c <SDMMC_CmdSendStatus+0xdc>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8007818:	00d0      	lsls	r0, r2, #3
 800781a:	d431      	bmi.n	8007880 <SDMMC_CmdSendStatus+0xe0>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800781c:	0111      	lsls	r1, r2, #4
 800781e:	d432      	bmi.n	8007886 <SDMMC_CmdSendStatus+0xe6>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8007820:	0154      	lsls	r4, r2, #5
 8007822:	d433      	bmi.n	800788c <SDMMC_CmdSendStatus+0xec>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8007824:	01d0      	lsls	r0, r2, #7
 8007826:	d434      	bmi.n	8007892 <SDMMC_CmdSendStatus+0xf2>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8007828:	0211      	lsls	r1, r2, #8
 800782a:	d435      	bmi.n	8007898 <SDMMC_CmdSendStatus+0xf8>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800782c:	0254      	lsls	r4, r2, #9
 800782e:	d436      	bmi.n	800789e <SDMMC_CmdSendStatus+0xfe>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8007830:	0290      	lsls	r0, r2, #10
 8007832:	d440      	bmi.n	80078b6 <SDMMC_CmdSendStatus+0x116>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8007834:	02d1      	lsls	r1, r2, #11
 8007836:	d43b      	bmi.n	80078b0 <SDMMC_CmdSendStatus+0x110>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8007838:	0354      	lsls	r4, r2, #13
 800783a:	d436      	bmi.n	80078aa <SDMMC_CmdSendStatus+0x10a>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800783c:	0390      	lsls	r0, r2, #14
 800783e:	d431      	bmi.n	80078a4 <SDMMC_CmdSendStatus+0x104>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 8007840:	03d1      	lsls	r1, r2, #15
 8007842:	d444      	bmi.n	80078ce <SDMMC_CmdSendStatus+0x12e>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8007844:	0414      	lsls	r4, r2, #16
 8007846:	d43f      	bmi.n	80078c8 <SDMMC_CmdSendStatus+0x128>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8007848:	0450      	lsls	r0, r2, #17
 800784a:	d43a      	bmi.n	80078c2 <SDMMC_CmdSendStatus+0x122>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800784c:	0491      	lsls	r1, r2, #18
 800784e:	d435      	bmi.n	80078bc <SDMMC_CmdSendStatus+0x11c>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8007850:	f012 0f08 	tst.w	r2, #8
 8007854:	bf14      	ite	ne
 8007856:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
 800785a:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 800785e:	e7bf      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8007860:	2201      	movs	r2, #1
 8007862:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007864:	e7bc      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8007866:	2301      	movs	r3, #1
 8007868:	e7ba      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800786a:	2204      	movs	r2, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800786c:	4613      	mov	r3, r2
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800786e:	6382      	str	r2, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8007870:	e7b6      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8007872:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007876:	e7b3      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8007878:	2340      	movs	r3, #64	; 0x40
 800787a:	e7b1      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800787c:	2380      	movs	r3, #128	; 0x80
 800787e:	e7af      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8007880:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007884:	e7ac      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8007886:	f44f 7300 	mov.w	r3, #512	; 0x200
 800788a:	e7a9      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800788c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007890:	e7a6      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8007892:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8007896:	e7a3      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_COM_CRC_FAILED;
 8007898:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800789c:	e7a0      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_ILLEGAL_CMD;
 800789e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80078a2:	e79d      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 80078a4:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80078a8:	e79a      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 80078aa:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80078ae:	e797      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_CC_ERR;
 80078b0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80078b4:	e794      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_CARD_ECC_FAILED;
 80078b6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80078ba:	e791      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_ERASE_RESET;
 80078bc:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80078c0:	e78e      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 80078c2:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 80078c6:	e78b      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_WP_ERASE_SKIP;
 80078c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 80078cc:	e788      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80078ce:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 80078d2:	e785      	b.n	80077e0 <SDMMC_CmdSendStatus+0x40>
 80078d4:	20000680 	.word	0x20000680
 80078d8:	10624dd3 	.word	0x10624dd3
 80078dc:	fffff000 	.word	0xfffff000
 80078e0:	fdffe008 	.word	0xfdffe008

080078e4 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
 80078e4:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 80078e6:	4903      	ldr	r1, [pc, #12]	; (80078f4 <MX_FATFS_Init+0x10>)
 80078e8:	4803      	ldr	r0, [pc, #12]	; (80078f8 <MX_FATFS_Init+0x14>)
 80078ea:	f001 fbf7 	bl	80090dc <FATFS_LinkDriver>
 80078ee:	4b03      	ldr	r3, [pc, #12]	; (80078fc <MX_FATFS_Init+0x18>)
 80078f0:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  /* USER CODE END Init */
}
 80078f2:	bd08      	pop	{r3, pc}
 80078f4:	200194c8 	.word	0x200194c8
 80078f8:	08016b08 	.word	0x08016b08
 80078fc:	200194cc 	.word	0x200194cc

08007900 <BSP_SD_GetStats>:
extern SD_HandleTypeDef hsd1;

static sSdStats gSdStats = {0};

sSdStats BSP_SD_GetStats(void)
{
 8007900:	b570      	push	{r4, r5, r6, lr}
  sSdStats stats = gSdStats;
 8007902:	4c17      	ldr	r4, [pc, #92]	; (8007960 <BSP_SD_GetStats+0x60>)
{
 8007904:	4605      	mov	r5, r0
  sSdStats stats = gSdStats;
 8007906:	4684      	mov	ip, r0
 8007908:	46a6      	mov	lr, r4
  if(gSdStats.readMax < gSdStats.readLast)
 800790a:	6926      	ldr	r6, [r4, #16]
  sSdStats stats = gSdStats;
 800790c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8007910:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8007914:	e89e 000f 	ldmia.w	lr, {r0, r1, r2, r3}
 8007918:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
  if(gSdStats.readMax < gSdStats.readLast)
 800791c:	69a3      	ldr	r3, [r4, #24]
  gSdStats.writeAll += gSdStats.writeLast;
  gSdStats.readLast = 0;
  gSdStats.writeLast = 0;
  return stats;

}
 800791e:	4628      	mov	r0, r5
  if(gSdStats.writeMax < gSdStats.writeLast)
 8007920:	6961      	ldr	r1, [r4, #20]
  if(gSdStats.readMax < gSdStats.readLast)
 8007922:	42b3      	cmp	r3, r6
  if(gSdStats.writeMax < gSdStats.writeLast)
 8007924:	69e3      	ldr	r3, [r4, #28]
  gSdStats.readAll += gSdStats.readLast;
 8007926:	6822      	ldr	r2, [r4, #0]
    gSdStats.readMax = gSdStats.readLast;
 8007928:	bf38      	it	cc
 800792a:	61a6      	strcc	r6, [r4, #24]
  if(gSdStats.writeMax < gSdStats.writeLast)
 800792c:	428b      	cmp	r3, r1
  gSdStats.readAll += gSdStats.readLast;
 800792e:	6865      	ldr	r5, [r4, #4]
    gSdStats.writeMax = gSdStats.writeLast;
 8007930:	bf38      	it	cc
 8007932:	61e1      	strcc	r1, [r4, #28]
  gSdStats.readAll += gSdStats.readLast;
 8007934:	1992      	adds	r2, r2, r6
 8007936:	6022      	str	r2, [r4, #0]
 8007938:	f145 0500 	adc.w	r5, r5, #0
  gSdStats.writeAll += gSdStats.writeLast;
 800793c:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
  gSdStats.readLast = 0;
 8007940:	ed9f 7b05 	vldr	d7, [pc, #20]	; 8007958 <BSP_SD_GetStats+0x58>
  gSdStats.writeAll += gSdStats.writeLast;
 8007944:	185b      	adds	r3, r3, r1
 8007946:	f142 0200 	adc.w	r2, r2, #0
 800794a:	e9c4 5301 	strd	r5, r3, [r4, #4]
 800794e:	60e2      	str	r2, [r4, #12]
  gSdStats.readLast = 0;
 8007950:	ed84 7b04 	vstr	d7, [r4, #16]
}
 8007954:	bd70      	pop	{r4, r5, r6, pc}
 8007956:	bf00      	nop
	...
 8007960:	200194d0 	.word	0x200194d0

08007964 <BSP_SD_ReadBlocks_DMA>:
  * @param  ReadAddr: Address from where data is to be read
  * @param  NumOfBlocks: Number of SD blocks to read
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)
{
 8007964:	b538      	push	{r3, r4, r5, lr}
 8007966:	4614      	mov	r4, r2
  uint8_t sd_state = MSD_OK;

  /* Read block(s) in DMA transfer mode */
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 8007968:	4d08      	ldr	r5, [pc, #32]	; (800798c <BSP_SD_ReadBlocks_DMA+0x28>)
{
 800796a:	460a      	mov	r2, r1
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
 800796c:	4601      	mov	r1, r0
 800796e:	4623      	mov	r3, r4
 8007970:	4628      	mov	r0, r5
 8007972:	f7fd f9c7 	bl	8004d04 <HAL_SD_ReadBlocks_DMA>
 8007976:	b930      	cbnz	r0, 8007986 <BSP_SD_ReadBlocks_DMA+0x22>
  {
    sd_state = MSD_ERROR;
  } else {
    gSdStats.readLast += NumOfBlocks * hsd1.SdCard.BlockSize;
 8007978:	4905      	ldr	r1, [pc, #20]	; (8007990 <BSP_SD_ReadBlocks_DMA+0x2c>)
 800797a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 800797c:	690a      	ldr	r2, [r1, #16]
 800797e:	fb03 2204 	mla	r2, r3, r4, r2
 8007982:	610a      	str	r2, [r1, #16]
  }

  return sd_state;
}
 8007984:	bd38      	pop	{r3, r4, r5, pc}
    sd_state = MSD_ERROR;
 8007986:	2001      	movs	r0, #1
}
 8007988:	bd38      	pop	{r3, r4, r5, pc}
 800798a:	bf00      	nop
 800798c:	20018b04 	.word	0x20018b04
 8007990:	200194d0 	.word	0x200194d0

08007994 <BSP_SD_WriteBlocks_DMA>:
  * @param  WriteAddr: Address from where data is to be written
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)
{
 8007994:	b538      	push	{r3, r4, r5, lr}
 8007996:	4614      	mov	r4, r2
  uint8_t sd_state = MSD_OK;

  /* Write block(s) in DMA transfer mode */
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 8007998:	4d08      	ldr	r5, [pc, #32]	; (80079bc <BSP_SD_WriteBlocks_DMA+0x28>)
{
 800799a:	460a      	mov	r2, r1
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
 800799c:	4601      	mov	r1, r0
 800799e:	4623      	mov	r3, r4
 80079a0:	4628      	mov	r0, r5
 80079a2:	f7fd fa51 	bl	8004e48 <HAL_SD_WriteBlocks_DMA>
 80079a6:	b930      	cbnz	r0, 80079b6 <BSP_SD_WriteBlocks_DMA+0x22>
  {
    sd_state = MSD_ERROR;
  } else {
    gSdStats.writeLast += NumOfBlocks * hsd1.SdCard.BlockSize;
 80079a8:	4905      	ldr	r1, [pc, #20]	; (80079c0 <BSP_SD_WriteBlocks_DMA+0x2c>)
 80079aa:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80079ac:	694a      	ldr	r2, [r1, #20]
 80079ae:	fb03 2204 	mla	r2, r3, r4, r2
 80079b2:	614a      	str	r2, [r1, #20]
  }

  return sd_state;
}
 80079b4:	bd38      	pop	{r3, r4, r5, pc}
    sd_state = MSD_ERROR;
 80079b6:	2001      	movs	r0, #1
}
 80079b8:	bd38      	pop	{r3, r4, r5, pc}
 80079ba:	bf00      	nop
 80079bc:	20018b04 	.word	0x20018b04
 80079c0:	200194d0 	.word	0x200194d0

080079c4 <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
 80079c4:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 80079c6:	4803      	ldr	r0, [pc, #12]	; (80079d4 <BSP_SD_GetCardState+0x10>)
 80079c8:	f7fd ff7e 	bl	80058c8 <HAL_SD_GetCardState>
}
 80079cc:	3804      	subs	r0, #4
 80079ce:	bf18      	it	ne
 80079d0:	2001      	movne	r0, #1
 80079d2:	bd08      	pop	{r3, pc}
 80079d4:	20018b04 	.word	0x20018b04

080079d8 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
 80079d8:	4601      	mov	r1, r0
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
 80079da:	4801      	ldr	r0, [pc, #4]	; (80079e0 <BSP_SD_GetCardInfo+0x8>)
 80079dc:	f7fd beca 	b.w	8005774 <HAL_SD_GetCardInfo>
 80079e0:	20018b04 	.word	0x20018b04

080079e4 <BSP_SD_AbortCallback>:
  * @note empty (up to the user to fill it in or to remove it if useless)
  */
__weak void BSP_SD_AbortCallback(void)
{

}
 80079e4:	4770      	bx	lr
 80079e6:	bf00      	nop

080079e8 <HAL_SD_AbortCallback>:
{
 80079e8:	b508      	push	{r3, lr}
  BSP_SD_AbortCallback();
 80079ea:	f7ff fffb 	bl	80079e4 <BSP_SD_AbortCallback>
}
 80079ee:	bd08      	pop	{r3, pc}

080079f0 <HAL_SD_TxCpltCallback>:
{
 80079f0:	b508      	push	{r3, lr}
  BSP_SD_WriteCpltCallback();
 80079f2:	f000 f969 	bl	8007cc8 <BSP_SD_WriteCpltCallback>
}
 80079f6:	bd08      	pop	{r3, pc}

080079f8 <HAL_SD_RxCpltCallback>:
{
 80079f8:	b508      	push	{r3, lr}
  BSP_SD_ReadCpltCallback();
 80079fa:	f000 f979 	bl	8007cf0 <BSP_SD_ReadCpltCallback>
}
 80079fe:	bd08      	pop	{r3, pc}

08007a00 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
 8007a00:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
 8007a02:	2301      	movs	r3, #1
{
 8007a04:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
 8007a06:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0)
 8007a0a:	f000 f821 	bl	8007a50 <BSP_PlatformIsDetected>
 8007a0e:	b908      	cbnz	r0, 8007a14 <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
 8007a10:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
 8007a14:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8007a18:	b003      	add	sp, #12
 8007a1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a1e:	bf00      	nop

08007a20 <BSP_SD_Init>:
{
 8007a20:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8007a22:	f7ff ffed 	bl	8007a00 <BSP_SD_IsDetected>
 8007a26:	2801      	cmp	r0, #1
 8007a28:	d001      	beq.n	8007a2e <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
 8007a2a:	2002      	movs	r0, #2
}
 8007a2c:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
 8007a2e:	4807      	ldr	r0, [pc, #28]	; (8007a4c <BSP_SD_Init+0x2c>)
 8007a30:	f7fd fe82 	bl	8005738 <HAL_SD_Init>
  if (sd_state == MSD_OK)
 8007a34:	2800      	cmp	r0, #0
 8007a36:	d1f9      	bne.n	8007a2c <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
 8007a38:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007a3c:	4803      	ldr	r0, [pc, #12]	; (8007a4c <BSP_SD_Init+0x2c>)
 8007a3e:	f7fd fead 	bl	800579c <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
 8007a42:	3800      	subs	r0, #0
 8007a44:	bf18      	it	ne
 8007a46:	2001      	movne	r0, #1
}
 8007a48:	bd08      	pop	{r3, pc}
 8007a4a:	bf00      	nop
 8007a4c:	20018b04 	.word	0x20018b04

08007a50 <BSP_PlatformIsDetected>:
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8007a50:	2104      	movs	r1, #4
 8007a52:	4804      	ldr	r0, [pc, #16]	; (8007a64 <BSP_PlatformIsDetected+0x14>)
uint8_t	BSP_PlatformIsDetected(void) {
 8007a54:	b508      	push	{r3, lr}
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8007a56:	f7fb ff3f 	bl	80038d8 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */
    return status;
}
 8007a5a:	fab0 f080 	clz	r0, r0
 8007a5e:	0940      	lsrs	r0, r0, #5
 8007a60:	bd08      	pop	{r3, pc}
 8007a62:	bf00      	nop
 8007a64:	40020400 	.word	0x40020400

08007a68 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8007a68:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;
 8007a6a:	4c15      	ldr	r4, [pc, #84]	; (8007ac0 <SD_initialize+0x58>)
 8007a6c:	2501      	movs	r5, #1
 8007a6e:	7025      	strb	r5, [r4, #0]
   * as the osMessage API will fail otherwise
   */
#if (osCMSIS <= 0x20000U)
  if(osKernelRunning())
#else
  if(osKernelGetState() == osKernelRunning)
 8007a70:	f001 fbfa 	bl	8009268 <osKernelGetState>
 8007a74:	2802      	cmp	r0, #2
 8007a76:	d001      	beq.n	8007a7c <SD_initialize+0x14>
        Stat |= STA_NOINIT;
      }
    }
  }

  return Stat;
 8007a78:	7820      	ldrb	r0, [r4, #0]
}
 8007a7a:	bd38      	pop	{r3, r4, r5, pc}
    if(BSP_SD_Init() == MSD_OK)
 8007a7c:	f7ff ffd0 	bl	8007a20 <BSP_SD_Init>
 8007a80:	b190      	cbz	r0, 8007aa8 <SD_initialize+0x40>
    if (Stat != STA_NOINIT)
 8007a82:	7823      	ldrb	r3, [r4, #0]
 8007a84:	2b01      	cmp	r3, #1
 8007a86:	d0f7      	beq.n	8007a78 <SD_initialize+0x10>
      if (SDQueueID == NULL)
 8007a88:	4d0e      	ldr	r5, [pc, #56]	; (8007ac4 <SD_initialize+0x5c>)
 8007a8a:	682a      	ldr	r2, [r5, #0]
 8007a8c:	2a00      	cmp	r2, #0
 8007a8e:	d1f3      	bne.n	8007a78 <SD_initialize+0x10>
      SDQueueID = osMessageQueueNew(QUEUE_SIZE, 2, NULL);
 8007a90:	2102      	movs	r1, #2
 8007a92:	200a      	movs	r0, #10
 8007a94:	f001 fe94 	bl	80097c0 <osMessageQueueNew>
 8007a98:	6028      	str	r0, [r5, #0]
      if (SDQueueID == NULL)
 8007a9a:	2800      	cmp	r0, #0
 8007a9c:	d1ec      	bne.n	8007a78 <SD_initialize+0x10>
        Stat |= STA_NOINIT;
 8007a9e:	7823      	ldrb	r3, [r4, #0]
 8007aa0:	f043 0301 	orr.w	r3, r3, #1
 8007aa4:	7023      	strb	r3, [r4, #0]
 8007aa6:	e7e7      	b.n	8007a78 <SD_initialize+0x10>
  Stat = STA_NOINIT;
 8007aa8:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007aaa:	f7ff ff8b 	bl	80079c4 <BSP_SD_GetCardState>
 8007aae:	b918      	cbnz	r0, 8007ab8 <SD_initialize+0x50>
    Stat &= ~STA_NOINIT;
 8007ab0:	7823      	ldrb	r3, [r4, #0]
 8007ab2:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8007ab6:	7023      	strb	r3, [r4, #0]
  return Stat;
 8007ab8:	7823      	ldrb	r3, [r4, #0]
 8007aba:	b2db      	uxtb	r3, r3
      Stat = SD_CheckStatus(lun);
 8007abc:	7023      	strb	r3, [r4, #0]
 8007abe:	e7e0      	b.n	8007a82 <SD_initialize+0x1a>
 8007ac0:	2000068c 	.word	0x2000068c
 8007ac4:	200194f0 	.word	0x200194f0

08007ac8 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8007ac8:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8007aca:	2301      	movs	r3, #1
 8007acc:	4c05      	ldr	r4, [pc, #20]	; (8007ae4 <SD_status+0x1c>)
 8007ace:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007ad0:	f7ff ff78 	bl	80079c4 <BSP_SD_GetCardState>
 8007ad4:	b918      	cbnz	r0, 8007ade <SD_status+0x16>
    Stat &= ~STA_NOINIT;
 8007ad6:	7823      	ldrb	r3, [r4, #0]
 8007ad8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8007adc:	7023      	strb	r3, [r4, #0]
  return Stat;
 8007ade:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 8007ae0:	bd10      	pop	{r4, pc}
 8007ae2:	bf00      	nop
 8007ae4:	2000068c 	.word	0x2000068c

08007ae8 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007ae8:	4b18      	ldr	r3, [pc, #96]	; (8007b4c <SD_ioctl+0x64>)
{
 8007aea:	b530      	push	{r4, r5, lr}
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007aec:	7818      	ldrb	r0, [r3, #0]
{
 8007aee:	b089      	sub	sp, #36	; 0x24
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007af0:	f010 0401 	ands.w	r4, r0, #1
 8007af4:	d106      	bne.n	8007b04 <SD_ioctl+0x1c>
 8007af6:	4615      	mov	r5, r2

  switch (cmd)
 8007af8:	2903      	cmp	r1, #3
 8007afa:	d824      	bhi.n	8007b46 <SD_ioctl+0x5e>
 8007afc:	e8df f001 	tbb	[pc, r1]
 8007b00:	1a120a06 	.word	0x1a120a06
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007b04:	2403      	movs	r4, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 8007b06:	4620      	mov	r0, r4
 8007b08:	b009      	add	sp, #36	; 0x24
 8007b0a:	bd30      	pop	{r4, r5, pc}
    res = RES_OK;
 8007b0c:	460c      	mov	r4, r1
}
 8007b0e:	4620      	mov	r0, r4
 8007b10:	b009      	add	sp, #36	; 0x24
 8007b12:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 8007b14:	4668      	mov	r0, sp
 8007b16:	f7ff ff5f 	bl	80079d8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 8007b1a:	9b06      	ldr	r3, [sp, #24]
}
 8007b1c:	4620      	mov	r0, r4
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 8007b1e:	602b      	str	r3, [r5, #0]
}
 8007b20:	b009      	add	sp, #36	; 0x24
 8007b22:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 8007b24:	4668      	mov	r0, sp
 8007b26:	f7ff ff57 	bl	80079d8 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 8007b2a:	9b07      	ldr	r3, [sp, #28]
}
 8007b2c:	4620      	mov	r0, r4
    *(WORD*)buff = CardInfo.LogBlockSize;
 8007b2e:	802b      	strh	r3, [r5, #0]
}
 8007b30:	b009      	add	sp, #36	; 0x24
 8007b32:	bd30      	pop	{r4, r5, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 8007b34:	4668      	mov	r0, sp
 8007b36:	f7ff ff4f 	bl	80079d8 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8007b3a:	9b07      	ldr	r3, [sp, #28]
}
 8007b3c:	4620      	mov	r0, r4
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8007b3e:	0a5b      	lsrs	r3, r3, #9
 8007b40:	602b      	str	r3, [r5, #0]
}
 8007b42:	b009      	add	sp, #36	; 0x24
 8007b44:	bd30      	pop	{r4, r5, pc}
  switch (cmd)
 8007b46:	2404      	movs	r4, #4
 8007b48:	e7dd      	b.n	8007b06 <SD_ioctl+0x1e>
 8007b4a:	bf00      	nop
 8007b4c:	2000068c 	.word	0x2000068c

08007b50 <SD_write>:
{
 8007b50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007b54:	b082      	sub	sp, #8
 8007b56:	460c      	mov	r4, r1
 8007b58:	4616      	mov	r6, r2
 8007b5a:	461d      	mov	r5, r3
  while( osKernelGetTickCount() - timer < timeout)
 8007b5c:	f241 3887 	movw	r8, #4999	; 0x1387
  timer = osKernelGetTickCount();
 8007b60:	f001 fbb6 	bl	80092d0 <osKernelGetTickCount>
 8007b64:	4607      	mov	r7, r0
  while( osKernelGetTickCount() - timer < timeout)
 8007b66:	e002      	b.n	8007b6e <SD_write+0x1e>
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007b68:	f7ff ff2c 	bl	80079c4 <BSP_SD_GetCardState>
 8007b6c:	b140      	cbz	r0, 8007b80 <SD_write+0x30>
  while( osKernelGetTickCount() - timer < timeout)
 8007b6e:	f001 fbaf 	bl	80092d0 <osKernelGetTickCount>
 8007b72:	1bc0      	subs	r0, r0, r7
 8007b74:	4540      	cmp	r0, r8
 8007b76:	d9f7      	bls.n	8007b68 <SD_write+0x18>
    return res;
 8007b78:	2001      	movs	r0, #1
}
 8007b7a:	b002      	add	sp, #8
 8007b7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  alignedAddr = (uint32_t)buff & ~0x1F;
 8007b80:	f024 001f 	bic.w	r0, r4, #31
  SCB_CleanDCache_by_Addr((uint32_t*)alignedAddr, count*BLOCKSIZE + ((uint32_t)buff - alignedAddr));
 8007b84:	eb04 2345 	add.w	r3, r4, r5, lsl #9
 8007b88:	1a1b      	subs	r3, r3, r0
  __ASM volatile ("dsb 0xF":::"memory");
 8007b8a:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
 8007b8e:	2b00      	cmp	r3, #0
 8007b90:	dd0d      	ble.n	8007bae <SD_write+0x5e>
 8007b92:	3b01      	subs	r3, #1
 8007b94:	f100 0c20 	add.w	ip, r0, #32
      SCB->DCCMVAC = op_addr;
 8007b98:	4a1a      	ldr	r2, [pc, #104]	; (8007c04 <SD_write+0xb4>)
 8007b9a:	f023 031f 	bic.w	r3, r3, #31
 8007b9e:	4463      	add	r3, ip
    while (op_size > 0) {
 8007ba0:	459c      	cmp	ip, r3
      SCB->DCCMVAC = op_addr;
 8007ba2:	f8c2 0268 	str.w	r0, [r2, #616]	; 0x268
      op_addr += (uint32_t)linesize;
 8007ba6:	4660      	mov	r0, ip
    while (op_size > 0) {
 8007ba8:	f10c 0c20 	add.w	ip, ip, #32
 8007bac:	d1f8      	bne.n	8007ba0 <SD_write+0x50>
 8007bae:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007bb2:	f3bf 8f6f 	isb	sy
  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
 8007bb6:	462a      	mov	r2, r5
 8007bb8:	4631      	mov	r1, r6
 8007bba:	4620      	mov	r0, r4
 8007bbc:	f7ff feea 	bl	8007994 <BSP_SD_WriteBlocks_DMA>
 8007bc0:	2800      	cmp	r0, #0
 8007bc2:	d1d9      	bne.n	8007b78 <SD_write+0x28>
    status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
 8007bc4:	4c10      	ldr	r4, [pc, #64]	; (8007c08 <SD_write+0xb8>)
 8007bc6:	4602      	mov	r2, r0
 8007bc8:	f241 3388 	movw	r3, #5000	; 0x1388
 8007bcc:	f10d 0106 	add.w	r1, sp, #6
 8007bd0:	6820      	ldr	r0, [r4, #0]
 8007bd2:	f001 fe97 	bl	8009904 <osMessageQueueGet>
    if ((status == osOK) && (event == WRITE_CPLT_MSG))
 8007bd6:	2800      	cmp	r0, #0
 8007bd8:	d1ce      	bne.n	8007b78 <SD_write+0x28>
 8007bda:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8007bde:	2b02      	cmp	r3, #2
 8007be0:	d1ca      	bne.n	8007b78 <SD_write+0x28>
        timer = osKernelGetTickCount();
 8007be2:	f001 fb75 	bl	80092d0 <osKernelGetTickCount>
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 8007be6:	f241 3587 	movw	r5, #4999	; 0x1387
        timer = osKernelGetTickCount();
 8007bea:	4604      	mov	r4, r0
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 8007bec:	e003      	b.n	8007bf6 <SD_write+0xa6>
          if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007bee:	f7ff fee9 	bl	80079c4 <BSP_SD_GetCardState>
 8007bf2:	2800      	cmp	r0, #0
 8007bf4:	d0c1      	beq.n	8007b7a <SD_write+0x2a>
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
 8007bf6:	f001 fb6b 	bl	80092d0 <osKernelGetTickCount>
 8007bfa:	1b00      	subs	r0, r0, r4
 8007bfc:	42a8      	cmp	r0, r5
 8007bfe:	d9f6      	bls.n	8007bee <SD_write+0x9e>
 8007c00:	e7ba      	b.n	8007b78 <SD_write+0x28>
 8007c02:	bf00      	nop
 8007c04:	e000ed00 	.word	0xe000ed00
 8007c08:	200194f0 	.word	0x200194f0

08007c0c <SD_read>:
{
 8007c0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007c10:	b082      	sub	sp, #8
 8007c12:	460e      	mov	r6, r1
 8007c14:	4690      	mov	r8, r2
 8007c16:	461f      	mov	r7, r3
  while( osKernelGetTickCount() - timer < timeout)
 8007c18:	f241 3587 	movw	r5, #4999	; 0x1387
  timer = osKernelGetTickCount();
 8007c1c:	f001 fb58 	bl	80092d0 <osKernelGetTickCount>
 8007c20:	4604      	mov	r4, r0
  while( osKernelGetTickCount() - timer < timeout)
 8007c22:	e002      	b.n	8007c2a <SD_read+0x1e>
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007c24:	f7ff fece 	bl	80079c4 <BSP_SD_GetCardState>
 8007c28:	b140      	cbz	r0, 8007c3c <SD_read+0x30>
  while( osKernelGetTickCount() - timer < timeout)
 8007c2a:	f001 fb51 	bl	80092d0 <osKernelGetTickCount>
 8007c2e:	1b00      	subs	r0, r0, r4
 8007c30:	42a8      	cmp	r0, r5
 8007c32:	d9f7      	bls.n	8007c24 <SD_read+0x18>
    return res;
 8007c34:	2001      	movs	r0, #1
}
 8007c36:	b002      	add	sp, #8
 8007c38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = BSP_SD_ReadBlocks_DMA((uint32_t*)buff, (uint32_t)(sector), count);
 8007c3c:	463a      	mov	r2, r7
 8007c3e:	4641      	mov	r1, r8
 8007c40:	4630      	mov	r0, r6
 8007c42:	f7ff fe8f 	bl	8007964 <BSP_SD_ReadBlocks_DMA>
    if (ret == MSD_OK) {
 8007c46:	2800      	cmp	r0, #0
 8007c48:	d1f4      	bne.n	8007c34 <SD_read+0x28>
          status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
 8007c4a:	491d      	ldr	r1, [pc, #116]	; (8007cc0 <SD_read+0xb4>)
 8007c4c:	4602      	mov	r2, r0
 8007c4e:	f241 3388 	movw	r3, #5000	; 0x1388
 8007c52:	6808      	ldr	r0, [r1, #0]
 8007c54:	f10d 0106 	add.w	r1, sp, #6
 8007c58:	f001 fe54 	bl	8009904 <osMessageQueueGet>
          if ((status == osOK) && (event == READ_CPLT_MSG))
 8007c5c:	2800      	cmp	r0, #0
 8007c5e:	d1e9      	bne.n	8007c34 <SD_read+0x28>
 8007c60:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8007c64:	2b01      	cmp	r3, #1
 8007c66:	d1e5      	bne.n	8007c34 <SD_read+0x28>
            timer = osKernelGetTickCount();
 8007c68:	f001 fb32 	bl	80092d0 <osKernelGetTickCount>
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 8007c6c:	f241 3587 	movw	r5, #4999	; 0x1387
            timer = osKernelGetTickCount();
 8007c70:	4604      	mov	r4, r0
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 8007c72:	e002      	b.n	8007c7a <SD_read+0x6e>
              if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
 8007c74:	f7ff fea6 	bl	80079c4 <BSP_SD_GetCardState>
 8007c78:	b128      	cbz	r0, 8007c86 <SD_read+0x7a>
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
 8007c7a:	f001 fb29 	bl	80092d0 <osKernelGetTickCount>
 8007c7e:	1b00      	subs	r0, r0, r4
 8007c80:	42a8      	cmp	r0, r5
 8007c82:	d9f7      	bls.n	8007c74 <SD_read+0x68>
 8007c84:	e7d6      	b.n	8007c34 <SD_read+0x28>
                alignedAddr = (uint32_t)buff & ~0x1F;
 8007c86:	f026 021f 	bic.w	r2, r6, #31
                SCB_InvalidateDCache_by_Addr((uint32_t*)alignedAddr, count*BLOCKSIZE + ((uint32_t)buff - alignedAddr));
 8007c8a:	eb06 2347 	add.w	r3, r6, r7, lsl #9
 8007c8e:	1a9b      	subs	r3, r3, r2
  __ASM volatile ("dsb 0xF":::"memory");
 8007c90:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
 8007c94:	2b00      	cmp	r3, #0
 8007c96:	dd0d      	ble.n	8007cb4 <SD_read+0xa8>
 8007c98:	1e59      	subs	r1, r3, #1
 8007c9a:	f102 0320 	add.w	r3, r2, #32
      SCB->DCIMVAC = op_addr;
 8007c9e:	4c09      	ldr	r4, [pc, #36]	; (8007cc4 <SD_read+0xb8>)
 8007ca0:	f021 011f 	bic.w	r1, r1, #31
 8007ca4:	4419      	add	r1, r3
    while (op_size > 0) {
 8007ca6:	428b      	cmp	r3, r1
      SCB->DCIMVAC = op_addr;
 8007ca8:	f8c4 225c 	str.w	r2, [r4, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
 8007cac:	461a      	mov	r2, r3
    while (op_size > 0) {
 8007cae:	f103 0320 	add.w	r3, r3, #32
 8007cb2:	d1f8      	bne.n	8007ca6 <SD_read+0x9a>
 8007cb4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007cb8:	f3bf 8f6f 	isb	sy
}
 8007cbc:	e7bb      	b.n	8007c36 <SD_read+0x2a>
 8007cbe:	bf00      	nop
 8007cc0:	200194f0 	.word	0x200194f0
 8007cc4:	e000ed00 	.word	0xe000ed00

08007cc8 <BSP_SD_WriteCpltCallback>:
  * @brief Tx Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
void BSP_SD_WriteCpltCallback(void)
{
 8007cc8:	b500      	push	{lr}
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, WRITE_CPLT_MSG, 0);
#else
   const uint16_t msg = WRITE_CPLT_MSG;
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cca:	2300      	movs	r3, #0
{
 8007ccc:	b083      	sub	sp, #12
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cce:	4807      	ldr	r0, [pc, #28]	; (8007cec <BSP_SD_WriteCpltCallback+0x24>)
   const uint16_t msg = WRITE_CPLT_MSG;
 8007cd0:	f04f 0c02 	mov.w	ip, #2
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cd4:	f10d 0106 	add.w	r1, sp, #6
 8007cd8:	461a      	mov	r2, r3
 8007cda:	6800      	ldr	r0, [r0, #0]
   const uint16_t msg = WRITE_CPLT_MSG;
 8007cdc:	f8ad c006 	strh.w	ip, [sp, #6]
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007ce0:	f001 fdb8 	bl	8009854 <osMessageQueuePut>
#endif
}
 8007ce4:	b003      	add	sp, #12
 8007ce6:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cea:	bf00      	nop
 8007cec:	200194f0 	.word	0x200194f0

08007cf0 <BSP_SD_ReadCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
void BSP_SD_ReadCpltCallback(void)
{
 8007cf0:	b500      	push	{lr}
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, READ_CPLT_MSG, 0);
#else
   const uint16_t msg = READ_CPLT_MSG;
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cf2:	2300      	movs	r3, #0
{
 8007cf4:	b083      	sub	sp, #12
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cf6:	4807      	ldr	r0, [pc, #28]	; (8007d14 <BSP_SD_ReadCpltCallback+0x24>)
   const uint16_t msg = READ_CPLT_MSG;
 8007cf8:	f04f 0c01 	mov.w	ip, #1
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007cfc:	f10d 0106 	add.w	r1, sp, #6
 8007d00:	461a      	mov	r2, r3
 8007d02:	6800      	ldr	r0, [r0, #0]
   const uint16_t msg = READ_CPLT_MSG;
 8007d04:	f8ad c006 	strh.w	ip, [sp, #6]
   osMessageQueuePut(SDQueueID, (const void *)&msg, 0, 0);
 8007d08:	f001 fda4 	bl	8009854 <osMessageQueuePut>
#endif
}
 8007d0c:	b003      	add	sp, #12
 8007d0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007d12:	bf00      	nop
 8007d14:	200194f0 	.word	0x200194f0

08007d18 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 8007d18:	4b03      	ldr	r3, [pc, #12]	; (8007d28 <disk_status+0x10>)
 8007d1a:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8007d1e:	4403      	add	r3, r0
 8007d20:	6852      	ldr	r2, [r2, #4]
 8007d22:	7a18      	ldrb	r0, [r3, #8]
 8007d24:	6853      	ldr	r3, [r2, #4]
 8007d26:	4718      	bx	r3
 8007d28:	200194fc 	.word	0x200194fc

08007d2c <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 8007d2c:	4b07      	ldr	r3, [pc, #28]	; (8007d4c <disk_initialize+0x20>)
 8007d2e:	5c1a      	ldrb	r2, [r3, r0]
 8007d30:	b952      	cbnz	r2, 8007d48 <disk_initialize+0x1c>
  {
    disk.is_initialized[pdrv] = 1;
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8007d32:	eb03 0280 	add.w	r2, r3, r0, lsl #2
 8007d36:	1819      	adds	r1, r3, r0
    disk.is_initialized[pdrv] = 1;
 8007d38:	f04f 0c01 	mov.w	ip, #1
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8007d3c:	6852      	ldr	r2, [r2, #4]
    disk.is_initialized[pdrv] = 1;
 8007d3e:	f803 c000 	strb.w	ip, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8007d42:	7a08      	ldrb	r0, [r1, #8]
 8007d44:	6813      	ldr	r3, [r2, #0]
 8007d46:	4718      	bx	r3
  }
  return stat;
}
 8007d48:	2000      	movs	r0, #0
 8007d4a:	4770      	bx	lr
 8007d4c:	200194fc 	.word	0x200194fc

08007d50 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 8007d50:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8007d52:	4c05      	ldr	r4, [pc, #20]	; (8007d68 <disk_read+0x18>)
 8007d54:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8007d58:	4404      	add	r4, r0
 8007d5a:	686d      	ldr	r5, [r5, #4]
 8007d5c:	7a20      	ldrb	r0, [r4, #8]
 8007d5e:	68ac      	ldr	r4, [r5, #8]
 8007d60:	46a4      	mov	ip, r4
  return res;
}
 8007d62:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 8007d64:	4760      	bx	ip
 8007d66:	bf00      	nop
 8007d68:	200194fc 	.word	0x200194fc

08007d6c <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 8007d6c:	b570      	push	{r4, r5, r6, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8007d6e:	f04f 36ff 	mov.w	r6, #4294967295
 8007d72:	2300      	movs	r3, #0
{
 8007d74:	4604      	mov	r4, r0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8007d76:	42b1      	cmp	r1, r6
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8007d78:	70c3      	strb	r3, [r0, #3]
 8007d7a:	62c6      	str	r6, [r0, #44]	; 0x2c
	if (sector != fs->winsect) {	/* Window offset changed? */
 8007d7c:	d120      	bne.n	8007dc0 <check_fs+0x54>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8007d7e:	f64a 2355 	movw	r3, #43605	; 0xaa55
 8007d82:	f8b4 222e 	ldrh.w	r2, [r4, #558]	; 0x22e
 8007d86:	429a      	cmp	r2, r3
 8007d88:	d12a      	bne.n	8007de0 <check_fs+0x74>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8007d8a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8007d8e:	2be9      	cmp	r3, #233	; 0xe9
 8007d90:	d007      	beq.n	8007da2 <check_fs+0x36>
 8007d92:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8007d94:	4a16      	ldr	r2, [pc, #88]	; (8007df0 <check_fs+0x84>)
 8007d96:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8007d9a:	4293      	cmp	r3, r2
 8007d9c:	d001      	beq.n	8007da2 <check_fs+0x36>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
 8007d9e:	2002      	movs	r0, #2
}
 8007da0:	bd70      	pop	{r4, r5, r6, pc}
	rv = rv << 8 | ptr[0];
 8007da2:	f8d4 3066 	ldr.w	r3, [r4, #102]	; 0x66
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8007da6:	4a13      	ldr	r2, [pc, #76]	; (8007df4 <check_fs+0x88>)
 8007da8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8007dac:	4293      	cmp	r3, r2
 8007dae:	d01c      	beq.n	8007dea <check_fs+0x7e>
	rv = rv << 8 | ptr[0];
 8007db0:	f8d4 0082 	ldr.w	r0, [r4, #130]	; 0x82
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8007db4:	4b10      	ldr	r3, [pc, #64]	; (8007df8 <check_fs+0x8c>)
 8007db6:	4298      	cmp	r0, r3
 8007db8:	bf14      	ite	ne
 8007dba:	2002      	movne	r0, #2
 8007dbc:	2000      	moveq	r0, #0
}
 8007dbe:	bd70      	pop	{r4, r5, r6, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8007dc0:	460d      	mov	r5, r1
 8007dc2:	460a      	mov	r2, r1
 8007dc4:	2301      	movs	r3, #1
 8007dc6:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8007dca:	7840      	ldrb	r0, [r0, #1]
 8007dcc:	f7ff ffc0 	bl	8007d50 <disk_read>
 8007dd0:	b940      	cbnz	r0, 8007de4 <check_fs+0x78>
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8007dd2:	f64a 2355 	movw	r3, #43605	; 0xaa55
 8007dd6:	f8b4 222e 	ldrh.w	r2, [r4, #558]	; 0x22e
			fs->winsect = sector;
 8007dda:	62e5      	str	r5, [r4, #44]	; 0x2c
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8007ddc:	429a      	cmp	r2, r3
 8007dde:	d0d4      	beq.n	8007d8a <check_fs+0x1e>
 8007de0:	2003      	movs	r0, #3
}
 8007de2:	bd70      	pop	{r4, r5, r6, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8007de4:	2004      	movs	r0, #4
			fs->winsect = sector;
 8007de6:	62e6      	str	r6, [r4, #44]	; 0x2c
}
 8007de8:	bd70      	pop	{r4, r5, r6, pc}
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8007dea:	2000      	movs	r0, #0
}
 8007dec:	bd70      	pop	{r4, r5, r6, pc}
 8007dee:	bf00      	nop
 8007df0:	009000eb 	.word	0x009000eb
 8007df4:	00544146 	.word	0x00544146
 8007df8:	33544146 	.word	0x33544146

08007dfc <find_volume.constprop.0>:
/*-----------------------------------------------------------------------*/
/* Find logical drive and check if the volume is mounted                 */
/*-----------------------------------------------------------------------*/

static
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 8007dfc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 8007e00:	2300      	movs	r3, #0
	if (*path) {	/* If the pointer is not a null */
 8007e02:	6804      	ldr	r4, [r0, #0]
	*rfs = 0;
 8007e04:	600b      	str	r3, [r1, #0]
	if (*path) {	/* If the pointer is not a null */
 8007e06:	b194      	cbz	r4, 8007e2e <find_volume.constprop.0+0x32>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8007e08:	460d      	mov	r5, r1
 8007e0a:	7821      	ldrb	r1, [r4, #0]
 8007e0c:	291f      	cmp	r1, #31
 8007e0e:	d912      	bls.n	8007e36 <find_volume.constprop.0+0x3a>
 8007e10:	293a      	cmp	r1, #58	; 0x3a
 8007e12:	d010      	beq.n	8007e36 <find_volume.constprop.0+0x3a>
 8007e14:	4622      	mov	r2, r4
 8007e16:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8007e1a:	2b1f      	cmp	r3, #31
 8007e1c:	d90d      	bls.n	8007e3a <find_volume.constprop.0+0x3e>
 8007e1e:	2b3a      	cmp	r3, #58	; 0x3a
 8007e20:	d1f9      	bne.n	8007e16 <find_volume.constprop.0+0x1a>
			i = *tp++ - '0';
 8007e22:	3401      	adds	r4, #1
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 8007e24:	42a2      	cmp	r2, r4
 8007e26:	d102      	bne.n	8007e2e <find_volume.constprop.0+0x32>
 8007e28:	2930      	cmp	r1, #48	; 0x30
 8007e2a:	f000 80cb 	beq.w	8007fc4 <find_volume.constprop.0+0x1c8>
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8007e2e:	250b      	movs	r5, #11
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 8007e30:	4628      	mov	r0, r5
 8007e32:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8007e36:	460b      	mov	r3, r1
 8007e38:	4622      	mov	r2, r4
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 8007e3a:	2b3a      	cmp	r3, #58	; 0x3a
 8007e3c:	d0f1      	beq.n	8007e22 <find_volume.constprop.0+0x26>
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8007e3e:	4b7e      	ldr	r3, [pc, #504]	; (8008038 <find_volume.constprop.0+0x23c>)
 8007e40:	681c      	ldr	r4, [r3, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8007e42:	2c00      	cmp	r4, #0
 8007e44:	f000 80b6 	beq.w	8007fb4 <find_volume.constprop.0+0x1b8>
	return (fs && ff_req_grant(fs->sobj)) ? 1 : 0;
 8007e48:	6920      	ldr	r0, [r4, #16]
 8007e4a:	f001 f9e5 	bl	8009218 <ff_req_grant>
 8007e4e:	b918      	cbnz	r0, 8007e58 <find_volume.constprop.0+0x5c>
	ENTER_FF(fs);						/* Lock the volume */
 8007e50:	250f      	movs	r5, #15
}
 8007e52:	4628      	mov	r0, r5
 8007e54:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*rfs = fs;							/* Return pointer to the file system object */
 8007e58:	602c      	str	r4, [r5, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8007e5a:	7823      	ldrb	r3, [r4, #0]
 8007e5c:	2b00      	cmp	r3, #0
 8007e5e:	d177      	bne.n	8007f50 <find_volume.constprop.0+0x154>
	fs->fs_type = 0;					/* Clear the file system object */
 8007e60:	2000      	movs	r0, #0
 8007e62:	8020      	strh	r0, [r4, #0]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8007e64:	f7ff ff62 	bl	8007d2c <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8007e68:	f010 0501 	ands.w	r5, r0, #1
 8007e6c:	f040 80a6 	bne.w	8007fbc <find_volume.constprop.0+0x1c0>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8007e70:	4629      	mov	r1, r5
 8007e72:	4620      	mov	r0, r4
 8007e74:	f7ff ff7a 	bl	8007d6c <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8007e78:	2802      	cmp	r0, #2
 8007e7a:	d070      	beq.n	8007f5e <find_volume.constprop.0+0x162>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8007e7c:	2804      	cmp	r0, #4
 8007e7e:	f000 8093 	beq.w	8007fa8 <find_volume.constprop.0+0x1ac>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8007e82:	2801      	cmp	r0, #1
 8007e84:	f200 8092 	bhi.w	8007fac <find_volume.constprop.0+0x1b0>
	bsect = 0;
 8007e88:	462e      	mov	r6, r5
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8007e8a:	f8b4 303b 	ldrh.w	r3, [r4, #59]	; 0x3b
 8007e8e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007e92:	f040 808b 	bne.w	8007fac <find_volume.constprop.0+0x1b0>
		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 8007e96:	f8b4 2046 	ldrh.w	r2, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8007e9a:	b902      	cbnz	r2, 8007e9e <find_volume.constprop.0+0xa2>
	rv = rv << 8 | ptr[0];
 8007e9c:	6d62      	ldr	r2, [r4, #84]	; 0x54
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8007e9e:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
		fs->fsize = fasize;
 8007ea2:	61a2      	str	r2, [r4, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8007ea4:	1e59      	subs	r1, r3, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8007ea6:	70a3      	strb	r3, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8007ea8:	2901      	cmp	r1, #1
 8007eaa:	d87f      	bhi.n	8007fac <find_volume.constprop.0+0x1b0>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8007eac:	f894 103d 	ldrb.w	r1, [r4, #61]	; 0x3d
 8007eb0:	b288      	uxth	r0, r1
 8007eb2:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8007eb4:	2800      	cmp	r0, #0
 8007eb6:	d079      	beq.n	8007fac <find_volume.constprop.0+0x1b0>
 8007eb8:	1e48      	subs	r0, r1, #1
 8007eba:	4208      	tst	r0, r1
 8007ebc:	d176      	bne.n	8007fac <find_volume.constprop.0+0x1b0>
	rv = ptr[1];
 8007ebe:	f8b4 e041 	ldrh.w	lr, [r4, #65]	; 0x41
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8007ec2:	f01e 0f0f 	tst.w	lr, #15
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8007ec6:	f8a4 e008 	strh.w	lr, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8007eca:	d16f      	bne.n	8007fac <find_volume.constprop.0+0x1b0>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 8007ecc:	f8b4 0043 	ldrh.w	r0, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8007ed0:	b900      	cbnz	r0, 8007ed4 <find_volume.constprop.0+0xd8>
	rv = rv << 8 | ptr[0];
 8007ed2:	6d20      	ldr	r0, [r4, #80]	; 0x50
	rv = ptr[1];
 8007ed4:	f8b4 c03e 	ldrh.w	ip, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8007ed8:	f1bc 0f00 	cmp.w	ip, #0
 8007edc:	d066      	beq.n	8007fac <find_volume.constprop.0+0x1b0>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8007ede:	fb02 f303 	mul.w	r3, r2, r3
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8007ee2:	eb0c 171e 	add.w	r7, ip, lr, lsr #4
 8007ee6:	441f      	add	r7, r3
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8007ee8:	4287      	cmp	r7, r0
 8007eea:	d85f      	bhi.n	8007fac <find_volume.constprop.0+0x1b0>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8007eec:	eba0 0807 	sub.w	r8, r0, r7
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8007ef0:	4588      	cmp	r8, r1
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8007ef2:	fbb8 f0f1 	udiv	r0, r8, r1
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8007ef6:	d359      	bcc.n	8007fac <find_volume.constprop.0+0x1b0>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8007ef8:	f64f 71f5 	movw	r1, #65525	; 0xfff5
 8007efc:	4288      	cmp	r0, r1
 8007efe:	f200 8081 	bhi.w	8008004 <find_volume.constprop.0+0x208>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8007f02:	f640 71f5 	movw	r1, #4085	; 0xff5
		fs->database = bsect + sysect;					/* Data start sector */
 8007f06:	4437      	add	r7, r6
		fs->volbase = bsect;							/* Volume start sector */
 8007f08:	61e6      	str	r6, [r4, #28]
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8007f0a:	4288      	cmp	r0, r1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8007f0c:	f100 0002 	add.w	r0, r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8007f10:	eb0c 0106 	add.w	r1, ip, r6
		fs->database = bsect + sysect;					/* Data start sector */
 8007f14:	62a7      	str	r7, [r4, #40]	; 0x28
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8007f16:	6160      	str	r0, [r4, #20]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8007f18:	6221      	str	r1, [r4, #32]
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8007f1a:	f200 8085 	bhi.w	8008028 <find_volume.constprop.0+0x22c>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8007f1e:	f1be 0f00 	cmp.w	lr, #0
 8007f22:	d043      	beq.n	8007fac <find_volume.constprop.0+0x1b0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8007f24:	440b      	add	r3, r1
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8007f26:	2101      	movs	r1, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8007f28:	6263      	str	r3, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8007f2a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 8007f2e:	f000 0001 	and.w	r0, r0, #1
 8007f32:	eb00 0353 	add.w	r3, r0, r3, lsr #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8007f36:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 8007f3a:	ebb2 2f53 	cmp.w	r2, r3, lsr #9
 8007f3e:	d335      	bcc.n	8007fac <find_volume.constprop.0+0x1b0>
	fs->id = ++Fsid;		/* File system mount ID */
 8007f40:	4a3e      	ldr	r2, [pc, #248]	; (800803c <find_volume.constprop.0+0x240>)
	fs->fs_type = fmt;		/* FAT sub-type */
 8007f42:	7021      	strb	r1, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8007f44:	8813      	ldrh	r3, [r2, #0]
 8007f46:	3301      	adds	r3, #1
 8007f48:	b29b      	uxth	r3, r3
 8007f4a:	8013      	strh	r3, [r2, #0]
 8007f4c:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
 8007f4e:	e780      	b.n	8007e52 <find_volume.constprop.0+0x56>
		stat = disk_status(fs->drv);
 8007f50:	7860      	ldrb	r0, [r4, #1]
 8007f52:	f7ff fee1 	bl	8007d18 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8007f56:	f010 0501 	ands.w	r5, r0, #1
 8007f5a:	d181      	bne.n	8007e60 <find_volume.constprop.0+0x64>
 8007f5c:	e779      	b.n	8007e52 <find_volume.constprop.0+0x56>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8007f5e:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
 8007f62:	bb93      	cbnz	r3, 8007fca <find_volume.constprop.0+0x1ce>
 8007f64:	46a9      	mov	r9, r5
 8007f66:	f894 3202 	ldrb.w	r3, [r4, #514]	; 0x202
 8007f6a:	2b00      	cmp	r3, #0
 8007f6c:	d048      	beq.n	8008000 <find_volume.constprop.0+0x204>
	rv = rv << 8 | ptr[0];
 8007f6e:	f8d4 8206 	ldr.w	r8, [r4, #518]	; 0x206
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8007f72:	f894 7212 	ldrb.w	r7, [r4, #530]	; 0x212
 8007f76:	b10f      	cbz	r7, 8007f7c <find_volume.constprop.0+0x180>
	rv = rv << 8 | ptr[0];
 8007f78:	f8d4 7216 	ldr.w	r7, [r4, #534]	; 0x216
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8007f7c:	f894 6222 	ldrb.w	r6, [r4, #546]	; 0x222
 8007f80:	b10e      	cbz	r6, 8007f86 <find_volume.constprop.0+0x18a>
	rv = rv << 8 | ptr[0];
 8007f82:	f8d4 6226 	ldr.w	r6, [r4, #550]	; 0x226
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8007f86:	f1b9 0f00 	cmp.w	r9, #0
 8007f8a:	d121      	bne.n	8007fd0 <find_volume.constprop.0+0x1d4>
 8007f8c:	f1b8 0f00 	cmp.w	r8, #0
 8007f90:	d12e      	bne.n	8007ff0 <find_volume.constprop.0+0x1f4>
 8007f92:	bb2f      	cbnz	r7, 8007fe0 <find_volume.constprop.0+0x1e4>
 8007f94:	b156      	cbz	r6, 8007fac <find_volume.constprop.0+0x1b0>
 8007f96:	4631      	mov	r1, r6
 8007f98:	4620      	mov	r0, r4
 8007f9a:	f7ff fee7 	bl	8007d6c <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8007f9e:	2801      	cmp	r0, #1
 8007fa0:	f67f af73 	bls.w	8007e8a <find_volume.constprop.0+0x8e>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8007fa4:	2804      	cmp	r0, #4
 8007fa6:	d101      	bne.n	8007fac <find_volume.constprop.0+0x1b0>
 8007fa8:	2501      	movs	r5, #1
 8007faa:	e752      	b.n	8007e52 <find_volume.constprop.0+0x56>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8007fac:	250d      	movs	r5, #13
}
 8007fae:	4628      	mov	r0, r5
 8007fb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8007fb4:	250c      	movs	r5, #12
}
 8007fb6:	4628      	mov	r0, r5
 8007fb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8007fbc:	2503      	movs	r5, #3
}
 8007fbe:	4628      	mov	r0, r5
 8007fc0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					*path = ++tt;
 8007fc4:	3201      	adds	r2, #1
 8007fc6:	6002      	str	r2, [r0, #0]
	if (vol < 0) return FR_INVALID_DRIVE;
 8007fc8:	e739      	b.n	8007e3e <find_volume.constprop.0+0x42>
	rv = rv << 8 | ptr[0];
 8007fca:	f8d4 91f6 	ldr.w	r9, [r4, #502]	; 0x1f6
	return rv;
 8007fce:	e7ca      	b.n	8007f66 <find_volume.constprop.0+0x16a>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8007fd0:	4649      	mov	r1, r9
 8007fd2:	4620      	mov	r0, r4
 8007fd4:	f7ff feca 	bl	8007d6c <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8007fd8:	2801      	cmp	r0, #1
 8007fda:	d8d7      	bhi.n	8007f8c <find_volume.constprop.0+0x190>
 8007fdc:	464e      	mov	r6, r9
 8007fde:	e754      	b.n	8007e8a <find_volume.constprop.0+0x8e>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8007fe0:	4639      	mov	r1, r7
 8007fe2:	4620      	mov	r0, r4
 8007fe4:	f7ff fec2 	bl	8007d6c <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8007fe8:	2801      	cmp	r0, #1
 8007fea:	d8d3      	bhi.n	8007f94 <find_volume.constprop.0+0x198>
 8007fec:	463e      	mov	r6, r7
 8007fee:	e74c      	b.n	8007e8a <find_volume.constprop.0+0x8e>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8007ff0:	4641      	mov	r1, r8
 8007ff2:	4620      	mov	r0, r4
 8007ff4:	f7ff feba 	bl	8007d6c <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8007ff8:	2801      	cmp	r0, #1
 8007ffa:	d8ca      	bhi.n	8007f92 <find_volume.constprop.0+0x196>
 8007ffc:	4646      	mov	r6, r8
 8007ffe:	e744      	b.n	8007e8a <find_volume.constprop.0+0x8e>
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8008000:	4698      	mov	r8, r3
 8008002:	e7b6      	b.n	8007f72 <find_volume.constprop.0+0x176>
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8008004:	eb0c 0106 	add.w	r1, ip, r6
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8008008:	1c83      	adds	r3, r0, #2
		fs->database = bsect + sysect;					/* Data start sector */
 800800a:	4437      	add	r7, r6
		fs->volbase = bsect;							/* Volume start sector */
 800800c:	61e6      	str	r6, [r4, #28]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 800800e:	6221      	str	r1, [r4, #32]
	rv = rv << 8 | ptr[0];
 8008010:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
		fs->database = bsect + sysect;					/* Data start sector */
 8008014:	62a7      	str	r7, [r4, #40]	; 0x28
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 8008016:	ea51 010e 	orrs.w	r1, r1, lr
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 800801a:	6163      	str	r3, [r4, #20]
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 800801c:	d1c6      	bne.n	8007fac <find_volume.constprop.0+0x1b0>
	rv = rv << 8 | ptr[0];
 800801e:	6de1      	ldr	r1, [r4, #92]	; 0x5c
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8008020:	009b      	lsls	r3, r3, #2
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8008022:	6261      	str	r1, [r4, #36]	; 0x24
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8008024:	2103      	movs	r1, #3
 8008026:	e786      	b.n	8007f36 <find_volume.constprop.0+0x13a>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8008028:	f1be 0f00 	cmp.w	lr, #0
 800802c:	d0be      	beq.n	8007fac <find_volume.constprop.0+0x1b0>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800802e:	4419      	add	r1, r3
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8008030:	0043      	lsls	r3, r0, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8008032:	6261      	str	r1, [r4, #36]	; 0x24
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 8008034:	2102      	movs	r1, #2
 8008036:	e77e      	b.n	8007f36 <find_volume.constprop.0+0x13a>
 8008038:	200194f4 	.word	0x200194f4
 800803c:	200194f8 	.word	0x200194f8

08008040 <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8008040:	2901      	cmp	r1, #1
 8008042:	d92f      	bls.n	80080a4 <get_fat.isra.0+0x64>
 8008044:	6943      	ldr	r3, [r0, #20]
 8008046:	4299      	cmp	r1, r3
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8008048:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800804c:	460c      	mov	r4, r1
 800804e:	4605      	mov	r5, r0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8008050:	d302      	bcc.n	8008058 <get_fat.isra.0+0x18>
		switch (fs->fs_type) {
 8008052:	2001      	movs	r0, #1
}
 8008054:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		switch (fs->fs_type) {
 8008058:	7803      	ldrb	r3, [r0, #0]
 800805a:	2b02      	cmp	r3, #2
 800805c:	d033      	beq.n	80080c6 <get_fat.isra.0+0x86>
 800805e:	2b03      	cmp	r3, #3
 8008060:	d022      	beq.n	80080a8 <get_fat.isra.0+0x68>
 8008062:	2b01      	cmp	r3, #1
 8008064:	d1f5      	bne.n	8008052 <get_fat.isra.0+0x12>
			bc = (UINT)clst; bc += bc / 2;
 8008066:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800806a:	6a01      	ldr	r1, [r0, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 800806c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800806e:	eb01 2756 	add.w	r7, r1, r6, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008072:	4287      	cmp	r7, r0
 8008074:	d146      	bne.n	8008104 <get_fat.isra.0+0xc4>
			wc = fs->win[bc++ % SS(fs)];
 8008076:	1c77      	adds	r7, r6, #1
 8008078:	f3c6 0608 	ubfx	r6, r6, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800807c:	eb01 2857 	add.w	r8, r1, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 8008080:	442e      	add	r6, r5
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008082:	4580      	cmp	r8, r0
			wc = fs->win[bc++ % SS(fs)];
 8008084:	f896 6030 	ldrb.w	r6, [r6, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008088:	d147      	bne.n	800811a <get_fat.isra.0+0xda>
			wc |= fs->win[bc % SS(fs)] << 8;
 800808a:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800808e:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8008090:	443d      	add	r5, r7
 8008092:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
 8008096:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 800809a:	bf4c      	ite	mi
 800809c:	0900      	lsrmi	r0, r0, #4
 800809e:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 80080a2:	e7d7      	b.n	8008054 <get_fat.isra.0+0x14>
		val = 1;	/* Internal error */
 80080a4:	2001      	movs	r0, #1
}
 80080a6:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80080a8:	6a06      	ldr	r6, [r0, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80080aa:	f100 0730 	add.w	r7, r0, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 80080ae:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80080b0:	eb06 16d1 	add.w	r6, r6, r1, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 80080b4:	429e      	cmp	r6, r3
 80080b6:	d11c      	bne.n	80080f2 <get_fat.isra.0+0xb2>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 80080b8:	00a4      	lsls	r4, r4, #2
 80080ba:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 80080be:	5938      	ldr	r0, [r7, r4]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 80080c0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
 80080c4:	e7c6      	b.n	8008054 <get_fat.isra.0+0x14>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80080c6:	6a06      	ldr	r6, [r0, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80080c8:	f100 0730 	add.w	r7, r0, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 80080cc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80080ce:	eb06 2611 	add.w	r6, r6, r1, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 80080d2:	429e      	cmp	r6, r3
 80080d4:	d104      	bne.n	80080e0 <get_fat.isra.0+0xa0>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80080d6:	0064      	lsls	r4, r4, #1
 80080d8:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 80080dc:	5b38      	ldrh	r0, [r7, r4]
			break;
 80080de:	e7b9      	b.n	8008054 <get_fat.isra.0+0x14>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80080e0:	2301      	movs	r3, #1
 80080e2:	4632      	mov	r2, r6
 80080e4:	7840      	ldrb	r0, [r0, #1]
 80080e6:	4639      	mov	r1, r7
 80080e8:	f7ff fe32 	bl	8007d50 <disk_read>
 80080ec:	bb00      	cbnz	r0, 8008130 <get_fat.isra.0+0xf0>
			fs->winsect = sector;
 80080ee:	62ee      	str	r6, [r5, #44]	; 0x2c
	return res;
 80080f0:	e7f1      	b.n	80080d6 <get_fat.isra.0+0x96>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 80080f2:	2301      	movs	r3, #1
 80080f4:	4632      	mov	r2, r6
 80080f6:	7840      	ldrb	r0, [r0, #1]
 80080f8:	4639      	mov	r1, r7
 80080fa:	f7ff fe29 	bl	8007d50 <disk_read>
 80080fe:	b9b8      	cbnz	r0, 8008130 <get_fat.isra.0+0xf0>
			fs->winsect = sector;
 8008100:	62ee      	str	r6, [r5, #44]	; 0x2c
	return res;
 8008102:	e7d9      	b.n	80080b8 <get_fat.isra.0+0x78>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008104:	463a      	mov	r2, r7
 8008106:	f105 0130 	add.w	r1, r5, #48	; 0x30
 800810a:	7868      	ldrb	r0, [r5, #1]
 800810c:	f7ff fe20 	bl	8007d50 <disk_read>
 8008110:	b970      	cbnz	r0, 8008130 <get_fat.isra.0+0xf0>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8008112:	6a29      	ldr	r1, [r5, #32]
 8008114:	4638      	mov	r0, r7
			fs->winsect = sector;
 8008116:	62ef      	str	r7, [r5, #44]	; 0x2c
	return res;
 8008118:	e7ad      	b.n	8008076 <get_fat.isra.0+0x36>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800811a:	2301      	movs	r3, #1
 800811c:	4642      	mov	r2, r8
 800811e:	f105 0130 	add.w	r1, r5, #48	; 0x30
 8008122:	7868      	ldrb	r0, [r5, #1]
 8008124:	f7ff fe14 	bl	8007d50 <disk_read>
 8008128:	b910      	cbnz	r0, 8008130 <get_fat.isra.0+0xf0>
			fs->winsect = sector;
 800812a:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
	return res;
 800812e:	e7ac      	b.n	800808a <get_fat.isra.0+0x4a>
			fs->winsect = sector;
 8008130:	f04f 33ff 	mov.w	r3, #4294967295
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8008134:	4618      	mov	r0, r3
			fs->winsect = sector;
 8008136:	62eb      	str	r3, [r5, #44]	; 0x2c
	return res;
 8008138:	e78c      	b.n	8008054 <get_fat.isra.0+0x14>
 800813a:	bf00      	nop

0800813c <dir_sdi.constprop.0>:
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 800813c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	dp->dptr = ofs;				/* Set current offset */
 8008140:	2300      	movs	r3, #0
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8008142:	6884      	ldr	r4, [r0, #8]
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 8008144:	4606      	mov	r6, r0
	FATFS *fs = dp->obj.fs;
 8008146:	f8d0 8000 	ldr.w	r8, [r0]
	dp->dptr = ofs;				/* Set current offset */
 800814a:	6103      	str	r3, [r0, #16]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800814c:	bb84      	cbnz	r4, 80081b0 <dir_sdi.constprop.0+0x74>
 800814e:	f898 3000 	ldrb.w	r3, [r8]
 8008152:	2b02      	cmp	r3, #2
 8008154:	d827      	bhi.n	80081a6 <dir_sdi.constprop.0+0x6a>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8008156:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 800815a:	b303      	cbz	r3, 800819e <dir_sdi.constprop.0+0x62>
		dp->sect = fs->dirbase;
 800815c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8008160:	61b3      	str	r3, [r6, #24]
	dp->clust = clst;					/* Current cluster# */
 8008162:	6174      	str	r4, [r6, #20]
	if (!dp->sect) return FR_INT_ERR;
 8008164:	b1db      	cbz	r3, 800819e <dir_sdi.constprop.0+0x62>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8008166:	f108 0330 	add.w	r3, r8, #48	; 0x30
	return FR_OK;
 800816a:	2500      	movs	r5, #0
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800816c:	61f3      	str	r3, [r6, #28]
}
 800816e:	4628      	mov	r0, r5
 8008170:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8008174:	6a3d      	ldr	r5, [r7, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008176:	f107 0930 	add.w	r9, r7, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800817a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 800817c:	eb05 15d4 	add.w	r5, r5, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008180:	429d      	cmp	r5, r3
 8008182:	d15e      	bne.n	8008242 <dir_sdi.constprop.0+0x106>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8008184:	00a4      	lsls	r4, r4, #2
 8008186:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 800818a:	f859 4004 	ldr.w	r4, [r9, r4]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 800818e:	f024 4470 	bic.w	r4, r4, #4026531840	; 0xf0000000
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8008192:	2c01      	cmp	r4, #1
 8008194:	d903      	bls.n	800819e <dir_sdi.constprop.0+0x62>
 8008196:	f8d8 3014 	ldr.w	r3, [r8, #20]
 800819a:	42a3      	cmp	r3, r4
 800819c:	d80c      	bhi.n	80081b8 <dir_sdi.constprop.0+0x7c>
		switch (fs->fs_type) {
 800819e:	2502      	movs	r5, #2
}
 80081a0:	4628      	mov	r0, r5
 80081a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		clst = fs->dirbase;
 80081a6:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 80081aa:	2b00      	cmp	r3, #0
 80081ac:	d0d3      	beq.n	8008156 <dir_sdi.constprop.0+0x1a>
 80081ae:	461c      	mov	r4, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80081b0:	f8b8 200a 	ldrh.w	r2, [r8, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
 80081b4:	2a00      	cmp	r2, #0
 80081b6:	d16e      	bne.n	8008296 <dir_sdi.constprop.0+0x15a>
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80081b8:	2c01      	cmp	r4, #1
 80081ba:	d9f0      	bls.n	800819e <dir_sdi.constprop.0+0x62>
 80081bc:	6837      	ldr	r7, [r6, #0]
 80081be:	697b      	ldr	r3, [r7, #20]
 80081c0:	429c      	cmp	r4, r3
 80081c2:	d2ec      	bcs.n	800819e <dir_sdi.constprop.0+0x62>
		switch (fs->fs_type) {
 80081c4:	783d      	ldrb	r5, [r7, #0]
 80081c6:	2d02      	cmp	r5, #2
 80081c8:	d024      	beq.n	8008214 <dir_sdi.constprop.0+0xd8>
 80081ca:	2d03      	cmp	r5, #3
 80081cc:	d0d2      	beq.n	8008174 <dir_sdi.constprop.0+0x38>
 80081ce:	2d01      	cmp	r5, #1
 80081d0:	d1e5      	bne.n	800819e <dir_sdi.constprop.0+0x62>
			bc = (UINT)clst; bc += bc / 2;
 80081d2:	eb04 0954 	add.w	r9, r4, r4, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80081d6:	6a39      	ldr	r1, [r7, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80081d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80081da:	eb01 2a59 	add.w	sl, r1, r9, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80081de:	459a      	cmp	sl, r3
 80081e0:	d138      	bne.n	8008254 <dir_sdi.constprop.0+0x118>
			wc = fs->win[bc++ % SS(fs)];
 80081e2:	f109 0a01 	add.w	sl, r9, #1
 80081e6:	f3c9 0908 	ubfx	r9, r9, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 80081ea:	eb01 2b5a 	add.w	fp, r1, sl, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 80081ee:	44b9      	add	r9, r7
	if (sector != fs->winsect) {	/* Window offset changed? */
 80081f0:	459b      	cmp	fp, r3
			wc = fs->win[bc++ % SS(fs)];
 80081f2:	f899 9030 	ldrb.w	r9, [r9, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 80081f6:	d13a      	bne.n	800826e <dir_sdi.constprop.0+0x132>
			wc |= fs->win[bc % SS(fs)] << 8;
 80081f8:	f3ca 0a08 	ubfx	sl, sl, #0, #9
 80081fc:	4457      	add	r7, sl
 80081fe:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8008202:	ea49 2903 	orr.w	r9, r9, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8008206:	07e3      	lsls	r3, r4, #31
 8008208:	bf4c      	ite	mi
 800820a:	ea4f 1419 	movmi.w	r4, r9, lsr #4
 800820e:	f3c9 040b 	ubfxpl	r4, r9, #0, #12
 8008212:	e7be      	b.n	8008192 <dir_sdi.constprop.0+0x56>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8008214:	6a3d      	ldr	r5, [r7, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008216:	f107 0930 	add.w	r9, r7, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 800821a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 800821c:	eb05 2514 	add.w	r5, r5, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008220:	429d      	cmp	r5, r3
 8008222:	d105      	bne.n	8008230 <dir_sdi.constprop.0+0xf4>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8008224:	0064      	lsls	r4, r4, #1
 8008226:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 800822a:	f839 4004 	ldrh.w	r4, [r9, r4]
			break;
 800822e:	e7b0      	b.n	8008192 <dir_sdi.constprop.0+0x56>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008230:	2301      	movs	r3, #1
 8008232:	462a      	mov	r2, r5
 8008234:	7878      	ldrb	r0, [r7, #1]
 8008236:	4649      	mov	r1, r9
 8008238:	f7ff fd8a 	bl	8007d50 <disk_read>
 800823c:	bb10      	cbnz	r0, 8008284 <dir_sdi.constprop.0+0x148>
			fs->winsect = sector;
 800823e:	62fd      	str	r5, [r7, #44]	; 0x2c
	return res;
 8008240:	e7f0      	b.n	8008224 <dir_sdi.constprop.0+0xe8>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008242:	2301      	movs	r3, #1
 8008244:	462a      	mov	r2, r5
 8008246:	7878      	ldrb	r0, [r7, #1]
 8008248:	4649      	mov	r1, r9
 800824a:	f7ff fd81 	bl	8007d50 <disk_read>
 800824e:	b9c8      	cbnz	r0, 8008284 <dir_sdi.constprop.0+0x148>
			fs->winsect = sector;
 8008250:	62fd      	str	r5, [r7, #44]	; 0x2c
	return res;
 8008252:	e797      	b.n	8008184 <dir_sdi.constprop.0+0x48>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008254:	462b      	mov	r3, r5
 8008256:	4652      	mov	r2, sl
 8008258:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800825c:	7878      	ldrb	r0, [r7, #1]
 800825e:	f7ff fd77 	bl	8007d50 <disk_read>
 8008262:	b9a0      	cbnz	r0, 800828e <dir_sdi.constprop.0+0x152>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8008264:	4653      	mov	r3, sl
 8008266:	6a39      	ldr	r1, [r7, #32]
			fs->winsect = sector;
 8008268:	f8c7 a02c 	str.w	sl, [r7, #44]	; 0x2c
	return res;
 800826c:	e7b9      	b.n	80081e2 <dir_sdi.constprop.0+0xa6>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800826e:	2301      	movs	r3, #1
 8008270:	465a      	mov	r2, fp
 8008272:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8008276:	7878      	ldrb	r0, [r7, #1]
 8008278:	f7ff fd6a 	bl	8007d50 <disk_read>
 800827c:	b938      	cbnz	r0, 800828e <dir_sdi.constprop.0+0x152>
			fs->winsect = sector;
 800827e:	f8c7 b02c 	str.w	fp, [r7, #44]	; 0x2c
	return res;
 8008282:	e7b9      	b.n	80081f8 <dir_sdi.constprop.0+0xbc>
			fs->winsect = sector;
 8008284:	f04f 33ff 	mov.w	r3, #4294967295
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8008288:	2501      	movs	r5, #1
			fs->winsect = sector;
 800828a:	62fb      	str	r3, [r7, #44]	; 0x2c
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800828c:	e76f      	b.n	800816e <dir_sdi.constprop.0+0x32>
			fs->winsect = sector;
 800828e:	f04f 33ff 	mov.w	r3, #4294967295
 8008292:	62fb      	str	r3, [r7, #44]	; 0x2c
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8008294:	e76b      	b.n	800816e <dir_sdi.constprop.0+0x32>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008296:	f8d8 1014 	ldr.w	r1, [r8, #20]
	clst -= 2;
 800829a:	1ea0      	subs	r0, r4, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800829c:	3902      	subs	r1, #2
 800829e:	4288      	cmp	r0, r1
 80082a0:	d205      	bcs.n	80082ae <dir_sdi.constprop.0+0x172>
	return clst * fs->csize + fs->database;
 80082a2:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
 80082a6:	fb00 3302 	mla	r3, r0, r2, r3
		dp->sect = clust2sect(fs, clst);
 80082aa:	61b3      	str	r3, [r6, #24]
 80082ac:	e759      	b.n	8008162 <dir_sdi.constprop.0+0x26>
 80082ae:	2300      	movs	r3, #0
 80082b0:	e9c6 4305 	strd	r4, r3, [r6, #20]
	if (!dp->sect) return FR_INT_ERR;
 80082b4:	e773      	b.n	800819e <dir_sdi.constprop.0+0x62>
 80082b6:	bf00      	nop

080082b8 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80082b8:	b570      	push	{r4, r5, r6, lr}
 80082ba:	b082      	sub	sp, #8
 80082bc:	e9cd 1000 	strd	r1, r0, [sp]
	if (*path) {	/* If the pointer is not a null */
 80082c0:	b189      	cbz	r1, 80082e6 <f_mount+0x2e>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 80082c2:	4614      	mov	r4, r2
 80082c4:	780a      	ldrb	r2, [r1, #0]
 80082c6:	2a3a      	cmp	r2, #58	; 0x3a
 80082c8:	d011      	beq.n	80082ee <f_mount+0x36>
 80082ca:	2a1f      	cmp	r2, #31
 80082cc:	d90f      	bls.n	80082ee <f_mount+0x36>
 80082ce:	4608      	mov	r0, r1
 80082d0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80082d4:	2b1f      	cmp	r3, #31
 80082d6:	d90c      	bls.n	80082f2 <f_mount+0x3a>
 80082d8:	2b3a      	cmp	r3, #58	; 0x3a
 80082da:	d1f9      	bne.n	80082d0 <f_mount+0x18>
			i = *tp++ - '0';
 80082dc:	3101      	adds	r1, #1
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 80082de:	4288      	cmp	r0, r1
 80082e0:	d101      	bne.n	80082e6 <f_mount+0x2e>
 80082e2:	2a30      	cmp	r2, #48	; 0x30
 80082e4:	d007      	beq.n	80082f6 <f_mount+0x3e>
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
	if (vol < 0) return FR_INVALID_DRIVE;
 80082e6:	240b      	movs	r4, #11

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 80082e8:	4620      	mov	r0, r4
 80082ea:	b002      	add	sp, #8
 80082ec:	bd70      	pop	{r4, r5, r6, pc}
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 80082ee:	4613      	mov	r3, r2
 80082f0:	4608      	mov	r0, r1
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 80082f2:	2b3a      	cmp	r3, #58	; 0x3a
 80082f4:	d0f2      	beq.n	80082dc <f_mount+0x24>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80082f6:	4e19      	ldr	r6, [pc, #100]	; (800835c <f_mount+0xa4>)
 80082f8:	6835      	ldr	r5, [r6, #0]
	if (cfs) {
 80082fa:	b12d      	cbz	r5, 8008308 <f_mount+0x50>
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
 80082fc:	6928      	ldr	r0, [r5, #16]
 80082fe:	f000 ff85 	bl	800920c <ff_del_syncobj>
 8008302:	b328      	cbz	r0, 8008350 <f_mount+0x98>
		cfs->fs_type = 0;				/* Clear old fs object */
 8008304:	2300      	movs	r3, #0
 8008306:	702b      	strb	r3, [r5, #0]
	if (fs) {
 8008308:	9901      	ldr	r1, [sp, #4]
 800830a:	b1e1      	cbz	r1, 8008346 <f_mount+0x8e>
		fs->fs_type = 0;				/* Clear new fs object */
 800830c:	2000      	movs	r0, #0
 800830e:	f801 0b10 	strb.w	r0, [r1], #16
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
 8008312:	f000 ff6f 	bl	80091f4 <ff_cre_syncobj>
 8008316:	b1d8      	cbz	r0, 8008350 <f_mount+0x98>
	FatFs[vol] = fs;					/* Register new fs object */
 8008318:	9b01      	ldr	r3, [sp, #4]
 800831a:	6033      	str	r3, [r6, #0]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800831c:	b1e3      	cbz	r3, 8008358 <f_mount+0xa0>
 800831e:	2c01      	cmp	r4, #1
 8008320:	d11a      	bne.n	8008358 <f_mount+0xa0>
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 8008322:	a901      	add	r1, sp, #4
 8008324:	4668      	mov	r0, sp
 8008326:	f7ff fd69 	bl	8007dfc <find_volume.constprop.0>
	LEAVE_FF(fs, res);
 800832a:	9b01      	ldr	r3, [sp, #4]
	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 800832c:	4604      	mov	r4, r0
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 800832e:	b163      	cbz	r3, 800834a <f_mount+0x92>
 8008330:	f1a0 020b 	sub.w	r2, r0, #11
 8008334:	b2d2      	uxtb	r2, r2
 8008336:	2a01      	cmp	r2, #1
 8008338:	d907      	bls.n	800834a <f_mount+0x92>
 800833a:	280f      	cmp	r0, #15
 800833c:	d005      	beq.n	800834a <f_mount+0x92>
		ff_rel_grant(fs->sobj);
 800833e:	6918      	ldr	r0, [r3, #16]
 8008340:	f000 ff74 	bl	800922c <ff_rel_grant>
 8008344:	e001      	b.n	800834a <f_mount+0x92>
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8008346:	460c      	mov	r4, r1
	FatFs[vol] = fs;					/* Register new fs object */
 8008348:	6031      	str	r1, [r6, #0]
}
 800834a:	4620      	mov	r0, r4
 800834c:	b002      	add	sp, #8
 800834e:	bd70      	pop	{r4, r5, r6, pc}
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
 8008350:	2402      	movs	r4, #2
}
 8008352:	4620      	mov	r0, r4
 8008354:	b002      	add	sp, #8
 8008356:	bd70      	pop	{r4, r5, r6, pc}
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8008358:	2400      	movs	r4, #0
 800835a:	e7f6      	b.n	800834a <f_mount+0x92>
 800835c:	200194f4 	.word	0x200194f4

08008360 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8008360:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008364:	ed2d 8b02 	vpush	{d8}
 8008368:	f5ad 7d17 	sub.w	sp, sp, #604	; 0x25c
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800836c:	9000      	str	r0, [sp, #0]
{
 800836e:	9107      	str	r1, [sp, #28]
 8008370:	9205      	str	r2, [sp, #20]
	if (!fp) return FR_INVALID_OBJECT;
 8008372:	2800      	cmp	r0, #0
 8008374:	f000 82e1 	beq.w	800893a <f_open+0x5da>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
	res = find_volume(&path, &fs, mode);
 8008378:	a908      	add	r1, sp, #32
 800837a:	a807      	add	r0, sp, #28
 800837c:	f7ff fd3e 	bl	8007dfc <find_volume.constprop.0>
	if (res == FR_OK) {
 8008380:	4604      	mov	r4, r0
 8008382:	b188      	cbz	r0, 80083a8 <f_open+0x48>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8008384:	2200      	movs	r2, #0
 8008386:	9900      	ldr	r1, [sp, #0]

	LEAVE_FF(fs, res);
 8008388:	9b08      	ldr	r3, [sp, #32]
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800838a:	600a      	str	r2, [r1, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 800838c:	b12b      	cbz	r3, 800839a <f_open+0x3a>
 800838e:	f1a4 020b 	sub.w	r2, r4, #11
 8008392:	b2d2      	uxtb	r2, r2
 8008394:	2a01      	cmp	r2, #1
 8008396:	f200 8297 	bhi.w	80088c8 <f_open+0x568>
}
 800839a:	4620      	mov	r0, r4
 800839c:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
 80083a0:	ecbd 8b02 	vpop	{d8}
 80083a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dj.obj.fs = fs;
 80083a8:	9b08      	ldr	r3, [sp, #32]
		INIT_NAMBUF(fs);
 80083aa:	af16      	add	r7, sp, #88	; 0x58
		res = follow_path(&dj, path);	/* Follow the file path */
 80083ac:	f8dd b01c 	ldr.w	fp, [sp, #28]
		dj.obj.fs = fs;
 80083b0:	9301      	str	r3, [sp, #4]
 80083b2:	9309      	str	r3, [sp, #36]	; 0x24
		INIT_NAMBUF(fs);
 80083b4:	60df      	str	r7, [r3, #12]
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 80083b6:	f89b 3000 	ldrb.w	r3, [fp]
 80083ba:	2b2f      	cmp	r3, #47	; 0x2f
 80083bc:	d103      	bne.n	80083c6 <f_open+0x66>
 80083be:	f81b 3f01 	ldrb.w	r3, [fp, #1]!
 80083c2:	2b2f      	cmp	r3, #47	; 0x2f
 80083c4:	d0fb      	beq.n	80083be <f_open+0x5e>
 80083c6:	2b5c      	cmp	r3, #92	; 0x5c
 80083c8:	d0f9      	beq.n	80083be <f_open+0x5e>
		obj->sclust = 0;					/* Start from root directory */
 80083ca:	2300      	movs	r3, #0
 80083cc:	930b      	str	r3, [sp, #44]	; 0x2c
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 80083ce:	f89b 3000 	ldrb.w	r3, [fp]
 80083d2:	2b1f      	cmp	r3, #31
 80083d4:	f240 8282 	bls.w	80088dc <f_open+0x57c>
		if (w < ' ') break;				/* Break if end of the path name */
 80083d8:	2b1f      	cmp	r3, #31
		w = p[si++];					/* Get a character */
 80083da:	b298      	uxth	r0, r3
		if (w < ' ') break;				/* Break if end of the path name */
 80083dc:	d935      	bls.n	800844a <f_open+0xea>
 80083de:	1ebe      	subs	r6, r7, #2
 80083e0:	465d      	mov	r5, fp
		w = p[si++];					/* Get a character */
 80083e2:	2401      	movs	r4, #1
 80083e4:	e008      	b.n	80083f8 <f_open+0x98>
		lfn[di++] = w;					/* Store the Unicode character */
 80083e6:	f826 0f02 	strh.w	r0, [r6, #2]!
		w = p[si++];					/* Get a character */
 80083ea:	1c63      	adds	r3, r4, #1
 80083ec:	f815 0f01 	ldrb.w	r0, [r5, #1]!
		if (w < ' ') break;				/* Break if end of the path name */
 80083f0:	281f      	cmp	r0, #31
 80083f2:	f240 8238 	bls.w	8008866 <f_open+0x506>
		w = p[si++];					/* Get a character */
 80083f6:	461c      	mov	r4, r3
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 80083f8:	282f      	cmp	r0, #47	; 0x2f
 80083fa:	f104 38ff 	add.w	r8, r4, #4294967295
 80083fe:	d028      	beq.n	8008452 <f_open+0xf2>
 8008400:	285c      	cmp	r0, #92	; 0x5c
 8008402:	d026      	beq.n	8008452 <f_open+0xf2>
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8008404:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 8008408:	d00e      	beq.n	8008428 <f_open+0xc8>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 800840a:	2101      	movs	r1, #1
 800840c:	f000 fe8a 	bl	8009124 <ff_convert>
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8008410:	b150      	cbz	r0, 8008428 <f_open+0xc8>
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 8008412:	287f      	cmp	r0, #127	; 0x7f
 8008414:	d8e7      	bhi.n	80083e6 <f_open+0x86>
	while (*str && *str != chr) str++;
 8008416:	2322      	movs	r3, #34	; 0x22
 8008418:	4aaa      	ldr	r2, [pc, #680]	; (80086c4 <f_open+0x364>)
 800841a:	e003      	b.n	8008424 <f_open+0xc4>
 800841c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8008420:	2b00      	cmp	r3, #0
 8008422:	d0e0      	beq.n	80083e6 <f_open+0x86>
 8008424:	4298      	cmp	r0, r3
 8008426:	d1f9      	bne.n	800841c <f_open+0xbc>
			res = dir_find(dp);				/* Find an object with the segment name */
 8008428:	2406      	movs	r4, #6
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 800842a:	2200      	movs	r2, #0
 800842c:	9900      	ldr	r1, [sp, #0]
	LEAVE_FF(fs, res);
 800842e:	9b08      	ldr	r3, [sp, #32]
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8008430:	600a      	str	r2, [r1, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008432:	2b00      	cmp	r3, #0
 8008434:	d0b1      	beq.n	800839a <f_open+0x3a>
		ff_rel_grant(fs->sobj);
 8008436:	6918      	ldr	r0, [r3, #16]
 8008438:	f000 fef8 	bl	800922c <ff_rel_grant>
}
 800843c:	4620      	mov	r0, r4
 800843e:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
 8008442:	ecbd 8b02 	vpop	{d8}
 8008446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	lfn[di] = 0;						/* LFN is created */
 800844a:	2300      	movs	r3, #0
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 800844c:	2406      	movs	r4, #6
	lfn[di] = 0;						/* LFN is created */
 800844e:	803b      	strh	r3, [r7, #0]
			if (res != FR_OK) break;
 8008450:	e7eb      	b.n	800842a <f_open+0xca>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8008452:	f81b 3004 	ldrb.w	r3, [fp, r4]
 8008456:	eb0b 0204 	add.w	r2, fp, r4
 800845a:	2b5c      	cmp	r3, #92	; 0x5c
 800845c:	d002      	beq.n	8008464 <f_open+0x104>
 800845e:	2b2f      	cmp	r3, #47	; 0x2f
 8008460:	f040 82d0 	bne.w	8008a04 <f_open+0x6a4>
 8008464:	1c63      	adds	r3, r4, #1
 8008466:	445b      	add	r3, fp
 8008468:	469b      	mov	fp, r3
 800846a:	f813 2b01 	ldrb.w	r2, [r3], #1
 800846e:	2a2f      	cmp	r2, #47	; 0x2f
 8008470:	d0fa      	beq.n	8008468 <f_open+0x108>
 8008472:	2a5c      	cmp	r2, #92	; 0x5c
 8008474:	d0f8      	beq.n	8008468 <f_open+0x108>
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8008476:	f1b8 0f00 	cmp.w	r8, #0
 800847a:	d0e6      	beq.n	800844a <f_open+0xea>
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800847c:	2100      	movs	r1, #0
	while (di) {						/* Snip off trailing spaces and dots if exist */
 800847e:	2503      	movs	r5, #3
 8008480:	eb07 0248 	add.w	r2, r7, r8, lsl #1
 8008484:	e002      	b.n	800848c <f_open+0x12c>
 8008486:	f1b8 0801 	subs.w	r8, r8, #1
 800848a:	d0de      	beq.n	800844a <f_open+0xea>
		w = lfn[di - 1];
 800848c:	f832 3d02 	ldrh.w	r3, [r2, #-2]!
		if (w != ' ' && w != '.') break;
 8008490:	2b20      	cmp	r3, #32
 8008492:	d0f8      	beq.n	8008486 <f_open+0x126>
 8008494:	2b2e      	cmp	r3, #46	; 0x2e
 8008496:	d0f6      	beq.n	8008486 <f_open+0x126>
		*d++ = (BYTE)val;
 8008498:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
	lfn[di] = 0;						/* LFN is created */
 800849c:	2200      	movs	r2, #0
 800849e:	f827 2018 	strh.w	r2, [r7, r8, lsl #1]
		*d++ = (BYTE)val;
 80084a2:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
 80084a6:	f242 0320 	movw	r3, #8224	; 0x2020
 80084aa:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
 80084ae:	2320      	movs	r3, #32
 80084b0:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 80084b4:	8838      	ldrh	r0, [r7, #0]
 80084b6:	4298      	cmp	r0, r3
 80084b8:	d002      	beq.n	80084c0 <f_open+0x160>
 80084ba:	282e      	cmp	r0, #46	; 0x2e
 80084bc:	f040 8296 	bne.w	80089ec <f_open+0x68c>
 80084c0:	463a      	mov	r2, r7
 80084c2:	2300      	movs	r3, #0
 80084c4:	f832 0f02 	ldrh.w	r0, [r2, #2]!
 80084c8:	461c      	mov	r4, r3
 80084ca:	3301      	adds	r3, #1
 80084cc:	2820      	cmp	r0, #32
 80084ce:	d0f9      	beq.n	80084c4 <f_open+0x164>
 80084d0:	282e      	cmp	r0, #46	; 0x2e
 80084d2:	d0f7      	beq.n	80084c4 <f_open+0x164>
		w = lfn[si++];					/* Get an LFN character */
 80084d4:	3402      	adds	r4, #2
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 80084d6:	eb07 0348 	add.w	r3, r7, r8, lsl #1
 80084da:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 80084de:	2a2e      	cmp	r2, #46	; 0x2e
 80084e0:	d002      	beq.n	80084e8 <f_open+0x188>
 80084e2:	f1b8 0801 	subs.w	r8, r8, #1
 80084e6:	d1f8      	bne.n	80084da <f_open+0x17a>
		if (!w) break;					/* Break on end of the LFN */
 80084e8:	b360      	cbz	r0, 8008544 <f_open+0x1e4>
 80084ea:	f04f 0900 	mov.w	r9, #0
 80084ee:	f04f 0a08 	mov.w	sl, #8
 80084f2:	464e      	mov	r6, r9
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 80084f4:	2820      	cmp	r0, #32
 80084f6:	d005      	beq.n	8008504 <f_open+0x1a4>
 80084f8:	282e      	cmp	r0, #46	; 0x2e
 80084fa:	f040 80c1 	bne.w	8008680 <f_open+0x320>
 80084fe:	45a0      	cmp	r8, r4
 8008500:	f000 80be 	beq.w	8008680 <f_open+0x320>
			cf |= NS_LOSS | NS_LFN; continue;
 8008504:	f045 0503 	orr.w	r5, r5, #3
 8008508:	b2ed      	uxtb	r5, r5
		w = lfn[si++];					/* Get an LFN character */
 800850a:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
 800850e:	3401      	adds	r4, #1
		if (!w) break;					/* Break on end of the LFN */
 8008510:	2800      	cmp	r0, #0
 8008512:	d1ef      	bne.n	80084f4 <f_open+0x194>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8008514:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
 8008518:	2be5      	cmp	r3, #229	; 0xe5
 800851a:	d102      	bne.n	8008522 <f_open+0x1c2>
 800851c:	2305      	movs	r3, #5
 800851e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
	if (ni == 8) b <<= 2;
 8008522:	f1ba 0f08 	cmp.w	sl, #8
 8008526:	f000 81b1 	beq.w	800888c <f_open+0x52c>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 800852a:	f009 030c 	and.w	r3, r9, #12
 800852e:	2b0c      	cmp	r3, #12
 8008530:	d005      	beq.n	800853e <f_open+0x1de>
 8008532:	f009 0903 	and.w	r9, r9, #3
 8008536:	f1b9 0f03 	cmp.w	r9, #3
 800853a:	f040 81b1 	bne.w	80088a0 <f_open+0x540>
 800853e:	f045 0502 	orr.w	r5, r5, #2
 8008542:	b2ed      	uxtb	r5, r5
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8008544:	a809      	add	r0, sp, #36	; 0x24
	FATFS *fs = dp->obj.fs;
 8008546:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
	dp->fn[NSFLAG] = cf;	/* SFN is created */
 800854a:	f88d 504f 	strb.w	r5, [sp, #79]	; 0x4f
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800854e:	f7ff fdf5 	bl	800813c <dir_sdi.constprop.0>
	if (res != FR_OK) return res;
 8008552:	2800      	cmp	r0, #0
 8008554:	f040 827b 	bne.w	8008a4e <f_open+0x6ee>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8008558:	22ff      	movs	r2, #255	; 0xff
 800855a:	f04f 33ff 	mov.w	r3, #4294967295
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800855e:	f8cd b010 	str.w	fp, [sp, #16]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008562:	f108 0630 	add.w	r6, r8, #48	; 0x30
		res = move_window(fs, dp->sect);
 8008566:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8008568:	4615      	mov	r5, r2
			if (uc != 0xFFFF) return 0;		/* Check filler */
 800856a:	4693      	mov	fp, r2
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800856c:	9314      	str	r3, [sp, #80]	; 0x50
	if (sector != fs->winsect) {	/* Window offset changed? */
 800856e:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 8008572:	42bb      	cmp	r3, r7
 8008574:	d00f      	beq.n	8008596 <f_open+0x236>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008576:	2301      	movs	r3, #1
 8008578:	463a      	mov	r2, r7
 800857a:	4631      	mov	r1, r6
 800857c:	f898 0001 	ldrb.w	r0, [r8, #1]
 8008580:	f7ff fbe6 	bl	8007d50 <disk_read>
 8008584:	b128      	cbz	r0, 8008592 <f_open+0x232>
			fs->winsect = sector;
 8008586:	f04f 33ff 	mov.w	r3, #4294967295
				res = FR_DISK_ERR;
 800858a:	2401      	movs	r4, #1
			fs->winsect = sector;
 800858c:	f8c8 302c 	str.w	r3, [r8, #44]	; 0x2c
				if (res == FR_NO_FILE) {	/* Object is not found */
 8008590:	e74b      	b.n	800842a <f_open+0xca>
			fs->winsect = sector;
 8008592:	f8c8 702c 	str.w	r7, [r8, #44]	; 0x2c
		c = dp->dir[DIR_Name];
 8008596:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8008598:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800859a:	b33a      	cbz	r2, 80085ec <f_open+0x28c>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800859c:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800859e:	2ae5      	cmp	r2, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 80085a0:	f003 013f 	and.w	r1, r3, #63	; 0x3f
 80085a4:	f88d 102a 	strb.w	r1, [sp, #42]	; 0x2a
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80085a8:	d003      	beq.n	80085b2 <f_open+0x252>
 80085aa:	0718      	lsls	r0, r3, #28
 80085ac:	d525      	bpl.n	80085fa <f_open+0x29a>
 80085ae:	290f      	cmp	r1, #15
 80085b0:	d053      	beq.n	800865a <f_open+0x2fa>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80085b2:	f04f 33ff 	mov.w	r3, #4294967295
 80085b6:	25ff      	movs	r5, #255	; 0xff
 80085b8:	9314      	str	r3, [sp, #80]	; 0x50
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80085ba:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80085bc:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80085be:	3420      	adds	r4, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80085c0:	f5b4 1f00 	cmp.w	r4, #2097152	; 0x200000
 80085c4:	d212      	bcs.n	80085ec <f_open+0x28c>
 80085c6:	b18f      	cbz	r7, 80085ec <f_open+0x28c>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80085c8:	f3c4 0208 	ubfx	r2, r4, #0, #9
	FATFS *fs = dp->obj.fs;
 80085cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80085ce:	b942      	cbnz	r2, 80085e2 <f_open+0x282>
		dp->sect++;				/* Next sector */
 80085d0:	3701      	adds	r7, #1
		if (!dp->clust) {		/* Static table */
 80085d2:	990e      	ldr	r1, [sp, #56]	; 0x38
		dp->sect++;				/* Next sector */
 80085d4:	970f      	str	r7, [sp, #60]	; 0x3c
		if (!dp->clust) {		/* Static table */
 80085d6:	b9f1      	cbnz	r1, 8008616 <f_open+0x2b6>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 80085d8:	8918      	ldrh	r0, [r3, #8]
 80085da:	ebb0 1f54 	cmp.w	r0, r4, lsr #5
 80085de:	f240 813e 	bls.w	800885e <f_open+0x4fe>
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80085e2:	3330      	adds	r3, #48	; 0x30
	dp->dptr = ofs;						/* Current entry */
 80085e4:	940d      	str	r4, [sp, #52]	; 0x34
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80085e6:	4413      	add	r3, r2
 80085e8:	9310      	str	r3, [sp, #64]	; 0x40
	} while (res == FR_OK);
 80085ea:	e7c0      	b.n	800856e <f_open+0x20e>
			ns = dp->fn[NSFLAG];
 80085ec:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80085f0:	075d      	lsls	r5, r3, #29
 80085f2:	f100 8209 	bmi.w	8008a08 <f_open+0x6a8>
 80085f6:	2405      	movs	r4, #5
 80085f8:	e717      	b.n	800842a <f_open+0xca>
			if (a == AM_LFN) {			/* An LFN entry is found */
 80085fa:	290f      	cmp	r1, #15
 80085fc:	d02d      	beq.n	800865a <f_open+0x2fa>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 80085fe:	2d00      	cmp	r5, #0
 8008600:	d064      	beq.n	80086cc <f_open+0x36c>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8008602:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
 8008606:	07d1      	lsls	r1, r2, #31
 8008608:	f140 80b4 	bpl.w	8008774 <f_open+0x414>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 800860c:	f04f 33ff 	mov.w	r3, #4294967295
 8008610:	25ff      	movs	r5, #255	; 0xff
 8008612:	9314      	str	r3, [sp, #80]	; 0x50
 8008614:	e7d1      	b.n	80085ba <f_open+0x25a>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8008616:	8958      	ldrh	r0, [r3, #10]
 8008618:	3801      	subs	r0, #1
 800861a:	ea10 2a54 	ands.w	sl, r0, r4, lsr #9
 800861e:	d1e0      	bne.n	80085e2 <f_open+0x282>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8008620:	4618      	mov	r0, r3
 8008622:	9203      	str	r2, [sp, #12]
 8008624:	9302      	str	r3, [sp, #8]
 8008626:	f7ff fd0b 	bl	8008040 <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 800862a:	2801      	cmp	r0, #1
 800862c:	f240 8191 	bls.w	8008952 <f_open+0x5f2>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8008630:	1c47      	adds	r7, r0, #1
 8008632:	f000 818a 	beq.w	800894a <f_open+0x5ea>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 8008636:	9b02      	ldr	r3, [sp, #8]
 8008638:	9a03      	ldr	r2, [sp, #12]
 800863a:	6959      	ldr	r1, [r3, #20]
 800863c:	4288      	cmp	r0, r1
 800863e:	f080 818a 	bcs.w	8008956 <f_open+0x5f6>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008642:	3902      	subs	r1, #2
				dp->clust = clst;		/* Initialize data for new cluster */
 8008644:	900e      	str	r0, [sp, #56]	; 0x38
	clst -= 2;
 8008646:	3802      	subs	r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008648:	4288      	cmp	r0, r1
 800864a:	f080 8180 	bcs.w	800894e <f_open+0x5ee>
	return clst * fs->csize + fs->database;
 800864e:	8959      	ldrh	r1, [r3, #10]
 8008650:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 8008652:	fb00 7701 	mla	r7, r0, r1, r7
				dp->sect = clust2sect(fs, clst);
 8008656:	970f      	str	r7, [sp, #60]	; 0x3c
 8008658:	e7c3      	b.n	80085e2 <f_open+0x282>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800865a:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 800865e:	065b      	lsls	r3, r3, #25
 8008660:	d4ab      	bmi.n	80085ba <f_open+0x25a>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8008662:	0657      	lsls	r7, r2, #25
 8008664:	f140 80e3 	bpl.w	800882e <f_open+0x4ce>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8008668:	9b0d      	ldr	r3, [sp, #52]	; 0x34
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800866a:	f002 05bf 	and.w	r5, r2, #191	; 0xbf
						sum = dp->dir[LDIR_Chksum];
 800866e:	f894 b00d 	ldrb.w	fp, [r4, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8008672:	9314      	str	r3, [sp, #80]	; 0x50
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8008674:	7b63      	ldrb	r3, [r4, #13]
 8008676:	455b      	cmp	r3, fp
 8008678:	f000 817a 	beq.w	8008970 <f_open+0x610>
 800867c:	25ff      	movs	r5, #255	; 0xff
 800867e:	e79c      	b.n	80085ba <f_open+0x25a>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8008680:	45b2      	cmp	sl, r6
 8008682:	f240 80d8 	bls.w	8008836 <f_open+0x4d6>
 8008686:	eba8 0104 	sub.w	r1, r8, r4
 800868a:	fab1 f181 	clz	r1, r1
 800868e:	0949      	lsrs	r1, r1, #5
 8008690:	2900      	cmp	r1, #0
 8008692:	f040 80d0 	bne.w	8008836 <f_open+0x4d6>
		if (w >= 0x80) {				/* Non ASCII character */
 8008696:	287f      	cmp	r0, #127	; 0x7f
 8008698:	f200 80ea 	bhi.w	8008870 <f_open+0x510>
	while (*str && *str != chr) str++;
 800869c:	232b      	movs	r3, #43	; 0x2b
 800869e:	4a0a      	ldr	r2, [pc, #40]	; (80086c8 <f_open+0x368>)
 80086a0:	e004      	b.n	80086ac <f_open+0x34c>
 80086a2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80086a6:	2b00      	cmp	r3, #0
 80086a8:	f000 815a 	beq.w	8008960 <f_open+0x600>
 80086ac:	4283      	cmp	r3, r0
 80086ae:	d1f8      	bne.n	80086a2 <f_open+0x342>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 80086b0:	f045 0503 	orr.w	r5, r5, #3
 80086b4:	205f      	movs	r0, #95	; 0x5f
 80086b6:	b2ed      	uxtb	r5, r5
		dp->fn[i++] = (BYTE)w;
 80086b8:	ab09      	add	r3, sp, #36	; 0x24
 80086ba:	4433      	add	r3, r6
 80086bc:	3601      	adds	r6, #1
 80086be:	f883 0020 	strb.w	r0, [r3, #32]
 80086c2:	e722      	b.n	800850a <f_open+0x1aa>
 80086c4:	08016b1c 	.word	0x08016b1c
 80086c8:	08016b28 	.word	0x08016b28
		sum = (sum >> 1) + (sum << 7) + *dir++;
 80086cc:	7821      	ldrb	r1, [r4, #0]
 80086ce:	7865      	ldrb	r5, [r4, #1]
 80086d0:	01ca      	lsls	r2, r1, #7
 80086d2:	78a0      	ldrb	r0, [r4, #2]
 80086d4:	f894 a003 	ldrb.w	sl, [r4, #3]
 80086d8:	ea42 0251 	orr.w	r2, r2, r1, lsr #1
 80086dc:	f894 9004 	ldrb.w	r9, [r4, #4]
 80086e0:	f894 e005 	ldrb.w	lr, [r4, #5]
 80086e4:	442a      	add	r2, r5
 80086e6:	f894 c006 	ldrb.w	ip, [r4, #6]
 80086ea:	79e7      	ldrb	r7, [r4, #7]
 80086ec:	f3c2 0146 	ubfx	r1, r2, #1, #7
 80086f0:	7a25      	ldrb	r5, [r4, #8]
 80086f2:	ea41 11c2 	orr.w	r1, r1, r2, lsl #7
 80086f6:	fa50 f181 	uxtab	r1, r0, r1
 80086fa:	7a60      	ldrb	r0, [r4, #9]
 80086fc:	f3c1 0246 	ubfx	r2, r1, #1, #7
 8008700:	ea42 11c1 	orr.w	r1, r2, r1, lsl #7
 8008704:	fa5a f181 	uxtab	r1, sl, r1
 8008708:	f894 a00a 	ldrb.w	sl, [r4, #10]
 800870c:	f3c1 0246 	ubfx	r2, r1, #1, #7
 8008710:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
 8008714:	fa59 f982 	uxtab	r9, r9, r2
 8008718:	f3c9 0246 	ubfx	r2, r9, #1, #7
 800871c:	ea42 12c9 	orr.w	r2, r2, r9, lsl #7
 8008720:	fa5e fe82 	uxtab	lr, lr, r2
 8008724:	f3ce 0246 	ubfx	r2, lr, #1, #7
 8008728:	ea42 12ce 	orr.w	r2, r2, lr, lsl #7
 800872c:	fa5c fc82 	uxtab	ip, ip, r2
 8008730:	f3cc 0246 	ubfx	r2, ip, #1, #7
 8008734:	ea42 12cc 	orr.w	r2, r2, ip, lsl #7
 8008738:	fa57 f782 	uxtab	r7, r7, r2
 800873c:	f3c7 0246 	ubfx	r2, r7, #1, #7
 8008740:	ea42 12c7 	orr.w	r2, r2, r7, lsl #7
 8008744:	fa55 f582 	uxtab	r5, r5, r2
 8008748:	f3c5 0246 	ubfx	r2, r5, #1, #7
 800874c:	ea42 12c5 	orr.w	r2, r2, r5, lsl #7
 8008750:	fa50 f282 	uxtab	r2, r0, r2
 8008754:	f3c2 0046 	ubfx	r0, r2, #1, #7
 8008758:	ea40 10c2 	orr.w	r0, r0, r2, lsl #7
 800875c:	fa5a fa80 	uxtab	sl, sl, r0
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8008760:	fa5f fa8a 	uxtb.w	sl, sl
 8008764:	45da      	cmp	sl, fp
 8008766:	f47f af4c 	bne.w	8008602 <f_open+0x2a2>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800876a:	f8dd b010 	ldr.w	fp, [sp, #16]
 800876e:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
 8008772:	e043      	b.n	80087fc <f_open+0x49c>
	} while (--cnt && r == 0);
 8008774:	7820      	ldrb	r0, [r4, #0]
 8008776:	f89d 1044 	ldrb.w	r1, [sp, #68]	; 0x44
 800877a:	4288      	cmp	r0, r1
 800877c:	f47f af46 	bne.w	800860c <f_open+0x2ac>
 8008780:	f89d 0045 	ldrb.w	r0, [sp, #69]	; 0x45
 8008784:	7861      	ldrb	r1, [r4, #1]
 8008786:	4288      	cmp	r0, r1
 8008788:	f47f af40 	bne.w	800860c <f_open+0x2ac>
 800878c:	78a0      	ldrb	r0, [r4, #2]
 800878e:	f89d 1046 	ldrb.w	r1, [sp, #70]	; 0x46
 8008792:	4288      	cmp	r0, r1
 8008794:	f47f af3a 	bne.w	800860c <f_open+0x2ac>
 8008798:	78e0      	ldrb	r0, [r4, #3]
 800879a:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
 800879e:	4288      	cmp	r0, r1
 80087a0:	f47f af34 	bne.w	800860c <f_open+0x2ac>
 80087a4:	7920      	ldrb	r0, [r4, #4]
 80087a6:	f89d 1048 	ldrb.w	r1, [sp, #72]	; 0x48
 80087aa:	4288      	cmp	r0, r1
 80087ac:	f47f af2e 	bne.w	800860c <f_open+0x2ac>
 80087b0:	7960      	ldrb	r0, [r4, #5]
 80087b2:	f89d 1049 	ldrb.w	r1, [sp, #73]	; 0x49
 80087b6:	4288      	cmp	r0, r1
 80087b8:	f47f af28 	bne.w	800860c <f_open+0x2ac>
 80087bc:	79a0      	ldrb	r0, [r4, #6]
 80087be:	f89d 104a 	ldrb.w	r1, [sp, #74]	; 0x4a
 80087c2:	4288      	cmp	r0, r1
 80087c4:	f47f af22 	bne.w	800860c <f_open+0x2ac>
 80087c8:	79e0      	ldrb	r0, [r4, #7]
 80087ca:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
 80087ce:	4288      	cmp	r0, r1
 80087d0:	f47f af1c 	bne.w	800860c <f_open+0x2ac>
 80087d4:	7a20      	ldrb	r0, [r4, #8]
 80087d6:	f89d 104c 	ldrb.w	r1, [sp, #76]	; 0x4c
 80087da:	4288      	cmp	r0, r1
 80087dc:	f47f af16 	bne.w	800860c <f_open+0x2ac>
 80087e0:	7a60      	ldrb	r0, [r4, #9]
 80087e2:	f89d 104d 	ldrb.w	r1, [sp, #77]	; 0x4d
 80087e6:	4288      	cmp	r0, r1
 80087e8:	f47f af10 	bne.w	800860c <f_open+0x2ac>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 80087ec:	7aa0      	ldrb	r0, [r4, #10]
 80087ee:	f89d 104e 	ldrb.w	r1, [sp, #78]	; 0x4e
 80087f2:	4288      	cmp	r0, r1
 80087f4:	f47f af0a 	bne.w	800860c <f_open+0x2ac>
 80087f8:	f8dd b010 	ldr.w	fp, [sp, #16]
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 80087fc:	0751      	lsls	r1, r2, #29
 80087fe:	d479      	bmi.n	80088f4 <f_open+0x594>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8008800:	06dc      	lsls	r4, r3, #27
 8008802:	f57f aef8 	bpl.w	80085f6 <f_open+0x296>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8008806:	9901      	ldr	r1, [sp, #4]
 8008808:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800880a:	f101 0330 	add.w	r3, r1, #48	; 0x30
	if (fs->fs_type == FS_FAT32) {
 800880e:	7809      	ldrb	r1, [r1, #0]
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8008810:	f3c2 0208 	ubfx	r2, r2, #0, #9
	if (fs->fs_type == FS_FAT32) {
 8008814:	2903      	cmp	r1, #3
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8008816:	4413      	add	r3, r2
	cl = ld_word(dir + DIR_FstClusLO);
 8008818:	8b5a      	ldrh	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 800881a:	d102      	bne.n	8008822 <f_open+0x4c2>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 800881c:	8a9b      	ldrh	r3, [r3, #20]
 800881e:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8008822:	9b09      	ldr	r3, [sp, #36]	; 0x24
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8008824:	920b      	str	r2, [sp, #44]	; 0x2c
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8008826:	68df      	ldr	r7, [r3, #12]
		w = p[si++];					/* Get a character */
 8008828:	f89b 3000 	ldrb.w	r3, [fp]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800882c:	e5d4      	b.n	80083d8 <f_open+0x78>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800882e:	42aa      	cmp	r2, r5
 8008830:	f47f af24 	bne.w	800867c <f_open+0x31c>
 8008834:	e71e      	b.n	8008674 <f_open+0x314>
			if (ni == 11) {				/* Long extension */
 8008836:	f1ba 0f0b 	cmp.w	sl, #11
 800883a:	f000 80f6 	beq.w	8008a2a <f_open+0x6ca>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 800883e:	45a0      	cmp	r8, r4
 8008840:	d004      	beq.n	800884c <f_open+0x4ec>
 8008842:	f045 0503 	orr.w	r5, r5, #3
 8008846:	b2ed      	uxtb	r5, r5
			if (si > di) break;			/* No extension */
 8008848:	f4ff ae64 	bcc.w	8008514 <f_open+0x1b4>
			b <<= 2; continue;
 800884c:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8008850:	4644      	mov	r4, r8
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8008852:	f04f 0a0b 	mov.w	sl, #11
 8008856:	2608      	movs	r6, #8
			b <<= 2; continue;
 8008858:	fa5f f989 	uxtb.w	r9, r9
 800885c:	e655      	b.n	800850a <f_open+0x1aa>
			ns = dp->fn[NSFLAG];
 800885e:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
				dp->sect = 0; return FR_NO_FILE;
 8008862:	910f      	str	r1, [sp, #60]	; 0x3c
				if (res == FR_NO_FILE) {	/* Object is not found */
 8008864:	e6c4      	b.n	80085f0 <f_open+0x290>
	*path = &p[si];						/* Return pointer to the next segment */
 8008866:	449b      	add	fp, r3
 8008868:	46a0      	mov	r8, r4
 800886a:	2507      	movs	r5, #7
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800886c:	2104      	movs	r1, #4
 800886e:	e607      	b.n	8008480 <f_open+0x120>
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 8008870:	f000 fc58 	bl	8009124 <ff_convert>
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8008874:	b320      	cbz	r0, 80088c0 <f_open+0x560>
 8008876:	4b79      	ldr	r3, [pc, #484]	; (8008a5c <f_open+0x6fc>)
			cf |= NS_LFN;				/* Force create LFN entry */
 8008878:	f045 0502 	orr.w	r5, r5, #2
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 800887c:	4403      	add	r3, r0
			cf |= NS_LFN;				/* Force create LFN entry */
 800887e:	b2ed      	uxtb	r5, r5
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8008880:	f813 0c80 	ldrb.w	r0, [r3, #-128]
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8008884:	2800      	cmp	r0, #0
 8008886:	f43f af13 	beq.w	80086b0 <f_open+0x350>
 800888a:	e707      	b.n	800869c <f_open+0x33c>
	if (ni == 8) b <<= 2;
 800888c:	ea4f 0389 	mov.w	r3, r9, lsl #2
 8008890:	f003 030c 	and.w	r3, r3, #12
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8008894:	2b0c      	cmp	r3, #12
 8008896:	f43f ae52 	beq.w	800853e <f_open+0x1de>
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 800889a:	07ae      	lsls	r6, r5, #30
 800889c:	d509      	bpl.n	80088b2 <f_open+0x552>
 800889e:	e651      	b.n	8008544 <f_open+0x1e4>
 80088a0:	07ac      	lsls	r4, r5, #30
 80088a2:	f53f ae4f 	bmi.w	8008544 <f_open+0x1e4>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 80088a6:	f1b9 0f01 	cmp.w	r9, #1
 80088aa:	d102      	bne.n	80088b2 <f_open+0x552>
 80088ac:	f045 0510 	orr.w	r5, r5, #16
 80088b0:	b2ed      	uxtb	r5, r5
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 80088b2:	2b04      	cmp	r3, #4
 80088b4:	f47f ae46 	bne.w	8008544 <f_open+0x1e4>
 80088b8:	f045 0508 	orr.w	r5, r5, #8
 80088bc:	b2ed      	uxtb	r5, r5
 80088be:	e641      	b.n	8008544 <f_open+0x1e4>
			cf |= NS_LFN;				/* Force create LFN entry */
 80088c0:	f045 0502 	orr.w	r5, r5, #2
 80088c4:	b2ed      	uxtb	r5, r5
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 80088c6:	e6f3      	b.n	80086b0 <f_open+0x350>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 80088c8:	2c0f      	cmp	r4, #15
 80088ca:	f47f adb4 	bne.w	8008436 <f_open+0xd6>
}
 80088ce:	4620      	mov	r0, r4
 80088d0:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
 80088d4:	ecbd 8b02 	vpop	{d8}
 80088d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->fn[NSFLAG] = NS_NONAME;
 80088dc:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 80088de:	a809      	add	r0, sp, #36	; 0x24
		dp->fn[NSFLAG] = NS_NONAME;
 80088e0:	f88d 304f 	strb.w	r3, [sp, #79]	; 0x4f
		res = dir_sdi(dp, 0);
 80088e4:	f7ff fc2a 	bl	800813c <dir_sdi.constprop.0>
		if (res == FR_OK) {
 80088e8:	4604      	mov	r4, r0
 80088ea:	2800      	cmp	r0, #0
 80088ec:	f47f ad4a 	bne.w	8008384 <f_open+0x24>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80088f0:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
 80088f4:	0610      	lsls	r0, r2, #24
 80088f6:	f53f ad97 	bmi.w	8008428 <f_open+0xc8>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 80088fa:	f89d 402a 	ldrb.w	r4, [sp, #42]	; 0x2a
 80088fe:	f014 0410 	ands.w	r4, r4, #16
 8008902:	f040 8081 	bne.w	8008a08 <f_open+0x6a8>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8008906:	9b08      	ldr	r3, [sp, #32]
 8008908:	9a10      	ldr	r2, [sp, #64]	; 0x40
	if (fs->fs_type == FS_FAT32) {
 800890a:	7818      	ldrb	r0, [r3, #0]
	cl = ld_word(dir + DIR_FstClusLO);
 800890c:	8b51      	ldrh	r1, [r2, #26]
	if (fs->fs_type == FS_FAT32) {
 800890e:	2803      	cmp	r0, #3
 8008910:	d102      	bne.n	8008918 <f_open+0x5b8>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8008912:	8a90      	ldrh	r0, [r2, #20]
 8008914:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8008918:	9d00      	ldr	r5, [sp, #0]
 800891a:	60a9      	str	r1, [r5, #8]
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 800891c:	9905      	ldr	r1, [sp, #20]
	rv = rv << 8 | ptr[0];
 800891e:	69d2      	ldr	r2, [r2, #28]
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 8008920:	f001 0001 	and.w	r0, r1, #1
			fp->obj.id = fs->id;
 8008924:	88d9      	ldrh	r1, [r3, #6]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8008926:	60ea      	str	r2, [r5, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
 8008928:	2200      	movs	r2, #0
			fp->obj.fs = fs;	 	/* Validate the file object */
 800892a:	602b      	str	r3, [r5, #0]
			fp->cltbl = 0;			/* Disable fast seek mode */
 800892c:	622a      	str	r2, [r5, #32]
			fp->flag = mode;		/* Set file access mode */
 800892e:	7428      	strb	r0, [r5, #16]
			fp->obj.id = fs->id;
 8008930:	80a9      	strh	r1, [r5, #4]
			fp->err = 0;			/* Clear error flag */
 8008932:	746a      	strb	r2, [r5, #17]
			fp->sect = 0;			/* Invalidate current data sector */
 8008934:	61ea      	str	r2, [r5, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8008936:	616a      	str	r2, [r5, #20]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008938:	e57d      	b.n	8008436 <f_open+0xd6>
	if (!fp) return FR_INVALID_OBJECT;
 800893a:	2409      	movs	r4, #9
}
 800893c:	4620      	mov	r0, r4
 800893e:	f50d 7d17 	add.w	sp, sp, #604	; 0x25c
 8008942:	ecbd 8b02 	vpop	{d8}
 8008946:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 800894a:	2401      	movs	r4, #1
 800894c:	e56d      	b.n	800842a <f_open+0xca>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800894e:	4617      	mov	r7, r2
 8008950:	e681      	b.n	8008656 <f_open+0x2f6>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8008952:	2402      	movs	r4, #2
 8008954:	e569      	b.n	800842a <f_open+0xca>
			ns = dp->fn[NSFLAG];
 8008956:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
 800895a:	f8cd a03c 	str.w	sl, [sp, #60]	; 0x3c
				if (res == FR_NO_FILE) {	/* Object is not found */
 800895e:	e647      	b.n	80085f0 <f_open+0x290>
				if (IsUpper(w)) {		/* ASCII large capital */
 8008960:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 8008964:	2b19      	cmp	r3, #25
 8008966:	d844      	bhi.n	80089f2 <f_open+0x692>
					b |= 2;
 8008968:	f049 0902 	orr.w	r9, r9, #2
		dp->fn[i++] = (BYTE)w;
 800896c:	b2c0      	uxtb	r0, r0
 800896e:	e6a3      	b.n	80086b8 <f_open+0x358>
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 8008970:	8b63      	ldrh	r3, [r4, #26]
 8008972:	2b00      	cmp	r3, #0
 8008974:	f47f ae82 	bne.w	800867c <f_open+0x31c>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8008978:	7827      	ldrb	r7, [r4, #0]
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 800897a:	2201      	movs	r2, #1
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 800897c:	f8d8 100c 	ldr.w	r1, [r8, #12]
 8008980:	ee08 6a10 	vmov	s16, r6
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 8008984:	f007 073f 	and.w	r7, r7, #63	; 0x3f
 8008988:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8008a60 <f_open+0x700>
 800898c:	f8cd 8008 	str.w	r8, [sp, #8]
 8008990:	46a0      	mov	r8, r4
 8008992:	3f01      	subs	r7, #1
 8008994:	f8cd b00c 	str.w	fp, [sp, #12]
 8008998:	f109 0a0d 	add.w	sl, r9, #13
 800899c:	46ab      	mov	fp, r5
 800899e:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 80089a2:	460d      	mov	r5, r1
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80089a4:	9106      	str	r1, [sp, #24]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80089a6:	eb07 0783 	add.w	r7, r7, r3, lsl #2
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80089aa:	e00f      	b.n	80089cc <f_open+0x66c>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 80089ac:	2ffe      	cmp	r7, #254	; 0xfe
 80089ae:	4620      	mov	r0, r4
 80089b0:	d816      	bhi.n	80089e0 <f_open+0x680>
 80089b2:	f000 fbd5 	bl	8009160 <ff_wtoupper>
 80089b6:	4606      	mov	r6, r0
 80089b8:	f835 0017 	ldrh.w	r0, [r5, r7, lsl #1]
 80089bc:	3701      	adds	r7, #1
 80089be:	f000 fbcf 	bl	8009160 <ff_wtoupper>
 80089c2:	4286      	cmp	r6, r0
 80089c4:	4622      	mov	r2, r4
 80089c6:	d10b      	bne.n	80089e0 <f_open+0x680>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80089c8:	45ca      	cmp	sl, r9
 80089ca:	d01f      	beq.n	8008a0c <f_open+0x6ac>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 80089cc:	f819 3b01 	ldrb.w	r3, [r9], #1
	rv = ptr[1];
 80089d0:	f838 4003 	ldrh.w	r4, [r8, r3]
		if (wc) {
 80089d4:	2a00      	cmp	r2, #0
 80089d6:	d1e9      	bne.n	80089ac <f_open+0x64c>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80089d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80089dc:	429c      	cmp	r4, r3
 80089de:	d0f3      	beq.n	80089c8 <f_open+0x668>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80089e0:	e9dd 8b02 	ldrd	r8, fp, [sp, #8]
 80089e4:	ee18 6a10 	vmov	r6, s16
 80089e8:	25ff      	movs	r5, #255	; 0xff
 80089ea:	e5e6      	b.n	80085ba <f_open+0x25a>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 80089ec:	460d      	mov	r5, r1
 80089ee:	2401      	movs	r4, #1
 80089f0:	e571      	b.n	80084d6 <f_open+0x176>
					if (IsLower(w)) {	/* ASCII small capital */
 80089f2:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 80089f6:	2b19      	cmp	r3, #25
						b |= 1; w -= 0x20;
 80089f8:	bf9c      	itt	ls
 80089fa:	3820      	subls	r0, #32
 80089fc:	f049 0901 	orrls.w	r9, r9, #1
		dp->fn[i++] = (BYTE)w;
 8008a00:	b2c0      	uxtb	r0, r0
 8008a02:	e659      	b.n	80086b8 <f_open+0x358>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8008a04:	4693      	mov	fp, r2
 8008a06:	e536      	b.n	8008476 <f_open+0x116>
			res = dir_find(dp);				/* Find an object with the segment name */
 8008a08:	2404      	movs	r4, #4
 8008a0a:	e50e      	b.n	800842a <f_open+0xca>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8008a0c:	4644      	mov	r4, r8
 8008a0e:	465d      	mov	r5, fp
 8008a10:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8008a14:	ee18 6a10 	vmov	r6, s16
 8008a18:	7823      	ldrb	r3, [r4, #0]
 8008a1a:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8008a1e:	0658      	lsls	r0, r3, #25
 8008a20:	d500      	bpl.n	8008a24 <f_open+0x6c4>
 8008a22:	b972      	cbnz	r2, 8008a42 <f_open+0x6e2>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8008a24:	3d01      	subs	r5, #1
 8008a26:	b2ed      	uxtb	r5, r5
 8008a28:	e5c7      	b.n	80085ba <f_open+0x25a>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8008a2a:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
				cf |= NS_LOSS | NS_LFN; break;
 8008a2e:	f045 0503 	orr.w	r5, r5, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8008a32:	2be5      	cmp	r3, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN; break;
 8008a34:	b2ed      	uxtb	r5, r5
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8008a36:	f47f ad78 	bne.w	800852a <f_open+0x1ca>
 8008a3a:	2305      	movs	r3, #5
 8008a3c:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
	if (ni == 8) b <<= 2;
 8008a40:	e573      	b.n	800852a <f_open+0x1ca>
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8008a42:	9b06      	ldr	r3, [sp, #24]
 8008a44:	f833 3017 	ldrh.w	r3, [r3, r7, lsl #1]
 8008a48:	2b00      	cmp	r3, #0
 8008a4a:	d0eb      	beq.n	8008a24 <f_open+0x6c4>
 8008a4c:	e616      	b.n	800867c <f_open+0x31c>
				if (res == FR_NO_FILE) {	/* Object is not found */
 8008a4e:	2804      	cmp	r0, #4
			ns = dp->fn[NSFLAG];
 8008a50:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
				if (res == FR_NO_FILE) {	/* Object is not found */
 8008a54:	f43f adcc 	beq.w	80085f0 <f_open+0x290>
 8008a58:	4604      	mov	r4, r0
 8008a5a:	e493      	b.n	8008384 <f_open+0x24>
 8008a5c:	08016b30 	.word	0x08016b30
 8008a60:	08016bb0 	.word	0x08016bb0

08008a64 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 8008a64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008a68:	4698      	mov	r8, r3
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 8008a6a:	2300      	movs	r3, #0
{
 8008a6c:	b083      	sub	sp, #12
	*br = 0;	/* Clear read byte counter */
 8008a6e:	f8c8 3000 	str.w	r3, [r8]
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8008a72:	b150      	cbz	r0, 8008a8a <f_read+0x26>
 8008a74:	6803      	ldr	r3, [r0, #0]
 8008a76:	4604      	mov	r4, r0
 8008a78:	b13b      	cbz	r3, 8008a8a <f_read+0x26>
 8008a7a:	4617      	mov	r7, r2
 8008a7c:	781a      	ldrb	r2, [r3, #0]
 8008a7e:	b122      	cbz	r2, 8008a8a <f_read+0x26>
 8008a80:	460e      	mov	r6, r1
 8008a82:	88da      	ldrh	r2, [r3, #6]
 8008a84:	8881      	ldrh	r1, [r0, #4]
 8008a86:	4291      	cmp	r1, r2
 8008a88:	d005      	beq.n	8008a96 <f_read+0x32>
	FRESULT res = FR_INVALID_OBJECT;
 8008a8a:	f04f 0a09 	mov.w	sl, #9
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 8008a8e:	4650      	mov	r0, sl
 8008a90:	b003      	add	sp, #12
 8008a92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return (fs && ff_req_grant(fs->sobj)) ? 1 : 0;
 8008a96:	6918      	ldr	r0, [r3, #16]
 8008a98:	f000 fbbe 	bl	8009218 <ff_req_grant>
 8008a9c:	2800      	cmp	r0, #0
 8008a9e:	f000 810d 	beq.w	8008cbc <f_read+0x258>
			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8008aa2:	6823      	ldr	r3, [r4, #0]
 8008aa4:	7858      	ldrb	r0, [r3, #1]
 8008aa6:	f7ff f937 	bl	8007d18 <disk_status>
 8008aaa:	07c0      	lsls	r0, r0, #31
 8008aac:	f100 8114 	bmi.w	8008cd8 <f_read+0x274>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8008ab0:	f894 a011 	ldrb.w	sl, [r4, #17]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8008ab4:	f8d4 9000 	ldr.w	r9, [r4]
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8008ab8:	f1ba 0f00 	cmp.w	sl, #0
 8008abc:	f040 80bb 	bne.w	8008c36 <f_read+0x1d2>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8008ac0:	7c23      	ldrb	r3, [r4, #16]
 8008ac2:	f013 0301 	ands.w	r3, r3, #1
 8008ac6:	9301      	str	r3, [sp, #4]
 8008ac8:	f000 80ec 	beq.w	8008ca4 <f_read+0x240>
	remain = fp->obj.objsize - fp->fptr;
 8008acc:	6961      	ldr	r1, [r4, #20]
 8008ace:	68e3      	ldr	r3, [r4, #12]
 8008ad0:	1a5b      	subs	r3, r3, r1
 8008ad2:	429f      	cmp	r7, r3
 8008ad4:	bf28      	it	cs
 8008ad6:	461f      	movcs	r7, r3
	for ( ;  btr;								/* Repeat until all data read */
 8008ad8:	2f00      	cmp	r7, #0
 8008ada:	d063      	beq.n	8008ba4 <f_read+0x140>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008adc:	f109 0b30 	add.w	fp, r9, #48	; 0x30
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8008ae0:	f3c1 0308 	ubfx	r3, r1, #0, #9
 8008ae4:	2b00      	cmp	r3, #0
 8008ae6:	d061      	beq.n	8008bac <f_read+0x148>
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 8008ae8:	69e2      	ldr	r2, [r4, #28]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8008aea:	f5c3 7500 	rsb	r5, r3, #512	; 0x200
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008aee:	f8d9 102c 	ldr.w	r1, [r9, #44]	; 0x2c
 8008af2:	42bd      	cmp	r5, r7
 8008af4:	bf28      	it	cs
 8008af6:	463d      	movcs	r5, r7
 8008af8:	4291      	cmp	r1, r2
 8008afa:	d01d      	beq.n	8008b38 <f_read+0xd4>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008afc:	2301      	movs	r3, #1
 8008afe:	4659      	mov	r1, fp
 8008b00:	f899 0001 	ldrb.w	r0, [r9, #1]
 8008b04:	9200      	str	r2, [sp, #0]
 8008b06:	f7ff f923 	bl	8007d50 <disk_read>
 8008b0a:	9a00      	ldr	r2, [sp, #0]
 8008b0c:	b178      	cbz	r0, 8008b2e <f_read+0xca>
			fs->winsect = sector;
 8008b0e:	f04f 32ff 	mov.w	r2, #4294967295
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 8008b12:	2301      	movs	r3, #1
 8008b14:	f8dd a004 	ldr.w	sl, [sp, #4]
			fs->winsect = sector;
 8008b18:	f8c9 202c 	str.w	r2, [r9, #44]	; 0x2c
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
 8008b1c:	7463      	strb	r3, [r4, #17]
		ff_rel_grant(fs->sobj);
 8008b1e:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8008b22:	f000 fb83 	bl	800922c <ff_rel_grant>
}
 8008b26:	4650      	mov	r0, sl
 8008b28:	b003      	add	sp, #12
 8008b2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8008b2e:	6963      	ldr	r3, [r4, #20]
			fs->winsect = sector;
 8008b30:	f8c9 202c 	str.w	r2, [r9, #44]	; 0x2c
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8008b34:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008b38:	1c5a      	adds	r2, r3, #1
 8008b3a:	f105 3eff 	add.w	lr, r5, #4294967295
 8008b3e:	445b      	add	r3, fp
	if (cnt) {
 8008b40:	445a      	add	r2, fp
 8008b42:	1ab2      	subs	r2, r6, r2
 8008b44:	2a02      	cmp	r2, #2
 8008b46:	f240 8090 	bls.w	8008c6a <f_read+0x206>
 8008b4a:	f1be 0f07 	cmp.w	lr, #7
 8008b4e:	f240 808c 	bls.w	8008c6a <f_read+0x206>
 8008b52:	f025 0c03 	bic.w	ip, r5, #3
 8008b56:	4632      	mov	r2, r6
 8008b58:	4619      	mov	r1, r3
 8008b5a:	44b4      	add	ip, r6
			*d++ = *s++;
 8008b5c:	f851 0b04 	ldr.w	r0, [r1], #4
 8008b60:	f842 0b04 	str.w	r0, [r2], #4
		} while (--cnt);
 8008b64:	4594      	cmp	ip, r2
 8008b66:	d1f9      	bne.n	8008b5c <f_read+0xf8>
 8008b68:	f025 0203 	bic.w	r2, r5, #3
 8008b6c:	4295      	cmp	r5, r2
 8008b6e:	eb06 0102 	add.w	r1, r6, r2
 8008b72:	eb03 0002 	add.w	r0, r3, r2
 8008b76:	d00a      	beq.n	8008b8e <f_read+0x12a>
			*d++ = *s++;
 8008b78:	5c9b      	ldrb	r3, [r3, r2]
 8008b7a:	54b3      	strb	r3, [r6, r2]
		} while (--cnt);
 8008b7c:	ebbe 0202 	subs.w	r2, lr, r2
 8008b80:	d005      	beq.n	8008b8e <f_read+0x12a>
			*d++ = *s++;
 8008b82:	7843      	ldrb	r3, [r0, #1]
		} while (--cnt);
 8008b84:	2a01      	cmp	r2, #1
			*d++ = *s++;
 8008b86:	704b      	strb	r3, [r1, #1]
		} while (--cnt);
 8008b88:	d001      	beq.n	8008b8e <f_read+0x12a>
			*d++ = *s++;
 8008b8a:	7883      	ldrb	r3, [r0, #2]
 8008b8c:	708b      	strb	r3, [r1, #2]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8008b8e:	6961      	ldr	r1, [r4, #20]
	for ( ;  btr;								/* Repeat until all data read */
 8008b90:	1b7f      	subs	r7, r7, r5
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8008b92:	f8d8 3000 	ldr.w	r3, [r8]
 8008b96:	442e      	add	r6, r5
 8008b98:	4429      	add	r1, r5
 8008b9a:	442b      	add	r3, r5
 8008b9c:	6161      	str	r1, [r4, #20]
 8008b9e:	f8c8 3000 	str.w	r3, [r8]
	for ( ;  btr;								/* Repeat until all data read */
 8008ba2:	d19d      	bne.n	8008ae0 <f_read+0x7c>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008ba4:	f1b9 0f00 	cmp.w	r9, #0
 8008ba8:	d152      	bne.n	8008c50 <f_read+0x1ec>
 8008baa:	e770      	b.n	8008a8e <f_read+0x2a>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8008bac:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 8008bb0:	0a4a      	lsrs	r2, r1, #9
 8008bb2:	3b01      	subs	r3, #1
			if (csect == 0) {					/* On the cluster boundary? */
 8008bb4:	ea13 2351 	ands.w	r3, r3, r1, lsr #9
 8008bb8:	d02b      	beq.n	8008c12 <f_read+0x1ae>
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 8008bba:	69a2      	ldr	r2, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008bbc:	f8d9 1014 	ldr.w	r1, [r9, #20]
	clst -= 2;
 8008bc0:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008bc2:	3902      	subs	r1, #2
 8008bc4:	428a      	cmp	r2, r1
 8008bc6:	d231      	bcs.n	8008c2c <f_read+0x1c8>
	return clst * fs->csize + fs->database;
 8008bc8:	f8b9 100a 	ldrh.w	r1, [r9, #10]
 8008bcc:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
 8008bd0:	fb01 0202 	mla	r2, r1, r2, r0
			if (!sect) ABORT(fs, FR_INT_ERR);
 8008bd4:	b352      	cbz	r2, 8008c2c <f_read+0x1c8>
			if (cc) {							/* Read maximum contiguous sectors directly */
 8008bd6:	f5b7 7f00 	cmp.w	r7, #512	; 0x200
			sect += csect;
 8008bda:	441a      	add	r2, r3
			if (cc) {							/* Read maximum contiguous sectors directly */
 8008bdc:	d340      	bcc.n	8008c60 <f_read+0x1fc>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8008bde:	eb03 2057 	add.w	r0, r3, r7, lsr #9
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8008be2:	0a7d      	lsrs	r5, r7, #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8008be4:	4288      	cmp	r0, r1
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8008be6:	f899 0001 	ldrb.w	r0, [r9, #1]
					cc = fs->csize - csect;
 8008bea:	bf88      	it	hi
 8008bec:	1acd      	subhi	r5, r1, r3
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8008bee:	4631      	mov	r1, r6
 8008bf0:	462b      	mov	r3, r5
 8008bf2:	f7ff f8ad 	bl	8007d50 <disk_read>
 8008bf6:	2800      	cmp	r0, #0
 8008bf8:	d05e      	beq.n	8008cb8 <f_read+0x254>
 8008bfa:	2301      	movs	r3, #1
 8008bfc:	f8dd a004 	ldr.w	sl, [sp, #4]
 8008c00:	7463      	strb	r3, [r4, #17]
		ff_rel_grant(fs->sobj);
 8008c02:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8008c06:	f000 fb11 	bl	800922c <ff_rel_grant>
}
 8008c0a:	4650      	mov	r0, sl
 8008c0c:	b003      	add	sp, #12
 8008c0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (fp->fptr == 0) {			/* On the top of the file? */
 8008c12:	bb99      	cbnz	r1, 8008c7c <f_read+0x218>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8008c14:	68a2      	ldr	r2, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8008c16:	2a01      	cmp	r2, #1
 8008c18:	d908      	bls.n	8008c2c <f_read+0x1c8>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8008c1a:	1c51      	adds	r1, r2, #1
 8008c1c:	d0ed      	beq.n	8008bfa <f_read+0x196>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008c1e:	f8d9 1014 	ldr.w	r1, [r9, #20]
				fp->clust = clst;				/* Update current cluster */
 8008c22:	61a2      	str	r2, [r4, #24]
	clst -= 2;
 8008c24:	3a02      	subs	r2, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008c26:	3902      	subs	r1, #2
 8008c28:	428a      	cmp	r2, r1
 8008c2a:	d3cd      	bcc.n	8008bc8 <f_read+0x164>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8008c2c:	f04f 0a02 	mov.w	sl, #2
 8008c30:	f884 a011 	strb.w	sl, [r4, #17]
 8008c34:	e00c      	b.n	8008c50 <f_read+0x1ec>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008c36:	f1b9 0f00 	cmp.w	r9, #0
 8008c3a:	f43f af28 	beq.w	8008a8e <f_read+0x2a>
 8008c3e:	f1aa 030b 	sub.w	r3, sl, #11
 8008c42:	2b01      	cmp	r3, #1
 8008c44:	f67f af23 	bls.w	8008a8e <f_read+0x2a>
 8008c48:	f1ba 0f0f 	cmp.w	sl, #15
 8008c4c:	f43f af1f 	beq.w	8008a8e <f_read+0x2a>
		ff_rel_grant(fs->sobj);
 8008c50:	f8d9 0010 	ldr.w	r0, [r9, #16]
 8008c54:	f000 faea 	bl	800922c <ff_rel_grant>
}
 8008c58:	4650      	mov	r0, sl
 8008c5a:	b003      	add	sp, #12
 8008c5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8008c60:	6963      	ldr	r3, [r4, #20]
			fp->sect = sect;
 8008c62:	61e2      	str	r2, [r4, #28]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8008c64:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008c68:	e73f      	b.n	8008aea <f_read+0x86>
 8008c6a:	1e72      	subs	r2, r6, #1
 8008c6c:	1958      	adds	r0, r3, r5
			*d++ = *s++;
 8008c6e:	f813 1b01 	ldrb.w	r1, [r3], #1
		} while (--cnt);
 8008c72:	4298      	cmp	r0, r3
			*d++ = *s++;
 8008c74:	f802 1f01 	strb.w	r1, [r2, #1]!
		} while (--cnt);
 8008c78:	d1f9      	bne.n	8008c6e <f_read+0x20a>
 8008c7a:	e788      	b.n	8008b8e <f_read+0x12a>
					if (fp->cltbl) {
 8008c7c:	6a20      	ldr	r0, [r4, #32]
 8008c7e:	b300      	cbz	r0, 8008cc2 <f_read+0x25e>
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8008c80:	6821      	ldr	r1, [r4, #0]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8008c82:	3004      	adds	r0, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8008c84:	8949      	ldrh	r1, [r1, #10]
 8008c86:	fbb2 f2f1 	udiv	r2, r2, r1
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8008c8a:	6801      	ldr	r1, [r0, #0]
		if (ncl == 0) return 0;	/* End of table? (error) */
 8008c8c:	b929      	cbnz	r1, 8008c9a <f_read+0x236>
 8008c8e:	e7cd      	b.n	8008c2c <f_read+0x1c8>
		cl -= ncl; tbl++;		/* Next fragment */
 8008c90:	1a52      	subs	r2, r2, r1
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8008c92:	f850 1f08 	ldr.w	r1, [r0, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8008c96:	2900      	cmp	r1, #0
 8008c98:	d0c8      	beq.n	8008c2c <f_read+0x1c8>
		if (cl < ncl) break;	/* In this fragment? */
 8008c9a:	428a      	cmp	r2, r1
 8008c9c:	d2f8      	bcs.n	8008c90 <f_read+0x22c>
	return cl + *tbl;	/* Return the cluster number */
 8008c9e:	6840      	ldr	r0, [r0, #4]
 8008ca0:	4402      	add	r2, r0
 8008ca2:	e7b8      	b.n	8008c16 <f_read+0x1b2>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008ca4:	f1b9 0f00 	cmp.w	r9, #0
 8008ca8:	d013      	beq.n	8008cd2 <f_read+0x26e>
		ff_rel_grant(fs->sobj);
 8008caa:	f8d9 0010 	ldr.w	r0, [r9, #16]
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8008cae:	f04f 0a07 	mov.w	sl, #7
		ff_rel_grant(fs->sobj);
 8008cb2:	f000 fabb 	bl	800922c <ff_rel_grant>
}
 8008cb6:	e6ea      	b.n	8008a8e <f_read+0x2a>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8008cb8:	026d      	lsls	r5, r5, #9
				continue;
 8008cba:	e768      	b.n	8008b8e <f_read+0x12a>
			res = FR_TIMEOUT;
 8008cbc:	f04f 0a0f 	mov.w	sl, #15
 8008cc0:	e6e5      	b.n	8008a8e <f_read+0x2a>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8008cc2:	69a1      	ldr	r1, [r4, #24]
 8008cc4:	6820      	ldr	r0, [r4, #0]
 8008cc6:	9300      	str	r3, [sp, #0]
 8008cc8:	f7ff f9ba 	bl	8008040 <get_fat.isra.0>
 8008ccc:	9b00      	ldr	r3, [sp, #0]
 8008cce:	4602      	mov	r2, r0
 8008cd0:	e7a1      	b.n	8008c16 <f_read+0x1b2>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8008cd2:	f04f 0a07 	mov.w	sl, #7
 8008cd6:	e6da      	b.n	8008a8e <f_read+0x2a>
				unlock_fs(obj->fs, FR_OK);
 8008cd8:	6823      	ldr	r3, [r4, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008cda:	2b00      	cmp	r3, #0
 8008cdc:	f43f aed5 	beq.w	8008a8a <f_read+0x26>
		ff_rel_grant(fs->sobj);
 8008ce0:	6918      	ldr	r0, [r3, #16]
	FRESULT res = FR_INVALID_OBJECT;
 8008ce2:	f04f 0a09 	mov.w	sl, #9
		ff_rel_grant(fs->sobj);
 8008ce6:	f000 faa1 	bl	800922c <ff_rel_grant>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8008cea:	e6d0      	b.n	8008a8e <f_read+0x2a>

08008cec <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8008cec:	b538      	push	{r3, r4, r5, lr}
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8008cee:	b140      	cbz	r0, 8008d02 <f_close+0x16>
 8008cf0:	6803      	ldr	r3, [r0, #0]
 8008cf2:	4604      	mov	r4, r0
 8008cf4:	b12b      	cbz	r3, 8008d02 <f_close+0x16>
 8008cf6:	781a      	ldrb	r2, [r3, #0]
 8008cf8:	b11a      	cbz	r2, 8008d02 <f_close+0x16>
 8008cfa:	8881      	ldrh	r1, [r0, #4]
 8008cfc:	88da      	ldrh	r2, [r3, #6]
 8008cfe:	4291      	cmp	r1, r2
 8008d00:	d002      	beq.n	8008d08 <f_close+0x1c>
			res = FR_TIMEOUT;
 8008d02:	2509      	movs	r5, #9
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8008d04:	4628      	mov	r0, r5
 8008d06:	bd38      	pop	{r3, r4, r5, pc}
	return (fs && ff_req_grant(fs->sobj)) ? 1 : 0;
 8008d08:	6918      	ldr	r0, [r3, #16]
 8008d0a:	f000 fa85 	bl	8009218 <ff_req_grant>
 8008d0e:	b178      	cbz	r0, 8008d30 <f_close+0x44>
			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8008d10:	6823      	ldr	r3, [r4, #0]
 8008d12:	7858      	ldrb	r0, [r3, #1]
 8008d14:	f7ff f800 	bl	8007d18 <disk_status>
 8008d18:	f010 0501 	ands.w	r5, r0, #1
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8008d1c:	6823      	ldr	r3, [r4, #0]
			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8008d1e:	d109      	bne.n	8008d34 <f_close+0x48>
				fp->obj.fs = 0;			/* Invalidate file object */
 8008d20:	6025      	str	r5, [r4, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008d22:	2b00      	cmp	r3, #0
 8008d24:	d0ee      	beq.n	8008d04 <f_close+0x18>
		ff_rel_grant(fs->sobj);
 8008d26:	6918      	ldr	r0, [r3, #16]
 8008d28:	f000 fa80 	bl	800922c <ff_rel_grant>
}
 8008d2c:	4628      	mov	r0, r5
 8008d2e:	bd38      	pop	{r3, r4, r5, pc}
			res = FR_TIMEOUT;
 8008d30:	250f      	movs	r5, #15
 8008d32:	e7e7      	b.n	8008d04 <f_close+0x18>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008d34:	2b00      	cmp	r3, #0
 8008d36:	d0e4      	beq.n	8008d02 <f_close+0x16>
		ff_rel_grant(fs->sobj);
 8008d38:	6918      	ldr	r0, [r3, #16]
	FRESULT res = FR_INVALID_OBJECT;
 8008d3a:	2509      	movs	r5, #9
		ff_rel_grant(fs->sobj);
 8008d3c:	f000 fa76 	bl	800922c <ff_rel_grant>
		if (res == FR_OK) {
 8008d40:	e7e0      	b.n	8008d04 <f_close+0x18>
 8008d42:	bf00      	nop

08008d44 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8008d44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008d48:	b087      	sub	sp, #28
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8008d4a:	b148      	cbz	r0, 8008d60 <f_lseek+0x1c>
 8008d4c:	6803      	ldr	r3, [r0, #0]
 8008d4e:	4604      	mov	r4, r0
 8008d50:	b133      	cbz	r3, 8008d60 <f_lseek+0x1c>
 8008d52:	781a      	ldrb	r2, [r3, #0]
 8008d54:	b122      	cbz	r2, 8008d60 <f_lseek+0x1c>
 8008d56:	460d      	mov	r5, r1
 8008d58:	88da      	ldrh	r2, [r3, #6]
 8008d5a:	8881      	ldrh	r1, [r0, #4]
 8008d5c:	4291      	cmp	r1, r2
 8008d5e:	d004      	beq.n	8008d6a <f_lseek+0x26>
	FRESULT res = FR_INVALID_OBJECT;
 8008d60:	2609      	movs	r6, #9
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 8008d62:	4630      	mov	r0, r6
 8008d64:	b007      	add	sp, #28
 8008d66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return (fs && ff_req_grant(fs->sobj)) ? 1 : 0;
 8008d6a:	6918      	ldr	r0, [r3, #16]
 8008d6c:	f000 fa54 	bl	8009218 <ff_req_grant>
 8008d70:	2800      	cmp	r0, #0
 8008d72:	f000 812c 	beq.w	8008fce <f_lseek+0x28a>
			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8008d76:	6823      	ldr	r3, [r4, #0]
 8008d78:	7858      	ldrb	r0, [r3, #1]
 8008d7a:	f7fe ffcd 	bl	8007d18 <disk_status>
 8008d7e:	07c0      	lsls	r0, r0, #31
 8008d80:	f100 814f 	bmi.w	8009022 <f_lseek+0x2de>
	if (res == FR_OK) res = (FRESULT)fp->err;
 8008d84:	7c66      	ldrb	r6, [r4, #17]
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8008d86:	f8d4 a000 	ldr.w	sl, [r4]
	if (res != FR_OK) LEAVE_FF(fs, res);
 8008d8a:	2e00      	cmp	r6, #0
 8008d8c:	f040 809f 	bne.w	8008ece <f_lseek+0x18a>
	if (fp->cltbl) {	/* Fast seek */
 8008d90:	6a22      	ldr	r2, [r4, #32]
 8008d92:	2a00      	cmp	r2, #0
 8008d94:	d04e      	beq.n	8008e34 <f_lseek+0xf0>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8008d96:	1c69      	adds	r1, r5, #1
 8008d98:	f000 80a6 	beq.w	8008ee8 <f_lseek+0x1a4>
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 8008d9c:	68e1      	ldr	r1, [r4, #12]
 8008d9e:	428d      	cmp	r5, r1
 8008da0:	bf28      	it	cs
 8008da2:	460d      	movcs	r5, r1
			fp->fptr = ofs;				/* Set file pointer */
 8008da4:	6165      	str	r5, [r4, #20]
			if (ofs) {
 8008da6:	2d00      	cmp	r5, #0
 8008da8:	d03d      	beq.n	8008e26 <f_lseek+0xe2>
				fp->clust = clmt_clust(fp, ofs - 1);
 8008daa:	1e6b      	subs	r3, r5, #1
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8008dac:	f8ba 000a 	ldrh.w	r0, [sl, #10]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8008db0:	3204      	adds	r2, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8008db2:	0a5f      	lsrs	r7, r3, #9
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8008db4:	6813      	ldr	r3, [r2, #0]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8008db6:	fbb7 f1f0 	udiv	r1, r7, r0
		if (ncl == 0) return 0;	/* End of table? (error) */
 8008dba:	b933      	cbnz	r3, 8008dca <f_lseek+0x86>
 8008dbc:	e104      	b.n	8008fc8 <f_lseek+0x284>
		cl -= ncl; tbl++;		/* Next fragment */
 8008dbe:	1ac9      	subs	r1, r1, r3
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8008dc0:	f852 3f08 	ldr.w	r3, [r2, #8]!
		if (ncl == 0) return 0;	/* End of table? (error) */
 8008dc4:	2b00      	cmp	r3, #0
 8008dc6:	f000 80ff 	beq.w	8008fc8 <f_lseek+0x284>
		if (cl < ncl) break;	/* In this fragment? */
 8008dca:	428b      	cmp	r3, r1
 8008dcc:	d9f7      	bls.n	8008dbe <f_lseek+0x7a>
	return cl + *tbl;	/* Return the cluster number */
 8008dce:	6853      	ldr	r3, [r2, #4]
 8008dd0:	440b      	add	r3, r1
	clst -= 2;
 8008dd2:	1e99      	subs	r1, r3, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008dd4:	f8da 2014 	ldr.w	r2, [sl, #20]
				fp->clust = clmt_clust(fp, ofs - 1);
 8008dd8:	61a3      	str	r3, [r4, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8008dda:	3a02      	subs	r2, #2
 8008ddc:	4291      	cmp	r1, r2
 8008dde:	f080 80d2 	bcs.w	8008f86 <f_lseek+0x242>
	return clst * fs->csize + fs->database;
 8008de2:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 8008de6:	fb00 3101 	mla	r1, r0, r1, r3
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8008dea:	2900      	cmp	r1, #0
 8008dec:	f000 80cb 	beq.w	8008f86 <f_lseek+0x242>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8008df0:	f3c5 0508 	ubfx	r5, r5, #0, #9
 8008df4:	b135      	cbz	r5, 8008e04 <f_lseek+0xc0>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8008df6:	1e43      	subs	r3, r0, #1
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8008df8:	69e2      	ldr	r2, [r4, #28]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8008dfa:	403b      	ands	r3, r7
 8008dfc:	440b      	add	r3, r1
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8008dfe:	429a      	cmp	r2, r3
 8008e00:	d000      	beq.n	8008e04 <f_lseek+0xc0>
					fp->sect = dsc;
 8008e02:	61e3      	str	r3, [r4, #28]
		ff_rel_grant(fs->sobj);
 8008e04:	f8da 0010 	ldr.w	r0, [sl, #16]
 8008e08:	f000 fa10 	bl	800922c <ff_rel_grant>
}
 8008e0c:	4630      	mov	r0, r6
 8008e0e:	b007      	add	sp, #28
 8008e10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*fp->cltbl = ulen;	/* Number of items used */
 8008e14:	2302      	movs	r3, #2
 8008e16:	6013      	str	r3, [r2, #0]
			if (ulen <= tlen) {
 8008e18:	9b01      	ldr	r3, [sp, #4]
 8008e1a:	2b01      	cmp	r3, #1
 8008e1c:	f240 80d9 	bls.w	8008fd2 <f_lseek+0x28e>
				*tbl = 0;		/* Terminate table */
 8008e20:	2300      	movs	r3, #0
 8008e22:	9a02      	ldr	r2, [sp, #8]
 8008e24:	6013      	str	r3, [r2, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008e26:	f1ba 0f00 	cmp.w	sl, #0
 8008e2a:	d1eb      	bne.n	8008e04 <f_lseek+0xc0>
}
 8008e2c:	4630      	mov	r0, r6
 8008e2e:	b007      	add	sp, #28
 8008e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8008e34:	68e1      	ldr	r1, [r4, #12]
		ifptr = fp->fptr;
 8008e36:	6963      	ldr	r3, [r4, #20]
 8008e38:	428d      	cmp	r5, r1
		fp->fptr = nsect = 0;
 8008e3a:	6166      	str	r6, [r4, #20]
 8008e3c:	bf28      	it	cs
 8008e3e:	460d      	movcs	r5, r1
		if (ofs) {
 8008e40:	2d00      	cmp	r5, #0
 8008e42:	d0f0      	beq.n	8008e26 <f_lseek+0xe2>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8008e44:	f8ba 700a 	ldrh.w	r7, [sl, #10]
 8008e48:	027f      	lsls	r7, r7, #9
			if (ifptr > 0 &&
 8008e4a:	b1cb      	cbz	r3, 8008e80 <f_lseek+0x13c>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8008e4c:	3b01      	subs	r3, #1
 8008e4e:	1e6a      	subs	r2, r5, #1
 8008e50:	fbb3 f1f7 	udiv	r1, r3, r7
 8008e54:	fbb2 f2f7 	udiv	r2, r2, r7
			if (ifptr > 0 &&
 8008e58:	428a      	cmp	r2, r1
 8008e5a:	d311      	bcc.n	8008e80 <f_lseek+0x13c>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8008e5c:	427a      	negs	r2, r7
 8008e5e:	4013      	ands	r3, r2
				clst = fp->clust;
 8008e60:	69a2      	ldr	r2, [r4, #24]
				ofs -= fp->fptr;
 8008e62:	eba5 0803 	sub.w	r8, r5, r3
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8008e66:	6163      	str	r3, [r4, #20]
			if (clst != 0) {
 8008e68:	2a00      	cmp	r2, #0
 8008e6a:	f040 8134 	bne.w	80090d6 <f_lseek+0x392>
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8008e6e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8008e72:	2b00      	cmp	r3, #0
 8008e74:	d0c6      	beq.n	8008e04 <f_lseek+0xc0>
 8008e76:	69e3      	ldr	r3, [r4, #28]
 8008e78:	4293      	cmp	r3, r2
 8008e7a:	d0c3      	beq.n	8008e04 <f_lseek+0xc0>
			fp->sect = nsect;
 8008e7c:	61e2      	str	r2, [r4, #28]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008e7e:	e7c1      	b.n	8008e04 <f_lseek+0xc0>
				clst = fp->obj.sclust;					/* start from the first cluster */
 8008e80:	68a1      	ldr	r1, [r4, #8]
				fp->clust = clst;
 8008e82:	61a1      	str	r1, [r4, #24]
			if (clst != 0) {
 8008e84:	2900      	cmp	r1, #0
 8008e86:	d0bd      	beq.n	8008e04 <f_lseek+0xc0>
 8008e88:	46a8      	mov	r8, r5
 8008e8a:	2300      	movs	r3, #0
				while (ofs > bcs) {						/* Cluster following loop */
 8008e8c:	4547      	cmp	r7, r8
 8008e8e:	f080 80dc 	bcs.w	800904a <f_lseek+0x306>
 8008e92:	4650      	mov	r0, sl
 8008e94:	e00b      	b.n	8008eae <f_lseek+0x16a>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8008e96:	2801      	cmp	r0, #1
 8008e98:	d975      	bls.n	8008f86 <f_lseek+0x242>
 8008e9a:	f8da 3014 	ldr.w	r3, [sl, #20]
 8008e9e:	4283      	cmp	r3, r0
 8008ea0:	d971      	bls.n	8008f86 <f_lseek+0x242>
				while (ofs > bcs) {						/* Cluster following loop */
 8008ea2:	4547      	cmp	r7, r8
					ofs -= bcs; fp->fptr += bcs;
 8008ea4:	6963      	ldr	r3, [r4, #20]
					fp->clust = clst;
 8008ea6:	61a0      	str	r0, [r4, #24]
				while (ofs > bcs) {						/* Cluster following loop */
 8008ea8:	f080 810d 	bcs.w	80090c6 <f_lseek+0x382>
 8008eac:	6820      	ldr	r0, [r4, #0]
					ofs -= bcs; fp->fptr += bcs;
 8008eae:	443b      	add	r3, r7
 8008eb0:	eba8 0807 	sub.w	r8, r8, r7
 8008eb4:	6163      	str	r3, [r4, #20]
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8008eb6:	f7ff f8c3 	bl	8008040 <get_fat.isra.0>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8008eba:	1c43      	adds	r3, r0, #1
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8008ebc:	4601      	mov	r1, r0
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8008ebe:	d1ea      	bne.n	8008e96 <f_lseek+0x152>
 8008ec0:	2601      	movs	r6, #1
 8008ec2:	7466      	strb	r6, [r4, #17]
		ff_rel_grant(fs->sobj);
 8008ec4:	f8da 0010 	ldr.w	r0, [sl, #16]
 8008ec8:	f000 f9b0 	bl	800922c <ff_rel_grant>
}
 8008ecc:	e749      	b.n	8008d62 <f_lseek+0x1e>
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008ece:	f1ba 0f00 	cmp.w	sl, #0
 8008ed2:	f43f af46 	beq.w	8008d62 <f_lseek+0x1e>
 8008ed6:	f1a6 030b 	sub.w	r3, r6, #11
 8008eda:	2b01      	cmp	r3, #1
 8008edc:	f67f af41 	bls.w	8008d62 <f_lseek+0x1e>
 8008ee0:	2e0f      	cmp	r6, #15
 8008ee2:	f43f af3e 	beq.w	8008d62 <f_lseek+0x1e>
 8008ee6:	e78d      	b.n	8008e04 <f_lseek+0xc0>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8008ee8:	4613      	mov	r3, r2
			cl = fp->obj.sclust;		/* Origin of the chain */
 8008eea:	68a1      	ldr	r1, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8008eec:	f853 0b04 	ldr.w	r0, [r3], #4
 8008ef0:	e9cd 0301 	strd	r0, r3, [sp, #4]
			if (cl) {
 8008ef4:	2900      	cmp	r1, #0
 8008ef6:	d08d      	beq.n	8008e14 <f_lseek+0xd0>
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8008ef8:	2202      	movs	r2, #2
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 8008efa:	4657      	mov	r7, sl
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8008efc:	e9cd 2603 	strd	r2, r6, [sp, #12]
 8008f00:	460e      	mov	r6, r1
 8008f02:	4635      	mov	r5, r6
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8008f04:	f04f 0b00 	mov.w	fp, #0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8008f08:	2d01      	cmp	r5, #1
						pcl = cl; ncl++;
 8008f0a:	f10b 0b01 	add.w	fp, fp, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8008f0e:	d902      	bls.n	8008f16 <f_lseek+0x1d2>
 8008f10:	697b      	ldr	r3, [r7, #20]
 8008f12:	429d      	cmp	r5, r3
 8008f14:	d306      	bcc.n	8008f24 <f_lseek+0x1e0>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8008f16:	2602      	movs	r6, #2
 8008f18:	7466      	strb	r6, [r4, #17]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008f1a:	f1ba 0f00 	cmp.w	sl, #0
 8008f1e:	f43f af20 	beq.w	8008d62 <f_lseek+0x1e>
 8008f22:	e76f      	b.n	8008e04 <f_lseek+0xc0>
		switch (fs->fs_type) {
 8008f24:	783b      	ldrb	r3, [r7, #0]
 8008f26:	2b02      	cmp	r3, #2
 8008f28:	d040      	beq.n	8008fac <f_lseek+0x268>
 8008f2a:	2b03      	cmp	r3, #3
 8008f2c:	d02e      	beq.n	8008f8c <f_lseek+0x248>
 8008f2e:	2b01      	cmp	r3, #1
 8008f30:	d1f1      	bne.n	8008f16 <f_lseek+0x1d2>
			bc = (UINT)clst; bc += bc / 2;
 8008f32:	eb05 0955 	add.w	r9, r5, r5, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8008f36:	6a3a      	ldr	r2, [r7, #32]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f38:	6af9      	ldr	r1, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8008f3a:	eb02 2859 	add.w	r8, r2, r9, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f3e:	4588      	cmp	r8, r1
 8008f40:	d158      	bne.n	8008ff4 <f_lseek+0x2b0>
			wc = fs->win[bc++ % SS(fs)];
 8008f42:	f109 0801 	add.w	r8, r9, #1
 8008f46:	f3c9 0908 	ubfx	r9, r9, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8008f4a:	eb02 2258 	add.w	r2, r2, r8, lsr #9
			wc = fs->win[bc++ % SS(fs)];
 8008f4e:	44b9      	add	r9, r7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f50:	428a      	cmp	r2, r1
			wc = fs->win[bc++ % SS(fs)];
 8008f52:	f899 9030 	ldrb.w	r9, [r9, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f56:	d16d      	bne.n	8009034 <f_lseek+0x2f0>
			wc |= fs->win[bc % SS(fs)] << 8;
 8008f58:	f3c8 0808 	ubfx	r8, r8, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8008f5c:	07ea      	lsls	r2, r5, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8008f5e:	4447      	add	r7, r8
 8008f60:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8008f64:	ea49 2903 	orr.w	r9, r9, r3, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8008f68:	bf4c      	ite	mi
 8008f6a:	ea4f 1919 	movmi.w	r9, r9, lsr #4
 8008f6e:	f3c9 090b 	ubfxpl	r9, r9, #0, #12
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8008f72:	f1b9 0f01 	cmp.w	r9, #1
 8008f76:	d9ce      	bls.n	8008f16 <f_lseek+0x1d2>
					} while (cl == pcl + 1);
 8008f78:	3501      	adds	r5, #1
 8008f7a:	454d      	cmp	r5, r9
 8008f7c:	f040 8087 	bne.w	800908e <f_lseek+0x34a>
 8008f80:	464d      	mov	r5, r9
 8008f82:	6827      	ldr	r7, [r4, #0]
 8008f84:	e7c0      	b.n	8008f08 <f_lseek+0x1c4>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8008f86:	2602      	movs	r6, #2
 8008f88:	7466      	strb	r6, [r4, #17]
 8008f8a:	e73b      	b.n	8008e04 <f_lseek+0xc0>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8008f8c:	6a3a      	ldr	r2, [r7, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008f8e:	f107 0930 	add.w	r9, r7, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8008f94:	eb02 18d5 	add.w	r8, r2, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008f98:	4598      	cmp	r8, r3
 8008f9a:	d138      	bne.n	800900e <f_lseek+0x2ca>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8008f9c:	00ab      	lsls	r3, r5, #2
 8008f9e:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
	rv = rv << 8 | ptr[0];
 8008fa2:	f859 9003 	ldr.w	r9, [r9, r3]
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8008fa6:	f029 4970 	bic.w	r9, r9, #4026531840	; 0xf0000000
			break;
 8008faa:	e7e2      	b.n	8008f72 <f_lseek+0x22e>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8008fac:	6a3a      	ldr	r2, [r7, #32]
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008fae:	f107 0930 	add.w	r9, r7, #48	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008fb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8008fb4:	eb02 2815 	add.w	r8, r2, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 8008fb8:	4598      	cmp	r8, r3
 8008fba:	d110      	bne.n	8008fde <f_lseek+0x29a>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8008fbc:	006b      	lsls	r3, r5, #1
 8008fbe:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
 8008fc2:	f839 9003 	ldrh.w	r9, [r9, r3]
			break;
 8008fc6:	e7d4      	b.n	8008f72 <f_lseek+0x22e>
 8008fc8:	f06f 0101 	mvn.w	r1, #1
 8008fcc:	e702      	b.n	8008dd4 <f_lseek+0x90>
			res = FR_TIMEOUT;
 8008fce:	260f      	movs	r6, #15
	LEAVE_FF(fs, res);
 8008fd0:	e6c7      	b.n	8008d62 <f_lseek+0x1e>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8008fd2:	2611      	movs	r6, #17
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8008fd4:	f1ba 0f00 	cmp.w	sl, #0
 8008fd8:	f43f af28 	beq.w	8008e2c <f_lseek+0xe8>
 8008fdc:	e712      	b.n	8008e04 <f_lseek+0xc0>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008fde:	2301      	movs	r3, #1
 8008fe0:	4642      	mov	r2, r8
 8008fe2:	7878      	ldrb	r0, [r7, #1]
 8008fe4:	4649      	mov	r1, r9
 8008fe6:	f7fe feb3 	bl	8007d50 <disk_read>
 8008fea:	2800      	cmp	r0, #0
 8008fec:	d145      	bne.n	800907a <f_lseek+0x336>
			fs->winsect = sector;
 8008fee:	f8c7 802c 	str.w	r8, [r7, #44]	; 0x2c
	return res;
 8008ff2:	e7e3      	b.n	8008fbc <f_lseek+0x278>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8008ff4:	4642      	mov	r2, r8
 8008ff6:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8008ffa:	7878      	ldrb	r0, [r7, #1]
 8008ffc:	f7fe fea8 	bl	8007d50 <disk_read>
 8009000:	2800      	cmp	r0, #0
 8009002:	d13a      	bne.n	800907a <f_lseek+0x336>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8009004:	4641      	mov	r1, r8
 8009006:	6a3a      	ldr	r2, [r7, #32]
			fs->winsect = sector;
 8009008:	f8c7 802c 	str.w	r8, [r7, #44]	; 0x2c
	return res;
 800900c:	e799      	b.n	8008f42 <f_lseek+0x1fe>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 800900e:	2301      	movs	r3, #1
 8009010:	4642      	mov	r2, r8
 8009012:	7878      	ldrb	r0, [r7, #1]
 8009014:	4649      	mov	r1, r9
 8009016:	f7fe fe9b 	bl	8007d50 <disk_read>
 800901a:	bb70      	cbnz	r0, 800907a <f_lseek+0x336>
			fs->winsect = sector;
 800901c:	f8c7 802c 	str.w	r8, [r7, #44]	; 0x2c
	return res;
 8009020:	e7bc      	b.n	8008f9c <f_lseek+0x258>
				unlock_fs(obj->fs, FR_OK);
 8009022:	6823      	ldr	r3, [r4, #0]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8009024:	2b00      	cmp	r3, #0
 8009026:	f43f ae9b 	beq.w	8008d60 <f_lseek+0x1c>
		ff_rel_grant(fs->sobj);
 800902a:	6918      	ldr	r0, [r3, #16]
 800902c:	2609      	movs	r6, #9
 800902e:	f000 f8fd 	bl	800922c <ff_rel_grant>
	if (res != FR_OK) LEAVE_FF(fs, res);
 8009032:	e696      	b.n	8008d62 <f_lseek+0x1e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8009034:	2301      	movs	r3, #1
 8009036:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800903a:	7878      	ldrb	r0, [r7, #1]
 800903c:	9205      	str	r2, [sp, #20]
 800903e:	f7fe fe87 	bl	8007d50 <disk_read>
 8009042:	9a05      	ldr	r2, [sp, #20]
 8009044:	b9c8      	cbnz	r0, 800907a <f_lseek+0x336>
			fs->winsect = sector;
 8009046:	62fa      	str	r2, [r7, #44]	; 0x2c
	return res;
 8009048:	e786      	b.n	8008f58 <f_lseek+0x214>
				while (ofs > bcs) {						/* Cluster following loop */
 800904a:	462b      	mov	r3, r5
				if (ofs % SS(fs)) {
 800904c:	f3c8 0208 	ubfx	r2, r8, #0, #9
				fp->fptr += ofs;
 8009050:	6163      	str	r3, [r4, #20]
				if (ofs % SS(fs)) {
 8009052:	2a00      	cmp	r2, #0
 8009054:	f43f af0b 	beq.w	8008e6e <f_lseek+0x12a>
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8009058:	f8da 2014 	ldr.w	r2, [sl, #20]
	clst -= 2;
 800905c:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800905e:	3a02      	subs	r2, #2
 8009060:	4291      	cmp	r1, r2
 8009062:	d290      	bcs.n	8008f86 <f_lseek+0x242>
	return clst * fs->csize + fs->database;
 8009064:	f8ba 000a 	ldrh.w	r0, [sl, #10]
 8009068:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
 800906c:	fb01 2200 	mla	r2, r1, r0, r2
					if (!nsect) ABORT(fs, FR_INT_ERR);
 8009070:	2a00      	cmp	r2, #0
 8009072:	d088      	beq.n	8008f86 <f_lseek+0x242>
					nsect += (DWORD)(ofs / SS(fs));
 8009074:	eb02 2258 	add.w	r2, r2, r8, lsr #9
 8009078:	e6f9      	b.n	8008e6e <f_lseek+0x12a>
			fs->winsect = sector;
 800907a:	f04f 33ff 	mov.w	r3, #4294967295
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 800907e:	2601      	movs	r6, #1
			fs->winsect = sector;
 8009080:	62fb      	str	r3, [r7, #44]	; 0x2c
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8009082:	7466      	strb	r6, [r4, #17]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
 8009084:	f1ba 0f00 	cmp.w	sl, #0
 8009088:	f43f ae6b 	beq.w	8008d62 <f_lseek+0x1e>
 800908c:	e6ba      	b.n	8008e04 <f_lseek+0xc0>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 800908e:	9b03      	ldr	r3, [sp, #12]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8009090:	9a01      	ldr	r2, [sp, #4]
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8009092:	3302      	adds	r3, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8009094:	429a      	cmp	r2, r3
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8009096:	9303      	str	r3, [sp, #12]
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8009098:	d30c      	bcc.n	80090b4 <f_lseek+0x370>
						*tbl++ = ncl; *tbl++ = tcl;
 800909a:	9a02      	ldr	r2, [sp, #8]
 800909c:	4613      	mov	r3, r2
 800909e:	f843 bb08 	str.w	fp, [r3], #8
 80090a2:	6056      	str	r6, [r2, #4]
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 80090a4:	f8da 2014 	ldr.w	r2, [sl, #20]
 80090a8:	454a      	cmp	r2, r9
 80090aa:	d90e      	bls.n	80090ca <f_lseek+0x386>
						*tbl++ = ncl; *tbl++ = tcl;
 80090ac:	9302      	str	r3, [sp, #8]
{
 80090ae:	464e      	mov	r6, r9
 80090b0:	6827      	ldr	r7, [r4, #0]
 80090b2:	e726      	b.n	8008f02 <f_lseek+0x1be>
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 80090b4:	f8da 3014 	ldr.w	r3, [sl, #20]
 80090b8:	454b      	cmp	r3, r9
 80090ba:	d8f8      	bhi.n	80090ae <f_lseek+0x36a>
			*fp->cltbl = ulen;	/* Number of items used */
 80090bc:	6a23      	ldr	r3, [r4, #32]
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 80090be:	2611      	movs	r6, #17
			*fp->cltbl = ulen;	/* Number of items used */
 80090c0:	9a03      	ldr	r2, [sp, #12]
 80090c2:	601a      	str	r2, [r3, #0]
			if (ulen <= tlen) {
 80090c4:	e69e      	b.n	8008e04 <f_lseek+0xc0>
				fp->fptr += ofs;
 80090c6:	4443      	add	r3, r8
 80090c8:	e7c0      	b.n	800904c <f_lseek+0x308>
			*fp->cltbl = ulen;	/* Number of items used */
 80090ca:	6a22      	ldr	r2, [r4, #32]
						*tbl++ = ncl; *tbl++ = tcl;
 80090cc:	9302      	str	r3, [sp, #8]
			*fp->cltbl = ulen;	/* Number of items used */
 80090ce:	9b03      	ldr	r3, [sp, #12]
 80090d0:	9e04      	ldr	r6, [sp, #16]
 80090d2:	6013      	str	r3, [r2, #0]
			if (ulen <= tlen) {
 80090d4:	e6a4      	b.n	8008e20 <f_lseek+0xdc>
 80090d6:	4611      	mov	r1, r2
 80090d8:	e6d8      	b.n	8008e8c <f_lseek+0x148>
 80090da:	bf00      	nop

080090dc <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 80090dc:	4b10      	ldr	r3, [pc, #64]	; (8009120 <FATFS_LinkDriver+0x44>)
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 80090de:	b410      	push	{r4}
  if(disk.nbr < _VOLUMES)
 80090e0:	7a5c      	ldrb	r4, [r3, #9]
 80090e2:	b9cc      	cbnz	r4, 8009118 <FATFS_LinkDriver+0x3c>
 80090e4:	4602      	mov	r2, r0
    disk.is_initialized[disk.nbr] = 0;
 80090e6:	f004 00ff 	and.w	r0, r4, #255	; 0xff
 80090ea:	7a5c      	ldrb	r4, [r3, #9]
 80090ec:	5518      	strb	r0, [r3, r4]
    disk.drv[disk.nbr] = drv;
 80090ee:	7a5c      	ldrb	r4, [r3, #9]
 80090f0:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 80090f4:	6062      	str	r2, [r4, #4]
    disk.lun[disk.nbr] = lun;
 80090f6:	7a5c      	ldrb	r4, [r3, #9]
    DiskNum = disk.nbr++;
 80090f8:	7a5a      	ldrb	r2, [r3, #9]
    disk.lun[disk.nbr] = lun;
 80090fa:	441c      	add	r4, r3
 80090fc:	7220      	strb	r0, [r4, #8]
    DiskNum = disk.nbr++;
 80090fe:	1c54      	adds	r4, r2, #1
    path[0] = DiskNum + '0';
 8009100:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
 8009102:	b2e4      	uxtb	r4, r4
 8009104:	725c      	strb	r4, [r3, #9]
    path[1] = ':';
 8009106:	243a      	movs	r4, #58	; 0x3a
    path[2] = '/';
 8009108:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 800910a:	700a      	strb	r2, [r1, #0]
    path[1] = ':';
 800910c:	704c      	strb	r4, [r1, #1]
    path[3] = 0;
 800910e:	70c8      	strb	r0, [r1, #3]
  return FATFS_LinkDriverEx(drv, path, 0);
}
 8009110:	f85d 4b04 	ldr.w	r4, [sp], #4
    path[2] = '/';
 8009114:	708b      	strb	r3, [r1, #2]
}
 8009116:	4770      	bx	lr
  uint8_t ret = 1;
 8009118:	2001      	movs	r0, #1
}
 800911a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800911e:	4770      	bx	lr
 8009120:	200194fc 	.word	0x200194fc

08009124 <ff_convert>:
)
{
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8009124:	287f      	cmp	r0, #127	; 0x7f
 8009126:	d912      	bls.n	800914e <ff_convert+0x2a>
		c = chr;

	} else {
		if (dir) {		/* OEM code to Unicode */
 8009128:	b971      	cbnz	r1, 8009148 <ff_convert+0x24>
 800912a:	4b0c      	ldr	r3, [pc, #48]	; (800915c <ff_convert+0x38>)
 800912c:	e001      	b.n	8009132 <ff_convert+0xe>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 800912e:	2980      	cmp	r1, #128	; 0x80
 8009130:	d00c      	beq.n	800914c <ff_convert+0x28>
				if (chr == Tbl[c]) break;
 8009132:	f833 2b02 	ldrh.w	r2, [r3], #2
 8009136:	fa1f fc81 	uxth.w	ip, r1
			for (c = 0; c < 0x80; c++) {
 800913a:	3101      	adds	r1, #1
				if (chr == Tbl[c]) break;
 800913c:	4282      	cmp	r2, r0
 800913e:	d1f6      	bne.n	800912e <ff_convert+0xa>
			}
			c = (c + 0x80) & 0xFF;
 8009140:	f10c 0080 	add.w	r0, ip, #128	; 0x80
 8009144:	b280      	uxth	r0, r0
 8009146:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8009148:	28ff      	cmp	r0, #255	; 0xff
 800914a:	d901      	bls.n	8009150 <ff_convert+0x2c>
 800914c:	2000      	movs	r0, #0
		}
	}

	return c;
}
 800914e:	4770      	bx	lr
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8009150:	4b02      	ldr	r3, [pc, #8]	; (800915c <ff_convert+0x38>)
 8009152:	3880      	subs	r0, #128	; 0x80
 8009154:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8009158:	4770      	bx	lr
 800915a:	bf00      	nop
 800915c:	08016bc0 	.word	0x08016bc0

08009160 <ff_wtoupper>:
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 8009160:	4b22      	ldr	r3, [pc, #136]	; (80091ec <ff_wtoupper+0x8c>)
 8009162:	4a23      	ldr	r2, [pc, #140]	; (80091f0 <ff_wtoupper+0x90>)
 8009164:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 8009168:	bf28      	it	cs
 800916a:	4613      	movcs	r3, r2
{
 800916c:	b510      	push	{r4, lr}
 800916e:	3304      	adds	r3, #4
 8009170:	e001      	b.n	8009176 <ff_wtoupper+0x16>
			case 7: chr -= 80; break;				/* Shift -80 */
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
			}
			break;
		}
		if (!cmd) p += nc;
 8009172:	3304      	adds	r3, #4
 8009174:	b1da      	cbz	r2, 80091ae <ff_wtoupper+0x4e>
		bc = *p++;								/* Get block base */
 8009176:	f833 1c04 	ldrh.w	r1, [r3, #-4]
		if (!bc || chr < bc) break;
 800917a:	461c      	mov	r4, r3
 800917c:	b1b1      	cbz	r1, 80091ac <ff_wtoupper+0x4c>
 800917e:	4288      	cmp	r0, r1
 8009180:	d314      	bcc.n	80091ac <ff_wtoupper+0x4c>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8009182:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 8009186:	fa5f fc82 	uxtb.w	ip, r2
 800918a:	0a12      	lsrs	r2, r2, #8
		if (chr < bc + nc) {	/* In the block? */
 800918c:	eb0c 0e01 	add.w	lr, ip, r1
 8009190:	4570      	cmp	r0, lr
 8009192:	daee      	bge.n	8009172 <ff_wtoupper+0x12>
			switch (cmd) {
 8009194:	2a08      	cmp	r2, #8
 8009196:	d809      	bhi.n	80091ac <ff_wtoupper+0x4c>
 8009198:	e8df f002 	tbb	[pc, r2]
 800919c:	19161005 	.word	0x19161005
 80091a0:	25221f1c 	.word	0x25221f1c
 80091a4:	0c          	.byte	0x0c
 80091a5:	00          	.byte	0x00
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 80091a6:	1a41      	subs	r1, r0, r1
 80091a8:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
	}

	return chr;
}
 80091ac:	bd10      	pop	{r4, pc}
		if (!cmd) p += nc;
 80091ae:	eb04 034c 	add.w	r3, r4, ip, lsl #1
 80091b2:	e7dc      	b.n	800916e <ff_wtoupper+0xe>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 80091b4:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
 80091b8:	b280      	uxth	r0, r0
}
 80091ba:	bd10      	pop	{r4, pc}
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 80091bc:	1a43      	subs	r3, r0, r1
 80091be:	f003 0301 	and.w	r3, r3, #1
 80091c2:	1ac0      	subs	r0, r0, r3
 80091c4:	b280      	uxth	r0, r0
}
 80091c6:	bd10      	pop	{r4, pc}
			case 2: chr -= 16; break;				/* Shift -16 */
 80091c8:	3810      	subs	r0, #16
 80091ca:	b280      	uxth	r0, r0
}
 80091cc:	bd10      	pop	{r4, pc}
			case 3:	chr -= 32; break;				/* Shift -32 */
 80091ce:	3820      	subs	r0, #32
 80091d0:	b280      	uxth	r0, r0
}
 80091d2:	bd10      	pop	{r4, pc}
			case 4:	chr -= 48; break;				/* Shift -48 */
 80091d4:	3830      	subs	r0, #48	; 0x30
 80091d6:	b280      	uxth	r0, r0
}
 80091d8:	bd10      	pop	{r4, pc}
			case 5:	chr -= 26; break;				/* Shift -26 */
 80091da:	381a      	subs	r0, #26
 80091dc:	b280      	uxth	r0, r0
}
 80091de:	bd10      	pop	{r4, pc}
			case 6:	chr += 8; break;				/* Shift +8 */
 80091e0:	3008      	adds	r0, #8
 80091e2:	b280      	uxth	r0, r0
}
 80091e4:	bd10      	pop	{r4, pc}
			case 7: chr -= 80; break;				/* Shift -80 */
 80091e6:	3850      	subs	r0, #80	; 0x50
 80091e8:	b280      	uxth	r0, r0
}
 80091ea:	bd10      	pop	{r4, pc}
 80091ec:	08016cc0 	.word	0x08016cc0
 80091f0:	08016eb4 	.word	0x08016eb4

080091f4 <ff_cre_syncobj>:

int ff_cre_syncobj (	/* 1:Function succeeded, 0:Could not create the sync object */
	BYTE vol,			/* Corresponding volume (logical drive number) */
	_SYNC_t *sobj		/* Pointer to return the created sync object */
)
{
 80091f4:	b510      	push	{r4, lr}
 80091f6:	460c      	mov	r4, r1

#if (osCMSIS < 0x20000U)
    osSemaphoreDef(SEM);
    *sobj = osSemaphoreCreate(osSemaphore(SEM), 1);
#else
    *sobj = osSemaphoreNew(1, 1, NULL);
 80091f8:	2101      	movs	r1, #1
 80091fa:	2200      	movs	r2, #0
 80091fc:	4608      	mov	r0, r1
 80091fe:	f000 f9db 	bl	80095b8 <osSemaphoreNew>
 8009202:	6020      	str	r0, [r4, #0]

#endif
    ret = (*sobj != NULL);

    return ret;
}
 8009204:	3800      	subs	r0, #0
 8009206:	bf18      	it	ne
 8009208:	2001      	movne	r0, #1
 800920a:	bd10      	pop	{r4, pc}

0800920c <ff_del_syncobj>:
*/

int ff_del_syncobj (	/* 1:Function succeeded, 0:Could not delete due to any error */
	_SYNC_t sobj		/* Sync object tied to the logical drive to be deleted */
)
{
 800920c:	b508      	push	{r3, lr}
#if _USE_MUTEX
    osMutexDelete (sobj);
#else
    osSemaphoreDelete (sobj);
 800920e:	f000 faaf 	bl	8009770 <osSemaphoreDelete>
#endif
    return 1;
}
 8009212:	2001      	movs	r0, #1
 8009214:	bd08      	pop	{r3, pc}
 8009216:	bf00      	nop

08009218 <ff_req_grant>:
#else

#if _USE_MUTEX
   if(osMutexAcquire(sobj, _FS_TIMEOUT) == osOK)
#else
   if(osSemaphoreAcquire(sobj, _FS_TIMEOUT) == osOK)
 8009218:	f241 3188 	movw	r1, #5000	; 0x1388
{
 800921c:	b508      	push	{r3, lr}
   if(osSemaphoreAcquire(sobj, _FS_TIMEOUT) == osOK)
 800921e:	f000 fa25 	bl	800966c <osSemaphoreAcquire>
  {
    ret = 1;
  }

  return ret;
}
 8009222:	fab0 f080 	clz	r0, r0
 8009226:	0940      	lsrs	r0, r0, #5
 8009228:	bd08      	pop	{r3, pc}
 800922a:	bf00      	nop

0800922c <ff_rel_grant>:
)
{
#if _USE_MUTEX
  osMutexRelease(sobj);
#else
  osSemaphoreRelease(sobj);
 800922c:	f000 ba60 	b.w	80096f0 <osSemaphoreRelease>

08009230 <osKernelInitialize>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8009230:	f3ef 8305 	mrs	r3, IPSR
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 8009234:	b97b      	cbnz	r3, 8009256 <osKernelInitialize+0x26>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009236:	f3ef 8310 	mrs	r3, PRIMASK
 800923a:	b943      	cbnz	r3, 800924e <osKernelInitialize+0x1e>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800923c:	f3ef 8311 	mrs	r3, BASEPRI
 8009240:	b92b      	cbnz	r3, 800924e <osKernelInitialize+0x1e>
 8009242:	4b08      	ldr	r3, [pc, #32]	; (8009264 <osKernelInitialize+0x34>)
 8009244:	6818      	ldr	r0, [r3, #0]
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelInactive) {
 8009246:	b948      	cbnz	r0, 800925c <osKernelInitialize+0x2c>
      #if defined(USE_FREERTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 8009248:	2201      	movs	r2, #1
 800924a:	601a      	str	r2, [r3, #0]
      stat = osOK;
 800924c:	4770      	bx	lr
  if (IS_IRQ()) {
 800924e:	4b05      	ldr	r3, [pc, #20]	; (8009264 <osKernelInitialize+0x34>)
 8009250:	6818      	ldr	r0, [r3, #0]
 8009252:	2802      	cmp	r0, #2
 8009254:	d1f7      	bne.n	8009246 <osKernelInitialize+0x16>
    stat = osErrorISR;
 8009256:	f06f 0005 	mvn.w	r0, #5
 800925a:	4770      	bx	lr
    } else {
      stat = osError;
 800925c:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (stat);
}
 8009260:	4770      	bx	lr
 8009262:	bf00      	nop
 8009264:	20019768 	.word	0x20019768

08009268 <osKernelGetState>:
  }

  return (osOK);
}

osKernelState_t osKernelGetState (void) {
 8009268:	b508      	push	{r3, lr}
  osKernelState_t state;

  switch (xTaskGetSchedulerState()) {
 800926a:	f002 fbd3 	bl	800ba14 <xTaskGetSchedulerState>
 800926e:	b148      	cbz	r0, 8009284 <osKernelGetState+0x1c>
 8009270:	2802      	cmp	r0, #2
 8009272:	d006      	beq.n	8009282 <osKernelGetState+0x1a>
      state = osKernelLocked;
      break;

    case taskSCHEDULER_NOT_STARTED:
    default:
      if (KernelState == osKernelReady) {
 8009274:	4b04      	ldr	r3, [pc, #16]	; (8009288 <osKernelGetState+0x20>)
 8009276:	6818      	ldr	r0, [r3, #0]
 8009278:	f1a0 0001 	sub.w	r0, r0, #1
 800927c:	fab0 f080 	clz	r0, r0
 8009280:	0940      	lsrs	r0, r0, #5
      }
      break;
  }

  return (state);
}
 8009282:	bd08      	pop	{r3, pc}
  switch (xTaskGetSchedulerState()) {
 8009284:	2003      	movs	r0, #3
}
 8009286:	bd08      	pop	{r3, pc}
 8009288:	20019768 	.word	0x20019768

0800928c <osKernelStart>:

osStatus_t osKernelStart (void) {
 800928c:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800928e:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 8009292:	b9c3      	cbnz	r3, 80092c6 <osKernelStart+0x3a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009294:	f3ef 8310 	mrs	r3, PRIMASK
 8009298:	b15b      	cbz	r3, 80092b2 <osKernelStart+0x26>
 800929a:	4b0c      	ldr	r3, [pc, #48]	; (80092cc <osKernelStart+0x40>)
 800929c:	681a      	ldr	r2, [r3, #0]
 800929e:	2a02      	cmp	r2, #2
 80092a0:	d011      	beq.n	80092c6 <osKernelStart+0x3a>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelReady) {
 80092a2:	2a01      	cmp	r2, #1
 80092a4:	d10c      	bne.n	80092c0 <osKernelStart+0x34>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 80092a6:	2202      	movs	r2, #2
 80092a8:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 80092aa:	f001 ff75 	bl	800b198 <vTaskStartScheduler>
      stat = osOK;
 80092ae:	2000      	movs	r0, #0
      stat = osError;
    }
  }

  return (stat);
}
 80092b0:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80092b2:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80092b6:	2b00      	cmp	r3, #0
 80092b8:	d1ef      	bne.n	800929a <osKernelStart+0xe>
 80092ba:	4b04      	ldr	r3, [pc, #16]	; (80092cc <osKernelStart+0x40>)
 80092bc:	681a      	ldr	r2, [r3, #0]
 80092be:	e7f0      	b.n	80092a2 <osKernelStart+0x16>
      stat = osError;
 80092c0:	f04f 30ff 	mov.w	r0, #4294967295
}
 80092c4:	bd08      	pop	{r3, pc}
    stat = osErrorISR;
 80092c6:	f06f 0005 	mvn.w	r0, #5
}
 80092ca:	bd08      	pop	{r3, pc}
 80092cc:	20019768 	.word	0x20019768

080092d0 <osKernelGetTickCount>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80092d0:	f3ef 8305 	mrs	r3, IPSR
}

uint32_t osKernelGetTickCount (void) {
  TickType_t ticks;

  if (IS_IRQ()) {
 80092d4:	b943      	cbnz	r3, 80092e8 <osKernelGetTickCount+0x18>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80092d6:	f3ef 8310 	mrs	r3, PRIMASK
 80092da:	b13b      	cbz	r3, 80092ec <osKernelGetTickCount+0x1c>
 80092dc:	4b08      	ldr	r3, [pc, #32]	; (8009300 <osKernelGetTickCount+0x30>)
 80092de:	681b      	ldr	r3, [r3, #0]
 80092e0:	2b02      	cmp	r3, #2
 80092e2:	d001      	beq.n	80092e8 <osKernelGetTickCount+0x18>
    ticks = xTaskGetTickCountFromISR();
  } else {
    ticks = xTaskGetTickCount();
 80092e4:	f001 bffc 	b.w	800b2e0 <xTaskGetTickCount>
    ticks = xTaskGetTickCountFromISR();
 80092e8:	f002 b800 	b.w	800b2ec <xTaskGetTickCountFromISR>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80092ec:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80092f0:	2b00      	cmp	r3, #0
 80092f2:	d0f7      	beq.n	80092e4 <osKernelGetTickCount+0x14>
 80092f4:	4b02      	ldr	r3, [pc, #8]	; (8009300 <osKernelGetTickCount+0x30>)
 80092f6:	681b      	ldr	r3, [r3, #0]
 80092f8:	2b02      	cmp	r3, #2
 80092fa:	d1f3      	bne.n	80092e4 <osKernelGetTickCount+0x14>
 80092fc:	e7f4      	b.n	80092e8 <osKernelGetTickCount+0x18>
 80092fe:	bf00      	nop
 8009300:	20019768 	.word	0x20019768

08009304 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 8009304:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 8009306:	2400      	movs	r4, #0
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 8009308:	b087      	sub	sp, #28
 800930a:	4615      	mov	r5, r2
  hTask = NULL;
 800930c:	9405      	str	r4, [sp, #20]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800930e:	f3ef 8205 	mrs	r2, IPSR

  if (!IS_IRQ() && (func != NULL)) {
 8009312:	2a00      	cmp	r2, #0
 8009314:	d134      	bne.n	8009380 <osThreadNew+0x7c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009316:	f3ef 8310 	mrs	r3, PRIMASK
 800931a:	2b00      	cmp	r3, #0
 800931c:	d133      	bne.n	8009386 <osThreadNew+0x82>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800931e:	f3ef 8311 	mrs	r3, BASEPRI
 8009322:	2b00      	cmp	r3, #0
 8009324:	d12f      	bne.n	8009386 <osThreadNew+0x82>
 8009326:	2800      	cmp	r0, #0
 8009328:	d031      	beq.n	800938e <osThreadNew+0x8a>
    prio  = (UBaseType_t)osPriorityNormal;

    name = NULL;
    mem  = -1;

    if (attr != NULL) {
 800932a:	b1f5      	cbz	r5, 800936a <osThreadNew+0x66>
      if (attr->name != NULL) {
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
 800932c:	69ac      	ldr	r4, [r5, #24]
 800932e:	2c00      	cmp	r4, #0
 8009330:	d030      	beq.n	8009394 <osThreadNew+0x90>
        prio = (UBaseType_t)attr->priority;
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8009332:	1e63      	subs	r3, r4, #1
 8009334:	2b37      	cmp	r3, #55	; 0x37
 8009336:	d823      	bhi.n	8009380 <osThreadNew+0x7c>
 8009338:	686b      	ldr	r3, [r5, #4]
 800933a:	07db      	lsls	r3, r3, #31
 800933c:	d420      	bmi.n	8009380 <osThreadNew+0x7c>
        return (NULL);
      }

      if (attr->stack_size > 0U) {
 800933e:	696b      	ldr	r3, [r5, #20]
 8009340:	b353      	cbz	r3, 8009398 <osThreadNew+0x94>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 8009342:	ea4f 0c93 	mov.w	ip, r3, lsr #2
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8009346:	68ae      	ldr	r6, [r5, #8]
      if (attr->name != NULL) {
 8009348:	682f      	ldr	r7, [r5, #0]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 800934a:	b346      	cbz	r6, 800939e <osThreadNew+0x9a>
 800934c:	68ea      	ldr	r2, [r5, #12]
 800934e:	2a5f      	cmp	r2, #95	; 0x5f
 8009350:	d91d      	bls.n	800938e <osThreadNew+0x8a>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8009352:	692d      	ldr	r5, [r5, #16]
 8009354:	b1dd      	cbz	r5, 800938e <osThreadNew+0x8a>
 8009356:	b1d3      	cbz	r3, 800938e <osThreadNew+0x8a>
    else {
      mem = 0;
    }

    if (mem == 1) {
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8009358:	460b      	mov	r3, r1
 800935a:	4662      	mov	r2, ip
 800935c:	4639      	mov	r1, r7
 800935e:	9400      	str	r4, [sp, #0]
 8009360:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8009364:	f001 fea6 	bl	800b0b4 <xTaskCreateStatic>
 8009368:	e00b      	b.n	8009382 <osThreadNew+0x7e>
 800936a:	2280      	movs	r2, #128	; 0x80
    prio  = (UBaseType_t)osPriorityNormal;
 800936c:	2418      	movs	r4, #24
                                                                                    (StaticTask_t *)attr->cb_mem);
    }
    else {
      if (mem == 0) {
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 800936e:	9400      	str	r4, [sp, #0]
 8009370:	ac05      	add	r4, sp, #20
 8009372:	460b      	mov	r3, r1
 8009374:	4629      	mov	r1, r5
 8009376:	9401      	str	r4, [sp, #4]
 8009378:	f001 fedc 	bl	800b134 <xTaskCreate>
 800937c:	2801      	cmp	r0, #1
 800937e:	d006      	beq.n	800938e <osThreadNew+0x8a>
        return (NULL);
 8009380:	2000      	movs	r0, #0
      }
    }
  }

  return ((osThreadId_t)hTask);
}
 8009382:	b007      	add	sp, #28
 8009384:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (!IS_IRQ() && (func != NULL)) {
 8009386:	4b0b      	ldr	r3, [pc, #44]	; (80093b4 <osThreadNew+0xb0>)
 8009388:	681b      	ldr	r3, [r3, #0]
 800938a:	2b02      	cmp	r3, #2
 800938c:	d1cb      	bne.n	8009326 <osThreadNew+0x22>
  return ((osThreadId_t)hTask);
 800938e:	9805      	ldr	r0, [sp, #20]
}
 8009390:	b007      	add	sp, #28
 8009392:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009394:	2418      	movs	r4, #24
 8009396:	e7cf      	b.n	8009338 <osThreadNew+0x34>
    stack = configMINIMAL_STACK_SIZE;
 8009398:	f04f 0c80 	mov.w	ip, #128	; 0x80
 800939c:	e7d3      	b.n	8009346 <osThreadNew+0x42>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 800939e:	68eb      	ldr	r3, [r5, #12]
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	d1f4      	bne.n	800938e <osThreadNew+0x8a>
 80093a4:	692b      	ldr	r3, [r5, #16]
 80093a6:	2b00      	cmp	r3, #0
 80093a8:	d1f1      	bne.n	800938e <osThreadNew+0x8a>
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 80093aa:	fa1f f28c 	uxth.w	r2, ip
 80093ae:	463d      	mov	r5, r7
 80093b0:	e7dd      	b.n	800936e <osThreadNew+0x6a>
 80093b2:	bf00      	nop
 80093b4:	20019768 	.word	0x20019768

080093b8 <osDelay>:

  /* Return flags before clearing */
  return (rflags);
}

osStatus_t osDelay (uint32_t ticks) {
 80093b8:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80093ba:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 80093be:	b9ab      	cbnz	r3, 80093ec <osDelay+0x34>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80093c0:	f3ef 8310 	mrs	r3, PRIMASK
 80093c4:	b12b      	cbz	r3, 80093d2 <osDelay+0x1a>
 80093c6:	4b0b      	ldr	r3, [pc, #44]	; (80093f4 <osDelay+0x3c>)
 80093c8:	681b      	ldr	r3, [r3, #0]
 80093ca:	2b02      	cmp	r3, #2
 80093cc:	d00e      	beq.n	80093ec <osDelay+0x34>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
 80093ce:	b948      	cbnz	r0, 80093e4 <osDelay+0x2c>
      vTaskDelay(ticks);
    }
  }

  return (stat);
}
 80093d0:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80093d2:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80093d6:	2b00      	cmp	r3, #0
 80093d8:	d0f9      	beq.n	80093ce <osDelay+0x16>
 80093da:	4b06      	ldr	r3, [pc, #24]	; (80093f4 <osDelay+0x3c>)
 80093dc:	681b      	ldr	r3, [r3, #0]
 80093de:	2b02      	cmp	r3, #2
 80093e0:	d1f5      	bne.n	80093ce <osDelay+0x16>
 80093e2:	e003      	b.n	80093ec <osDelay+0x34>
      vTaskDelay(ticks);
 80093e4:	f002 f8e4 	bl	800b5b0 <vTaskDelay>
    stat = osOK;
 80093e8:	2000      	movs	r0, #0
}
 80093ea:	bd08      	pop	{r3, pc}
    stat = osErrorISR;
 80093ec:	f06f 0005 	mvn.w	r0, #5
}
 80093f0:	bd08      	pop	{r3, pc}
 80093f2:	bf00      	nop
 80093f4:	20019768 	.word	0x20019768

080093f8 <osDelayUntil>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80093f8:	f3ef 8305 	mrs	r3, IPSR

osStatus_t osDelayUntil (uint32_t ticks) {
  TickType_t tcnt, delay;
  osStatus_t stat;

  if (IS_IRQ()) {
 80093fc:	bb03      	cbnz	r3, 8009440 <osDelayUntil+0x48>
osStatus_t osDelayUntil (uint32_t ticks) {
 80093fe:	b510      	push	{r4, lr}
 8009400:	4604      	mov	r4, r0
 8009402:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009404:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 8009408:	b17b      	cbz	r3, 800942a <osDelayUntil+0x32>
 800940a:	4b0f      	ldr	r3, [pc, #60]	; (8009448 <osDelayUntil+0x50>)
 800940c:	681b      	ldr	r3, [r3, #0]
 800940e:	2b02      	cmp	r3, #2
 8009410:	d013      	beq.n	800943a <osDelayUntil+0x42>
    stat = osErrorISR;
  }
  else {
    stat = osOK;
    tcnt = xTaskGetTickCount();
 8009412:	f001 ff65 	bl	800b2e0 <xTaskGetTickCount>

    /* Determine remaining number of ticks to delay */
    delay = (TickType_t)ticks - tcnt;
 8009416:	1a21      	subs	r1, r4, r0
    tcnt = xTaskGetTickCount();
 8009418:	9001      	str	r0, [sp, #4]

    /* Check if target tick has not expired */
    if((delay != 0U) && (0 == (delay >> (8 * sizeof(TickType_t) - 1)))) {
 800941a:	2900      	cmp	r1, #0
 800941c:	dd0a      	ble.n	8009434 <osDelayUntil+0x3c>
      vTaskDelayUntil (&tcnt, delay);
 800941e:	a801      	add	r0, sp, #4
 8009420:	f002 f8fa 	bl	800b618 <vTaskDelayUntil>
    stat = osOK;
 8009424:	2000      	movs	r0, #0
      stat = osErrorParameter;
    }
  }

  return (stat);
}
 8009426:	b002      	add	sp, #8
 8009428:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800942a:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800942e:	2b00      	cmp	r3, #0
 8009430:	d0ef      	beq.n	8009412 <osDelayUntil+0x1a>
 8009432:	e7ea      	b.n	800940a <osDelayUntil+0x12>
      stat = osErrorParameter;
 8009434:	f06f 0003 	mvn.w	r0, #3
  return (stat);
 8009438:	e7f5      	b.n	8009426 <osDelayUntil+0x2e>
    stat = osErrorISR;
 800943a:	f06f 0005 	mvn.w	r0, #5
 800943e:	e7f2      	b.n	8009426 <osDelayUntil+0x2e>
 8009440:	f06f 0005 	mvn.w	r0, #5
}
 8009444:	4770      	bx	lr
 8009446:	bf00      	nop
 8009448:	20019768 	.word	0x20019768

0800944c <osMutexNew>:
  return (stat);
}

/*---------------------------------------------------------------------------*/

osMutexId_t osMutexNew (const osMutexAttr_t *attr) {
 800944c:	b530      	push	{r4, r5, lr}
 800944e:	b083      	sub	sp, #12
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8009450:	f3ef 8505 	mrs	r5, IPSR
  const char *name;
  #endif

  hMutex = NULL;

  if (!IS_IRQ()) {
 8009454:	b9e5      	cbnz	r5, 8009490 <osMutexNew+0x44>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009456:	4604      	mov	r4, r0
 8009458:	f3ef 8310 	mrs	r3, PRIMASK
 800945c:	b9a3      	cbnz	r3, 8009488 <osMutexNew+0x3c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800945e:	f3ef 8311 	mrs	r3, BASEPRI
 8009462:	b98b      	cbnz	r3, 8009488 <osMutexNew+0x3c>
    if (attr != NULL) {
 8009464:	b1bc      	cbz	r4, 8009496 <osMutexNew+0x4a>
      type = attr->attr_bits;
 8009466:	6865      	ldr	r5, [r4, #4]
      rmtx = 1U;
    } else {
      rmtx = 0U;
    }

    if ((type & osMutexRobust) != osMutexRobust) {
 8009468:	072b      	lsls	r3, r5, #28
 800946a:	d411      	bmi.n	8009490 <osMutexNew+0x44>
      mem = -1;

      if (attr != NULL) {
        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 800946c:	68a1      	ldr	r1, [r4, #8]
    if ((type & osMutexRecursive) == osMutexRecursive) {
 800946e:	f005 0501 	and.w	r5, r5, #1
        if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 8009472:	68e3      	ldr	r3, [r4, #12]
 8009474:	b301      	cbz	r1, 80094b8 <osMutexNew+0x6c>
 8009476:	2b4f      	cmp	r3, #79	; 0x4f
 8009478:	d90a      	bls.n	8009490 <osMutexNew+0x44>
      else {
        mem = 0;
      }

      if (mem == 1) {
        if (rmtx != 0U) {
 800947a:	b325      	cbz	r5, 80094c6 <osMutexNew+0x7a>
          hMutex = xSemaphoreCreateRecursiveMutexStatic (attr->cb_mem);
 800947c:	2004      	movs	r0, #4
 800947e:	f000 fe41 	bl	800a104 <xQueueCreateMutexStatic>
          }
        }
      }

      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hMutex != NULL) {
 8009482:	b128      	cbz	r0, 8009490 <osMutexNew+0x44>
        if (attr != NULL) {
          name = attr->name;
 8009484:	6824      	ldr	r4, [r4, #0]
 8009486:	e00c      	b.n	80094a2 <osMutexNew+0x56>
  if (!IS_IRQ()) {
 8009488:	4b13      	ldr	r3, [pc, #76]	; (80094d8 <osMutexNew+0x8c>)
 800948a:	681b      	ldr	r3, [r3, #0]
 800948c:	2b02      	cmp	r3, #2
 800948e:	d1e9      	bne.n	8009464 <osMutexNew+0x18>
  hMutex = NULL;
 8009490:	2000      	movs	r0, #0
      }
    }
  }

  return ((osMutexId_t)hMutex);
}
 8009492:	b003      	add	sp, #12
 8009494:	bd30      	pop	{r4, r5, pc}
            hMutex = xSemaphoreCreateMutex ();
 8009496:	2001      	movs	r0, #1
 8009498:	f000 feaa 	bl	800a1f0 <xQueueCreateMutex>
      if (hMutex != NULL) {
 800949c:	2800      	cmp	r0, #0
 800949e:	d0f7      	beq.n	8009490 <osMutexNew+0x44>
 80094a0:	4625      	mov	r5, r4
        vQueueAddToRegistry (hMutex, name);
 80094a2:	4621      	mov	r1, r4
 80094a4:	9001      	str	r0, [sp, #4]
 80094a6:	f001 fb99 	bl	800abdc <vQueueAddToRegistry>
      if ((hMutex != NULL) && (rmtx != 0U)) {
 80094aa:	9801      	ldr	r0, [sp, #4]
 80094ac:	2d00      	cmp	r5, #0
 80094ae:	d0f0      	beq.n	8009492 <osMutexNew+0x46>
        hMutex = (SemaphoreHandle_t)((uint32_t)hMutex | 1U);
 80094b0:	f040 0001 	orr.w	r0, r0, #1
}
 80094b4:	b003      	add	sp, #12
 80094b6:	bd30      	pop	{r4, r5, pc}
          if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 80094b8:	2b00      	cmp	r3, #0
 80094ba:	d1e9      	bne.n	8009490 <osMutexNew+0x44>
          if (rmtx != 0U) {
 80094bc:	b93d      	cbnz	r5, 80094ce <osMutexNew+0x82>
            hMutex = xSemaphoreCreateMutex ();
 80094be:	2001      	movs	r0, #1
 80094c0:	f000 fe96 	bl	800a1f0 <xQueueCreateMutex>
      if (hMutex != NULL) {
 80094c4:	e7dd      	b.n	8009482 <osMutexNew+0x36>
          hMutex = xSemaphoreCreateMutexStatic (attr->cb_mem);
 80094c6:	2001      	movs	r0, #1
 80094c8:	f000 fe1c 	bl	800a104 <xQueueCreateMutexStatic>
 80094cc:	e7d9      	b.n	8009482 <osMutexNew+0x36>
            hMutex = xSemaphoreCreateRecursiveMutex ();
 80094ce:	2004      	movs	r0, #4
 80094d0:	f000 fe8e 	bl	800a1f0 <xQueueCreateMutex>
 80094d4:	e7d5      	b.n	8009482 <osMutexNew+0x36>
 80094d6:	bf00      	nop
 80094d8:	20019768 	.word	0x20019768

080094dc <osMutexAcquire>:

osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout) {
 80094dc:	b510      	push	{r4, lr}
 80094de:	460c      	mov	r4, r1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80094e0:	f3ef 8105 	mrs	r1, IPSR

  rmtx = (uint32_t)mutex_id & 1U;

  stat = osOK;

  if (IS_IRQ()) {
 80094e4:	bb49      	cbnz	r1, 800953a <osMutexAcquire+0x5e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80094e6:	f020 0201 	bic.w	r2, r0, #1
 80094ea:	f000 0001 	and.w	r0, r0, #1
 80094ee:	f3ef 8110 	mrs	r1, PRIMASK
 80094f2:	b191      	cbz	r1, 800951a <osMutexAcquire+0x3e>
 80094f4:	4914      	ldr	r1, [pc, #80]	; (8009548 <osMutexAcquire+0x6c>)
 80094f6:	6809      	ldr	r1, [r1, #0]
 80094f8:	2902      	cmp	r1, #2
 80094fa:	d01e      	beq.n	800953a <osMutexAcquire+0x5e>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
 80094fc:	b302      	cbz	r2, 8009540 <osMutexAcquire+0x64>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
      if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
 80094fe:	4621      	mov	r1, r4
    if (rmtx != 0U) {
 8009500:	b9a0      	cbnz	r0, 800952c <osMutexAcquire+0x50>
          stat = osErrorResource;
        }
      }
    }
    else {
      if (xSemaphoreTake (hMutex, timeout) != pdPASS) {
 8009502:	4610      	mov	r0, r2
 8009504:	f001 f908 	bl	800a718 <xQueueSemaphoreTake>
 8009508:	2801      	cmp	r0, #1
 800950a:	d014      	beq.n	8009536 <osMutexAcquire+0x5a>
          stat = osErrorResource;
 800950c:	2c00      	cmp	r4, #0
 800950e:	bf14      	ite	ne
 8009510:	f06f 0001 	mvnne.w	r0, #1
 8009514:	f06f 0002 	mvneq.w	r0, #2
      }
    }
  }

  return (stat);
}
 8009518:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800951a:	f3ef 8111 	mrs	r1, BASEPRI
  if (IS_IRQ()) {
 800951e:	2900      	cmp	r1, #0
 8009520:	d0ec      	beq.n	80094fc <osMutexAcquire+0x20>
 8009522:	4909      	ldr	r1, [pc, #36]	; (8009548 <osMutexAcquire+0x6c>)
 8009524:	6809      	ldr	r1, [r1, #0]
 8009526:	2902      	cmp	r1, #2
 8009528:	d1e8      	bne.n	80094fc <osMutexAcquire+0x20>
 800952a:	e006      	b.n	800953a <osMutexAcquire+0x5e>
      if (xSemaphoreTakeRecursive (hMutex, timeout) != pdPASS) {
 800952c:	4610      	mov	r0, r2
 800952e:	f001 fa83 	bl	800aa38 <xQueueTakeMutexRecursive>
 8009532:	2801      	cmp	r0, #1
 8009534:	d1ea      	bne.n	800950c <osMutexAcquire+0x30>
  stat = osOK;
 8009536:	2000      	movs	r0, #0
}
 8009538:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 800953a:	f06f 0005 	mvn.w	r0, #5
}
 800953e:	bd10      	pop	{r4, pc}
    stat = osErrorParameter;
 8009540:	f06f 0003 	mvn.w	r0, #3
}
 8009544:	bd10      	pop	{r4, pc}
 8009546:	bf00      	nop
 8009548:	20019768 	.word	0x20019768

0800954c <osMutexRelease>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800954c:	f3ef 8205 	mrs	r2, IPSR

  rmtx = (uint32_t)mutex_id & 1U;

  stat = osOK;

  if (IS_IRQ()) {
 8009550:	bb6a      	cbnz	r2, 80095ae <osMutexRelease+0x62>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009552:	f000 0301 	and.w	r3, r0, #1
osStatus_t osMutexRelease (osMutexId_t mutex_id) {
 8009556:	b510      	push	{r4, lr}
 8009558:	f020 0401 	bic.w	r4, r0, #1
 800955c:	f3ef 8210 	mrs	r2, PRIMASK
  if (IS_IRQ()) {
 8009560:	b172      	cbz	r2, 8009580 <osMutexRelease+0x34>
 8009562:	4a14      	ldr	r2, [pc, #80]	; (80095b4 <osMutexRelease+0x68>)
 8009564:	6812      	ldr	r2, [r2, #0]
 8009566:	2a02      	cmp	r2, #2
 8009568:	d01b      	beq.n	80095a2 <osMutexRelease+0x56>
    stat = osErrorISR;
  }
  else if (hMutex == NULL) {
 800956a:	b1ec      	cbz	r4, 80095a8 <osMutexRelease+0x5c>
    stat = osErrorParameter;
  }
  else {
    if (rmtx != 0U) {
 800956c:	b98b      	cbnz	r3, 8009592 <osMutexRelease+0x46>
      if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
        stat = osErrorResource;
      }
    }
    else {
      if (xSemaphoreGive (hMutex) != pdPASS) {
 800956e:	461a      	mov	r2, r3
 8009570:	4619      	mov	r1, r3
 8009572:	4620      	mov	r0, r4
 8009574:	f000 fc3c 	bl	8009df0 <xQueueGenericSend>
 8009578:	2801      	cmp	r0, #1
 800957a:	d10f      	bne.n	800959c <osMutexRelease+0x50>
  stat = osOK;
 800957c:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 800957e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009580:	f3ef 8211 	mrs	r2, BASEPRI
  if (IS_IRQ()) {
 8009584:	2a00      	cmp	r2, #0
 8009586:	d0f0      	beq.n	800956a <osMutexRelease+0x1e>
 8009588:	4a0a      	ldr	r2, [pc, #40]	; (80095b4 <osMutexRelease+0x68>)
 800958a:	6812      	ldr	r2, [r2, #0]
 800958c:	2a02      	cmp	r2, #2
 800958e:	d1ec      	bne.n	800956a <osMutexRelease+0x1e>
 8009590:	e007      	b.n	80095a2 <osMutexRelease+0x56>
      if (xSemaphoreGiveRecursive (hMutex) != pdPASS) {
 8009592:	4620      	mov	r0, r4
 8009594:	f000 fe0a 	bl	800a1ac <xQueueGiveMutexRecursive>
 8009598:	2801      	cmp	r0, #1
 800959a:	d0ef      	beq.n	800957c <osMutexRelease+0x30>
        stat = osErrorResource;
 800959c:	f06f 0002 	mvn.w	r0, #2
}
 80095a0:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 80095a2:	f06f 0005 	mvn.w	r0, #5
}
 80095a6:	bd10      	pop	{r4, pc}
    stat = osErrorParameter;
 80095a8:	f06f 0003 	mvn.w	r0, #3
}
 80095ac:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 80095ae:	f06f 0005 	mvn.w	r0, #5
}
 80095b2:	4770      	bx	lr
 80095b4:	20019768 	.word	0x20019768

080095b8 <osSemaphoreNew>:
  return (stat);
}

/*---------------------------------------------------------------------------*/

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
 80095b8:	b570      	push	{r4, r5, r6, lr}
 80095ba:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80095bc:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hSemaphore = NULL;

  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 80095c0:	b9bb      	cbnz	r3, 80095f2 <osSemaphoreNew+0x3a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80095c2:	460e      	mov	r6, r1
 80095c4:	4615      	mov	r5, r2
 80095c6:	f3ef 8310 	mrs	r3, PRIMASK
 80095ca:	b9b3      	cbnz	r3, 80095fa <osSemaphoreNew+0x42>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80095cc:	f3ef 8311 	mrs	r3, BASEPRI
 80095d0:	b99b      	cbnz	r3, 80095fa <osSemaphoreNew+0x42>
 80095d2:	b170      	cbz	r0, 80095f2 <osSemaphoreNew+0x3a>
 80095d4:	42b0      	cmp	r0, r6
 80095d6:	d30c      	bcc.n	80095f2 <osSemaphoreNew+0x3a>
    mem = -1;

    if (attr != NULL) {
 80095d8:	b1b5      	cbz	r5, 8009608 <osSemaphoreNew+0x50>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 80095da:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 80095de:	b18a      	cbz	r2, 8009604 <osSemaphoreNew+0x4c>
 80095e0:	2b4f      	cmp	r3, #79	; 0x4f
 80095e2:	d906      	bls.n	80095f2 <osSemaphoreNew+0x3a>
    else {
      mem = 0;
    }

    if (mem != -1) {
      if (max_count == 1U) {
 80095e4:	2801      	cmp	r0, #1
 80095e6:	d036      	beq.n	8009656 <osSemaphoreNew+0x9e>
          }
        }
      }
      else {
        if (mem == 1) {
          hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
 80095e8:	4631      	mov	r1, r6
 80095ea:	f000 fb4d 	bl	8009c88 <xQueueCreateCountingSemaphoreStatic>
          hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
        }
      }
      
      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hSemaphore != NULL) {
 80095ee:	4604      	mov	r4, r0
 80095f0:	b998      	cbnz	r0, 800961a <osSemaphoreNew+0x62>
  hSemaphore = NULL;
 80095f2:	2400      	movs	r4, #0
      #endif
    }
  }

  return ((osSemaphoreId_t)hSemaphore);
}
 80095f4:	4620      	mov	r0, r4
 80095f6:	b002      	add	sp, #8
 80095f8:	bd70      	pop	{r4, r5, r6, pc}
  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 80095fa:	4b1b      	ldr	r3, [pc, #108]	; (8009668 <osSemaphoreNew+0xb0>)
 80095fc:	681b      	ldr	r3, [r3, #0]
 80095fe:	2b02      	cmp	r3, #2
 8009600:	d1e7      	bne.n	80095d2 <osSemaphoreNew+0x1a>
 8009602:	e7f6      	b.n	80095f2 <osSemaphoreNew+0x3a>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 8009604:	2b00      	cmp	r3, #0
 8009606:	d1f4      	bne.n	80095f2 <osSemaphoreNew+0x3a>
      if (max_count == 1U) {
 8009608:	2801      	cmp	r0, #1
 800960a:	d00e      	beq.n	800962a <osSemaphoreNew+0x72>
          hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
 800960c:	4631      	mov	r1, r6
 800960e:	f000 fba5 	bl	8009d5c <xQueueCreateCountingSemaphore>
 8009612:	4604      	mov	r4, r0
      if (hSemaphore != NULL) {
 8009614:	2c00      	cmp	r4, #0
 8009616:	d0ec      	beq.n	80095f2 <osSemaphoreNew+0x3a>
        if (attr != NULL) {
 8009618:	b105      	cbz	r5, 800961c <osSemaphoreNew+0x64>
          name = attr->name;
 800961a:	682d      	ldr	r5, [r5, #0]
        vQueueAddToRegistry (hSemaphore, name);
 800961c:	4620      	mov	r0, r4
 800961e:	4629      	mov	r1, r5
 8009620:	f001 fadc 	bl	800abdc <vQueueAddToRegistry>
}
 8009624:	4620      	mov	r0, r4
 8009626:	b002      	add	sp, #8
 8009628:	bd70      	pop	{r4, r5, r6, pc}
          hSemaphore = xSemaphoreCreateBinary();
 800962a:	2203      	movs	r2, #3
 800962c:	2100      	movs	r1, #0
 800962e:	f000 fadd 	bl	8009bec <xQueueGenericCreate>
 8009632:	4604      	mov	r4, r0
        if ((hSemaphore != NULL) && (initial_count != 0U)) {
 8009634:	2c00      	cmp	r4, #0
 8009636:	d0dc      	beq.n	80095f2 <osSemaphoreNew+0x3a>
 8009638:	2e00      	cmp	r6, #0
 800963a:	d0eb      	beq.n	8009614 <osSemaphoreNew+0x5c>
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
 800963c:	2300      	movs	r3, #0
 800963e:	4620      	mov	r0, r4
 8009640:	461a      	mov	r2, r3
 8009642:	4619      	mov	r1, r3
 8009644:	f000 fbd4 	bl	8009df0 <xQueueGenericSend>
 8009648:	2801      	cmp	r0, #1
 800964a:	d0e5      	beq.n	8009618 <osSemaphoreNew+0x60>
            vSemaphoreDelete (hSemaphore);
 800964c:	4620      	mov	r0, r4
            hSemaphore = NULL;
 800964e:	2400      	movs	r4, #0
            vSemaphoreDelete (hSemaphore);
 8009650:	f001 fa7a 	bl	800ab48 <vQueueDelete>
      if (hSemaphore != NULL) {
 8009654:	e7ce      	b.n	80095f4 <osSemaphoreNew+0x3c>
          hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
 8009656:	2103      	movs	r1, #3
 8009658:	4613      	mov	r3, r2
 800965a:	2200      	movs	r2, #0
 800965c:	9100      	str	r1, [sp, #0]
 800965e:	4611      	mov	r1, r2
 8009660:	f000 fa4e 	bl	8009b00 <xQueueGenericCreateStatic>
 8009664:	4604      	mov	r4, r0
 8009666:	e7e5      	b.n	8009634 <osSemaphoreNew+0x7c>
 8009668:	20019768 	.word	0x20019768

0800966c <osSemaphoreAcquire>:
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
 800966c:	2800      	cmp	r0, #0
 800966e:	d03a      	beq.n	80096e6 <osSemaphoreAcquire+0x7a>
osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout) {
 8009670:	b510      	push	{r4, lr}
 8009672:	460c      	mov	r4, r1
 8009674:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8009676:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
 800967a:	b163      	cbz	r3, 8009696 <osSemaphoreAcquire+0x2a>
    if (timeout != 0U) {
 800967c:	bb84      	cbnz	r4, 80096e0 <osSemaphoreAcquire+0x74>
      stat = osErrorParameter;
    }
    else {
      yield = pdFALSE;

      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
 800967e:	aa01      	add	r2, sp, #4
 8009680:	4621      	mov	r1, r4
      yield = pdFALSE;
 8009682:	9401      	str	r4, [sp, #4]
      if (xSemaphoreTakeFromISR (hSemaphore, &yield) != pdPASS) {
 8009684:	f001 f9fa 	bl	800aa7c <xQueueReceiveFromISR>
 8009688:	2801      	cmp	r0, #1
 800968a:	d125      	bne.n	80096d8 <osSemaphoreAcquire+0x6c>
        stat = osErrorResource;
      } else {
        portYIELD_FROM_ISR (yield);
 800968c:	9b01      	ldr	r3, [sp, #4]
 800968e:	b9b3      	cbnz	r3, 80096be <osSemaphoreAcquire+0x52>
  stat = osOK;
 8009690:	2000      	movs	r0, #0
      }
    }
  }

  return (stat);
}
 8009692:	b002      	add	sp, #8
 8009694:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009696:	f3ef 8310 	mrs	r3, PRIMASK
  else if (IS_IRQ()) {
 800969a:	b913      	cbnz	r3, 80096a2 <osSemaphoreAcquire+0x36>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800969c:	f3ef 8311 	mrs	r3, BASEPRI
 80096a0:	b11b      	cbz	r3, 80096aa <osSemaphoreAcquire+0x3e>
 80096a2:	4b12      	ldr	r3, [pc, #72]	; (80096ec <osSemaphoreAcquire+0x80>)
 80096a4:	681b      	ldr	r3, [r3, #0]
 80096a6:	2b02      	cmp	r3, #2
 80096a8:	d0e8      	beq.n	800967c <osSemaphoreAcquire+0x10>
    if (xSemaphoreTake (hSemaphore, (TickType_t)timeout) != pdPASS) {
 80096aa:	4621      	mov	r1, r4
 80096ac:	f001 f834 	bl	800a718 <xQueueSemaphoreTake>
 80096b0:	2801      	cmp	r0, #1
 80096b2:	d0ed      	beq.n	8009690 <osSemaphoreAcquire+0x24>
      if (timeout != 0U) {
 80096b4:	b184      	cbz	r4, 80096d8 <osSemaphoreAcquire+0x6c>
        stat = osErrorTimeout;
 80096b6:	f06f 0001 	mvn.w	r0, #1
}
 80096ba:	b002      	add	sp, #8
 80096bc:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
 80096be:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80096c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80096c6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80096ca:	f3bf 8f4f 	dsb	sy
 80096ce:	f3bf 8f6f 	isb	sy
  stat = osOK;
 80096d2:	4620      	mov	r0, r4
}
 80096d4:	b002      	add	sp, #8
 80096d6:	bd10      	pop	{r4, pc}
        stat = osErrorResource;
 80096d8:	f06f 0002 	mvn.w	r0, #2
}
 80096dc:	b002      	add	sp, #8
 80096de:	bd10      	pop	{r4, pc}
    stat = osErrorParameter;
 80096e0:	f06f 0003 	mvn.w	r0, #3
 80096e4:	e7d5      	b.n	8009692 <osSemaphoreAcquire+0x26>
 80096e6:	f06f 0003 	mvn.w	r0, #3
}
 80096ea:	4770      	bx	lr
 80096ec:	20019768 	.word	0x20019768

080096f0 <osSemaphoreRelease>:
  osStatus_t stat;
  BaseType_t yield;

  stat = osOK;

  if (hSemaphore == NULL) {
 80096f0:	2800      	cmp	r0, #0
 80096f2:	d037      	beq.n	8009764 <osSemaphoreRelease+0x74>
osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id) {
 80096f4:	b510      	push	{r4, lr}
 80096f6:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80096f8:	f3ef 8305 	mrs	r3, IPSR
    stat = osErrorParameter;
  }
  else if (IS_IRQ()) {
 80096fc:	b9c3      	cbnz	r3, 8009730 <osSemaphoreRelease+0x40>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80096fe:	f3ef 8310 	mrs	r3, PRIMASK
 8009702:	b16b      	cbz	r3, 8009720 <osSemaphoreRelease+0x30>
 8009704:	4b19      	ldr	r3, [pc, #100]	; (800976c <osSemaphoreRelease+0x7c>)
 8009706:	681b      	ldr	r3, [r3, #0]
 8009708:	2b02      	cmp	r3, #2
 800970a:	d011      	beq.n	8009730 <osSemaphoreRelease+0x40>
    } else {
      portYIELD_FROM_ISR (yield);
    }
  }
  else {
    if (xSemaphoreGive (hSemaphore) != pdPASS) {
 800970c:	2300      	movs	r3, #0
 800970e:	461a      	mov	r2, r3
 8009710:	4619      	mov	r1, r3
 8009712:	f000 fb6d 	bl	8009df0 <xQueueGenericSend>
 8009716:	2801      	cmp	r0, #1
 8009718:	d121      	bne.n	800975e <osSemaphoreRelease+0x6e>
  stat = osOK;
 800971a:	2000      	movs	r0, #0
      stat = osErrorResource;
    }
  }

  return (stat);
}
 800971c:	b002      	add	sp, #8
 800971e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009720:	f3ef 8311 	mrs	r3, BASEPRI
  else if (IS_IRQ()) {
 8009724:	2b00      	cmp	r3, #0
 8009726:	d0f1      	beq.n	800970c <osSemaphoreRelease+0x1c>
 8009728:	4b10      	ldr	r3, [pc, #64]	; (800976c <osSemaphoreRelease+0x7c>)
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	2b02      	cmp	r3, #2
 800972e:	d1ed      	bne.n	800970c <osSemaphoreRelease+0x1c>
    yield = pdFALSE;
 8009730:	2400      	movs	r4, #0
    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
 8009732:	a901      	add	r1, sp, #4
    yield = pdFALSE;
 8009734:	9401      	str	r4, [sp, #4]
    if (xSemaphoreGiveFromISR (hSemaphore, &yield) != pdTRUE) {
 8009736:	f000 fe05 	bl	800a344 <xQueueGiveFromISR>
 800973a:	2801      	cmp	r0, #1
 800973c:	d10f      	bne.n	800975e <osSemaphoreRelease+0x6e>
      portYIELD_FROM_ISR (yield);
 800973e:	9b01      	ldr	r3, [sp, #4]
 8009740:	2b00      	cmp	r3, #0
 8009742:	d0ea      	beq.n	800971a <osSemaphoreRelease+0x2a>
 8009744:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8009748:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800974c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8009750:	f3bf 8f4f 	dsb	sy
 8009754:	f3bf 8f6f 	isb	sy
  stat = osOK;
 8009758:	4620      	mov	r0, r4
}
 800975a:	b002      	add	sp, #8
 800975c:	bd10      	pop	{r4, pc}
      stat = osErrorResource;
 800975e:	f06f 0002 	mvn.w	r0, #2
 8009762:	e7db      	b.n	800971c <osSemaphoreRelease+0x2c>
    stat = osErrorParameter;
 8009764:	f06f 0003 	mvn.w	r0, #3
}
 8009768:	4770      	bx	lr
 800976a:	bf00      	nop
 800976c:	20019768 	.word	0x20019768

08009770 <osSemaphoreDelete>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8009770:	f3ef 8305 	mrs	r3, IPSR
osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
  SemaphoreHandle_t hSemaphore = (SemaphoreHandle_t)semaphore_id;
  osStatus_t stat;

#ifndef USE_FreeRTOS_HEAP_1
  if (IS_IRQ()) {
 8009774:	b9fb      	cbnz	r3, 80097b6 <osSemaphoreDelete+0x46>
osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id) {
 8009776:	b510      	push	{r4, lr}
 8009778:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800977a:	f3ef 8310 	mrs	r3, PRIMASK
  if (IS_IRQ()) {
 800977e:	b163      	cbz	r3, 800979a <osSemaphoreDelete+0x2a>
 8009780:	4b0e      	ldr	r3, [pc, #56]	; (80097bc <osSemaphoreDelete+0x4c>)
 8009782:	681b      	ldr	r3, [r3, #0]
 8009784:	2b02      	cmp	r3, #2
 8009786:	d010      	beq.n	80097aa <osSemaphoreDelete+0x3a>
    stat = osErrorISR;
  }
  else if (hSemaphore == NULL) {
 8009788:	b194      	cbz	r4, 80097b0 <osSemaphoreDelete+0x40>
    stat = osErrorParameter;
  }
  else {
    #if (configQUEUE_REGISTRY_SIZE > 0)
    vQueueUnregisterQueue (hSemaphore);
 800978a:	4620      	mov	r0, r4
 800978c:	f001 fa4e 	bl	800ac2c <vQueueUnregisterQueue>
    #endif

    stat = osOK;
    vSemaphoreDelete (hSemaphore);
 8009790:	4620      	mov	r0, r4
 8009792:	f001 f9d9 	bl	800ab48 <vQueueDelete>
    stat = osOK;
 8009796:	2000      	movs	r0, #0
#else
  stat = osError;
#endif

  return (stat);
}
 8009798:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800979a:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 800979e:	2b00      	cmp	r3, #0
 80097a0:	d0f2      	beq.n	8009788 <osSemaphoreDelete+0x18>
 80097a2:	4b06      	ldr	r3, [pc, #24]	; (80097bc <osSemaphoreDelete+0x4c>)
 80097a4:	681b      	ldr	r3, [r3, #0]
 80097a6:	2b02      	cmp	r3, #2
 80097a8:	d1ee      	bne.n	8009788 <osSemaphoreDelete+0x18>
    stat = osErrorISR;
 80097aa:	f06f 0005 	mvn.w	r0, #5
}
 80097ae:	bd10      	pop	{r4, pc}
    stat = osErrorParameter;
 80097b0:	f06f 0003 	mvn.w	r0, #3
}
 80097b4:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 80097b6:	f06f 0005 	mvn.w	r0, #5
}
 80097ba:	4770      	bx	lr
 80097bc:	20019768 	.word	0x20019768

080097c0 <osMessageQueueNew>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80097c0:	f3ef 8305 	mrs	r3, IPSR
  const char *name;
  #endif

  hQueue = NULL;

  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 80097c4:	b9fb      	cbnz	r3, 8009806 <osMessageQueueNew+0x46>
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr) {
 80097c6:	b530      	push	{r4, r5, lr}
 80097c8:	4614      	mov	r4, r2
 80097ca:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80097cc:	f3ef 8310 	mrs	r3, PRIMASK
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 80097d0:	b9a3      	cbnz	r3, 80097fc <osMessageQueueNew+0x3c>
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80097d2:	f3ef 8311 	mrs	r3, BASEPRI
 80097d6:	b98b      	cbnz	r3, 80097fc <osMessageQueueNew+0x3c>
 80097d8:	b168      	cbz	r0, 80097f6 <osMessageQueueNew+0x36>
 80097da:	b161      	cbz	r1, 80097f6 <osMessageQueueNew+0x36>
    mem = -1;

    if (attr != NULL) {
 80097dc:	b1ac      	cbz	r4, 800980a <osMessageQueueNew+0x4a>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 80097de:	68a3      	ldr	r3, [r4, #8]
 80097e0:	b1fb      	cbz	r3, 8009822 <osMessageQueueNew+0x62>
 80097e2:	68e2      	ldr	r2, [r4, #12]
 80097e4:	2a4f      	cmp	r2, #79	; 0x4f
 80097e6:	d906      	bls.n	80097f6 <osMessageQueueNew+0x36>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 80097e8:	6922      	ldr	r2, [r4, #16]
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticQueue_t)) &&
 80097ea:	b122      	cbz	r2, 80097f6 <osMessageQueueNew+0x36>
          (attr->mq_mem != NULL) && (attr->mq_size >= (msg_count * msg_size))) {
 80097ec:	fb01 fc00 	mul.w	ip, r1, r0
 80097f0:	6965      	ldr	r5, [r4, #20]
 80097f2:	4565      	cmp	r5, ip
 80097f4:	d224      	bcs.n	8009840 <osMessageQueueNew+0x80>
  hQueue = NULL;
 80097f6:	2000      	movs	r0, #0
    #endif

  }

  return ((osMessageQueueId_t)hQueue);
}
 80097f8:	b005      	add	sp, #20
 80097fa:	bd30      	pop	{r4, r5, pc}
  if (!IS_IRQ() && (msg_count > 0U) && (msg_size > 0U)) {
 80097fc:	4b14      	ldr	r3, [pc, #80]	; (8009850 <osMessageQueueNew+0x90>)
 80097fe:	681b      	ldr	r3, [r3, #0]
 8009800:	2b02      	cmp	r3, #2
 8009802:	d1e9      	bne.n	80097d8 <osMessageQueueNew+0x18>
 8009804:	e7f7      	b.n	80097f6 <osMessageQueueNew+0x36>
  hQueue = NULL;
 8009806:	2000      	movs	r0, #0
}
 8009808:	4770      	bx	lr
        hQueue = xQueueCreate (msg_count, msg_size);
 800980a:	4622      	mov	r2, r4
 800980c:	f000 f9ee 	bl	8009bec <xQueueGenericCreate>
    if (hQueue != NULL) {
 8009810:	2800      	cmp	r0, #0
 8009812:	d0f0      	beq.n	80097f6 <osMessageQueueNew+0x36>
      vQueueAddToRegistry (hQueue, name);
 8009814:	4621      	mov	r1, r4
 8009816:	9003      	str	r0, [sp, #12]
 8009818:	f001 f9e0 	bl	800abdc <vQueueAddToRegistry>
  return ((osMessageQueueId_t)hQueue);
 800981c:	9803      	ldr	r0, [sp, #12]
}
 800981e:	b005      	add	sp, #20
 8009820:	bd30      	pop	{r4, r5, pc}
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) &&
 8009822:	68e3      	ldr	r3, [r4, #12]
 8009824:	2b00      	cmp	r3, #0
 8009826:	d1e6      	bne.n	80097f6 <osMessageQueueNew+0x36>
 8009828:	6923      	ldr	r3, [r4, #16]
 800982a:	2b00      	cmp	r3, #0
 800982c:	d1e3      	bne.n	80097f6 <osMessageQueueNew+0x36>
            (attr->mq_mem == NULL) && (attr->mq_size == 0U)) {
 800982e:	6962      	ldr	r2, [r4, #20]
 8009830:	2a00      	cmp	r2, #0
 8009832:	d1e0      	bne.n	80097f6 <osMessageQueueNew+0x36>
        hQueue = xQueueCreate (msg_count, msg_size);
 8009834:	f000 f9da 	bl	8009bec <xQueueGenericCreate>
    if (hQueue != NULL) {
 8009838:	2800      	cmp	r0, #0
 800983a:	d0dc      	beq.n	80097f6 <osMessageQueueNew+0x36>
        name = attr->name;
 800983c:	6824      	ldr	r4, [r4, #0]
 800983e:	e7e9      	b.n	8009814 <osMessageQueueNew+0x54>
      hQueue = xQueueCreateStatic (msg_count, msg_size, attr->mq_mem, attr->cb_mem);
 8009840:	2500      	movs	r5, #0
 8009842:	9500      	str	r5, [sp, #0]
 8009844:	f000 f95c 	bl	8009b00 <xQueueGenericCreateStatic>
    if (hQueue != NULL) {
 8009848:	2800      	cmp	r0, #0
 800984a:	d1f7      	bne.n	800983c <osMessageQueueNew+0x7c>
 800984c:	e7d3      	b.n	80097f6 <osMessageQueueNew+0x36>
 800984e:	bf00      	nop
 8009850:	20019768 	.word	0x20019768

08009854 <osMessageQueuePut>:

osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout) {
 8009854:	b510      	push	{r4, lr}
 8009856:	461c      	mov	r4, r3
 8009858:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800985a:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 800985e:	b9cb      	cbnz	r3, 8009894 <osMessageQueuePut+0x40>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009860:	f3ef 8310 	mrs	r3, PRIMASK
 8009864:	2b00      	cmp	r3, #0
 8009866:	d03a      	beq.n	80098de <osMessageQueuePut+0x8a>
 8009868:	4b25      	ldr	r3, [pc, #148]	; (8009900 <osMessageQueuePut+0xac>)
 800986a:	681b      	ldr	r3, [r3, #0]
 800986c:	2b02      	cmp	r3, #2
 800986e:	d011      	beq.n	8009894 <osMessageQueuePut+0x40>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 8009870:	2800      	cmp	r0, #0
 8009872:	d041      	beq.n	80098f8 <osMessageQueuePut+0xa4>
 8009874:	fab1 f381 	clz	r3, r1
 8009878:	095b      	lsrs	r3, r3, #5
 800987a:	2900      	cmp	r1, #0
 800987c:	d03c      	beq.n	80098f8 <osMessageQueuePut+0xa4>
      stat = osErrorParameter;
    }
    else {
      if (xQueueSendToBack (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 800987e:	4622      	mov	r2, r4
 8009880:	f000 fab6 	bl	8009df0 <xQueueGenericSend>
 8009884:	2801      	cmp	r0, #1
 8009886:	d01a      	beq.n	80098be <osMessageQueuePut+0x6a>
        if (timeout != 0U) {
 8009888:	2c00      	cmp	r4, #0
 800988a:	d031      	beq.n	80098f0 <osMessageQueuePut+0x9c>
          stat = osErrorTimeout;
 800988c:	f06f 0001 	mvn.w	r0, #1
      }
    }
  }

  return (stat);
}
 8009890:	b002      	add	sp, #8
 8009892:	bd10      	pop	{r4, pc}
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 8009894:	3c00      	subs	r4, #0
 8009896:	bf18      	it	ne
 8009898:	2401      	movne	r4, #1
 800989a:	2900      	cmp	r1, #0
 800989c:	bf08      	it	eq
 800989e:	f044 0401 	orreq.w	r4, r4, #1
 80098a2:	bb4c      	cbnz	r4, 80098f8 <osMessageQueuePut+0xa4>
 80098a4:	fab0 f480 	clz	r4, r0
 80098a8:	0964      	lsrs	r4, r4, #5
 80098aa:	b328      	cbz	r0, 80098f8 <osMessageQueuePut+0xa4>
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 80098ac:	4623      	mov	r3, r4
 80098ae:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 80098b0:	9401      	str	r4, [sp, #4]
      if (xQueueSendToBackFromISR (hQueue, msg_ptr, &yield) != pdTRUE) {
 80098b2:	f000 fcd5 	bl	800a260 <xQueueGenericSendFromISR>
 80098b6:	2801      	cmp	r0, #1
 80098b8:	d11a      	bne.n	80098f0 <osMessageQueuePut+0x9c>
        portYIELD_FROM_ISR (yield);
 80098ba:	9b01      	ldr	r3, [sp, #4]
 80098bc:	b913      	cbnz	r3, 80098c4 <osMessageQueuePut+0x70>
  stat = osOK;
 80098be:	2000      	movs	r0, #0
}
 80098c0:	b002      	add	sp, #8
 80098c2:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
 80098c4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80098c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80098cc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80098d0:	f3bf 8f4f 	dsb	sy
 80098d4:	f3bf 8f6f 	isb	sy
  stat = osOK;
 80098d8:	4620      	mov	r0, r4
}
 80098da:	b002      	add	sp, #8
 80098dc:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80098de:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80098e2:	2b00      	cmp	r3, #0
 80098e4:	d0c4      	beq.n	8009870 <osMessageQueuePut+0x1c>
 80098e6:	4b06      	ldr	r3, [pc, #24]	; (8009900 <osMessageQueuePut+0xac>)
 80098e8:	681b      	ldr	r3, [r3, #0]
 80098ea:	2b02      	cmp	r3, #2
 80098ec:	d1c0      	bne.n	8009870 <osMessageQueuePut+0x1c>
 80098ee:	e7d1      	b.n	8009894 <osMessageQueuePut+0x40>
          stat = osErrorResource;
 80098f0:	f06f 0002 	mvn.w	r0, #2
}
 80098f4:	b002      	add	sp, #8
 80098f6:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 80098f8:	f06f 0003 	mvn.w	r0, #3
 80098fc:	e7e0      	b.n	80098c0 <osMessageQueuePut+0x6c>
 80098fe:	bf00      	nop
 8009900:	20019768 	.word	0x20019768

08009904 <osMessageQueueGet>:

osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout) {
 8009904:	b510      	push	{r4, lr}
 8009906:	461c      	mov	r4, r3
 8009908:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800990a:	f3ef 8305 	mrs	r3, IPSR

  (void)msg_prio; /* Message priority is ignored */

  stat = osOK;

  if (IS_IRQ()) {
 800990e:	b9ab      	cbnz	r3, 800993c <osMessageQueueGet+0x38>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8009910:	f3ef 8310 	mrs	r3, PRIMASK
 8009914:	2b00      	cmp	r3, #0
 8009916:	d035      	beq.n	8009984 <osMessageQueueGet+0x80>
 8009918:	4b22      	ldr	r3, [pc, #136]	; (80099a4 <osMessageQueueGet+0xa0>)
 800991a:	681b      	ldr	r3, [r3, #0]
 800991c:	2b02      	cmp	r3, #2
 800991e:	d00d      	beq.n	800993c <osMessageQueueGet+0x38>
        portYIELD_FROM_ISR (yield);
      }
    }
  }
  else {
    if ((hQueue == NULL) || (msg_ptr == NULL)) {
 8009920:	2800      	cmp	r0, #0
 8009922:	d03c      	beq.n	800999e <osMessageQueueGet+0x9a>
 8009924:	2900      	cmp	r1, #0
 8009926:	d03a      	beq.n	800999e <osMessageQueueGet+0x9a>
      stat = osErrorParameter;
    }
    else {
      if (xQueueReceive (hQueue, msg_ptr, (TickType_t)timeout) != pdPASS) {
 8009928:	4622      	mov	r2, r4
 800992a:	f000 fd6b 	bl	800a404 <xQueueReceive>
 800992e:	2801      	cmp	r0, #1
 8009930:	d018      	beq.n	8009964 <osMessageQueueGet+0x60>
        if (timeout != 0U) {
 8009932:	b384      	cbz	r4, 8009996 <osMessageQueueGet+0x92>
          stat = osErrorTimeout;
 8009934:	f06f 0001 	mvn.w	r0, #1
      }
    }
  }

  return (stat);
}
 8009938:	b002      	add	sp, #8
 800993a:	bd10      	pop	{r4, pc}
    if ((hQueue == NULL) || (msg_ptr == NULL) || (timeout != 0U)) {
 800993c:	3c00      	subs	r4, #0
 800993e:	bf18      	it	ne
 8009940:	2401      	movne	r4, #1
 8009942:	2900      	cmp	r1, #0
 8009944:	bf08      	it	eq
 8009946:	f044 0401 	orreq.w	r4, r4, #1
 800994a:	bb44      	cbnz	r4, 800999e <osMessageQueueGet+0x9a>
 800994c:	fab0 f480 	clz	r4, r0
 8009950:	0964      	lsrs	r4, r4, #5
 8009952:	b320      	cbz	r0, 800999e <osMessageQueueGet+0x9a>
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 8009954:	aa01      	add	r2, sp, #4
      yield = pdFALSE;
 8009956:	9401      	str	r4, [sp, #4]
      if (xQueueReceiveFromISR (hQueue, msg_ptr, &yield) != pdPASS) {
 8009958:	f001 f890 	bl	800aa7c <xQueueReceiveFromISR>
 800995c:	2801      	cmp	r0, #1
 800995e:	d11a      	bne.n	8009996 <osMessageQueueGet+0x92>
        portYIELD_FROM_ISR (yield);
 8009960:	9b01      	ldr	r3, [sp, #4]
 8009962:	b913      	cbnz	r3, 800996a <osMessageQueueGet+0x66>
  stat = osOK;
 8009964:	2000      	movs	r0, #0
}
 8009966:	b002      	add	sp, #8
 8009968:	bd10      	pop	{r4, pc}
        portYIELD_FROM_ISR (yield);
 800996a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800996e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009972:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8009976:	f3bf 8f4f 	dsb	sy
 800997a:	f3bf 8f6f 	isb	sy
  stat = osOK;
 800997e:	4620      	mov	r0, r4
}
 8009980:	b002      	add	sp, #8
 8009982:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009984:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 8009988:	2b00      	cmp	r3, #0
 800998a:	d0c9      	beq.n	8009920 <osMessageQueueGet+0x1c>
 800998c:	4b05      	ldr	r3, [pc, #20]	; (80099a4 <osMessageQueueGet+0xa0>)
 800998e:	681b      	ldr	r3, [r3, #0]
 8009990:	2b02      	cmp	r3, #2
 8009992:	d1c5      	bne.n	8009920 <osMessageQueueGet+0x1c>
 8009994:	e7d2      	b.n	800993c <osMessageQueueGet+0x38>
          stat = osErrorResource;
 8009996:	f06f 0002 	mvn.w	r0, #2
}
 800999a:	b002      	add	sp, #8
 800999c:	bd10      	pop	{r4, pc}
      stat = osErrorParameter;
 800999e:	f06f 0003 	mvn.w	r0, #3
 80099a2:	e7e0      	b.n	8009966 <osMessageQueueGet+0x62>
 80099a4:	20019768 	.word	0x20019768

080099a8 <vApplicationGetIdleTaskMemory>:
/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 80099a8:	4b04      	ldr	r3, [pc, #16]	; (80099bc <vApplicationGetIdleTaskMemory+0x14>)
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 80099aa:	b410      	push	{r4}
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 80099ac:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 80099ae:	2380      	movs	r3, #128	; 0x80
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 80099b0:	4c03      	ldr	r4, [pc, #12]	; (80099c0 <vApplicationGetIdleTaskMemory+0x18>)
 80099b2:	600c      	str	r4, [r1, #0]
}
 80099b4:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 80099b8:	6013      	str	r3, [r2, #0]
}
 80099ba:	4770      	bx	lr
 80099bc:	20019708 	.word	0x20019708
 80099c0:	20019508 	.word	0x20019508

080099c4 <vApplicationGetTimerTaskMemory>:
/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 80099c4:	4b05      	ldr	r3, [pc, #20]	; (80099dc <vApplicationGetTimerTaskMemory+0x18>)
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 80099c6:	b410      	push	{r4}
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 80099c8:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 80099ca:	f44f 7300 	mov.w	r3, #512	; 0x200
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 80099ce:	4c04      	ldr	r4, [pc, #16]	; (80099e0 <vApplicationGetTimerTaskMemory+0x1c>)
 80099d0:	600c      	str	r4, [r1, #0]
}
 80099d2:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 80099d6:	6013      	str	r3, [r2, #0]
}
 80099d8:	4770      	bx	lr
 80099da:	bf00      	nop
 80099dc:	20019f6c 	.word	0x20019f6c
 80099e0:	2001976c 	.word	0x2001976c

080099e4 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80099e4:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80099e8:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80099ec:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80099ee:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80099f0:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80099f2:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80099f4:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 80099f8:	4770      	bx	lr
 80099fa:	bf00      	nop

080099fc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 80099fc:	2300      	movs	r3, #0
 80099fe:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8009a00:	4770      	bx	lr
 8009a02:	bf00      	nop

08009a04 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8009a04:	6843      	ldr	r3, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 8009a06:	6802      	ldr	r2, [r0, #0]
{
 8009a08:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8009a0a:	689c      	ldr	r4, [r3, #8]
	( pxList->uxNumberOfItems )++;
 8009a0c:	3201      	adds	r2, #1
	pxNewListItem->pxNext = pxIndex;
 8009a0e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8009a10:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8009a12:	689c      	ldr	r4, [r3, #8]
 8009a14:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8009a16:	6099      	str	r1, [r3, #8]
}
 8009a18:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 8009a1c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8009a1e:	6002      	str	r2, [r0, #0]
}
 8009a20:	4770      	bx	lr
 8009a22:	bf00      	nop

08009a24 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8009a24:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8009a26:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8009a28:	1c6b      	adds	r3, r5, #1
 8009a2a:	d010      	beq.n	8009a4e <vListInsert+0x2a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8009a2c:	f100 0308 	add.w	r3, r0, #8
 8009a30:	461c      	mov	r4, r3
 8009a32:	685b      	ldr	r3, [r3, #4]
 8009a34:	681a      	ldr	r2, [r3, #0]
 8009a36:	42aa      	cmp	r2, r5
 8009a38:	d9fa      	bls.n	8009a30 <vListInsert+0xc>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 8009a3a:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8009a3c:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8009a3e:	3201      	adds	r2, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8009a40:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8009a42:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8009a44:	6061      	str	r1, [r4, #4]
	pxNewListItem->pxContainer = pxList;
 8009a46:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8009a48:	6002      	str	r2, [r0, #0]
}
 8009a4a:	bc30      	pop	{r4, r5}
 8009a4c:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8009a4e:	6904      	ldr	r4, [r0, #16]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8009a50:	6863      	ldr	r3, [r4, #4]
 8009a52:	e7f2      	b.n	8009a3a <vListInsert+0x16>

08009a54 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8009a54:	6903      	ldr	r3, [r0, #16]
{
 8009a56:	b410      	push	{r4}

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8009a58:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8009a5a:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	if( pxList->pxIndex == pxItemToRemove )
 8009a5e:	4284      	cmp	r4, r0

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;

	return pxList->uxNumberOfItems;
}
 8009a60:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8009a64:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8009a66:	6051      	str	r1, [r2, #4]
	pxItemToRemove->pxContainer = NULL;
 8009a68:	f04f 0100 	mov.w	r1, #0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8009a6c:	bf08      	it	eq
 8009a6e:	605a      	streq	r2, [r3, #4]
	( pxList->uxNumberOfItems )--;
 8009a70:	681a      	ldr	r2, [r3, #0]
	pxItemToRemove->pxContainer = NULL;
 8009a72:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8009a74:	3a01      	subs	r2, #1
 8009a76:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 8009a78:	6818      	ldr	r0, [r3, #0]
}
 8009a7a:	4770      	bx	lr

08009a7c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8009a7c:	b570      	push	{r4, r5, r6, lr}
 8009a7e:	4615      	mov	r5, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8009a80:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8009a82:	4604      	mov	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8009a84:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8009a86:	b92a      	cbnz	r2, 8009a94 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8009a88:	6805      	ldr	r5, [r0, #0]
 8009a8a:	b365      	cbz	r5, 8009ae6 <prvCopyDataToQueue+0x6a>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009a8c:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 8009a8e:	4610      	mov	r0, r2
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009a90:	63a6      	str	r6, [r4, #56]	; 0x38

	return xReturn;
}
 8009a92:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8009a94:	b97d      	cbnz	r5, 8009ab6 <prvCopyDataToQueue+0x3a>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8009a96:	6840      	ldr	r0, [r0, #4]
 8009a98:	f009 fb46 	bl	8013128 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8009a9c:	6863      	ldr	r3, [r4, #4]
 8009a9e:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009aa0:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8009aa2:	68a2      	ldr	r2, [r4, #8]
 8009aa4:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8009aa6:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8009aa8:	d319      	bcc.n	8009ade <prvCopyDataToQueue+0x62>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8009aaa:	6822      	ldr	r2, [r4, #0]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009aac:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 8009aae:	4628      	mov	r0, r5
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8009ab0:	6062      	str	r2, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ab2:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8009ab4:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8009ab6:	68c0      	ldr	r0, [r0, #12]
 8009ab8:	f009 fb36 	bl	8013128 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8009abc:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009abe:	68e3      	ldr	r3, [r4, #12]
 8009ac0:	4251      	negs	r1, r2
 8009ac2:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8009ac4:	6822      	ldr	r2, [r4, #0]
 8009ac6:	4293      	cmp	r3, r2
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8009ac8:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8009aca:	d202      	bcs.n	8009ad2 <prvCopyDataToQueue+0x56>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8009acc:	68a3      	ldr	r3, [r4, #8]
 8009ace:	440b      	add	r3, r1
 8009ad0:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8009ad2:	2d02      	cmp	r5, #2
 8009ad4:	d00d      	beq.n	8009af2 <prvCopyDataToQueue+0x76>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ad6:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 8009ad8:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ada:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8009adc:	bd70      	pop	{r4, r5, r6, pc}
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ade:	3601      	adds	r6, #1
BaseType_t xReturn = pdFALSE;
 8009ae0:	4628      	mov	r0, r5
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ae2:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8009ae4:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8009ae6:	6880      	ldr	r0, [r0, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8009ae8:	3601      	adds	r6, #1
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8009aea:	f001 ffe9 	bl	800bac0 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8009aee:	60a5      	str	r5, [r4, #8]
 8009af0:	e7ce      	b.n	8009a90 <prvCopyDataToQueue+0x14>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8009af2:	2e01      	cmp	r6, #1
BaseType_t xReturn = pdFALSE;
 8009af4:	f04f 0000 	mov.w	r0, #0
 8009af8:	bf38      	it	cc
 8009afa:	2601      	movcc	r6, #1
 8009afc:	e7c8      	b.n	8009a90 <prvCopyDataToQueue+0x14>
 8009afe:	bf00      	nop

08009b00 <xQueueGenericCreateStatic>:
	{
 8009b00:	b530      	push	{r4, r5, lr}
 8009b02:	b083      	sub	sp, #12
 8009b04:	f89d 4018 	ldrb.w	r4, [sp, #24]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8009b08:	b950      	cbnz	r0, 8009b20 <xQueueGenericCreateStatic+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8009b0a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b0e:	b672      	cpsid	i
 8009b10:	f383 8811 	msr	BASEPRI, r3
 8009b14:	f3bf 8f6f 	isb	sy
 8009b18:	f3bf 8f4f 	dsb	sy
 8009b1c:	b662      	cpsie	i
 8009b1e:	e7fe      	b.n	8009b1e <xQueueGenericCreateStatic+0x1e>
		configASSERT( pxStaticQueue != NULL );
 8009b20:	461d      	mov	r5, r3
 8009b22:	b163      	cbz	r3, 8009b3e <xQueueGenericCreateStatic+0x3e>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 8009b24:	b33a      	cbz	r2, 8009b76 <xQueueGenericCreateStatic+0x76>
 8009b26:	b9a9      	cbnz	r1, 8009b54 <xQueueGenericCreateStatic+0x54>
 8009b28:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b2c:	b672      	cpsid	i
 8009b2e:	f383 8811 	msr	BASEPRI, r3
 8009b32:	f3bf 8f6f 	isb	sy
 8009b36:	f3bf 8f4f 	dsb	sy
 8009b3a:	b662      	cpsie	i
 8009b3c:	e7fe      	b.n	8009b3c <xQueueGenericCreateStatic+0x3c>
 8009b3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b42:	b672      	cpsid	i
 8009b44:	f383 8811 	msr	BASEPRI, r3
 8009b48:	f3bf 8f6f 	isb	sy
 8009b4c:	f3bf 8f4f 	dsb	sy
 8009b50:	b662      	cpsie	i
		configASSERT( pxStaticQueue != NULL );
 8009b52:	e7fe      	b.n	8009b52 <xQueueGenericCreateStatic+0x52>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8009b54:	b17a      	cbz	r2, 8009b76 <xQueueGenericCreateStatic+0x76>
			volatile size_t xSize = sizeof( StaticQueue_t );
 8009b56:	2350      	movs	r3, #80	; 0x50
 8009b58:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 8009b5a:	9b01      	ldr	r3, [sp, #4]
 8009b5c:	2b50      	cmp	r3, #80	; 0x50
 8009b5e:	d017      	beq.n	8009b90 <xQueueGenericCreateStatic+0x90>
 8009b60:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b64:	b672      	cpsid	i
 8009b66:	f383 8811 	msr	BASEPRI, r3
 8009b6a:	f3bf 8f6f 	isb	sy
 8009b6e:	f3bf 8f4f 	dsb	sy
 8009b72:	b662      	cpsie	i
 8009b74:	e7fe      	b.n	8009b74 <xQueueGenericCreateStatic+0x74>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 8009b76:	2900      	cmp	r1, #0
 8009b78:	d0ed      	beq.n	8009b56 <xQueueGenericCreateStatic+0x56>
 8009b7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009b7e:	b672      	cpsid	i
 8009b80:	f383 8811 	msr	BASEPRI, r3
 8009b84:	f3bf 8f6f 	isb	sy
 8009b88:	f3bf 8f4f 	dsb	sy
 8009b8c:	b662      	cpsie	i
 8009b8e:	e7fe      	b.n	8009b8e <xQueueGenericCreateStatic+0x8e>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8009b90:	2900      	cmp	r1, #0
 8009b92:	bf08      	it	eq
 8009b94:	462a      	moveq	r2, r5
	pxNewQueue->uxLength = uxQueueLength;
 8009b96:	63e8      	str	r0, [r5, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8009b98:	6429      	str	r1, [r5, #64]	; 0x40
 8009b9a:	602a      	str	r2, [r5, #0]
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8009b9c:	9a01      	ldr	r2, [sp, #4]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8009b9e:	2201      	movs	r2, #1
 8009ba0:	f885 2046 	strb.w	r2, [r5, #70]	; 0x46
	taskENTER_CRITICAL();
 8009ba4:	f002 faa6 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009ba8:	6829      	ldr	r1, [r5, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009baa:	2300      	movs	r3, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8009bac:	6069      	str	r1, [r5, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009bae:	63ab      	str	r3, [r5, #56]	; 0x38
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bb0:	e9d5 200f 	ldrd	r2, r0, [r5, #60]	; 0x3c
 8009bb4:	fb00 f202 	mul.w	r2, r0, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bb8:	1a10      	subs	r0, r2, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bba:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bbc:	4401      	add	r1, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bbe:	60aa      	str	r2, [r5, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 8009bc0:	22ff      	movs	r2, #255	; 0xff
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009bc2:	f105 0010 	add.w	r0, r5, #16
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009bc6:	60e9      	str	r1, [r5, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8009bc8:	f885 2044 	strb.w	r2, [r5, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8009bcc:	f885 2045 	strb.w	r2, [r5, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009bd0:	f7ff ff08 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009bd4:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8009bd8:	f7ff ff04 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 8009bdc:	f002 fab0 	bl	800c140 <vPortExitCritical>
	}
 8009be0:	4628      	mov	r0, r5
		pxNewQueue->ucQueueType = ucQueueType;
 8009be2:	f885 404c 	strb.w	r4, [r5, #76]	; 0x4c
	}
 8009be6:	b003      	add	sp, #12
 8009be8:	bd30      	pop	{r4, r5, pc}
 8009bea:	bf00      	nop

08009bec <xQueueGenericCreate>:
	{
 8009bec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8009bee:	b950      	cbnz	r0, 8009c06 <xQueueGenericCreate+0x1a>
 8009bf0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009bf4:	b672      	cpsid	i
 8009bf6:	f383 8811 	msr	BASEPRI, r3
 8009bfa:	f3bf 8f6f 	isb	sy
 8009bfe:	f3bf 8f4f 	dsb	sy
 8009c02:	b662      	cpsie	i
 8009c04:	e7fe      	b.n	8009c04 <xQueueGenericCreate+0x18>
 8009c06:	460e      	mov	r6, r1
 8009c08:	4605      	mov	r5, r0
 8009c0a:	4617      	mov	r7, r2
		if( uxItemSize == ( UBaseType_t ) 0 )
 8009c0c:	bb59      	cbnz	r1, 8009c66 <xQueueGenericCreate+0x7a>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8009c0e:	2050      	movs	r0, #80	; 0x50
 8009c10:	f002 fbc2 	bl	800c398 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8009c14:	4604      	mov	r4, r0
 8009c16:	b3a0      	cbz	r0, 8009c82 <xQueueGenericCreate+0x96>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8009c18:	f884 6046 	strb.w	r6, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8009c1c:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
 8009c1e:	e9c4 560f 	strd	r5, r6, [r4, #60]	; 0x3c
	taskENTER_CRITICAL();
 8009c22:	f002 fa67 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c26:	6822      	ldr	r2, [r4, #0]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009c28:	f104 0010 	add.w	r0, r4, #16
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8009c2c:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c2e:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
 8009c32:	fb01 f303 	mul.w	r3, r1, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c36:	1a59      	subs	r1, r3, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c38:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c3a:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c3c:	60a3      	str	r3, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009c3e:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 8009c40:	23ff      	movs	r3, #255	; 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c42:	60e2      	str	r2, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009c44:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 8009c46:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8009c4a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009c4e:	f7ff fec9 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009c52:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8009c56:	f7ff fec5 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 8009c5a:	f002 fa71 	bl	800c140 <vPortExitCritical>
	}
 8009c5e:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
 8009c60:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
 8009c64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8009c66:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8009c6a:	3050      	adds	r0, #80	; 0x50
 8009c6c:	f002 fb94 	bl	800c398 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8009c70:	4604      	mov	r4, r0
 8009c72:	b130      	cbz	r0, 8009c82 <xQueueGenericCreate+0x96>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8009c74:	2300      	movs	r3, #0
 8009c76:	f880 3046 	strb.w	r3, [r0, #70]	; 0x46
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009c7a:	f100 0350 	add.w	r3, r0, #80	; 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8009c7e:	6003      	str	r3, [r0, #0]
 8009c80:	e7cd      	b.n	8009c1e <xQueueGenericCreate+0x32>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8009c82:	2400      	movs	r4, #0
	}
 8009c84:	4620      	mov	r0, r4
 8009c86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08009c88 <xQueueCreateCountingSemaphoreStatic>:
		configASSERT( uxMaxCount != 0 );
 8009c88:	b950      	cbnz	r0, 8009ca0 <xQueueCreateCountingSemaphoreStatic+0x18>
 8009c8a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009c8e:	b672      	cpsid	i
 8009c90:	f383 8811 	msr	BASEPRI, r3
 8009c94:	f3bf 8f6f 	isb	sy
 8009c98:	f3bf 8f4f 	dsb	sy
 8009c9c:	b662      	cpsie	i
 8009c9e:	e7fe      	b.n	8009c9e <xQueueCreateCountingSemaphoreStatic+0x16>
		configASSERT( uxInitialCount <= uxMaxCount );
 8009ca0:	4288      	cmp	r0, r1
 8009ca2:	d20a      	bcs.n	8009cba <xQueueCreateCountingSemaphoreStatic+0x32>
 8009ca4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009ca8:	b672      	cpsid	i
 8009caa:	f383 8811 	msr	BASEPRI, r3
 8009cae:	f3bf 8f6f 	isb	sy
 8009cb2:	f3bf 8f4f 	dsb	sy
 8009cb6:	b662      	cpsie	i
 8009cb8:	e7fe      	b.n	8009cb8 <xQueueCreateCountingSemaphoreStatic+0x30>
	{
 8009cba:	b530      	push	{r4, r5, lr}
 8009cbc:	4615      	mov	r5, r2
 8009cbe:	b085      	sub	sp, #20
		configASSERT( pxStaticQueue != NULL );
 8009cc0:	2a00      	cmp	r2, #0
 8009cc2:	d03f      	beq.n	8009d44 <xQueueCreateCountingSemaphoreStatic+0xbc>
			volatile size_t xSize = sizeof( StaticQueue_t );
 8009cc4:	2350      	movs	r3, #80	; 0x50
 8009cc6:	9303      	str	r3, [sp, #12]
			configASSERT( xSize == sizeof( Queue_t ) );
 8009cc8:	9b03      	ldr	r3, [sp, #12]
 8009cca:	2b50      	cmp	r3, #80	; 0x50
 8009ccc:	d00a      	beq.n	8009ce4 <xQueueCreateCountingSemaphoreStatic+0x5c>
 8009cce:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009cd2:	b672      	cpsid	i
 8009cd4:	f383 8811 	msr	BASEPRI, r3
 8009cd8:	f3bf 8f6f 	isb	sy
 8009cdc:	f3bf 8f4f 	dsb	sy
 8009ce0:	b662      	cpsie	i
 8009ce2:	e7fe      	b.n	8009ce2 <xQueueCreateCountingSemaphoreStatic+0x5a>
	pxNewQueue->uxItemSize = uxItemSize;
 8009ce4:	2400      	movs	r4, #0
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8009ce6:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8009ce8:	602a      	str	r2, [r5, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8009cea:	63d0      	str	r0, [r2, #60]	; 0x3c
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8009cec:	f882 3046 	strb.w	r3, [r2, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 8009cf0:	6414      	str	r4, [r2, #64]	; 0x40
 8009cf2:	9101      	str	r1, [sp, #4]
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 8009cf4:	9b03      	ldr	r3, [sp, #12]
	taskENTER_CRITICAL();
 8009cf6:	f002 f9fd 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009cfa:	6828      	ldr	r0, [r5, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009cfc:	63ac      	str	r4, [r5, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8009cfe:	6068      	str	r0, [r5, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d00:	e9d5 3c0f 	ldrd	r3, ip, [r5, #60]	; 0x3c
 8009d04:	fb03 f30c 	mul.w	r3, r3, ip
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d08:	eba3 0c0c 	sub.w	ip, r3, ip
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d0c:	4403      	add	r3, r0
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d0e:	4484      	add	ip, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d10:	60ab      	str	r3, [r5, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 8009d12:	23ff      	movs	r3, #255	; 0xff
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009d14:	f105 0010 	add.w	r0, r5, #16
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009d18:	f8c5 c00c 	str.w	ip, [r5, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8009d1c:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8009d20:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009d24:	f7ff fe5e 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009d28:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8009d2c:	f7ff fe5a 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 8009d30:	f002 fa06 	bl	800c140 <vPortExitCritical>
		pxNewQueue->ucQueueType = ucQueueType;
 8009d34:	2302      	movs	r3, #2
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8009d36:	9901      	ldr	r1, [sp, #4]
	}
 8009d38:	4628      	mov	r0, r5
		pxNewQueue->ucQueueType = ucQueueType;
 8009d3a:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8009d3e:	63a9      	str	r1, [r5, #56]	; 0x38
	}
 8009d40:	b005      	add	sp, #20
 8009d42:	bd30      	pop	{r4, r5, pc}
 8009d44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009d48:	b672      	cpsid	i
 8009d4a:	f383 8811 	msr	BASEPRI, r3
 8009d4e:	f3bf 8f6f 	isb	sy
 8009d52:	f3bf 8f4f 	dsb	sy
 8009d56:	b662      	cpsie	i
		configASSERT( pxStaticQueue != NULL );
 8009d58:	e7fe      	b.n	8009d58 <xQueueCreateCountingSemaphoreStatic+0xd0>
 8009d5a:	bf00      	nop

08009d5c <xQueueCreateCountingSemaphore>:
	{
 8009d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( uxMaxCount != 0 );
 8009d5e:	b950      	cbnz	r0, 8009d76 <xQueueCreateCountingSemaphore+0x1a>
 8009d60:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009d64:	b672      	cpsid	i
 8009d66:	f383 8811 	msr	BASEPRI, r3
 8009d6a:	f3bf 8f6f 	isb	sy
 8009d6e:	f3bf 8f4f 	dsb	sy
 8009d72:	b662      	cpsie	i
 8009d74:	e7fe      	b.n	8009d74 <xQueueCreateCountingSemaphore+0x18>
		configASSERT( uxInitialCount <= uxMaxCount );
 8009d76:	4288      	cmp	r0, r1
 8009d78:	4604      	mov	r4, r0
 8009d7a:	460f      	mov	r7, r1
 8009d7c:	d20a      	bcs.n	8009d94 <xQueueCreateCountingSemaphore+0x38>
 8009d7e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009d82:	b672      	cpsid	i
 8009d84:	f383 8811 	msr	BASEPRI, r3
 8009d88:	f3bf 8f6f 	isb	sy
 8009d8c:	f3bf 8f4f 	dsb	sy
 8009d90:	b662      	cpsie	i
 8009d92:	e7fe      	b.n	8009d92 <xQueueCreateCountingSemaphore+0x36>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8009d94:	2050      	movs	r0, #80	; 0x50
 8009d96:	f002 faff 	bl	800c398 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8009d9a:	4605      	mov	r5, r0
 8009d9c:	b330      	cbz	r0, 8009dec <xQueueCreateCountingSemaphore+0x90>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8009d9e:	2600      	movs	r6, #0
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8009da0:	6000      	str	r0, [r0, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8009da2:	63c4      	str	r4, [r0, #60]	; 0x3c
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 8009da4:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 8009da8:	6406      	str	r6, [r0, #64]	; 0x40
	taskENTER_CRITICAL();
 8009daa:	f002 f9a3 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dae:	682a      	ldr	r2, [r5, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8009db0:	63ae      	str	r6, [r5, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8009db2:	606a      	str	r2, [r5, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009db4:	e9d5 300f 	ldrd	r3, r0, [r5, #60]	; 0x3c
 8009db8:	fb00 f303 	mul.w	r3, r0, r3
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dbc:	1a18      	subs	r0, r3, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dbe:	4413      	add	r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dc0:	4402      	add	r2, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dc2:	60ab      	str	r3, [r5, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 8009dc4:	23ff      	movs	r3, #255	; 0xff
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009dc6:	f105 0010 	add.w	r0, r5, #16
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8009dca:	60ea      	str	r2, [r5, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8009dcc:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8009dd0:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8009dd4:	f7ff fe06 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8009dd8:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8009ddc:	f7ff fe02 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 8009de0:	f002 f9ae 	bl	800c140 <vPortExitCritical>
		pxNewQueue->ucQueueType = ucQueueType;
 8009de4:	2302      	movs	r3, #2
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8009de6:	63af      	str	r7, [r5, #56]	; 0x38
		pxNewQueue->ucQueueType = ucQueueType;
 8009de8:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
	}
 8009dec:	4628      	mov	r0, r5
 8009dee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08009df0 <xQueueGenericSend>:
{
 8009df0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8009df4:	b084      	sub	sp, #16
 8009df6:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8009df8:	2800      	cmp	r0, #0
 8009dfa:	f000 8107 	beq.w	800a00c <xQueueGenericSend+0x21c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8009dfe:	4688      	mov	r8, r1
 8009e00:	4604      	mov	r4, r0
 8009e02:	461f      	mov	r7, r3
 8009e04:	2900      	cmp	r1, #0
 8009e06:	f000 8099 	beq.w	8009f3c <xQueueGenericSend+0x14c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8009e0a:	2f02      	cmp	r7, #2
 8009e0c:	d10d      	bne.n	8009e2a <xQueueGenericSend+0x3a>
 8009e0e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009e10:	2b01      	cmp	r3, #1
 8009e12:	d00a      	beq.n	8009e2a <xQueueGenericSend+0x3a>
 8009e14:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009e18:	b672      	cpsid	i
 8009e1a:	f383 8811 	msr	BASEPRI, r3
 8009e1e:	f3bf 8f6f 	isb	sy
 8009e22:	f3bf 8f4f 	dsb	sy
 8009e26:	b662      	cpsie	i
 8009e28:	e7fe      	b.n	8009e28 <xQueueGenericSend+0x38>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8009e2a:	f001 fdf3 	bl	800ba14 <xTaskGetSchedulerState>
 8009e2e:	2800      	cmp	r0, #0
 8009e30:	f000 80f7 	beq.w	800a022 <xQueueGenericSend+0x232>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8009e34:	f1a7 0902 	sub.w	r9, r7, #2
 8009e38:	2500      	movs	r5, #0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009e3a:	f104 0624 	add.w	r6, r4, #36	; 0x24
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8009e3e:	fab9 f989 	clz	r9, r9
 8009e42:	ea4f 1959 	mov.w	r9, r9, lsr #5
		taskENTER_CRITICAL();
 8009e46:	f002 f955 	bl	800c0f4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8009e4a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009e4c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009e4e:	429a      	cmp	r2, r3
 8009e50:	f0c0 80f6 	bcc.w	800a040 <xQueueGenericSend+0x250>
 8009e54:	f1b9 0f00 	cmp.w	r9, #0
 8009e58:	f040 80f2 	bne.w	800a040 <xQueueGenericSend+0x250>
				if( xTicksToWait == ( TickType_t ) 0 )
 8009e5c:	9b01      	ldr	r3, [sp, #4]
 8009e5e:	2b00      	cmp	r3, #0
 8009e60:	f000 8107 	beq.w	800a072 <xQueueGenericSend+0x282>
				else if( xEntryTimeSet == pdFALSE )
 8009e64:	2d00      	cmp	r5, #0
 8009e66:	f000 80cd 	beq.w	800a004 <xQueueGenericSend+0x214>
		taskEXIT_CRITICAL();
 8009e6a:	f002 f969 	bl	800c140 <vPortExitCritical>
		vTaskSuspendAll();
 8009e6e:	f001 fa2f 	bl	800b2d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8009e72:	f002 f93f 	bl	800c0f4 <vPortEnterCritical>
 8009e76:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8009e7a:	2bff      	cmp	r3, #255	; 0xff
 8009e7c:	d102      	bne.n	8009e84 <xQueueGenericSend+0x94>
 8009e7e:	2300      	movs	r3, #0
 8009e80:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8009e84:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8009e88:	2bff      	cmp	r3, #255	; 0xff
 8009e8a:	d102      	bne.n	8009e92 <xQueueGenericSend+0xa2>
 8009e8c:	2300      	movs	r3, #0
 8009e8e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8009e92:	f002 f955 	bl	800c140 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8009e96:	a901      	add	r1, sp, #4
 8009e98:	a802      	add	r0, sp, #8
 8009e9a:	f001 fd57 	bl	800b94c <xTaskCheckForTimeOut>
 8009e9e:	2800      	cmp	r0, #0
 8009ea0:	f040 80eb 	bne.w	800a07a <xQueueGenericSend+0x28a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8009ea4:	f002 f926 	bl	800c0f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8009ea8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009eaa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009eac:	429a      	cmp	r2, r3
 8009eae:	d054      	beq.n	8009f5a <xQueueGenericSend+0x16a>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8009eb0:	f002 f946 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 8009eb4:	f002 f91e 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8009eb8:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 8009ebc:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009ebe:	2d00      	cmp	r5, #0
 8009ec0:	dc04      	bgt.n	8009ecc <xQueueGenericSend+0xdc>
 8009ec2:	e011      	b.n	8009ee8 <xQueueGenericSend+0xf8>
			--cTxLock;
 8009ec4:	1e6a      	subs	r2, r5, #1
 8009ec6:	b2d3      	uxtb	r3, r2
 8009ec8:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009eca:	b16b      	cbz	r3, 8009ee8 <xQueueGenericSend+0xf8>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009ecc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009ece:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009ed0:	b153      	cbz	r3, 8009ee8 <xQueueGenericSend+0xf8>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009ed2:	f001 fce3 	bl	800b89c <xTaskRemoveFromEventList>
 8009ed6:	2800      	cmp	r0, #0
 8009ed8:	d0f4      	beq.n	8009ec4 <xQueueGenericSend+0xd4>
						vTaskMissedYield();
 8009eda:	f001 fd8f 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 8009ede:	1e6a      	subs	r2, r5, #1
 8009ee0:	b2d3      	uxtb	r3, r2
 8009ee2:	b255      	sxtb	r5, r2
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009ee4:	2b00      	cmp	r3, #0
 8009ee6:	d1f1      	bne.n	8009ecc <xQueueGenericSend+0xdc>
		pxQueue->cTxLock = queueUNLOCKED;
 8009ee8:	23ff      	movs	r3, #255	; 0xff
 8009eea:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8009eee:	f002 f927 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 8009ef2:	f002 f8ff 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8009ef6:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8009efa:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009efc:	2d00      	cmp	r5, #0
 8009efe:	dd14      	ble.n	8009f2a <xQueueGenericSend+0x13a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009f00:	f104 0a10 	add.w	sl, r4, #16
 8009f04:	e003      	b.n	8009f0e <xQueueGenericSend+0x11e>
				--cRxLock;
 8009f06:	1e6a      	subs	r2, r5, #1
 8009f08:	b2d3      	uxtb	r3, r2
 8009f0a:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009f0c:	b16b      	cbz	r3, 8009f2a <xQueueGenericSend+0x13a>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009f0e:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009f10:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009f12:	b153      	cbz	r3, 8009f2a <xQueueGenericSend+0x13a>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009f14:	f001 fcc2 	bl	800b89c <xTaskRemoveFromEventList>
 8009f18:	2800      	cmp	r0, #0
 8009f1a:	d0f4      	beq.n	8009f06 <xQueueGenericSend+0x116>
					vTaskMissedYield();
 8009f1c:	f001 fd6e 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 8009f20:	1e6a      	subs	r2, r5, #1
 8009f22:	b2d3      	uxtb	r3, r2
 8009f24:	b255      	sxtb	r5, r2
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009f26:	2b00      	cmp	r3, #0
 8009f28:	d1f1      	bne.n	8009f0e <xQueueGenericSend+0x11e>
		pxQueue->cRxLock = queueUNLOCKED;
 8009f2a:	23ff      	movs	r3, #255	; 0xff
 8009f2c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8009f30:	f002 f906 	bl	800c140 <vPortExitCritical>
				( void ) xTaskResumeAll();
 8009f34:	f001 fb2a 	bl	800b58c <xTaskResumeAll>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8009f38:	2501      	movs	r5, #1
 8009f3a:	e784      	b.n	8009e46 <xQueueGenericSend+0x56>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8009f3c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8009f3e:	2b00      	cmp	r3, #0
 8009f40:	f43f af63 	beq.w	8009e0a <xQueueGenericSend+0x1a>
 8009f44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009f48:	b672      	cpsid	i
 8009f4a:	f383 8811 	msr	BASEPRI, r3
 8009f4e:	f3bf 8f6f 	isb	sy
 8009f52:	f3bf 8f4f 	dsb	sy
 8009f56:	b662      	cpsie	i
 8009f58:	e7fe      	b.n	8009f58 <xQueueGenericSend+0x168>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8009f5a:	f104 0a10 	add.w	sl, r4, #16
	taskEXIT_CRITICAL();
 8009f5e:	f002 f8ef 	bl	800c140 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8009f62:	9901      	ldr	r1, [sp, #4]
 8009f64:	4650      	mov	r0, sl
 8009f66:	f001 fbfb 	bl	800b760 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 8009f6a:	f002 f8c3 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8009f6e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8009f72:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009f74:	2d00      	cmp	r5, #0
 8009f76:	dc04      	bgt.n	8009f82 <xQueueGenericSend+0x192>
 8009f78:	e011      	b.n	8009f9e <xQueueGenericSend+0x1ae>
			--cTxLock;
 8009f7a:	1e6b      	subs	r3, r5, #1
 8009f7c:	b2da      	uxtb	r2, r3
 8009f7e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009f80:	b16a      	cbz	r2, 8009f9e <xQueueGenericSend+0x1ae>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009f82:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009f84:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8009f86:	b153      	cbz	r3, 8009f9e <xQueueGenericSend+0x1ae>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8009f88:	f001 fc88 	bl	800b89c <xTaskRemoveFromEventList>
 8009f8c:	2800      	cmp	r0, #0
 8009f8e:	d0f4      	beq.n	8009f7a <xQueueGenericSend+0x18a>
						vTaskMissedYield();
 8009f90:	f001 fd34 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 8009f94:	1e6b      	subs	r3, r5, #1
 8009f96:	b2da      	uxtb	r2, r3
 8009f98:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8009f9a:	2a00      	cmp	r2, #0
 8009f9c:	d1f1      	bne.n	8009f82 <xQueueGenericSend+0x192>
		pxQueue->cTxLock = queueUNLOCKED;
 8009f9e:	23ff      	movs	r3, #255	; 0xff
 8009fa0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8009fa4:	f002 f8cc 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 8009fa8:	f002 f8a4 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8009fac:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8009fb0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009fb2:	2d00      	cmp	r5, #0
 8009fb4:	dc04      	bgt.n	8009fc0 <xQueueGenericSend+0x1d0>
 8009fb6:	e011      	b.n	8009fdc <xQueueGenericSend+0x1ec>
				--cRxLock;
 8009fb8:	1e6b      	subs	r3, r5, #1
 8009fba:	b2da      	uxtb	r2, r3
 8009fbc:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009fbe:	b16a      	cbz	r2, 8009fdc <xQueueGenericSend+0x1ec>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009fc0:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009fc2:	4650      	mov	r0, sl
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8009fc4:	b153      	cbz	r3, 8009fdc <xQueueGenericSend+0x1ec>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8009fc6:	f001 fc69 	bl	800b89c <xTaskRemoveFromEventList>
 8009fca:	2800      	cmp	r0, #0
 8009fcc:	d0f4      	beq.n	8009fb8 <xQueueGenericSend+0x1c8>
					vTaskMissedYield();
 8009fce:	f001 fd15 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 8009fd2:	1e6b      	subs	r3, r5, #1
 8009fd4:	b2da      	uxtb	r2, r3
 8009fd6:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8009fd8:	2a00      	cmp	r2, #0
 8009fda:	d1f1      	bne.n	8009fc0 <xQueueGenericSend+0x1d0>
		pxQueue->cRxLock = queueUNLOCKED;
 8009fdc:	23ff      	movs	r3, #255	; 0xff
 8009fde:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 8009fe2:	f002 f8ad 	bl	800c140 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 8009fe6:	f001 fad1 	bl	800b58c <xTaskResumeAll>
 8009fea:	2800      	cmp	r0, #0
 8009fec:	d1a4      	bne.n	8009f38 <xQueueGenericSend+0x148>
					portYIELD_WITHIN_API();
 8009fee:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8009ff2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8009ff6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8009ffa:	f3bf 8f4f 	dsb	sy
 8009ffe:	f3bf 8f6f 	isb	sy
 800a002:	e799      	b.n	8009f38 <xQueueGenericSend+0x148>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800a004:	a802      	add	r0, sp, #8
 800a006:	f001 fc95 	bl	800b934 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800a00a:	e72e      	b.n	8009e6a <xQueueGenericSend+0x7a>
 800a00c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a010:	b672      	cpsid	i
 800a012:	f383 8811 	msr	BASEPRI, r3
 800a016:	f3bf 8f6f 	isb	sy
 800a01a:	f3bf 8f4f 	dsb	sy
 800a01e:	b662      	cpsie	i
	configASSERT( pxQueue );
 800a020:	e7fe      	b.n	800a020 <xQueueGenericSend+0x230>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a022:	9b01      	ldr	r3, [sp, #4]
 800a024:	2b00      	cmp	r3, #0
 800a026:	f43f af05 	beq.w	8009e34 <xQueueGenericSend+0x44>
 800a02a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a02e:	b672      	cpsid	i
 800a030:	f383 8811 	msr	BASEPRI, r3
 800a034:	f3bf 8f6f 	isb	sy
 800a038:	f3bf 8f4f 	dsb	sy
 800a03c:	b662      	cpsie	i
 800a03e:	e7fe      	b.n	800a03e <xQueueGenericSend+0x24e>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800a040:	463a      	mov	r2, r7
 800a042:	4641      	mov	r1, r8
 800a044:	4620      	mov	r0, r4
 800a046:	f7ff fd19 	bl	8009a7c <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a04a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a04c:	2b00      	cmp	r3, #0
 800a04e:	d152      	bne.n	800a0f6 <xQueueGenericSend+0x306>
					else if( xYieldRequired != pdFALSE )
 800a050:	b148      	cbz	r0, 800a066 <xQueueGenericSend+0x276>
						queueYIELD_IF_USING_PREEMPTION();
 800a052:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800a056:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a05a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800a05e:	f3bf 8f4f 	dsb	sy
 800a062:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 800a066:	f002 f86b 	bl	800c140 <vPortExitCritical>
				return pdPASS;
 800a06a:	2001      	movs	r0, #1
}
 800a06c:	b004      	add	sp, #16
 800a06e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					taskEXIT_CRITICAL();
 800a072:	f002 f865 	bl	800c140 <vPortExitCritical>
					return errQUEUE_FULL;
 800a076:	4648      	mov	r0, r9
 800a078:	e7f8      	b.n	800a06c <xQueueGenericSend+0x27c>
	taskENTER_CRITICAL();
 800a07a:	f002 f83b 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a07e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a082:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a084:	2d00      	cmp	r5, #0
 800a086:	dd10      	ble.n	800a0aa <xQueueGenericSend+0x2ba>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a088:	f104 0624 	add.w	r6, r4, #36	; 0x24
 800a08c:	e003      	b.n	800a096 <xQueueGenericSend+0x2a6>
			--cTxLock;
 800a08e:	1e6b      	subs	r3, r5, #1
 800a090:	b2da      	uxtb	r2, r3
 800a092:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a094:	b14a      	cbz	r2, 800a0aa <xQueueGenericSend+0x2ba>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a096:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a098:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a09a:	b133      	cbz	r3, 800a0aa <xQueueGenericSend+0x2ba>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a09c:	f001 fbfe 	bl	800b89c <xTaskRemoveFromEventList>
 800a0a0:	2800      	cmp	r0, #0
 800a0a2:	d0f4      	beq.n	800a08e <xQueueGenericSend+0x29e>
						vTaskMissedYield();
 800a0a4:	f001 fcaa 	bl	800b9fc <vTaskMissedYield>
 800a0a8:	e7f1      	b.n	800a08e <xQueueGenericSend+0x29e>
		pxQueue->cTxLock = queueUNLOCKED;
 800a0aa:	23ff      	movs	r3, #255	; 0xff
 800a0ac:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a0b0:	f002 f846 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a0b4:	f002 f81e 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a0b8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a0bc:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a0be:	2d00      	cmp	r5, #0
 800a0c0:	dd10      	ble.n	800a0e4 <xQueueGenericSend+0x2f4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a0c2:	f104 0610 	add.w	r6, r4, #16
 800a0c6:	e003      	b.n	800a0d0 <xQueueGenericSend+0x2e0>
				--cRxLock;
 800a0c8:	1e6b      	subs	r3, r5, #1
 800a0ca:	b2da      	uxtb	r2, r3
 800a0cc:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a0ce:	b14a      	cbz	r2, 800a0e4 <xQueueGenericSend+0x2f4>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a0d0:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a0d2:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a0d4:	b133      	cbz	r3, 800a0e4 <xQueueGenericSend+0x2f4>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a0d6:	f001 fbe1 	bl	800b89c <xTaskRemoveFromEventList>
 800a0da:	2800      	cmp	r0, #0
 800a0dc:	d0f4      	beq.n	800a0c8 <xQueueGenericSend+0x2d8>
					vTaskMissedYield();
 800a0de:	f001 fc8d 	bl	800b9fc <vTaskMissedYield>
 800a0e2:	e7f1      	b.n	800a0c8 <xQueueGenericSend+0x2d8>
		pxQueue->cRxLock = queueUNLOCKED;
 800a0e4:	23ff      	movs	r3, #255	; 0xff
 800a0e6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a0ea:	f002 f829 	bl	800c140 <vPortExitCritical>
			( void ) xTaskResumeAll();
 800a0ee:	f001 fa4d 	bl	800b58c <xTaskResumeAll>
			return errQUEUE_FULL;
 800a0f2:	2000      	movs	r0, #0
 800a0f4:	e7ba      	b.n	800a06c <xQueueGenericSend+0x27c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a0f6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800a0fa:	f001 fbcf 	bl	800b89c <xTaskRemoveFromEventList>
 800a0fe:	2800      	cmp	r0, #0
 800a100:	d0b1      	beq.n	800a066 <xQueueGenericSend+0x276>
 800a102:	e7a6      	b.n	800a052 <xQueueGenericSend+0x262>

0800a104 <xQueueCreateMutexStatic>:
		configASSERT( pxStaticQueue != NULL );
 800a104:	b189      	cbz	r1, 800a12a <xQueueCreateMutexStatic+0x26>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800a106:	2350      	movs	r3, #80	; 0x50
	{
 800a108:	b570      	push	{r4, r5, r6, lr}
 800a10a:	b082      	sub	sp, #8
			volatile size_t xSize = sizeof( StaticQueue_t );
 800a10c:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 800a10e:	9b01      	ldr	r3, [sp, #4]
 800a110:	2b50      	cmp	r3, #80	; 0x50
 800a112:	d015      	beq.n	800a140 <xQueueCreateMutexStatic+0x3c>
 800a114:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a118:	b672      	cpsid	i
 800a11a:	f383 8811 	msr	BASEPRI, r3
 800a11e:	f3bf 8f6f 	isb	sy
 800a122:	f3bf 8f4f 	dsb	sy
 800a126:	b662      	cpsie	i
 800a128:	e7fe      	b.n	800a128 <xQueueCreateMutexStatic+0x24>
 800a12a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a12e:	b672      	cpsid	i
 800a130:	f383 8811 	msr	BASEPRI, r3
 800a134:	f3bf 8f6f 	isb	sy
 800a138:	f3bf 8f4f 	dsb	sy
 800a13c:	b662      	cpsie	i
		configASSERT( pxStaticQueue != NULL );
 800a13e:	e7fe      	b.n	800a13e <xQueueCreateMutexStatic+0x3a>
	pxNewQueue->uxItemSize = uxItemSize;
 800a140:	2600      	movs	r6, #0
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800a142:	2301      	movs	r3, #1
 800a144:	460c      	mov	r4, r1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800a146:	6009      	str	r1, [r1, #0]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800a148:	f881 3046 	strb.w	r3, [r1, #70]	; 0x46
 800a14c:	4605      	mov	r5, r0
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 800a14e:	9a01      	ldr	r2, [sp, #4]
	pxNewQueue->uxItemSize = uxItemSize;
 800a150:	e9c1 360f 	strd	r3, r6, [r1, #60]	; 0x3c
	taskENTER_CRITICAL();
 800a154:	f001 ffce 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a158:	6821      	ldr	r1, [r4, #0]
		pxQueue->cRxLock = queueUNLOCKED;
 800a15a:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800a15c:	63a6      	str	r6, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800a15e:	6061      	str	r1, [r4, #4]
		pxQueue->cRxLock = queueUNLOCKED;
 800a160:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800a164:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a168:	e9d4 200f 	ldrd	r2, r0, [r4, #60]	; 0x3c
 800a16c:	fb00 f202 	mul.w	r2, r0, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a170:	1a10      	subs	r0, r2, r0
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a172:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a174:	4401      	add	r1, r0
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800a176:	f104 0010 	add.w	r0, r4, #16
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a17a:	e9c4 2102 	strd	r2, r1, [r4, #8]
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800a17e:	f7ff fc31 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800a182:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800a186:	f7ff fc2d 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 800a18a:	f001 ffd9 	bl	800c140 <vPortExitCritical>
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800a18e:	4633      	mov	r3, r6
 800a190:	4632      	mov	r2, r6
 800a192:	4631      	mov	r1, r6
 800a194:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
 800a196:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 800a19a:	60a6      	str	r6, [r4, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800a19c:	6026      	str	r6, [r4, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800a19e:	60e6      	str	r6, [r4, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800a1a0:	f7ff fe26 	bl	8009df0 <xQueueGenericSend>
	}
 800a1a4:	4620      	mov	r0, r4
 800a1a6:	b002      	add	sp, #8
 800a1a8:	bd70      	pop	{r4, r5, r6, pc}
 800a1aa:	bf00      	nop

0800a1ac <xQueueGiveMutexRecursive>:
	{
 800a1ac:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxMutex );
 800a1ae:	b138      	cbz	r0, 800a1c0 <xQueueGiveMutexRecursive+0x14>
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 800a1b0:	6885      	ldr	r5, [r0, #8]
 800a1b2:	4604      	mov	r4, r0
 800a1b4:	f001 fc28 	bl	800ba08 <xTaskGetCurrentTaskHandle>
 800a1b8:	4285      	cmp	r5, r0
 800a1ba:	d00c      	beq.n	800a1d6 <xQueueGiveMutexRecursive+0x2a>
			xReturn = pdFAIL;
 800a1bc:	2000      	movs	r0, #0
	}
 800a1be:	bd38      	pop	{r3, r4, r5, pc}
 800a1c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a1c4:	b672      	cpsid	i
 800a1c6:	f383 8811 	msr	BASEPRI, r3
 800a1ca:	f3bf 8f6f 	isb	sy
 800a1ce:	f3bf 8f4f 	dsb	sy
 800a1d2:	b662      	cpsie	i
		configASSERT( pxMutex );
 800a1d4:	e7fe      	b.n	800a1d4 <xQueueGiveMutexRecursive+0x28>
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 800a1d6:	68e3      	ldr	r3, [r4, #12]
 800a1d8:	3b01      	subs	r3, #1
 800a1da:	60e3      	str	r3, [r4, #12]
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 800a1dc:	b10b      	cbz	r3, 800a1e2 <xQueueGiveMutexRecursive+0x36>
			xReturn = pdPASS;
 800a1de:	2001      	movs	r0, #1
	}
 800a1e0:	bd38      	pop	{r3, r4, r5, pc}
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 800a1e2:	461a      	mov	r2, r3
 800a1e4:	4619      	mov	r1, r3
 800a1e6:	4620      	mov	r0, r4
 800a1e8:	f7ff fe02 	bl	8009df0 <xQueueGenericSend>
			xReturn = pdPASS;
 800a1ec:	2001      	movs	r0, #1
	}
 800a1ee:	bd38      	pop	{r3, r4, r5, pc}

0800a1f0 <xQueueCreateMutex>:
	{
 800a1f0:	b570      	push	{r4, r5, r6, lr}
 800a1f2:	4605      	mov	r5, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 800a1f4:	2050      	movs	r0, #80	; 0x50
 800a1f6:	f002 f8cf 	bl	800c398 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800a1fa:	4604      	mov	r4, r0
 800a1fc:	b370      	cbz	r0, 800a25c <xQueueCreateMutex+0x6c>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a1fe:	2600      	movs	r6, #0
	pxNewQueue->uxLength = uxQueueLength;
 800a200:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800a202:	6020      	str	r0, [r4, #0]
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 800a204:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
	pxNewQueue->uxItemSize = uxItemSize;
 800a208:	e9c0 360f 	strd	r3, r6, [r0, #60]	; 0x3c
	taskENTER_CRITICAL();
 800a20c:	f001 ff72 	bl	800c0f4 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a210:	6821      	ldr	r1, [r4, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800a212:	63a6      	str	r6, [r4, #56]	; 0x38
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800a214:	f104 0010 	add.w	r0, r4, #16
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800a218:	6061      	str	r1, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a21a:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
 800a21e:	fb03 f202 	mul.w	r2, r3, r2
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a222:	1ad3      	subs	r3, r2, r3
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a224:	440a      	add	r2, r1
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a226:	4419      	add	r1, r3
		pxQueue->cRxLock = queueUNLOCKED;
 800a228:	23ff      	movs	r3, #255	; 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a22a:	e9c4 2102 	strd	r2, r1, [r4, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 800a22e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800a232:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800a236:	f7ff fbd5 	bl	80099e4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800a23a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800a23e:	f7ff fbd1 	bl	80099e4 <vListInitialise>
	taskEXIT_CRITICAL();
 800a242:	f001 ff7d 	bl	800c140 <vPortExitCritical>
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800a246:	4633      	mov	r3, r6
 800a248:	4632      	mov	r2, r6
 800a24a:	4631      	mov	r1, r6
 800a24c:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
 800a24e:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 800a252:	60a6      	str	r6, [r4, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800a254:	6026      	str	r6, [r4, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800a256:	60e6      	str	r6, [r4, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800a258:	f7ff fdca 	bl	8009df0 <xQueueGenericSend>
	}
 800a25c:	4620      	mov	r0, r4
 800a25e:	bd70      	pop	{r4, r5, r6, pc}

0800a260 <xQueueGenericSendFromISR>:
	configASSERT( pxQueue );
 800a260:	2800      	cmp	r0, #0
 800a262:	d053      	beq.n	800a30c <xQueueGenericSendFromISR+0xac>
{
 800a264:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a268:	460e      	mov	r6, r1
 800a26a:	4604      	mov	r4, r0
 800a26c:	4617      	mov	r7, r2
 800a26e:	461d      	mov	r5, r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800a270:	b359      	cbz	r1, 800a2ca <xQueueGenericSendFromISR+0x6a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800a272:	2d02      	cmp	r5, #2
 800a274:	d10d      	bne.n	800a292 <xQueueGenericSendFromISR+0x32>
 800a276:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a278:	2b01      	cmp	r3, #1
 800a27a:	d00a      	beq.n	800a292 <xQueueGenericSendFromISR+0x32>
 800a27c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a280:	b672      	cpsid	i
 800a282:	f383 8811 	msr	BASEPRI, r3
 800a286:	f3bf 8f6f 	isb	sy
 800a28a:	f3bf 8f4f 	dsb	sy
 800a28e:	b662      	cpsie	i
 800a290:	e7fe      	b.n	800a290 <xQueueGenericSendFromISR+0x30>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800a292:	f002 f84f 	bl	800c334 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 800a296:	f3ef 8811 	mrs	r8, BASEPRI
 800a29a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a29e:	b672      	cpsid	i
 800a2a0:	f383 8811 	msr	BASEPRI, r3
 800a2a4:	f3bf 8f6f 	isb	sy
 800a2a8:	f3bf 8f4f 	dsb	sy
 800a2ac:	b662      	cpsie	i
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800a2ae:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a2b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a2b2:	429a      	cmp	r2, r3
 800a2b4:	d317      	bcc.n	800a2e6 <xQueueGenericSendFromISR+0x86>
 800a2b6:	f1a5 0002 	sub.w	r0, r5, #2
 800a2ba:	fab0 f080 	clz	r0, r0
 800a2be:	0940      	lsrs	r0, r0, #5
 800a2c0:	b988      	cbnz	r0, 800a2e6 <xQueueGenericSendFromISR+0x86>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800a2c2:	f388 8811 	msr	BASEPRI, r8
}
 800a2c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800a2ca:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a2cc:	2b00      	cmp	r3, #0
 800a2ce:	d0d0      	beq.n	800a272 <xQueueGenericSendFromISR+0x12>
	__asm volatile
 800a2d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a2d4:	b672      	cpsid	i
 800a2d6:	f383 8811 	msr	BASEPRI, r3
 800a2da:	f3bf 8f6f 	isb	sy
 800a2de:	f3bf 8f4f 	dsb	sy
 800a2e2:	b662      	cpsie	i
 800a2e4:	e7fe      	b.n	800a2e4 <xQueueGenericSendFromISR+0x84>
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800a2e6:	462a      	mov	r2, r5
			const int8_t cTxLock = pxQueue->cTxLock;
 800a2e8:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800a2ec:	4631      	mov	r1, r6
 800a2ee:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
 800a2f0:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800a2f2:	f7ff fbc3 	bl	8009a7c <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800a2f6:	1c6b      	adds	r3, r5, #1
 800a2f8:	d013      	beq.n	800a322 <xQueueGenericSendFromISR+0xc2>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800a2fa:	1c6b      	adds	r3, r5, #1
			xReturn = pdPASS;
 800a2fc:	2001      	movs	r0, #1
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800a2fe:	b25b      	sxtb	r3, r3
 800a300:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	__asm volatile
 800a304:	f388 8811 	msr	BASEPRI, r8
}
 800a308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm volatile
 800a30c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a310:	b672      	cpsid	i
 800a312:	f383 8811 	msr	BASEPRI, r3
 800a316:	f3bf 8f6f 	isb	sy
 800a31a:	f3bf 8f4f 	dsb	sy
 800a31e:	b662      	cpsie	i
	configASSERT( pxQueue );
 800a320:	e7fe      	b.n	800a320 <xQueueGenericSendFromISR+0xc0>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a322:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a324:	b90b      	cbnz	r3, 800a32a <xQueueGenericSendFromISR+0xca>
			xReturn = pdPASS;
 800a326:	2001      	movs	r0, #1
 800a328:	e7cb      	b.n	800a2c2 <xQueueGenericSendFromISR+0x62>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a32a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800a32e:	f001 fab5 	bl	800b89c <xTaskRemoveFromEventList>
							if( pxHigherPriorityTaskWoken != NULL )
 800a332:	2800      	cmp	r0, #0
 800a334:	d0f7      	beq.n	800a326 <xQueueGenericSendFromISR+0xc6>
 800a336:	2f00      	cmp	r7, #0
 800a338:	d0f5      	beq.n	800a326 <xQueueGenericSendFromISR+0xc6>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800a33a:	2301      	movs	r3, #1
			xReturn = pdPASS;
 800a33c:	4618      	mov	r0, r3
								*pxHigherPriorityTaskWoken = pdTRUE;
 800a33e:	603b      	str	r3, [r7, #0]
 800a340:	e7bf      	b.n	800a2c2 <xQueueGenericSendFromISR+0x62>
 800a342:	bf00      	nop

0800a344 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 800a344:	b380      	cbz	r0, 800a3a8 <xQueueGiveFromISR+0x64>
	configASSERT( pxQueue->uxItemSize == 0 );
 800a346:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
 800a348:	b570      	push	{r4, r5, r6, lr}
 800a34a:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 800a34c:	b153      	cbz	r3, 800a364 <xQueueGiveFromISR+0x20>
 800a34e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a352:	b672      	cpsid	i
 800a354:	f383 8811 	msr	BASEPRI, r3
 800a358:	f3bf 8f6f 	isb	sy
 800a35c:	f3bf 8f4f 	dsb	sy
 800a360:	b662      	cpsie	i
 800a362:	e7fe      	b.n	800a362 <xQueueGiveFromISR+0x1e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 800a364:	6803      	ldr	r3, [r0, #0]
 800a366:	460d      	mov	r5, r1
 800a368:	b34b      	cbz	r3, 800a3be <xQueueGiveFromISR+0x7a>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800a36a:	f001 ffe3 	bl	800c334 <vPortValidateInterruptPriority>
	__asm volatile
 800a36e:	f3ef 8611 	mrs	r6, BASEPRI
 800a372:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a376:	b672      	cpsid	i
 800a378:	f383 8811 	msr	BASEPRI, r3
 800a37c:	f3bf 8f6f 	isb	sy
 800a380:	f3bf 8f4f 	dsb	sy
 800a384:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800a386:	6ba3      	ldr	r3, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 800a388:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800a38a:	429a      	cmp	r2, r3
 800a38c:	d925      	bls.n	800a3da <xQueueGiveFromISR+0x96>
			const int8_t cTxLock = pxQueue->cTxLock;
 800a38e:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800a392:	3301      	adds	r3, #1
			if( cTxLock == queueUNLOCKED )
 800a394:	2aff      	cmp	r2, #255	; 0xff
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800a396:	63a3      	str	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
 800a398:	b253      	sxtb	r3, r2
			if( cTxLock == queueUNLOCKED )
 800a39a:	d022      	beq.n	800a3e2 <xQueueGiveFromISR+0x9e>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800a39c:	3301      	adds	r3, #1
			xReturn = pdPASS;
 800a39e:	2001      	movs	r0, #1
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800a3a0:	b25b      	sxtb	r3, r3
 800a3a2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800a3a6:	e019      	b.n	800a3dc <xQueueGiveFromISR+0x98>
	__asm volatile
 800a3a8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a3ac:	b672      	cpsid	i
 800a3ae:	f383 8811 	msr	BASEPRI, r3
 800a3b2:	f3bf 8f6f 	isb	sy
 800a3b6:	f3bf 8f4f 	dsb	sy
 800a3ba:	b662      	cpsie	i
	configASSERT( pxQueue );
 800a3bc:	e7fe      	b.n	800a3bc <xQueueGiveFromISR+0x78>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 800a3be:	6883      	ldr	r3, [r0, #8]
 800a3c0:	2b00      	cmp	r3, #0
 800a3c2:	d0d2      	beq.n	800a36a <xQueueGiveFromISR+0x26>
 800a3c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a3c8:	b672      	cpsid	i
 800a3ca:	f383 8811 	msr	BASEPRI, r3
 800a3ce:	f3bf 8f6f 	isb	sy
 800a3d2:	f3bf 8f4f 	dsb	sy
 800a3d6:	b662      	cpsie	i
 800a3d8:	e7fe      	b.n	800a3d8 <xQueueGiveFromISR+0x94>
			xReturn = errQUEUE_FULL;
 800a3da:	2000      	movs	r0, #0
	__asm volatile
 800a3dc:	f386 8811 	msr	BASEPRI, r6
}
 800a3e0:	bd70      	pop	{r4, r5, r6, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a3e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800a3e4:	b90b      	cbnz	r3, 800a3ea <xQueueGiveFromISR+0xa6>
			xReturn = pdPASS;
 800a3e6:	2001      	movs	r0, #1
 800a3e8:	e7f8      	b.n	800a3dc <xQueueGiveFromISR+0x98>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a3ea:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800a3ee:	f001 fa55 	bl	800b89c <xTaskRemoveFromEventList>
							if( pxHigherPriorityTaskWoken != NULL )
 800a3f2:	2d00      	cmp	r5, #0
 800a3f4:	d0f7      	beq.n	800a3e6 <xQueueGiveFromISR+0xa2>
 800a3f6:	2800      	cmp	r0, #0
 800a3f8:	d0f5      	beq.n	800a3e6 <xQueueGiveFromISR+0xa2>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800a3fa:	2301      	movs	r3, #1
			xReturn = pdPASS;
 800a3fc:	4618      	mov	r0, r3
								*pxHigherPriorityTaskWoken = pdTRUE;
 800a3fe:	602b      	str	r3, [r5, #0]
 800a400:	e7ec      	b.n	800a3dc <xQueueGiveFromISR+0x98>
 800a402:	bf00      	nop

0800a404 <xQueueReceive>:
{
 800a404:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a408:	b085      	sub	sp, #20
 800a40a:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 800a40c:	2800      	cmp	r0, #0
 800a40e:	f000 8166 	beq.w	800a6de <xQueueReceive+0x2da>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800a412:	460f      	mov	r7, r1
 800a414:	4604      	mov	r4, r0
 800a416:	2900      	cmp	r1, #0
 800a418:	f000 8096 	beq.w	800a548 <xQueueReceive+0x144>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a41c:	f001 fafa 	bl	800ba14 <xTaskGetSchedulerState>
 800a420:	2800      	cmp	r0, #0
 800a422:	f000 80a0 	beq.w	800a566 <xQueueReceive+0x162>
		taskENTER_CRITICAL();
 800a426:	f001 fe65 	bl	800c0f4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800a42a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800a42c:	2d00      	cmp	r5, #0
 800a42e:	d174      	bne.n	800a51a <xQueueReceive+0x116>
				if( xTicksToWait == ( TickType_t ) 0 )
 800a430:	9b01      	ldr	r3, [sp, #4]
 800a432:	2b00      	cmp	r3, #0
 800a434:	f000 80f8 	beq.w	800a628 <xQueueReceive+0x224>
		prvLockQueue( pxQueue );
 800a438:	46a8      	mov	r8, r5
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a43a:	f104 0624 	add.w	r6, r4, #36	; 0x24
					vTaskInternalSetTimeOutState( &xTimeOut );
 800a43e:	a802      	add	r0, sp, #8
 800a440:	f001 fa78 	bl	800b934 <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 800a444:	f001 fe7c 	bl	800c140 <vPortExitCritical>
		vTaskSuspendAll();
 800a448:	f000 ff42 	bl	800b2d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800a44c:	f001 fe52 	bl	800c0f4 <vPortEnterCritical>
 800a450:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a454:	2bff      	cmp	r3, #255	; 0xff
 800a456:	d101      	bne.n	800a45c <xQueueReceive+0x58>
 800a458:	f884 8044 	strb.w	r8, [r4, #68]	; 0x44
 800a45c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a460:	2bff      	cmp	r3, #255	; 0xff
 800a462:	d101      	bne.n	800a468 <xQueueReceive+0x64>
 800a464:	f884 8045 	strb.w	r8, [r4, #69]	; 0x45
 800a468:	f001 fe6a 	bl	800c140 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800a46c:	a901      	add	r1, sp, #4
 800a46e:	a802      	add	r0, sp, #8
 800a470:	f001 fa6c 	bl	800b94c <xTaskCheckForTimeOut>
 800a474:	2800      	cmp	r0, #0
 800a476:	f040 8085 	bne.w	800a584 <xQueueReceive+0x180>
	taskENTER_CRITICAL();
 800a47a:	f001 fe3b 	bl	800c0f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800a47e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a480:	2b00      	cmp	r3, #0
 800a482:	f000 80d7 	beq.w	800a634 <xQueueReceive+0x230>
	taskEXIT_CRITICAL();
 800a486:	f001 fe5b 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a48a:	f001 fe33 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a48e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a492:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a494:	2d00      	cmp	r5, #0
 800a496:	dc04      	bgt.n	800a4a2 <xQueueReceive+0x9e>
 800a498:	e011      	b.n	800a4be <xQueueReceive+0xba>
			--cTxLock;
 800a49a:	1e6b      	subs	r3, r5, #1
 800a49c:	b2da      	uxtb	r2, r3
 800a49e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a4a0:	b16a      	cbz	r2, 800a4be <xQueueReceive+0xba>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a4a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a4a4:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a4a6:	b153      	cbz	r3, 800a4be <xQueueReceive+0xba>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a4a8:	f001 f9f8 	bl	800b89c <xTaskRemoveFromEventList>
 800a4ac:	2800      	cmp	r0, #0
 800a4ae:	d0f4      	beq.n	800a49a <xQueueReceive+0x96>
						vTaskMissedYield();
 800a4b0:	f001 faa4 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 800a4b4:	1e6b      	subs	r3, r5, #1
 800a4b6:	b2da      	uxtb	r2, r3
 800a4b8:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a4ba:	2a00      	cmp	r2, #0
 800a4bc:	d1f1      	bne.n	800a4a2 <xQueueReceive+0x9e>
		pxQueue->cTxLock = queueUNLOCKED;
 800a4be:	23ff      	movs	r3, #255	; 0xff
 800a4c0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a4c4:	f001 fe3c 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a4c8:	f001 fe14 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a4cc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a4d0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a4d2:	2d00      	cmp	r5, #0
 800a4d4:	dd14      	ble.n	800a500 <xQueueReceive+0xfc>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a4d6:	f104 0910 	add.w	r9, r4, #16
 800a4da:	e003      	b.n	800a4e4 <xQueueReceive+0xe0>
				--cRxLock;
 800a4dc:	1e6b      	subs	r3, r5, #1
 800a4de:	b2da      	uxtb	r2, r3
 800a4e0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a4e2:	b16a      	cbz	r2, 800a500 <xQueueReceive+0xfc>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a4e4:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a4e6:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a4e8:	b153      	cbz	r3, 800a500 <xQueueReceive+0xfc>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a4ea:	f001 f9d7 	bl	800b89c <xTaskRemoveFromEventList>
 800a4ee:	2800      	cmp	r0, #0
 800a4f0:	d0f4      	beq.n	800a4dc <xQueueReceive+0xd8>
					vTaskMissedYield();
 800a4f2:	f001 fa83 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 800a4f6:	1e6b      	subs	r3, r5, #1
 800a4f8:	b2da      	uxtb	r2, r3
 800a4fa:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a4fc:	2a00      	cmp	r2, #0
 800a4fe:	d1f1      	bne.n	800a4e4 <xQueueReceive+0xe0>
		pxQueue->cRxLock = queueUNLOCKED;
 800a500:	23ff      	movs	r3, #255	; 0xff
 800a502:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a506:	f001 fe1b 	bl	800c140 <vPortExitCritical>
				( void ) xTaskResumeAll();
 800a50a:	f001 f83f 	bl	800b58c <xTaskResumeAll>
		taskENTER_CRITICAL();
 800a50e:	f001 fdf1 	bl	800c0f4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800a512:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800a514:	2d00      	cmp	r5, #0
 800a516:	f000 8083 	beq.w	800a620 <xQueueReceive+0x21c>
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800a51a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800a51c:	b152      	cbz	r2, 800a534 <xQueueReceive+0x130>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800a51e:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800a520:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800a522:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800a524:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800a526:	60e1      	str	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800a528:	d301      	bcc.n	800a52e <xQueueReceive+0x12a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800a52a:	6821      	ldr	r1, [r4, #0]
 800a52c:	60e1      	str	r1, [r4, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800a52e:	4638      	mov	r0, r7
 800a530:	f008 fdfa 	bl	8013128 <memcpy>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800a534:	3d01      	subs	r5, #1
 800a536:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a538:	6923      	ldr	r3, [r4, #16]
 800a53a:	2b00      	cmp	r3, #0
 800a53c:	f040 80da 	bne.w	800a6f4 <xQueueReceive+0x2f0>
				taskEXIT_CRITICAL();
 800a540:	f001 fdfe 	bl	800c140 <vPortExitCritical>
				return pdPASS;
 800a544:	2001      	movs	r0, #1
 800a546:	e072      	b.n	800a62e <xQueueReceive+0x22a>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800a548:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a54a:	2b00      	cmp	r3, #0
 800a54c:	f43f af66 	beq.w	800a41c <xQueueReceive+0x18>
	__asm volatile
 800a550:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a554:	b672      	cpsid	i
 800a556:	f383 8811 	msr	BASEPRI, r3
 800a55a:	f3bf 8f6f 	isb	sy
 800a55e:	f3bf 8f4f 	dsb	sy
 800a562:	b662      	cpsie	i
 800a564:	e7fe      	b.n	800a564 <xQueueReceive+0x160>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a566:	9b01      	ldr	r3, [sp, #4]
 800a568:	2b00      	cmp	r3, #0
 800a56a:	f43f af5c 	beq.w	800a426 <xQueueReceive+0x22>
 800a56e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a572:	b672      	cpsid	i
 800a574:	f383 8811 	msr	BASEPRI, r3
 800a578:	f3bf 8f6f 	isb	sy
 800a57c:	f3bf 8f4f 	dsb	sy
 800a580:	b662      	cpsie	i
 800a582:	e7fe      	b.n	800a582 <xQueueReceive+0x17e>
	taskENTER_CRITICAL();
 800a584:	f001 fdb6 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a588:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a58c:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a58e:	2d00      	cmp	r5, #0
 800a590:	dc04      	bgt.n	800a59c <xQueueReceive+0x198>
 800a592:	e011      	b.n	800a5b8 <xQueueReceive+0x1b4>
			--cTxLock;
 800a594:	1e6b      	subs	r3, r5, #1
 800a596:	b2da      	uxtb	r2, r3
 800a598:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a59a:	b16a      	cbz	r2, 800a5b8 <xQueueReceive+0x1b4>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a59c:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a59e:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a5a0:	b153      	cbz	r3, 800a5b8 <xQueueReceive+0x1b4>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a5a2:	f001 f97b 	bl	800b89c <xTaskRemoveFromEventList>
 800a5a6:	2800      	cmp	r0, #0
 800a5a8:	d0f4      	beq.n	800a594 <xQueueReceive+0x190>
						vTaskMissedYield();
 800a5aa:	f001 fa27 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 800a5ae:	1e6b      	subs	r3, r5, #1
 800a5b0:	b2da      	uxtb	r2, r3
 800a5b2:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a5b4:	2a00      	cmp	r2, #0
 800a5b6:	d1f1      	bne.n	800a59c <xQueueReceive+0x198>
		pxQueue->cTxLock = queueUNLOCKED;
 800a5b8:	23ff      	movs	r3, #255	; 0xff
 800a5ba:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a5be:	f001 fdbf 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a5c2:	f001 fd97 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a5c6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a5ca:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a5cc:	2d00      	cmp	r5, #0
 800a5ce:	dd14      	ble.n	800a5fa <xQueueReceive+0x1f6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a5d0:	f104 0910 	add.w	r9, r4, #16
 800a5d4:	e003      	b.n	800a5de <xQueueReceive+0x1da>
				--cRxLock;
 800a5d6:	1e6b      	subs	r3, r5, #1
 800a5d8:	b2da      	uxtb	r2, r3
 800a5da:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a5dc:	b16a      	cbz	r2, 800a5fa <xQueueReceive+0x1f6>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a5de:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a5e0:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a5e2:	b153      	cbz	r3, 800a5fa <xQueueReceive+0x1f6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a5e4:	f001 f95a 	bl	800b89c <xTaskRemoveFromEventList>
 800a5e8:	2800      	cmp	r0, #0
 800a5ea:	d0f4      	beq.n	800a5d6 <xQueueReceive+0x1d2>
					vTaskMissedYield();
 800a5ec:	f001 fa06 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 800a5f0:	1e6b      	subs	r3, r5, #1
 800a5f2:	b2da      	uxtb	r2, r3
 800a5f4:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a5f6:	2a00      	cmp	r2, #0
 800a5f8:	d1f1      	bne.n	800a5de <xQueueReceive+0x1da>
		pxQueue->cRxLock = queueUNLOCKED;
 800a5fa:	23ff      	movs	r3, #255	; 0xff
 800a5fc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a600:	f001 fd9e 	bl	800c140 <vPortExitCritical>
			( void ) xTaskResumeAll();
 800a604:	f000 ffc2 	bl	800b58c <xTaskResumeAll>
	taskENTER_CRITICAL();
 800a608:	f001 fd74 	bl	800c0f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800a60c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a60e:	b15b      	cbz	r3, 800a628 <xQueueReceive+0x224>
	taskEXIT_CRITICAL();
 800a610:	f001 fd96 	bl	800c140 <vPortExitCritical>
		taskENTER_CRITICAL();
 800a614:	f001 fd6e 	bl	800c0f4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800a618:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800a61a:	2d00      	cmp	r5, #0
 800a61c:	f47f af7d 	bne.w	800a51a <xQueueReceive+0x116>
				if( xTicksToWait == ( TickType_t ) 0 )
 800a620:	9b01      	ldr	r3, [sp, #4]
 800a622:	2b00      	cmp	r3, #0
 800a624:	f47f af0e 	bne.w	800a444 <xQueueReceive+0x40>
					taskEXIT_CRITICAL();
 800a628:	f001 fd8a 	bl	800c140 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800a62c:	2000      	movs	r0, #0
}
 800a62e:	b005      	add	sp, #20
 800a630:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	taskEXIT_CRITICAL();
 800a634:	f001 fd84 	bl	800c140 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800a638:	9901      	ldr	r1, [sp, #4]
 800a63a:	4630      	mov	r0, r6
 800a63c:	f001 f890 	bl	800b760 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 800a640:	f001 fd58 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a644:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a648:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a64a:	2d00      	cmp	r5, #0
 800a64c:	dc04      	bgt.n	800a658 <xQueueReceive+0x254>
 800a64e:	e011      	b.n	800a674 <xQueueReceive+0x270>
			--cTxLock;
 800a650:	1e6b      	subs	r3, r5, #1
 800a652:	b2da      	uxtb	r2, r3
 800a654:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a656:	b16a      	cbz	r2, 800a674 <xQueueReceive+0x270>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a658:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a65a:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a65c:	b153      	cbz	r3, 800a674 <xQueueReceive+0x270>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a65e:	f001 f91d 	bl	800b89c <xTaskRemoveFromEventList>
 800a662:	2800      	cmp	r0, #0
 800a664:	d0f4      	beq.n	800a650 <xQueueReceive+0x24c>
						vTaskMissedYield();
 800a666:	f001 f9c9 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 800a66a:	1e6b      	subs	r3, r5, #1
 800a66c:	b2da      	uxtb	r2, r3
 800a66e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a670:	2a00      	cmp	r2, #0
 800a672:	d1f1      	bne.n	800a658 <xQueueReceive+0x254>
		pxQueue->cTxLock = queueUNLOCKED;
 800a674:	23ff      	movs	r3, #255	; 0xff
 800a676:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a67a:	f001 fd61 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a67e:	f001 fd39 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a682:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a686:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a688:	2d00      	cmp	r5, #0
 800a68a:	dd14      	ble.n	800a6b6 <xQueueReceive+0x2b2>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a68c:	f104 0910 	add.w	r9, r4, #16
 800a690:	e003      	b.n	800a69a <xQueueReceive+0x296>
				--cRxLock;
 800a692:	1e6b      	subs	r3, r5, #1
 800a694:	b2da      	uxtb	r2, r3
 800a696:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a698:	b16a      	cbz	r2, 800a6b6 <xQueueReceive+0x2b2>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a69a:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a69c:	4648      	mov	r0, r9
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a69e:	b153      	cbz	r3, 800a6b6 <xQueueReceive+0x2b2>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a6a0:	f001 f8fc 	bl	800b89c <xTaskRemoveFromEventList>
 800a6a4:	2800      	cmp	r0, #0
 800a6a6:	d0f4      	beq.n	800a692 <xQueueReceive+0x28e>
					vTaskMissedYield();
 800a6a8:	f001 f9a8 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 800a6ac:	1e6b      	subs	r3, r5, #1
 800a6ae:	b2da      	uxtb	r2, r3
 800a6b0:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a6b2:	2a00      	cmp	r2, #0
 800a6b4:	d1f1      	bne.n	800a69a <xQueueReceive+0x296>
		pxQueue->cRxLock = queueUNLOCKED;
 800a6b6:	23ff      	movs	r3, #255	; 0xff
 800a6b8:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a6bc:	f001 fd40 	bl	800c140 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 800a6c0:	f000 ff64 	bl	800b58c <xTaskResumeAll>
 800a6c4:	2800      	cmp	r0, #0
 800a6c6:	d1a5      	bne.n	800a614 <xQueueReceive+0x210>
					portYIELD_WITHIN_API();
 800a6c8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800a6cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a6d0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800a6d4:	f3bf 8f4f 	dsb	sy
 800a6d8:	f3bf 8f6f 	isb	sy
		taskENTER_CRITICAL();
 800a6dc:	e79a      	b.n	800a614 <xQueueReceive+0x210>
 800a6de:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a6e2:	b672      	cpsid	i
 800a6e4:	f383 8811 	msr	BASEPRI, r3
 800a6e8:	f3bf 8f6f 	isb	sy
 800a6ec:	f3bf 8f4f 	dsb	sy
 800a6f0:	b662      	cpsie	i
	configASSERT( ( pxQueue ) );
 800a6f2:	e7fe      	b.n	800a6f2 <xQueueReceive+0x2ee>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a6f4:	f104 0010 	add.w	r0, r4, #16
 800a6f8:	f001 f8d0 	bl	800b89c <xTaskRemoveFromEventList>
 800a6fc:	2800      	cmp	r0, #0
 800a6fe:	f43f af1f 	beq.w	800a540 <xQueueReceive+0x13c>
						queueYIELD_IF_USING_PREEMPTION();
 800a702:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800a706:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a70a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800a70e:	f3bf 8f4f 	dsb	sy
 800a712:	f3bf 8f6f 	isb	sy
 800a716:	e713      	b.n	800a540 <xQueueReceive+0x13c>

0800a718 <xQueueSemaphoreTake>:
{
 800a718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a71c:	b084      	sub	sp, #16
 800a71e:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 800a720:	2800      	cmp	r0, #0
 800a722:	d05e      	beq.n	800a7e2 <xQueueSemaphoreTake+0xca>
	configASSERT( pxQueue->uxItemSize == 0 );
 800a724:	6c07      	ldr	r7, [r0, #64]	; 0x40
 800a726:	4604      	mov	r4, r0
 800a728:	b157      	cbz	r7, 800a740 <xQueueSemaphoreTake+0x28>
 800a72a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a72e:	b672      	cpsid	i
 800a730:	f383 8811 	msr	BASEPRI, r3
 800a734:	f3bf 8f6f 	isb	sy
 800a738:	f3bf 8f4f 	dsb	sy
 800a73c:	b662      	cpsie	i
 800a73e:	e7fe      	b.n	800a73e <xQueueSemaphoreTake+0x26>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a740:	f001 f968 	bl	800ba14 <xTaskGetSchedulerState>
 800a744:	4605      	mov	r5, r0
 800a746:	2800      	cmp	r0, #0
 800a748:	d056      	beq.n	800a7f8 <xQueueSemaphoreTake+0xe0>
 800a74a:	463d      	mov	r5, r7
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a74c:	f104 0624 	add.w	r6, r4, #36	; 0x24
		taskENTER_CRITICAL();
 800a750:	f001 fcd0 	bl	800c0f4 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 800a754:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 800a756:	2b00      	cmp	r3, #0
 800a758:	f040 814f 	bne.w	800a9fa <xQueueSemaphoreTake+0x2e2>
				if( xTicksToWait == ( TickType_t ) 0 )
 800a75c:	9b01      	ldr	r3, [sp, #4]
 800a75e:	2b00      	cmp	r3, #0
 800a760:	f000 813e 	beq.w	800a9e0 <xQueueSemaphoreTake+0x2c8>
				else if( xEntryTimeSet == pdFALSE )
 800a764:	2d00      	cmp	r5, #0
 800a766:	f000 80a1 	beq.w	800a8ac <xQueueSemaphoreTake+0x194>
		taskEXIT_CRITICAL();
 800a76a:	f001 fce9 	bl	800c140 <vPortExitCritical>
		vTaskSuspendAll();
 800a76e:	f000 fdaf 	bl	800b2d0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800a772:	f001 fcbf 	bl	800c0f4 <vPortEnterCritical>
 800a776:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a77a:	2bff      	cmp	r3, #255	; 0xff
 800a77c:	d102      	bne.n	800a784 <xQueueSemaphoreTake+0x6c>
 800a77e:	2300      	movs	r3, #0
 800a780:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 800a784:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a788:	2bff      	cmp	r3, #255	; 0xff
 800a78a:	d102      	bne.n	800a792 <xQueueSemaphoreTake+0x7a>
 800a78c:	2300      	movs	r3, #0
 800a78e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800a792:	f001 fcd5 	bl	800c140 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800a796:	a901      	add	r1, sp, #4
 800a798:	a802      	add	r0, sp, #8
 800a79a:	f001 f8d7 	bl	800b94c <xTaskCheckForTimeOut>
 800a79e:	2800      	cmp	r0, #0
 800a7a0:	d139      	bne.n	800a816 <xQueueSemaphoreTake+0xfe>
	taskENTER_CRITICAL();
 800a7a2:	f001 fca7 	bl	800c0f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800a7a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a7a8:	2b00      	cmp	r3, #0
 800a7aa:	f000 80a8 	beq.w	800a8fe <xQueueSemaphoreTake+0x1e6>
	taskEXIT_CRITICAL();
 800a7ae:	f001 fcc7 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a7b2:	f001 fc9f 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a7b6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a7ba:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a7bc:	2d00      	cmp	r5, #0
 800a7be:	dc05      	bgt.n	800a7cc <xQueueSemaphoreTake+0xb4>
 800a7c0:	e078      	b.n	800a8b4 <xQueueSemaphoreTake+0x19c>
			--cTxLock;
 800a7c2:	1e6b      	subs	r3, r5, #1
 800a7c4:	b2da      	uxtb	r2, r3
 800a7c6:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a7c8:	2a00      	cmp	r2, #0
 800a7ca:	d073      	beq.n	800a8b4 <xQueueSemaphoreTake+0x19c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a7cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a7ce:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a7d0:	2b00      	cmp	r3, #0
 800a7d2:	d06f      	beq.n	800a8b4 <xQueueSemaphoreTake+0x19c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a7d4:	f001 f862 	bl	800b89c <xTaskRemoveFromEventList>
 800a7d8:	2800      	cmp	r0, #0
 800a7da:	d0f2      	beq.n	800a7c2 <xQueueSemaphoreTake+0xaa>
						vTaskMissedYield();
 800a7dc:	f001 f90e 	bl	800b9fc <vTaskMissedYield>
 800a7e0:	e7ef      	b.n	800a7c2 <xQueueSemaphoreTake+0xaa>
 800a7e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a7e6:	b672      	cpsid	i
 800a7e8:	f383 8811 	msr	BASEPRI, r3
 800a7ec:	f3bf 8f6f 	isb	sy
 800a7f0:	f3bf 8f4f 	dsb	sy
 800a7f4:	b662      	cpsie	i
	configASSERT( ( pxQueue ) );
 800a7f6:	e7fe      	b.n	800a7f6 <xQueueSemaphoreTake+0xde>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a7f8:	9b01      	ldr	r3, [sp, #4]
 800a7fa:	2b00      	cmp	r3, #0
 800a7fc:	f000 80d6 	beq.w	800a9ac <xQueueSemaphoreTake+0x294>
 800a800:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a804:	b672      	cpsid	i
 800a806:	f383 8811 	msr	BASEPRI, r3
 800a80a:	f3bf 8f6f 	isb	sy
 800a80e:	f3bf 8f4f 	dsb	sy
 800a812:	b662      	cpsie	i
 800a814:	e7fe      	b.n	800a814 <xQueueSemaphoreTake+0xfc>
	taskENTER_CRITICAL();
 800a816:	f001 fc6d 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a81a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a81e:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a820:	2d00      	cmp	r5, #0
 800a822:	dc04      	bgt.n	800a82e <xQueueSemaphoreTake+0x116>
 800a824:	e011      	b.n	800a84a <xQueueSemaphoreTake+0x132>
			--cTxLock;
 800a826:	1e6b      	subs	r3, r5, #1
 800a828:	b2da      	uxtb	r2, r3
 800a82a:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a82c:	b16a      	cbz	r2, 800a84a <xQueueSemaphoreTake+0x132>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a82e:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a830:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a832:	b153      	cbz	r3, 800a84a <xQueueSemaphoreTake+0x132>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a834:	f001 f832 	bl	800b89c <xTaskRemoveFromEventList>
 800a838:	2800      	cmp	r0, #0
 800a83a:	d0f4      	beq.n	800a826 <xQueueSemaphoreTake+0x10e>
						vTaskMissedYield();
 800a83c:	f001 f8de 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 800a840:	1e6b      	subs	r3, r5, #1
 800a842:	b2da      	uxtb	r2, r3
 800a844:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a846:	2a00      	cmp	r2, #0
 800a848:	d1f1      	bne.n	800a82e <xQueueSemaphoreTake+0x116>
		pxQueue->cTxLock = queueUNLOCKED;
 800a84a:	23ff      	movs	r3, #255	; 0xff
 800a84c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a850:	f001 fc76 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a854:	f001 fc4e 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a858:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a85c:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a85e:	2d00      	cmp	r5, #0
 800a860:	dd14      	ble.n	800a88c <xQueueSemaphoreTake+0x174>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a862:	f104 0810 	add.w	r8, r4, #16
 800a866:	e003      	b.n	800a870 <xQueueSemaphoreTake+0x158>
				--cRxLock;
 800a868:	1e6b      	subs	r3, r5, #1
 800a86a:	b2da      	uxtb	r2, r3
 800a86c:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a86e:	b16a      	cbz	r2, 800a88c <xQueueSemaphoreTake+0x174>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a870:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a872:	4640      	mov	r0, r8
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a874:	b153      	cbz	r3, 800a88c <xQueueSemaphoreTake+0x174>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a876:	f001 f811 	bl	800b89c <xTaskRemoveFromEventList>
 800a87a:	2800      	cmp	r0, #0
 800a87c:	d0f4      	beq.n	800a868 <xQueueSemaphoreTake+0x150>
					vTaskMissedYield();
 800a87e:	f001 f8bd 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 800a882:	1e6b      	subs	r3, r5, #1
 800a884:	b2da      	uxtb	r2, r3
 800a886:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a888:	2a00      	cmp	r2, #0
 800a88a:	d1f1      	bne.n	800a870 <xQueueSemaphoreTake+0x158>
		pxQueue->cRxLock = queueUNLOCKED;
 800a88c:	23ff      	movs	r3, #255	; 0xff
 800a88e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a892:	f001 fc55 	bl	800c140 <vPortExitCritical>
			( void ) xTaskResumeAll();
 800a896:	f000 fe79 	bl	800b58c <xTaskResumeAll>
	taskENTER_CRITICAL();
 800a89a:	f001 fc2b 	bl	800c0f4 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800a89e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a8a0:	2b00      	cmp	r3, #0
 800a8a2:	d07c      	beq.n	800a99e <xQueueSemaphoreTake+0x286>
	taskEXIT_CRITICAL();
 800a8a4:	f001 fc4c 	bl	800c140 <vPortExitCritical>
	return xReturn;
 800a8a8:	2501      	movs	r5, #1
 800a8aa:	e751      	b.n	800a750 <xQueueSemaphoreTake+0x38>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800a8ac:	a802      	add	r0, sp, #8
 800a8ae:	f001 f841 	bl	800b934 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800a8b2:	e75a      	b.n	800a76a <xQueueSemaphoreTake+0x52>
		pxQueue->cTxLock = queueUNLOCKED;
 800a8b4:	23ff      	movs	r3, #255	; 0xff
 800a8b6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a8ba:	f001 fc41 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a8be:	f001 fc19 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a8c2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a8c6:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a8c8:	2d00      	cmp	r5, #0
 800a8ca:	dd10      	ble.n	800a8ee <xQueueSemaphoreTake+0x1d6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a8cc:	f104 0810 	add.w	r8, r4, #16
 800a8d0:	e003      	b.n	800a8da <xQueueSemaphoreTake+0x1c2>
				--cRxLock;
 800a8d2:	1e6b      	subs	r3, r5, #1
 800a8d4:	b2da      	uxtb	r2, r3
 800a8d6:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a8d8:	b14a      	cbz	r2, 800a8ee <xQueueSemaphoreTake+0x1d6>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a8da:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a8dc:	4640      	mov	r0, r8
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a8de:	b133      	cbz	r3, 800a8ee <xQueueSemaphoreTake+0x1d6>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a8e0:	f000 ffdc 	bl	800b89c <xTaskRemoveFromEventList>
 800a8e4:	2800      	cmp	r0, #0
 800a8e6:	d0f4      	beq.n	800a8d2 <xQueueSemaphoreTake+0x1ba>
					vTaskMissedYield();
 800a8e8:	f001 f888 	bl	800b9fc <vTaskMissedYield>
 800a8ec:	e7f1      	b.n	800a8d2 <xQueueSemaphoreTake+0x1ba>
		pxQueue->cRxLock = queueUNLOCKED;
 800a8ee:	23ff      	movs	r3, #255	; 0xff
 800a8f0:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a8f4:	f001 fc24 	bl	800c140 <vPortExitCritical>
				( void ) xTaskResumeAll();
 800a8f8:	f000 fe48 	bl	800b58c <xTaskResumeAll>
 800a8fc:	e7d4      	b.n	800a8a8 <xQueueSemaphoreTake+0x190>
	taskEXIT_CRITICAL();
 800a8fe:	f001 fc1f 	bl	800c140 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800a902:	6823      	ldr	r3, [r4, #0]
 800a904:	2b00      	cmp	r3, #0
 800a906:	d062      	beq.n	800a9ce <xQueueSemaphoreTake+0x2b6>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800a908:	9901      	ldr	r1, [sp, #4]
 800a90a:	4630      	mov	r0, r6
 800a90c:	f000 ff28 	bl	800b760 <vTaskPlaceOnEventList>
	taskENTER_CRITICAL();
 800a910:	f001 fbf0 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800a914:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800a918:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a91a:	2d00      	cmp	r5, #0
 800a91c:	dc04      	bgt.n	800a928 <xQueueSemaphoreTake+0x210>
 800a91e:	e00d      	b.n	800a93c <xQueueSemaphoreTake+0x224>
			--cTxLock;
 800a920:	1e6b      	subs	r3, r5, #1
 800a922:	b2da      	uxtb	r2, r3
 800a924:	b25d      	sxtb	r5, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800a926:	b14a      	cbz	r2, 800a93c <xQueueSemaphoreTake+0x224>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a928:	6a63      	ldr	r3, [r4, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a92a:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a92c:	b133      	cbz	r3, 800a93c <xQueueSemaphoreTake+0x224>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a92e:	f000 ffb5 	bl	800b89c <xTaskRemoveFromEventList>
 800a932:	2800      	cmp	r0, #0
 800a934:	d0f4      	beq.n	800a920 <xQueueSemaphoreTake+0x208>
						vTaskMissedYield();
 800a936:	f001 f861 	bl	800b9fc <vTaskMissedYield>
 800a93a:	e7f1      	b.n	800a920 <xQueueSemaphoreTake+0x208>
		pxQueue->cTxLock = queueUNLOCKED;
 800a93c:	23ff      	movs	r3, #255	; 0xff
 800a93e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 800a942:	f001 fbfd 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800a946:	f001 fbd5 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800a94a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800a94e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a950:	2d00      	cmp	r5, #0
 800a952:	dd10      	ble.n	800a976 <xQueueSemaphoreTake+0x25e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a954:	f104 0810 	add.w	r8, r4, #16
 800a958:	e003      	b.n	800a962 <xQueueSemaphoreTake+0x24a>
				--cRxLock;
 800a95a:	1e6b      	subs	r3, r5, #1
 800a95c:	b2da      	uxtb	r2, r3
 800a95e:	b25d      	sxtb	r5, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800a960:	b14a      	cbz	r2, 800a976 <xQueueSemaphoreTake+0x25e>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a962:	6923      	ldr	r3, [r4, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a964:	4640      	mov	r0, r8
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a966:	b133      	cbz	r3, 800a976 <xQueueSemaphoreTake+0x25e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a968:	f000 ff98 	bl	800b89c <xTaskRemoveFromEventList>
 800a96c:	2800      	cmp	r0, #0
 800a96e:	d0f4      	beq.n	800a95a <xQueueSemaphoreTake+0x242>
					vTaskMissedYield();
 800a970:	f001 f844 	bl	800b9fc <vTaskMissedYield>
 800a974:	e7f1      	b.n	800a95a <xQueueSemaphoreTake+0x242>
		pxQueue->cRxLock = queueUNLOCKED;
 800a976:	23ff      	movs	r3, #255	; 0xff
 800a978:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
 800a97c:	f001 fbe0 	bl	800c140 <vPortExitCritical>
				if( xTaskResumeAll() == pdFALSE )
 800a980:	f000 fe04 	bl	800b58c <xTaskResumeAll>
 800a984:	2800      	cmp	r0, #0
 800a986:	d18f      	bne.n	800a8a8 <xQueueSemaphoreTake+0x190>
					portYIELD_WITHIN_API();
 800a988:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800a98c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a990:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800a994:	f3bf 8f4f 	dsb	sy
 800a998:	f3bf 8f6f 	isb	sy
 800a99c:	e784      	b.n	800a8a8 <xQueueSemaphoreTake+0x190>
	taskEXIT_CRITICAL();
 800a99e:	f001 fbcf 	bl	800c140 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
 800a9a2:	b92f      	cbnz	r7, 800a9b0 <xQueueSemaphoreTake+0x298>
}
 800a9a4:	4638      	mov	r0, r7
 800a9a6:	b004      	add	sp, #16
 800a9a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800a9ac:	4607      	mov	r7, r0
 800a9ae:	e6cd      	b.n	800a74c <xQueueSemaphoreTake+0x34>
						taskENTER_CRITICAL();
 800a9b0:	f001 fba0 	bl	800c0f4 <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 800a9b4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a9b6:	b119      	cbz	r1, 800a9c0 <xQueueSemaphoreTake+0x2a8>
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 800a9b8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a9ba:	6819      	ldr	r1, [r3, #0]
 800a9bc:	f1c1 0138 	rsb	r1, r1, #56	; 0x38
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 800a9c0:	68a0      	ldr	r0, [r4, #8]
				return errQUEUE_EMPTY;
 800a9c2:	2700      	movs	r7, #0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 800a9c4:	f001 f8c6 	bl	800bb54 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 800a9c8:	f001 fbba 	bl	800c140 <vPortExitCritical>
 800a9cc:	e7ea      	b.n	800a9a4 <xQueueSemaphoreTake+0x28c>
						taskENTER_CRITICAL();
 800a9ce:	f001 fb91 	bl	800c0f4 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 800a9d2:	68a0      	ldr	r0, [r4, #8]
 800a9d4:	f001 f82e 	bl	800ba34 <xTaskPriorityInherit>
 800a9d8:	4607      	mov	r7, r0
						taskEXIT_CRITICAL();
 800a9da:	f001 fbb1 	bl	800c140 <vPortExitCritical>
 800a9de:	e793      	b.n	800a908 <xQueueSemaphoreTake+0x1f0>
						configASSERT( xInheritanceOccurred == pdFALSE );
 800a9e0:	2f00      	cmp	r7, #0
 800a9e2:	d0f1      	beq.n	800a9c8 <xQueueSemaphoreTake+0x2b0>
 800a9e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a9e8:	b672      	cpsid	i
 800a9ea:	f383 8811 	msr	BASEPRI, r3
 800a9ee:	f3bf 8f6f 	isb	sy
 800a9f2:	f3bf 8f4f 	dsb	sy
 800a9f6:	b662      	cpsie	i
 800a9f8:	e7fe      	b.n	800a9f8 <xQueueSemaphoreTake+0x2e0>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800a9fa:	3b01      	subs	r3, #1
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800a9fc:	6822      	ldr	r2, [r4, #0]
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800a9fe:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800aa00:	b12a      	cbz	r2, 800aa0e <xQueueSemaphoreTake+0x2f6>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800aa02:	6923      	ldr	r3, [r4, #16]
 800aa04:	b93b      	cbnz	r3, 800aa16 <xQueueSemaphoreTake+0x2fe>
				return pdPASS;
 800aa06:	2701      	movs	r7, #1
				taskEXIT_CRITICAL();
 800aa08:	f001 fb9a 	bl	800c140 <vPortExitCritical>
				return pdPASS;
 800aa0c:	e7ca      	b.n	800a9a4 <xQueueSemaphoreTake+0x28c>
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 800aa0e:	f001 f8f9 	bl	800bc04 <pvTaskIncrementMutexHeldCount>
 800aa12:	60a0      	str	r0, [r4, #8]
 800aa14:	e7f5      	b.n	800aa02 <xQueueSemaphoreTake+0x2ea>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800aa16:	f104 0010 	add.w	r0, r4, #16
 800aa1a:	f000 ff3f 	bl	800b89c <xTaskRemoveFromEventList>
 800aa1e:	2800      	cmp	r0, #0
 800aa20:	d0f1      	beq.n	800aa06 <xQueueSemaphoreTake+0x2ee>
						queueYIELD_IF_USING_PREEMPTION();
 800aa22:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800aa26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800aa2a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800aa2e:	f3bf 8f4f 	dsb	sy
 800aa32:	f3bf 8f6f 	isb	sy
 800aa36:	e7e6      	b.n	800aa06 <xQueueSemaphoreTake+0x2ee>

0800aa38 <xQueueTakeMutexRecursive>:
		configASSERT( pxMutex );
 800aa38:	b1a8      	cbz	r0, 800aa66 <xQueueTakeMutexRecursive+0x2e>
	{
 800aa3a:	b570      	push	{r4, r5, r6, lr}
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 800aa3c:	6886      	ldr	r6, [r0, #8]
 800aa3e:	4604      	mov	r4, r0
 800aa40:	460d      	mov	r5, r1
 800aa42:	f000 ffe1 	bl	800ba08 <xTaskGetCurrentTaskHandle>
 800aa46:	4286      	cmp	r6, r0
 800aa48:	d008      	beq.n	800aa5c <xQueueTakeMutexRecursive+0x24>
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 800aa4a:	4629      	mov	r1, r5
 800aa4c:	4620      	mov	r0, r4
 800aa4e:	f7ff fe63 	bl	800a718 <xQueueSemaphoreTake>
			if( xReturn != pdFAIL )
 800aa52:	b110      	cbz	r0, 800aa5a <xQueueTakeMutexRecursive+0x22>
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 800aa54:	68e3      	ldr	r3, [r4, #12]
 800aa56:	3301      	adds	r3, #1
 800aa58:	60e3      	str	r3, [r4, #12]
	}
 800aa5a:	bd70      	pop	{r4, r5, r6, pc}
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 800aa5c:	68e3      	ldr	r3, [r4, #12]
			xReturn = pdPASS;
 800aa5e:	2001      	movs	r0, #1
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 800aa60:	4403      	add	r3, r0
 800aa62:	60e3      	str	r3, [r4, #12]
	}
 800aa64:	bd70      	pop	{r4, r5, r6, pc}
 800aa66:	f04f 0350 	mov.w	r3, #80	; 0x50
 800aa6a:	b672      	cpsid	i
 800aa6c:	f383 8811 	msr	BASEPRI, r3
 800aa70:	f3bf 8f6f 	isb	sy
 800aa74:	f3bf 8f4f 	dsb	sy
 800aa78:	b662      	cpsie	i
		configASSERT( pxMutex );
 800aa7a:	e7fe      	b.n	800aa7a <xQueueTakeMutexRecursive+0x42>

0800aa7c <xQueueReceiveFromISR>:
{
 800aa7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 800aa80:	b330      	cbz	r0, 800aad0 <xQueueReceiveFromISR+0x54>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800aa82:	460e      	mov	r6, r1
 800aa84:	4604      	mov	r4, r0
 800aa86:	4617      	mov	r7, r2
 800aa88:	b1a1      	cbz	r1, 800aab4 <xQueueReceiveFromISR+0x38>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800aa8a:	f001 fc53 	bl	800c334 <vPortValidateInterruptPriority>
	__asm volatile
 800aa8e:	f3ef 8911 	mrs	r9, BASEPRI
 800aa92:	f04f 0350 	mov.w	r3, #80	; 0x50
 800aa96:	b672      	cpsid	i
 800aa98:	f383 8811 	msr	BASEPRI, r3
 800aa9c:	f3bf 8f6f 	isb	sy
 800aaa0:	f3bf 8f4f 	dsb	sy
 800aaa4:	b662      	cpsie	i
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800aaa6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800aaa8:	b9ed      	cbnz	r5, 800aae6 <xQueueReceiveFromISR+0x6a>
			xReturn = pdFAIL;
 800aaaa:	4628      	mov	r0, r5
	__asm volatile
 800aaac:	f389 8811 	msr	BASEPRI, r9
}
 800aab0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800aab4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800aab6:	2b00      	cmp	r3, #0
 800aab8:	d0e7      	beq.n	800aa8a <xQueueReceiveFromISR+0xe>
	__asm volatile
 800aaba:	f04f 0350 	mov.w	r3, #80	; 0x50
 800aabe:	b672      	cpsid	i
 800aac0:	f383 8811 	msr	BASEPRI, r3
 800aac4:	f3bf 8f6f 	isb	sy
 800aac8:	f3bf 8f4f 	dsb	sy
 800aacc:	b662      	cpsie	i
 800aace:	e7fe      	b.n	800aace <xQueueReceiveFromISR+0x52>
 800aad0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800aad4:	b672      	cpsid	i
 800aad6:	f383 8811 	msr	BASEPRI, r3
 800aada:	f3bf 8f6f 	isb	sy
 800aade:	f3bf 8f4f 	dsb	sy
 800aae2:	b662      	cpsie	i
	configASSERT( pxQueue );
 800aae4:	e7fe      	b.n	800aae4 <xQueueReceiveFromISR+0x68>
			const int8_t cRxLock = pxQueue->cRxLock;
 800aae6:	f894 8044 	ldrb.w	r8, [r4, #68]	; 0x44
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800aaea:	6c22      	ldr	r2, [r4, #64]	; 0x40
			const int8_t cRxLock = pxQueue->cRxLock;
 800aaec:	fa4f f888 	sxtb.w	r8, r8
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800aaf0:	b142      	cbz	r2, 800ab04 <xQueueReceiveFromISR+0x88>
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800aaf2:	68e1      	ldr	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800aaf4:	68a3      	ldr	r3, [r4, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800aaf6:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800aaf8:	4299      	cmp	r1, r3
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800aafa:	60e1      	str	r1, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800aafc:	d215      	bcs.n	800ab2a <xQueueReceiveFromISR+0xae>
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800aafe:	4630      	mov	r0, r6
 800ab00:	f008 fb12 	bl	8013128 <memcpy>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800ab04:	3d01      	subs	r5, #1
			if( cRxLock == queueUNLOCKED )
 800ab06:	f1b8 3fff 	cmp.w	r8, #4294967295
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800ab0a:	63a5      	str	r5, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800ab0c:	d009      	beq.n	800ab22 <xQueueReceiveFromISR+0xa6>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800ab0e:	f108 0301 	add.w	r3, r8, #1
			xReturn = pdPASS;
 800ab12:	2001      	movs	r0, #1
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800ab14:	b25b      	sxtb	r3, r3
 800ab16:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	__asm volatile
 800ab1a:	f389 8811 	msr	BASEPRI, r9
}
 800ab1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800ab22:	6923      	ldr	r3, [r4, #16]
 800ab24:	b923      	cbnz	r3, 800ab30 <xQueueReceiveFromISR+0xb4>
			xReturn = pdPASS;
 800ab26:	2001      	movs	r0, #1
 800ab28:	e7c0      	b.n	800aaac <xQueueReceiveFromISR+0x30>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800ab2a:	6821      	ldr	r1, [r4, #0]
 800ab2c:	60e1      	str	r1, [r4, #12]
 800ab2e:	e7e6      	b.n	800aafe <xQueueReceiveFromISR+0x82>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800ab30:	f104 0010 	add.w	r0, r4, #16
 800ab34:	f000 feb2 	bl	800b89c <xTaskRemoveFromEventList>
						if( pxHigherPriorityTaskWoken != NULL )
 800ab38:	2f00      	cmp	r7, #0
 800ab3a:	d0f4      	beq.n	800ab26 <xQueueReceiveFromISR+0xaa>
 800ab3c:	2800      	cmp	r0, #0
 800ab3e:	d0f2      	beq.n	800ab26 <xQueueReceiveFromISR+0xaa>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800ab40:	2301      	movs	r3, #1
			xReturn = pdPASS;
 800ab42:	4618      	mov	r0, r3
							*pxHigherPriorityTaskWoken = pdTRUE;
 800ab44:	603b      	str	r3, [r7, #0]
 800ab46:	e7b1      	b.n	800aaac <xQueueReceiveFromISR+0x30>

0800ab48 <vQueueDelete>:
	configASSERT( pxQueue );
 800ab48:	b1e0      	cbz	r0, 800ab84 <vQueueDelete+0x3c>

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 800ab4a:	4b23      	ldr	r3, [pc, #140]	; (800abd8 <vQueueDelete+0x90>)
 800ab4c:	685a      	ldr	r2, [r3, #4]
 800ab4e:	4290      	cmp	r0, r2
 800ab50:	d02d      	beq.n	800abae <vQueueDelete+0x66>
 800ab52:	68da      	ldr	r2, [r3, #12]
 800ab54:	4290      	cmp	r0, r2
 800ab56:	d02c      	beq.n	800abb2 <vQueueDelete+0x6a>
 800ab58:	695a      	ldr	r2, [r3, #20]
 800ab5a:	4290      	cmp	r0, r2
 800ab5c:	d02b      	beq.n	800abb6 <vQueueDelete+0x6e>
 800ab5e:	69da      	ldr	r2, [r3, #28]
 800ab60:	4290      	cmp	r0, r2
 800ab62:	d02a      	beq.n	800abba <vQueueDelete+0x72>
 800ab64:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ab66:	4290      	cmp	r0, r2
 800ab68:	d029      	beq.n	800abbe <vQueueDelete+0x76>
 800ab6a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ab6c:	4290      	cmp	r0, r2
 800ab6e:	d016      	beq.n	800ab9e <vQueueDelete+0x56>
 800ab70:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ab72:	4290      	cmp	r0, r2
 800ab74:	d025      	beq.n	800abc2 <vQueueDelete+0x7a>
 800ab76:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ab78:	4290      	cmp	r0, r2
 800ab7a:	d024      	beq.n	800abc6 <vQueueDelete+0x7e>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 800ab7c:	f890 3046 	ldrb.w	r3, [r0, #70]	; 0x46
 800ab80:	b15b      	cbz	r3, 800ab9a <vQueueDelete+0x52>
}
 800ab82:	4770      	bx	lr
	__asm volatile
 800ab84:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ab88:	b672      	cpsid	i
 800ab8a:	f383 8811 	msr	BASEPRI, r3
 800ab8e:	f3bf 8f6f 	isb	sy
 800ab92:	f3bf 8f4f 	dsb	sy
 800ab96:	b662      	cpsie	i
	configASSERT( pxQueue );
 800ab98:	e7fe      	b.n	800ab98 <vQueueDelete+0x50>
			vPortFree( pxQueue );
 800ab9a:	f001 bcb5 	b.w	800c508 <vPortFree>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800ab9e:	2205      	movs	r2, #5
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 800aba0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800aba4:	ed9f 7b0a 	vldr	d7, [pc, #40]	; 800abd0 <vQueueDelete+0x88>
 800aba8:	ed83 7b00 	vstr	d7, [r3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
				break;
 800abac:	e7e6      	b.n	800ab7c <vQueueDelete+0x34>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800abae:	2200      	movs	r2, #0
 800abb0:	e7f6      	b.n	800aba0 <vQueueDelete+0x58>
 800abb2:	2201      	movs	r2, #1
 800abb4:	e7f4      	b.n	800aba0 <vQueueDelete+0x58>
 800abb6:	2202      	movs	r2, #2
 800abb8:	e7f2      	b.n	800aba0 <vQueueDelete+0x58>
 800abba:	2203      	movs	r2, #3
 800abbc:	e7f0      	b.n	800aba0 <vQueueDelete+0x58>
 800abbe:	2204      	movs	r2, #4
 800abc0:	e7ee      	b.n	800aba0 <vQueueDelete+0x58>
 800abc2:	2206      	movs	r2, #6
 800abc4:	e7ec      	b.n	800aba0 <vQueueDelete+0x58>
 800abc6:	2207      	movs	r2, #7
 800abc8:	e7ea      	b.n	800aba0 <vQueueDelete+0x58>
 800abca:	bf00      	nop
 800abcc:	f3af 8000 	nop.w
	...
 800abd8:	20019fd0 	.word	0x20019fd0

0800abdc <vQueueAddToRegistry>:
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800abdc:	4b12      	ldr	r3, [pc, #72]	; (800ac28 <vQueueAddToRegistry+0x4c>)
 800abde:	681a      	ldr	r2, [r3, #0]
 800abe0:	b17a      	cbz	r2, 800ac02 <vQueueAddToRegistry+0x26>
 800abe2:	689a      	ldr	r2, [r3, #8]
 800abe4:	b162      	cbz	r2, 800ac00 <vQueueAddToRegistry+0x24>
 800abe6:	691a      	ldr	r2, [r3, #16]
 800abe8:	b192      	cbz	r2, 800ac10 <vQueueAddToRegistry+0x34>
 800abea:	699a      	ldr	r2, [r3, #24]
 800abec:	b192      	cbz	r2, 800ac14 <vQueueAddToRegistry+0x38>
 800abee:	6a1a      	ldr	r2, [r3, #32]
 800abf0:	b192      	cbz	r2, 800ac18 <vQueueAddToRegistry+0x3c>
 800abf2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800abf4:	b192      	cbz	r2, 800ac1c <vQueueAddToRegistry+0x40>
 800abf6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800abf8:	b192      	cbz	r2, 800ac20 <vQueueAddToRegistry+0x44>
 800abfa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800abfc:	b192      	cbz	r2, 800ac24 <vQueueAddToRegistry+0x48>
	}
 800abfe:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800ac00:	2201      	movs	r2, #1
				xQueueRegistry[ ux ].xHandle = xQueue;
 800ac02:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 800ac06:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800ac0a:	f8cc 0004 	str.w	r0, [ip, #4]
	}
 800ac0e:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800ac10:	2202      	movs	r2, #2
 800ac12:	e7f6      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac14:	2203      	movs	r2, #3
 800ac16:	e7f4      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac18:	2204      	movs	r2, #4
 800ac1a:	e7f2      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac1c:	2205      	movs	r2, #5
 800ac1e:	e7f0      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac20:	2206      	movs	r2, #6
 800ac22:	e7ee      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac24:	2207      	movs	r2, #7
 800ac26:	e7ec      	b.n	800ac02 <vQueueAddToRegistry+0x26>
 800ac28:	20019fd0 	.word	0x20019fd0

0800ac2c <vQueueUnregisterQueue>:
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 800ac2c:	4b17      	ldr	r3, [pc, #92]	; (800ac8c <vQueueUnregisterQueue+0x60>)
 800ac2e:	685a      	ldr	r2, [r3, #4]
 800ac30:	4290      	cmp	r0, r2
 800ac32:	d015      	beq.n	800ac60 <vQueueUnregisterQueue+0x34>
 800ac34:	68da      	ldr	r2, [r3, #12]
 800ac36:	4290      	cmp	r0, r2
 800ac38:	d01a      	beq.n	800ac70 <vQueueUnregisterQueue+0x44>
 800ac3a:	695a      	ldr	r2, [r3, #20]
 800ac3c:	4290      	cmp	r0, r2
 800ac3e:	d019      	beq.n	800ac74 <vQueueUnregisterQueue+0x48>
 800ac40:	69da      	ldr	r2, [r3, #28]
 800ac42:	4290      	cmp	r0, r2
 800ac44:	d018      	beq.n	800ac78 <vQueueUnregisterQueue+0x4c>
 800ac46:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ac48:	4290      	cmp	r0, r2
 800ac4a:	d017      	beq.n	800ac7c <vQueueUnregisterQueue+0x50>
 800ac4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ac4e:	4290      	cmp	r0, r2
 800ac50:	d016      	beq.n	800ac80 <vQueueUnregisterQueue+0x54>
 800ac52:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ac54:	4290      	cmp	r0, r2
 800ac56:	d015      	beq.n	800ac84 <vQueueUnregisterQueue+0x58>
 800ac58:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ac5a:	4282      	cmp	r2, r0
 800ac5c:	d014      	beq.n	800ac88 <vQueueUnregisterQueue+0x5c>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800ac5e:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800ac60:	2200      	movs	r2, #0
				xQueueRegistry[ ux ].pcQueueName = NULL;
 800ac62:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ac66:	2000      	movs	r0, #0
 800ac68:	2100      	movs	r1, #0
 800ac6a:	e9c3 0100 	strd	r0, r1, [r3]
	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800ac6e:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800ac70:	2201      	movs	r2, #1
 800ac72:	e7f6      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac74:	2202      	movs	r2, #2
 800ac76:	e7f4      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac78:	2203      	movs	r2, #3
 800ac7a:	e7f2      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac7c:	2204      	movs	r2, #4
 800ac7e:	e7f0      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac80:	2205      	movs	r2, #5
 800ac82:	e7ee      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac84:	2206      	movs	r2, #6
 800ac86:	e7ec      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac88:	2207      	movs	r2, #7
 800ac8a:	e7ea      	b.n	800ac62 <vQueueUnregisterQueue+0x36>
 800ac8c:	20019fd0 	.word	0x20019fd0

0800ac90 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800ac90:	b570      	push	{r4, r5, r6, lr}
 800ac92:	4605      	mov	r5, r0
 800ac94:	460e      	mov	r6, r1
 800ac96:	4614      	mov	r4, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800ac98:	f001 fa2c 	bl	800c0f4 <vPortEnterCritical>
 800ac9c:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 800aca0:	2bff      	cmp	r3, #255	; 0xff
 800aca2:	d102      	bne.n	800acaa <vQueueWaitForMessageRestricted+0x1a>
 800aca4:	2300      	movs	r3, #0
 800aca6:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
 800acaa:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 800acae:	2bff      	cmp	r3, #255	; 0xff
 800acb0:	d102      	bne.n	800acb8 <vQueueWaitForMessageRestricted+0x28>
 800acb2:	2300      	movs	r3, #0
 800acb4:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
 800acb8:	f001 fa42 	bl	800c140 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800acbc:	6bab      	ldr	r3, [r5, #56]	; 0x38
 800acbe:	2b00      	cmp	r3, #0
 800acc0:	d043      	beq.n	800ad4a <vQueueWaitForMessageRestricted+0xba>
	taskENTER_CRITICAL();
 800acc2:	f001 fa17 	bl	800c0f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800acc6:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 800acca:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800accc:	2c00      	cmp	r4, #0
 800acce:	dd14      	ble.n	800acfa <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800acd0:	f105 0624 	add.w	r6, r5, #36	; 0x24
 800acd4:	e003      	b.n	800acde <vQueueWaitForMessageRestricted+0x4e>
			--cTxLock;
 800acd6:	1e63      	subs	r3, r4, #1
 800acd8:	b2da      	uxtb	r2, r3
 800acda:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800acdc:	b16a      	cbz	r2, 800acfa <vQueueWaitForMessageRestricted+0x6a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800acde:	6a6b      	ldr	r3, [r5, #36]	; 0x24
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ace0:	4630      	mov	r0, r6
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800ace2:	b153      	cbz	r3, 800acfa <vQueueWaitForMessageRestricted+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ace4:	f000 fdda 	bl	800b89c <xTaskRemoveFromEventList>
 800ace8:	2800      	cmp	r0, #0
 800acea:	d0f4      	beq.n	800acd6 <vQueueWaitForMessageRestricted+0x46>
						vTaskMissedYield();
 800acec:	f000 fe86 	bl	800b9fc <vTaskMissedYield>
			--cTxLock;
 800acf0:	1e63      	subs	r3, r4, #1
 800acf2:	b2da      	uxtb	r2, r3
 800acf4:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800acf6:	2a00      	cmp	r2, #0
 800acf8:	d1f1      	bne.n	800acde <vQueueWaitForMessageRestricted+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
 800acfa:	23ff      	movs	r3, #255	; 0xff
 800acfc:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
 800ad00:	f001 fa1e 	bl	800c140 <vPortExitCritical>
	taskENTER_CRITICAL();
 800ad04:	f001 f9f6 	bl	800c0f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800ad08:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 800ad0c:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800ad0e:	2c00      	cmp	r4, #0
 800ad10:	dd14      	ble.n	800ad3c <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800ad12:	f105 0610 	add.w	r6, r5, #16
 800ad16:	e003      	b.n	800ad20 <vQueueWaitForMessageRestricted+0x90>
				--cRxLock;
 800ad18:	1e63      	subs	r3, r4, #1
 800ad1a:	b2da      	uxtb	r2, r3
 800ad1c:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800ad1e:	b16a      	cbz	r2, 800ad3c <vQueueWaitForMessageRestricted+0xac>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800ad20:	692b      	ldr	r3, [r5, #16]
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800ad22:	4630      	mov	r0, r6
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800ad24:	b153      	cbz	r3, 800ad3c <vQueueWaitForMessageRestricted+0xac>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800ad26:	f000 fdb9 	bl	800b89c <xTaskRemoveFromEventList>
 800ad2a:	2800      	cmp	r0, #0
 800ad2c:	d0f4      	beq.n	800ad18 <vQueueWaitForMessageRestricted+0x88>
					vTaskMissedYield();
 800ad2e:	f000 fe65 	bl	800b9fc <vTaskMissedYield>
				--cRxLock;
 800ad32:	1e63      	subs	r3, r4, #1
 800ad34:	b2da      	uxtb	r2, r3
 800ad36:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800ad38:	2a00      	cmp	r2, #0
 800ad3a:	d1f1      	bne.n	800ad20 <vQueueWaitForMessageRestricted+0x90>
		pxQueue->cRxLock = queueUNLOCKED;
 800ad3c:	23ff      	movs	r3, #255	; 0xff
 800ad3e:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
	}
 800ad42:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 800ad46:	f001 b9fb 	b.w	800c140 <vPortExitCritical>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 800ad4a:	4622      	mov	r2, r4
 800ad4c:	4631      	mov	r1, r6
 800ad4e:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800ad52:	f000 fd4f 	bl	800b7f4 <vTaskPlaceOnEventListRestricted>
 800ad56:	e7b4      	b.n	800acc2 <vQueueWaitForMessageRestricted+0x32>

0800ad58 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 800ad58:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ad5c:	4605      	mov	r5, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 800ad5e:	f001 f9c9 	bl	800c0f4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 800ad62:	4a34      	ldr	r2, [pc, #208]	; (800ae34 <prvAddNewTaskToReadyList+0xdc>)
		if( pxCurrentTCB == NULL )
 800ad64:	4e34      	ldr	r6, [pc, #208]	; (800ae38 <prvAddNewTaskToReadyList+0xe0>)
		uxCurrentNumberOfTasks++;
 800ad66:	6813      	ldr	r3, [r2, #0]
 800ad68:	3301      	adds	r3, #1
 800ad6a:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 800ad6c:	6833      	ldr	r3, [r6, #0]
 800ad6e:	2b00      	cmp	r3, #0
 800ad70:	d032      	beq.n	800add8 <prvAddNewTaskToReadyList+0x80>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 800ad72:	4c32      	ldr	r4, [pc, #200]	; (800ae3c <prvAddNewTaskToReadyList+0xe4>)
 800ad74:	6823      	ldr	r3, [r4, #0]
 800ad76:	b33b      	cbz	r3, 800adc8 <prvAddNewTaskToReadyList+0x70>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800ad78:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800ad7a:	4f31      	ldr	r7, [pc, #196]	; (800ae40 <prvAddNewTaskToReadyList+0xe8>)
		uxTaskNumber++;
 800ad7c:	4a31      	ldr	r2, [pc, #196]	; (800ae44 <prvAddNewTaskToReadyList+0xec>)
		prvAddTaskToReadyList( pxNewTCB );
 800ad7e:	4932      	ldr	r1, [pc, #200]	; (800ae48 <prvAddNewTaskToReadyList+0xf0>)
		uxTaskNumber++;
 800ad80:	6813      	ldr	r3, [r2, #0]
 800ad82:	3301      	adds	r3, #1
 800ad84:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 800ad86:	64ab      	str	r3, [r5, #72]	; 0x48
		prvAddTaskToReadyList( pxNewTCB );
 800ad88:	680b      	ldr	r3, [r1, #0]
 800ad8a:	4283      	cmp	r3, r0
 800ad8c:	d200      	bcs.n	800ad90 <prvAddNewTaskToReadyList+0x38>
 800ad8e:	6008      	str	r0, [r1, #0]
 800ad90:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800ad94:	1d29      	adds	r1, r5, #4
 800ad96:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 800ad9a:	f7fe fe33 	bl	8009a04 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 800ad9e:	f001 f9cf 	bl	800c140 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 800ada2:	6823      	ldr	r3, [r4, #0]
 800ada4:	b173      	cbz	r3, 800adc4 <prvAddNewTaskToReadyList+0x6c>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800ada6:	6832      	ldr	r2, [r6, #0]
 800ada8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800adaa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800adac:	429a      	cmp	r2, r3
 800adae:	d209      	bcs.n	800adc4 <prvAddNewTaskToReadyList+0x6c>
		{
			taskYIELD_IF_USING_PREEMPTION();
 800adb0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800adb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800adb8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800adbc:	f3bf 8f4f 	dsb	sy
 800adc0:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800adc4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800adc8:	6833      	ldr	r3, [r6, #0]
 800adca:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800adcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800adce:	4f1c      	ldr	r7, [pc, #112]	; (800ae40 <prvAddNewTaskToReadyList+0xe8>)
 800add0:	4283      	cmp	r3, r0
 800add2:	d8d3      	bhi.n	800ad7c <prvAddNewTaskToReadyList+0x24>
					pxCurrentTCB = pxNewTCB;
 800add4:	6035      	str	r5, [r6, #0]
 800add6:	e7d1      	b.n	800ad7c <prvAddNewTaskToReadyList+0x24>
			pxCurrentTCB = pxNewTCB;
 800add8:	6035      	str	r5, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800adda:	6813      	ldr	r3, [r2, #0]
 800addc:	2b01      	cmp	r3, #1
 800adde:	d003      	beq.n	800ade8 <prvAddNewTaskToReadyList+0x90>
		prvAddTaskToReadyList( pxNewTCB );
 800ade0:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800ade2:	4f17      	ldr	r7, [pc, #92]	; (800ae40 <prvAddNewTaskToReadyList+0xe8>)
 800ade4:	4c15      	ldr	r4, [pc, #84]	; (800ae3c <prvAddNewTaskToReadyList+0xe4>)
 800ade6:	e7c9      	b.n	800ad7c <prvAddNewTaskToReadyList+0x24>
 800ade8:	4f15      	ldr	r7, [pc, #84]	; (800ae40 <prvAddNewTaskToReadyList+0xe8>)
 800adea:	463c      	mov	r4, r7
 800adec:	f507 688c 	add.w	r8, r7, #1120	; 0x460
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800adf0:	4620      	mov	r0, r4
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800adf2:	3414      	adds	r4, #20
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800adf4:	f7fe fdf6 	bl	80099e4 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800adf8:	45a0      	cmp	r8, r4
 800adfa:	d1f9      	bne.n	800adf0 <prvAddNewTaskToReadyList+0x98>
	}

	vListInitialise( &xDelayedTaskList1 );
 800adfc:	f8df 9060 	ldr.w	r9, [pc, #96]	; 800ae60 <prvAddNewTaskToReadyList+0x108>
	vListInitialise( &xDelayedTaskList2 );
 800ae00:	f8df 8060 	ldr.w	r8, [pc, #96]	; 800ae64 <prvAddNewTaskToReadyList+0x10c>
	vListInitialise( &xDelayedTaskList1 );
 800ae04:	4648      	mov	r0, r9
 800ae06:	4c0d      	ldr	r4, [pc, #52]	; (800ae3c <prvAddNewTaskToReadyList+0xe4>)
 800ae08:	f7fe fdec 	bl	80099e4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800ae0c:	4640      	mov	r0, r8
 800ae0e:	f7fe fde9 	bl	80099e4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800ae12:	480e      	ldr	r0, [pc, #56]	; (800ae4c <prvAddNewTaskToReadyList+0xf4>)
 800ae14:	f7fe fde6 	bl	80099e4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800ae18:	480d      	ldr	r0, [pc, #52]	; (800ae50 <prvAddNewTaskToReadyList+0xf8>)
 800ae1a:	f7fe fde3 	bl	80099e4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800ae1e:	480d      	ldr	r0, [pc, #52]	; (800ae54 <prvAddNewTaskToReadyList+0xfc>)
 800ae20:	f7fe fde0 	bl	80099e4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800ae24:	4b0c      	ldr	r3, [pc, #48]	; (800ae58 <prvAddNewTaskToReadyList+0x100>)
		prvAddTaskToReadyList( pxNewTCB );
 800ae26:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
	pxDelayedTaskList = &xDelayedTaskList1;
 800ae28:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800ae2c:	4b0b      	ldr	r3, [pc, #44]	; (800ae5c <prvAddNewTaskToReadyList+0x104>)
 800ae2e:	f8c3 8000 	str.w	r8, [r3]
}
 800ae32:	e7a3      	b.n	800ad7c <prvAddNewTaskToReadyList+0x24>
 800ae34:	2001a47c 	.word	0x2001a47c
 800ae38:	2001a010 	.word	0x2001a010
 800ae3c:	2001a4d8 	.word	0x2001a4d8
 800ae40:	2001a01c 	.word	0x2001a01c
 800ae44:	2001a48c 	.word	0x2001a48c
 800ae48:	2001a490 	.word	0x2001a490
 800ae4c:	2001a4c4 	.word	0x2001a4c4
 800ae50:	2001a4f0 	.word	0x2001a4f0
 800ae54:	2001a4dc 	.word	0x2001a4dc
 800ae58:	2001a014 	.word	0x2001a014
 800ae5c:	2001a018 	.word	0x2001a018
 800ae60:	2001a494 	.word	0x2001a494
 800ae64:	2001a4a8 	.word	0x2001a4a8

0800ae68 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800ae68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800ae6a:	4e17      	ldr	r6, [pc, #92]	; (800aec8 <prvAddCurrentTaskToDelayedList+0x60>)
{
 800ae6c:	4604      	mov	r4, r0
const TickType_t xConstTickCount = xTickCount;
 800ae6e:	4b17      	ldr	r3, [pc, #92]	; (800aecc <prvAddCurrentTaskToDelayedList+0x64>)
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800ae70:	2200      	movs	r2, #0
{
 800ae72:	460f      	mov	r7, r1
const TickType_t xConstTickCount = xTickCount;
 800ae74:	681d      	ldr	r5, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800ae76:	6833      	ldr	r3, [r6, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ae78:	6830      	ldr	r0, [r6, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800ae7a:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ae7e:	3004      	adds	r0, #4
 800ae80:	f7fe fde8 	bl	8009a54 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800ae84:	1c63      	adds	r3, r4, #1
 800ae86:	d100      	bne.n	800ae8a <prvAddCurrentTaskToDelayedList+0x22>
 800ae88:	b9bf      	cbnz	r7, 800aeba <prvAddCurrentTaskToDelayedList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 800ae8a:	192c      	adds	r4, r5, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ae8c:	6833      	ldr	r3, [r6, #0]
 800ae8e:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 800ae90:	d307      	bcc.n	800aea2 <prvAddCurrentTaskToDelayedList+0x3a>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ae92:	4b0f      	ldr	r3, [pc, #60]	; (800aed0 <prvAddCurrentTaskToDelayedList+0x68>)
 800ae94:	6818      	ldr	r0, [r3, #0]
 800ae96:	6831      	ldr	r1, [r6, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800ae98:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ae9c:	3104      	adds	r1, #4
 800ae9e:	f7fe bdc1 	b.w	8009a24 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800aea2:	4b0c      	ldr	r3, [pc, #48]	; (800aed4 <prvAddCurrentTaskToDelayedList+0x6c>)
 800aea4:	6818      	ldr	r0, [r3, #0]
 800aea6:	6831      	ldr	r1, [r6, #0]
 800aea8:	3104      	adds	r1, #4
 800aeaa:	f7fe fdbb 	bl	8009a24 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800aeae:	4b0a      	ldr	r3, [pc, #40]	; (800aed8 <prvAddCurrentTaskToDelayedList+0x70>)
 800aeb0:	681a      	ldr	r2, [r3, #0]
 800aeb2:	42a2      	cmp	r2, r4
 800aeb4:	d900      	bls.n	800aeb8 <prvAddCurrentTaskToDelayedList+0x50>
					xNextTaskUnblockTime = xTimeToWake;
 800aeb6:	601c      	str	r4, [r3, #0]
}
 800aeb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800aeba:	6831      	ldr	r1, [r6, #0]
 800aebc:	4807      	ldr	r0, [pc, #28]	; (800aedc <prvAddCurrentTaskToDelayedList+0x74>)
 800aebe:	3104      	adds	r1, #4
}
 800aec0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800aec4:	f7fe bd9e 	b.w	8009a04 <vListInsertEnd>
 800aec8:	2001a010 	.word	0x2001a010
 800aecc:	2001a504 	.word	0x2001a504
 800aed0:	2001a018 	.word	0x2001a018
 800aed4:	2001a014 	.word	0x2001a014
 800aed8:	2001a4bc 	.word	0x2001a4bc
 800aedc:	2001a4dc 	.word	0x2001a4dc

0800aee0 <prvInitialiseNewTask.constprop.0>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800aee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800aee4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800aee6:	ea4f 0982 	mov.w	r9, r2, lsl #2
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800aeea:	4606      	mov	r6, r0
 800aeec:	460d      	mov	r5, r1
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800aeee:	464a      	mov	r2, r9
 800aef0:	21a5      	movs	r1, #165	; 0xa5
 800aef2:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 800aef4:	461f      	mov	r7, r3
 800aef6:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800aefa:	f1a9 0904 	sub.w	r9, r9, #4
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800aefe:	f008 f93b 	bl	8013178 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800af02:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800af04:	4499      	add	r9, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 800af06:	f029 0907 	bic.w	r9, r9, #7
			pxNewTCB->pxEndOfStack = pxTopOfStack;
 800af0a:	f8c4 9044 	str.w	r9, [r4, #68]	; 0x44
	if( pcName != NULL )
 800af0e:	2d00      	cmp	r5, #0
 800af10:	d07f      	beq.n	800b012 <prvInitialiseNewTask.constprop.0+0x132>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af12:	782b      	ldrb	r3, [r5, #0]
 800af14:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 800af18:	782b      	ldrb	r3, [r5, #0]
 800af1a:	2b00      	cmp	r3, #0
 800af1c:	d04d      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af1e:	786b      	ldrb	r3, [r5, #1]
 800af20:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
			if( pcName[ x ] == ( char ) 0x00 )
 800af24:	786b      	ldrb	r3, [r5, #1]
 800af26:	2b00      	cmp	r3, #0
 800af28:	d047      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af2a:	78ab      	ldrb	r3, [r5, #2]
 800af2c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
			if( pcName[ x ] == ( char ) 0x00 )
 800af30:	78ab      	ldrb	r3, [r5, #2]
 800af32:	2b00      	cmp	r3, #0
 800af34:	d041      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af36:	78eb      	ldrb	r3, [r5, #3]
 800af38:	f884 3037 	strb.w	r3, [r4, #55]	; 0x37
			if( pcName[ x ] == ( char ) 0x00 )
 800af3c:	78eb      	ldrb	r3, [r5, #3]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d03b      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af42:	792b      	ldrb	r3, [r5, #4]
 800af44:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
			if( pcName[ x ] == ( char ) 0x00 )
 800af48:	792b      	ldrb	r3, [r5, #4]
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d035      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af4e:	796b      	ldrb	r3, [r5, #5]
 800af50:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
			if( pcName[ x ] == ( char ) 0x00 )
 800af54:	796b      	ldrb	r3, [r5, #5]
 800af56:	2b00      	cmp	r3, #0
 800af58:	d02f      	beq.n	800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af5a:	79ab      	ldrb	r3, [r5, #6]
 800af5c:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
			if( pcName[ x ] == ( char ) 0x00 )
 800af60:	79ab      	ldrb	r3, [r5, #6]
 800af62:	b353      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af64:	79eb      	ldrb	r3, [r5, #7]
 800af66:	f884 303b 	strb.w	r3, [r4, #59]	; 0x3b
			if( pcName[ x ] == ( char ) 0x00 )
 800af6a:	79eb      	ldrb	r3, [r5, #7]
 800af6c:	b32b      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af6e:	7a2b      	ldrb	r3, [r5, #8]
 800af70:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
			if( pcName[ x ] == ( char ) 0x00 )
 800af74:	7a2b      	ldrb	r3, [r5, #8]
 800af76:	b303      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af78:	7a6b      	ldrb	r3, [r5, #9]
 800af7a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
			if( pcName[ x ] == ( char ) 0x00 )
 800af7e:	7a6b      	ldrb	r3, [r5, #9]
 800af80:	b1db      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af82:	7aab      	ldrb	r3, [r5, #10]
 800af84:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
			if( pcName[ x ] == ( char ) 0x00 )
 800af88:	7aab      	ldrb	r3, [r5, #10]
 800af8a:	b1b3      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af8c:	7aeb      	ldrb	r3, [r5, #11]
 800af8e:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
			if( pcName[ x ] == ( char ) 0x00 )
 800af92:	7aeb      	ldrb	r3, [r5, #11]
 800af94:	b18b      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800af96:	7b2b      	ldrb	r3, [r5, #12]
 800af98:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			if( pcName[ x ] == ( char ) 0x00 )
 800af9c:	7b2b      	ldrb	r3, [r5, #12]
 800af9e:	b163      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800afa0:	7b6b      	ldrb	r3, [r5, #13]
 800afa2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
			if( pcName[ x ] == ( char ) 0x00 )
 800afa6:	7b6b      	ldrb	r3, [r5, #13]
 800afa8:	b13b      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800afaa:	7bab      	ldrb	r3, [r5, #14]
 800afac:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
			if( pcName[ x ] == ( char ) 0x00 )
 800afb0:	7bab      	ldrb	r3, [r5, #14]
 800afb2:	b113      	cbz	r3, 800afba <prvInitialiseNewTask.constprop.0+0xda>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800afb4:	7beb      	ldrb	r3, [r5, #15]
 800afb6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800afba:	2300      	movs	r3, #0
 800afbc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800afc0:	9d08      	ldr	r5, [sp, #32]
		pxNewTCB->uxMutexesHeld = 0;
 800afc2:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800afc6:	1d20      	adds	r0, r4, #4
 800afc8:	2d37      	cmp	r5, #55	; 0x37
		pxNewTCB->uxMutexesHeld = 0;
 800afca:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
 800afce:	bf28      	it	cs
 800afd0:	2537      	movcs	r5, #55	; 0x37
	pxNewTCB->uxPriority = uxPriority;
 800afd2:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 800afd4:	6525      	str	r5, [r4, #80]	; 0x50
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800afd6:	f1c5 0538 	rsb	r5, r5, #56	; 0x38
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800afda:	f7fe fd0f 	bl	80099fc <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800afde:	f104 0018 	add.w	r0, r4, #24
 800afe2:	f7fe fd0b 	bl	80099fc <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 800afe6:	f8c4 a058 	str.w	sl, [r4, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800afea:	463a      	mov	r2, r7
 800afec:	4631      	mov	r1, r6
 800afee:	4648      	mov	r0, r9
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800aff0:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800aff2:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800aff4:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800aff6:	f884 a05c 	strb.w	sl, [r4, #92]	; 0x5c
		pxNewTCB->ucDelayAborted = pdFALSE;
 800affa:	f884 a05e 	strb.w	sl, [r4, #94]	; 0x5e
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800affe:	f001 f84f 	bl	800c0a0 <pxPortInitialiseStack>
 800b002:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 800b004:	f1b8 0f00 	cmp.w	r8, #0
 800b008:	d001      	beq.n	800b00e <prvInitialiseNewTask.constprop.0+0x12e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800b00a:	f8c8 4000 	str.w	r4, [r8]
}
 800b00e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800b012:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
 800b016:	e7d3      	b.n	800afc0 <prvInitialiseNewTask.constprop.0+0xe0>

0800b018 <prvIdleTask>:
{
 800b018:	b580      	push	{r7, lr}
 800b01a:	4c22      	ldr	r4, [pc, #136]	; (800b0a4 <prvIdleTask+0x8c>)
				taskYIELD();
 800b01c:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
 800b020:	4e21      	ldr	r6, [pc, #132]	; (800b0a8 <prvIdleTask+0x90>)
 800b022:	f04f 5880 	mov.w	r8, #268435456	; 0x10000000
 800b026:	4d21      	ldr	r5, [pc, #132]	; (800b0ac <prvIdleTask+0x94>)
 800b028:	4f21      	ldr	r7, [pc, #132]	; (800b0b0 <prvIdleTask+0x98>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800b02a:	6823      	ldr	r3, [r4, #0]
 800b02c:	b363      	cbz	r3, 800b088 <prvIdleTask+0x70>
			taskENTER_CRITICAL();
 800b02e:	f001 f861 	bl	800c0f4 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b032:	68f3      	ldr	r3, [r6, #12]
 800b034:	f8d3 a00c 	ldr.w	sl, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b038:	f10a 0004 	add.w	r0, sl, #4
 800b03c:	f7fe fd0a 	bl	8009a54 <uxListRemove>
				--uxCurrentNumberOfTasks;
 800b040:	682b      	ldr	r3, [r5, #0]
 800b042:	3b01      	subs	r3, #1
 800b044:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
 800b046:	6823      	ldr	r3, [r4, #0]
 800b048:	3b01      	subs	r3, #1
 800b04a:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 800b04c:	f001 f878 	bl	800c140 <vPortExitCritical>
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800b050:	f89a 305d 	ldrb.w	r3, [sl, #93]	; 0x5d
 800b054:	b173      	cbz	r3, 800b074 <prvIdleTask+0x5c>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800b056:	2b01      	cmp	r3, #1
 800b058:	d020      	beq.n	800b09c <prvIdleTask+0x84>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800b05a:	2b02      	cmp	r3, #2
 800b05c:	d0e5      	beq.n	800b02a <prvIdleTask+0x12>
 800b05e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b062:	b672      	cpsid	i
 800b064:	f383 8811 	msr	BASEPRI, r3
 800b068:	f3bf 8f6f 	isb	sy
 800b06c:	f3bf 8f4f 	dsb	sy
 800b070:	b662      	cpsie	i
 800b072:	e7fe      	b.n	800b072 <prvIdleTask+0x5a>
				vPortFree( pxTCB->pxStack );
 800b074:	f8da 0030 	ldr.w	r0, [sl, #48]	; 0x30
 800b078:	f001 fa46 	bl	800c508 <vPortFree>
				vPortFree( pxTCB );
 800b07c:	4650      	mov	r0, sl
 800b07e:	f001 fa43 	bl	800c508 <vPortFree>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800b082:	6823      	ldr	r3, [r4, #0]
 800b084:	2b00      	cmp	r3, #0
 800b086:	d1d2      	bne.n	800b02e <prvIdleTask+0x16>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800b088:	683b      	ldr	r3, [r7, #0]
 800b08a:	2b01      	cmp	r3, #1
 800b08c:	d9cd      	bls.n	800b02a <prvIdleTask+0x12>
				taskYIELD();
 800b08e:	f8c9 8d04 	str.w	r8, [r9, #3332]	; 0xd04
 800b092:	f3bf 8f4f 	dsb	sy
 800b096:	f3bf 8f6f 	isb	sy
 800b09a:	e7c6      	b.n	800b02a <prvIdleTask+0x12>
				vPortFree( pxTCB );
 800b09c:	4650      	mov	r0, sl
 800b09e:	f001 fa33 	bl	800c508 <vPortFree>
 800b0a2:	e7c2      	b.n	800b02a <prvIdleTask+0x12>
 800b0a4:	2001a480 	.word	0x2001a480
 800b0a8:	2001a4f0 	.word	0x2001a4f0
 800b0ac:	2001a47c 	.word	0x2001a47c
 800b0b0:	2001a01c 	.word	0x2001a01c

0800b0b4 <xTaskCreateStatic>:
	{
 800b0b4:	b530      	push	{r4, r5, lr}
 800b0b6:	b087      	sub	sp, #28
 800b0b8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
		configASSERT( puxStackBuffer != NULL );
 800b0ba:	b1e4      	cbz	r4, 800b0f6 <xTaskCreateStatic+0x42>
		configASSERT( pxTaskBuffer != NULL );
 800b0bc:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800b0be:	b17d      	cbz	r5, 800b0e0 <xTaskCreateStatic+0x2c>
			volatile size_t xSize = sizeof( StaticTask_t );
 800b0c0:	2560      	movs	r5, #96	; 0x60
 800b0c2:	9505      	str	r5, [sp, #20]
			configASSERT( xSize == sizeof( TCB_t ) );
 800b0c4:	9d05      	ldr	r5, [sp, #20]
 800b0c6:	2d60      	cmp	r5, #96	; 0x60
 800b0c8:	d020      	beq.n	800b10c <xTaskCreateStatic+0x58>
 800b0ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b0ce:	b672      	cpsid	i
 800b0d0:	f383 8811 	msr	BASEPRI, r3
 800b0d4:	f3bf 8f6f 	isb	sy
 800b0d8:	f3bf 8f4f 	dsb	sy
 800b0dc:	b662      	cpsie	i
 800b0de:	e7fe      	b.n	800b0de <xTaskCreateStatic+0x2a>
 800b0e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b0e4:	b672      	cpsid	i
 800b0e6:	f383 8811 	msr	BASEPRI, r3
 800b0ea:	f3bf 8f6f 	isb	sy
 800b0ee:	f3bf 8f4f 	dsb	sy
 800b0f2:	b662      	cpsie	i
		configASSERT( pxTaskBuffer != NULL );
 800b0f4:	e7fe      	b.n	800b0f4 <xTaskCreateStatic+0x40>
 800b0f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b0fa:	b672      	cpsid	i
 800b0fc:	f383 8811 	msr	BASEPRI, r3
 800b100:	f3bf 8f6f 	isb	sy
 800b104:	f3bf 8f4f 	dsb	sy
 800b108:	b662      	cpsie	i
		configASSERT( puxStackBuffer != NULL );
 800b10a:	e7fe      	b.n	800b10a <xTaskCreateStatic+0x56>
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b10c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800b10e:	632c      	str	r4, [r5, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b110:	2402      	movs	r4, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800b112:	9502      	str	r5, [sp, #8]
 800b114:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800b116:	9500      	str	r5, [sp, #0]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b118:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800b11a:	f885 405d 	strb.w	r4, [r5, #93]	; 0x5d
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800b11e:	ac04      	add	r4, sp, #16
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 800b120:	9d05      	ldr	r5, [sp, #20]
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800b122:	9401      	str	r4, [sp, #4]
 800b124:	f7ff fedc 	bl	800aee0 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800b128:	980c      	ldr	r0, [sp, #48]	; 0x30
 800b12a:	f7ff fe15 	bl	800ad58 <prvAddNewTaskToReadyList>
	}
 800b12e:	9804      	ldr	r0, [sp, #16]
 800b130:	b007      	add	sp, #28
 800b132:	bd30      	pop	{r4, r5, pc}

0800b134 <xTaskCreate>:
	{
 800b134:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b138:	4607      	mov	r7, r0
 800b13a:	b085      	sub	sp, #20
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 800b13c:	0090      	lsls	r0, r2, #2
	{
 800b13e:	4615      	mov	r5, r2
 800b140:	4688      	mov	r8, r1
 800b142:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 800b144:	f001 f928 	bl	800c398 <pvPortMalloc>
			if( pxStack != NULL )
 800b148:	b1d8      	cbz	r0, 800b182 <xTaskCreate+0x4e>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 800b14a:	4604      	mov	r4, r0
 800b14c:	2060      	movs	r0, #96	; 0x60
 800b14e:	f001 f923 	bl	800c398 <pvPortMalloc>
				if( pxNewTCB != NULL )
 800b152:	4606      	mov	r6, r0
 800b154:	b1d0      	cbz	r0, 800b18c <xTaskCreate+0x58>
					pxNewTCB->pxStack = pxStack;
 800b156:	6304      	str	r4, [r0, #48]	; 0x30
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800b158:	2400      	movs	r4, #0
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800b15a:	464b      	mov	r3, r9
 800b15c:	462a      	mov	r2, r5
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800b15e:	f886 405d 	strb.w	r4, [r6, #93]	; 0x5d
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800b162:	4641      	mov	r1, r8
 800b164:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 800b166:	4638      	mov	r0, r7
 800b168:	9602      	str	r6, [sp, #8]
 800b16a:	9401      	str	r4, [sp, #4]
 800b16c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800b16e:	9400      	str	r4, [sp, #0]
 800b170:	f7ff feb6 	bl	800aee0 <prvInitialiseNewTask.constprop.0>
			prvAddNewTaskToReadyList( pxNewTCB );
 800b174:	4630      	mov	r0, r6
 800b176:	f7ff fdef 	bl	800ad58 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800b17a:	2001      	movs	r0, #1
	}
 800b17c:	b005      	add	sp, #20
 800b17e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800b182:	f04f 30ff 	mov.w	r0, #4294967295
	}
 800b186:	b005      	add	sp, #20
 800b188:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 800b18c:	4620      	mov	r0, r4
 800b18e:	f001 f9bb 	bl	800c508 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800b192:	f04f 30ff 	mov.w	r0, #4294967295
 800b196:	e7f1      	b.n	800b17c <xTaskCreate+0x48>

0800b198 <vTaskStartScheduler>:
{
 800b198:	b570      	push	{r4, r5, r6, lr}
 800b19a:	b084      	sub	sp, #16
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800b19c:	2400      	movs	r4, #0
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800b19e:	4668      	mov	r0, sp
 800b1a0:	aa02      	add	r2, sp, #8
 800b1a2:	a901      	add	r1, sp, #4
		StackType_t *pxIdleTaskStackBuffer = NULL;
 800b1a4:	e9cd 4400 	strd	r4, r4, [sp]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800b1a8:	f7fe fbfe 	bl	80099a8 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800b1ac:	9801      	ldr	r0, [sp, #4]
		configASSERT( puxStackBuffer != NULL );
 800b1ae:	b1e8      	cbz	r0, 800b1ec <vTaskStartScheduler+0x54>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800b1b0:	9d00      	ldr	r5, [sp, #0]
		configASSERT( pxTaskBuffer != NULL );
 800b1b2:	b185      	cbz	r5, 800b1d6 <vTaskStartScheduler+0x3e>
			volatile size_t xSize = sizeof( StaticTask_t );
 800b1b4:	2260      	movs	r2, #96	; 0x60
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800b1b6:	9e02      	ldr	r6, [sp, #8]
			volatile size_t xSize = sizeof( StaticTask_t );
 800b1b8:	9203      	str	r2, [sp, #12]
			configASSERT( xSize == sizeof( TCB_t ) );
 800b1ba:	9a03      	ldr	r2, [sp, #12]
 800b1bc:	2a60      	cmp	r2, #96	; 0x60
 800b1be:	d020      	beq.n	800b202 <vTaskStartScheduler+0x6a>
 800b1c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b1c4:	b672      	cpsid	i
 800b1c6:	f383 8811 	msr	BASEPRI, r3
 800b1ca:	f3bf 8f6f 	isb	sy
 800b1ce:	f3bf 8f4f 	dsb	sy
 800b1d2:	b662      	cpsie	i
 800b1d4:	e7fe      	b.n	800b1d4 <vTaskStartScheduler+0x3c>
 800b1d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b1da:	b672      	cpsid	i
 800b1dc:	f383 8811 	msr	BASEPRI, r3
 800b1e0:	f3bf 8f6f 	isb	sy
 800b1e4:	f3bf 8f4f 	dsb	sy
 800b1e8:	b662      	cpsie	i
		configASSERT( pxTaskBuffer != NULL );
 800b1ea:	e7fe      	b.n	800b1ea <vTaskStartScheduler+0x52>
 800b1ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b1f0:	b672      	cpsid	i
 800b1f2:	f383 8811 	msr	BASEPRI, r3
 800b1f6:	f3bf 8f6f 	isb	sy
 800b1fa:	f3bf 8f4f 	dsb	sy
 800b1fe:	b662      	cpsie	i
		configASSERT( puxStackBuffer != NULL );
 800b200:	e7fe      	b.n	800b200 <vTaskStartScheduler+0x68>
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800b202:	00b6      	lsls	r6, r6, #2
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b204:	2302      	movs	r3, #2
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800b206:	21a5      	movs	r1, #165	; 0xa5
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800b208:	6328      	str	r0, [r5, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800b20a:	4632      	mov	r2, r6
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800b20c:	f885 305d 	strb.w	r3, [r5, #93]	; 0x5d
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 800b210:	9b03      	ldr	r3, [sp, #12]
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800b212:	f007 ffb1 	bl	8013178 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800b216:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800b218:	1f33      	subs	r3, r6, #4
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800b21a:	4928      	ldr	r1, [pc, #160]	; (800b2bc <vTaskStartScheduler+0x124>)
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800b21c:	1d28      	adds	r0, r5, #4
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800b21e:	18d6      	adds	r6, r2, r3
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800b220:	f885 4038 	strb.w	r4, [r5, #56]	; 0x38
 800b224:	6369      	str	r1, [r5, #52]	; 0x34
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 800b226:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800b22a:	f885 4043 	strb.w	r4, [r5, #67]	; 0x43
	pxNewTCB->uxPriority = uxPriority;
 800b22e:	62ec      	str	r4, [r5, #44]	; 0x2c
			pxNewTCB->pxEndOfStack = pxTopOfStack;
 800b230:	646e      	str	r6, [r5, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 800b232:	e9c5 4414 	strd	r4, r4, [r5, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800b236:	f7fe fbe1 	bl	80099fc <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800b23a:	f105 0018 	add.w	r0, r5, #24
 800b23e:	f7fe fbdd 	bl	80099fc <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b242:	2338      	movs	r3, #56	; 0x38
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800b244:	4622      	mov	r2, r4
 800b246:	491e      	ldr	r1, [pc, #120]	; (800b2c0 <vTaskStartScheduler+0x128>)
		pxNewTCB->ulNotifiedValue = 0;
 800b248:	65ac      	str	r4, [r5, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800b24a:	4630      	mov	r0, r6
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b24c:	61ab      	str	r3, [r5, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800b24e:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800b250:	626d      	str	r5, [r5, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800b252:	f885 405c 	strb.w	r4, [r5, #92]	; 0x5c
		pxNewTCB->ucDelayAborted = pdFALSE;
 800b256:	f885 405e 	strb.w	r4, [r5, #94]	; 0x5e
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800b25a:	f000 ff21 	bl	800c0a0 <pxPortInitialiseStack>
 800b25e:	4603      	mov	r3, r0
			prvAddNewTaskToReadyList( pxNewTCB );
 800b260:	4628      	mov	r0, r5
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800b262:	602b      	str	r3, [r5, #0]
			prvAddNewTaskToReadyList( pxNewTCB );
 800b264:	f7ff fd78 	bl	800ad58 <prvAddNewTaskToReadyList>
			xReturn = xTimerCreateTimerTask();
 800b268:	f000 fe78 	bl	800bf5c <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 800b26c:	2801      	cmp	r0, #1
 800b26e:	d00e      	beq.n	800b28e <vTaskStartScheduler+0xf6>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800b270:	3001      	adds	r0, #1
 800b272:	d001      	beq.n	800b278 <vTaskStartScheduler+0xe0>
}
 800b274:	b004      	add	sp, #16
 800b276:	bd70      	pop	{r4, r5, r6, pc}
 800b278:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b27c:	b672      	cpsid	i
 800b27e:	f383 8811 	msr	BASEPRI, r3
 800b282:	f3bf 8f6f 	isb	sy
 800b286:	f3bf 8f4f 	dsb	sy
 800b28a:	b662      	cpsie	i
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800b28c:	e7fe      	b.n	800b28c <vTaskStartScheduler+0xf4>
 800b28e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b292:	b672      	cpsid	i
 800b294:	f383 8811 	msr	BASEPRI, r3
 800b298:	f3bf 8f6f 	isb	sy
 800b29c:	f3bf 8f4f 	dsb	sy
 800b2a0:	b662      	cpsie	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800b2a2:	4b08      	ldr	r3, [pc, #32]	; (800b2c4 <vTaskStartScheduler+0x12c>)
 800b2a4:	f04f 31ff 	mov.w	r1, #4294967295
		xSchedulerRunning = pdTRUE;
 800b2a8:	4a07      	ldr	r2, [pc, #28]	; (800b2c8 <vTaskStartScheduler+0x130>)
		xNextTaskUnblockTime = portMAX_DELAY;
 800b2aa:	6019      	str	r1, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 800b2ac:	4b07      	ldr	r3, [pc, #28]	; (800b2cc <vTaskStartScheduler+0x134>)
		xSchedulerRunning = pdTRUE;
 800b2ae:	6010      	str	r0, [r2, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 800b2b0:	601c      	str	r4, [r3, #0]
}
 800b2b2:	b004      	add	sp, #16
 800b2b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( xPortStartScheduler() != pdFALSE )
 800b2b8:	f000 bfb8 	b.w	800c22c <xPortStartScheduler>
 800b2bc:	454c4449 	.word	0x454c4449
 800b2c0:	0800b019 	.word	0x0800b019
 800b2c4:	2001a4bc 	.word	0x2001a4bc
 800b2c8:	2001a4d8 	.word	0x2001a4d8
 800b2cc:	2001a504 	.word	0x2001a504

0800b2d0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800b2d0:	4a02      	ldr	r2, [pc, #8]	; (800b2dc <vTaskSuspendAll+0xc>)
 800b2d2:	6813      	ldr	r3, [r2, #0]
 800b2d4:	3301      	adds	r3, #1
 800b2d6:	6013      	str	r3, [r2, #0]
}
 800b2d8:	4770      	bx	lr
 800b2da:	bf00      	nop
 800b2dc:	2001a488 	.word	0x2001a488

0800b2e0 <xTaskGetTickCount>:
		xTicks = xTickCount;
 800b2e0:	4b01      	ldr	r3, [pc, #4]	; (800b2e8 <xTaskGetTickCount+0x8>)
 800b2e2:	6818      	ldr	r0, [r3, #0]
}
 800b2e4:	4770      	bx	lr
 800b2e6:	bf00      	nop
 800b2e8:	2001a504 	.word	0x2001a504

0800b2ec <xTaskGetTickCountFromISR>:
{
 800b2ec:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800b2ee:	f001 f821 	bl	800c334 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 800b2f2:	4b01      	ldr	r3, [pc, #4]	; (800b2f8 <xTaskGetTickCountFromISR+0xc>)
 800b2f4:	6818      	ldr	r0, [r3, #0]
}
 800b2f6:	bd08      	pop	{r3, pc}
 800b2f8:	2001a504 	.word	0x2001a504

0800b2fc <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b2fc:	4b50      	ldr	r3, [pc, #320]	; (800b440 <xTaskIncrementTick+0x144>)
 800b2fe:	681b      	ldr	r3, [r3, #0]
{
 800b300:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b304:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b306:	2b00      	cmp	r3, #0
 800b308:	d146      	bne.n	800b398 <xTaskIncrementTick+0x9c>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800b30a:	4b4e      	ldr	r3, [pc, #312]	; (800b444 <xTaskIncrementTick+0x148>)
 800b30c:	681e      	ldr	r6, [r3, #0]
 800b30e:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
 800b310:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800b312:	2e00      	cmp	r6, #0
 800b314:	d04e      	beq.n	800b3b4 <xTaskIncrementTick+0xb8>
 800b316:	f8df b144 	ldr.w	fp, [pc, #324]	; 800b45c <xTaskIncrementTick+0x160>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800b31a:	f8db 3000 	ldr.w	r3, [fp]
 800b31e:	42b3      	cmp	r3, r6
 800b320:	d85f      	bhi.n	800b3e2 <xTaskIncrementTick+0xe6>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b322:	4f49      	ldr	r7, [pc, #292]	; (800b448 <xTaskIncrementTick+0x14c>)
 800b324:	683b      	ldr	r3, [r7, #0]
 800b326:	681d      	ldr	r5, [r3, #0]
 800b328:	2d00      	cmp	r5, #0
 800b32a:	d076      	beq.n	800b41a <xTaskIncrementTick+0x11e>
BaseType_t xSwitchRequired = pdFALSE;
 800b32c:	2500      	movs	r5, #0
 800b32e:	f8df 9130 	ldr.w	r9, [pc, #304]	; 800b460 <xTaskIncrementTick+0x164>
 800b332:	f8df a130 	ldr.w	sl, [pc, #304]	; 800b464 <xTaskIncrementTick+0x168>
					prvAddTaskToReadyList( pxTCB );
 800b336:	f8df 8130 	ldr.w	r8, [pc, #304]	; 800b468 <xTaskIncrementTick+0x16c>
 800b33a:	e022      	b.n	800b382 <xTaskIncrementTick+0x86>
 800b33c:	9101      	str	r1, [sp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b33e:	f7fe fb89 	bl	8009a54 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800b342:	6aa3      	ldr	r3, [r4, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b344:	f104 0018 	add.w	r0, r4, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800b348:	9901      	ldr	r1, [sp, #4]
 800b34a:	b113      	cbz	r3, 800b352 <xTaskIncrementTick+0x56>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b34c:	f7fe fb82 	bl	8009a54 <uxListRemove>
 800b350:	9901      	ldr	r1, [sp, #4]
					prvAddTaskToReadyList( pxTCB );
 800b352:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800b354:	f8d8 3000 	ldr.w	r3, [r8]
 800b358:	4298      	cmp	r0, r3
 800b35a:	d901      	bls.n	800b360 <xTaskIncrementTick+0x64>
 800b35c:	f8c8 0000 	str.w	r0, [r8]
 800b360:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800b364:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 800b368:	f7fe fb4c 	bl	8009a04 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800b36c:	f8da 3000 	ldr.w	r3, [sl]
 800b370:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b372:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800b374:	429a      	cmp	r2, r3
 800b376:	bf28      	it	cs
 800b378:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b37a:	683b      	ldr	r3, [r7, #0]
 800b37c:	681b      	ldr	r3, [r3, #0]
 800b37e:	2b00      	cmp	r3, #0
 800b380:	d04f      	beq.n	800b422 <xTaskIncrementTick+0x126>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b382:	683b      	ldr	r3, [r7, #0]
 800b384:	68db      	ldr	r3, [r3, #12]
 800b386:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800b388:	6863      	ldr	r3, [r4, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b38a:	1d21      	adds	r1, r4, #4
					if( xConstTickCount < xItemValue )
 800b38c:	429e      	cmp	r6, r3
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b38e:	4608      	mov	r0, r1
					if( xConstTickCount < xItemValue )
 800b390:	d2d4      	bcs.n	800b33c <xTaskIncrementTick+0x40>
						xNextTaskUnblockTime = xItemValue;
 800b392:	f8cb 3000 	str.w	r3, [fp]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800b396:	e029      	b.n	800b3ec <xTaskIncrementTick+0xf0>
		++uxPendedTicks;
 800b398:	4a2c      	ldr	r2, [pc, #176]	; (800b44c <xTaskIncrementTick+0x150>)
BaseType_t xSwitchRequired = pdFALSE;
 800b39a:	2500      	movs	r5, #0
		++uxPendedTicks;
 800b39c:	6813      	ldr	r3, [r2, #0]
 800b39e:	3301      	adds	r3, #1
 800b3a0:	6013      	str	r3, [r2, #0]
		if( xYieldPending != pdFALSE )
 800b3a2:	4b2b      	ldr	r3, [pc, #172]	; (800b450 <xTaskIncrementTick+0x154>)
 800b3a4:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 800b3a6:	2b00      	cmp	r3, #0
}
 800b3a8:	bf0c      	ite	eq
 800b3aa:	4628      	moveq	r0, r5
 800b3ac:	2001      	movne	r0, #1
 800b3ae:	b003      	add	sp, #12
 800b3b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 800b3b4:	4b24      	ldr	r3, [pc, #144]	; (800b448 <xTaskIncrementTick+0x14c>)
 800b3b6:	681a      	ldr	r2, [r3, #0]
 800b3b8:	6812      	ldr	r2, [r2, #0]
 800b3ba:	bb1a      	cbnz	r2, 800b404 <xTaskIncrementTick+0x108>
 800b3bc:	4a25      	ldr	r2, [pc, #148]	; (800b454 <xTaskIncrementTick+0x158>)
 800b3be:	6818      	ldr	r0, [r3, #0]
 800b3c0:	6811      	ldr	r1, [r2, #0]
 800b3c2:	6019      	str	r1, [r3, #0]
 800b3c4:	4924      	ldr	r1, [pc, #144]	; (800b458 <xTaskIncrementTick+0x15c>)
 800b3c6:	6010      	str	r0, [r2, #0]
 800b3c8:	680a      	ldr	r2, [r1, #0]
 800b3ca:	3201      	adds	r2, #1
 800b3cc:	600a      	str	r2, [r1, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b3ce:	681a      	ldr	r2, [r3, #0]
 800b3d0:	6812      	ldr	r2, [r2, #0]
 800b3d2:	bb5a      	cbnz	r2, 800b42c <xTaskIncrementTick+0x130>
		xNextTaskUnblockTime = portMAX_DELAY;
 800b3d4:	f8df b084 	ldr.w	fp, [pc, #132]	; 800b45c <xTaskIncrementTick+0x160>
 800b3d8:	f04f 33ff 	mov.w	r3, #4294967295
 800b3dc:	f8cb 3000 	str.w	r3, [fp]
 800b3e0:	e79b      	b.n	800b31a <xTaskIncrementTick+0x1e>
BaseType_t xSwitchRequired = pdFALSE;
 800b3e2:	2500      	movs	r5, #0
 800b3e4:	f8df 9078 	ldr.w	r9, [pc, #120]	; 800b460 <xTaskIncrementTick+0x164>
 800b3e8:	f8df a078 	ldr.w	sl, [pc, #120]	; 800b464 <xTaskIncrementTick+0x168>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800b3ec:	f8da 3000 	ldr.w	r3, [sl]
 800b3f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b3f2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800b3f6:	009b      	lsls	r3, r3, #2
 800b3f8:	f859 3003 	ldr.w	r3, [r9, r3]
				xSwitchRequired = pdTRUE;
 800b3fc:	2b02      	cmp	r3, #2
 800b3fe:	bf28      	it	cs
 800b400:	2501      	movcs	r5, #1
 800b402:	e7ce      	b.n	800b3a2 <xTaskIncrementTick+0xa6>
 800b404:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b408:	b672      	cpsid	i
 800b40a:	f383 8811 	msr	BASEPRI, r3
 800b40e:	f3bf 8f6f 	isb	sy
 800b412:	f3bf 8f4f 	dsb	sy
 800b416:	b662      	cpsie	i
			taskSWITCH_DELAYED_LISTS();
 800b418:	e7fe      	b.n	800b418 <xTaskIncrementTick+0x11c>
 800b41a:	f8df 9044 	ldr.w	r9, [pc, #68]	; 800b460 <xTaskIncrementTick+0x164>
 800b41e:	f8df a044 	ldr.w	sl, [pc, #68]	; 800b464 <xTaskIncrementTick+0x168>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b422:	f04f 33ff 	mov.w	r3, #4294967295
 800b426:	f8cb 3000 	str.w	r3, [fp]
					break;
 800b42a:	e7df      	b.n	800b3ec <xTaskIncrementTick+0xf0>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b42c:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b42e:	f8df b02c 	ldr.w	fp, [pc, #44]	; 800b45c <xTaskIncrementTick+0x160>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b432:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b434:	68db      	ldr	r3, [r3, #12]
 800b436:	685b      	ldr	r3, [r3, #4]
 800b438:	f8cb 3000 	str.w	r3, [fp]
}
 800b43c:	e76d      	b.n	800b31a <xTaskIncrementTick+0x1e>
 800b43e:	bf00      	nop
 800b440:	2001a488 	.word	0x2001a488
 800b444:	2001a504 	.word	0x2001a504
 800b448:	2001a014 	.word	0x2001a014
 800b44c:	2001a484 	.word	0x2001a484
 800b450:	2001a508 	.word	0x2001a508
 800b454:	2001a018 	.word	0x2001a018
 800b458:	2001a4c0 	.word	0x2001a4c0
 800b45c:	2001a4bc 	.word	0x2001a4bc
 800b460:	2001a01c 	.word	0x2001a01c
 800b464:	2001a010 	.word	0x2001a010
 800b468:	2001a490 	.word	0x2001a490

0800b46c <xTaskResumeAll.part.0>:
BaseType_t xTaskResumeAll( void )
 800b46c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b470:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 800b472:	f000 fe3f 	bl	800c0f4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800b476:	4b3b      	ldr	r3, [pc, #236]	; (800b564 <xTaskResumeAll.part.0+0xf8>)
 800b478:	681a      	ldr	r2, [r3, #0]
 800b47a:	3a01      	subs	r2, #1
 800b47c:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b47e:	681b      	ldr	r3, [r3, #0]
 800b480:	2b00      	cmp	r3, #0
 800b482:	d156      	bne.n	800b532 <xTaskResumeAll.part.0+0xc6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800b484:	4b38      	ldr	r3, [pc, #224]	; (800b568 <xTaskResumeAll.part.0+0xfc>)
 800b486:	681b      	ldr	r3, [r3, #0]
 800b488:	2b00      	cmp	r3, #0
 800b48a:	d052      	beq.n	800b532 <xTaskResumeAll.part.0+0xc6>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800b48c:	4d37      	ldr	r5, [pc, #220]	; (800b56c <xTaskResumeAll.part.0+0x100>)
 800b48e:	682b      	ldr	r3, [r5, #0]
 800b490:	2b00      	cmp	r3, #0
 800b492:	d063      	beq.n	800b55c <xTaskResumeAll.part.0+0xf0>
 800b494:	4e36      	ldr	r6, [pc, #216]	; (800b570 <xTaskResumeAll.part.0+0x104>)
						xYieldPending = pdTRUE;
 800b496:	f04f 0a01 	mov.w	sl, #1
 800b49a:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 800b584 <xTaskResumeAll.part.0+0x118>
 800b49e:	4f35      	ldr	r7, [pc, #212]	; (800b574 <xTaskResumeAll.part.0+0x108>)
 800b4a0:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 800b588 <xTaskResumeAll.part.0+0x11c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b4a4:	68eb      	ldr	r3, [r5, #12]
 800b4a6:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b4a8:	f104 0b04 	add.w	fp, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b4ac:	f104 0018 	add.w	r0, r4, #24
 800b4b0:	f7fe fad0 	bl	8009a54 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b4b4:	4658      	mov	r0, fp
 800b4b6:	f7fe facd 	bl	8009a54 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800b4ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b4bc:	6832      	ldr	r2, [r6, #0]
 800b4be:	4659      	mov	r1, fp
 800b4c0:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 800b4c4:	4293      	cmp	r3, r2
 800b4c6:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 800b4ca:	d900      	bls.n	800b4ce <xTaskResumeAll.part.0+0x62>
 800b4cc:	6033      	str	r3, [r6, #0]
 800b4ce:	f7fe fa99 	bl	8009a04 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800b4d2:	683b      	ldr	r3, [r7, #0]
 800b4d4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b4d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b4d8:	429a      	cmp	r2, r3
 800b4da:	d332      	bcc.n	800b542 <xTaskResumeAll.part.0+0xd6>
						xYieldPending = pdTRUE;
 800b4dc:	f8c9 a000 	str.w	sl, [r9]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800b4e0:	682b      	ldr	r3, [r5, #0]
 800b4e2:	2b00      	cmp	r3, #0
 800b4e4:	d1de      	bne.n	800b4a4 <xTaskResumeAll.part.0+0x38>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b4e6:	4b24      	ldr	r3, [pc, #144]	; (800b578 <xTaskResumeAll.part.0+0x10c>)
 800b4e8:	681a      	ldr	r2, [r3, #0]
 800b4ea:	6812      	ldr	r2, [r2, #0]
 800b4ec:	2a00      	cmp	r2, #0
 800b4ee:	d030      	beq.n	800b552 <xTaskResumeAll.part.0+0xe6>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b4f0:	681a      	ldr	r2, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b4f2:	4b22      	ldr	r3, [pc, #136]	; (800b57c <xTaskResumeAll.part.0+0x110>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b4f4:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b4f6:	68d2      	ldr	r2, [r2, #12]
 800b4f8:	6852      	ldr	r2, [r2, #4]
 800b4fa:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800b4fc:	4e20      	ldr	r6, [pc, #128]	; (800b580 <xTaskResumeAll.part.0+0x114>)
 800b4fe:	6834      	ldr	r4, [r6, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800b500:	b144      	cbz	r4, 800b514 <xTaskResumeAll.part.0+0xa8>
								xYieldPending = pdTRUE;
 800b502:	2501      	movs	r5, #1
							if( xTaskIncrementTick() != pdFALSE )
 800b504:	f7ff fefa 	bl	800b2fc <xTaskIncrementTick>
 800b508:	b108      	cbz	r0, 800b50e <xTaskResumeAll.part.0+0xa2>
								xYieldPending = pdTRUE;
 800b50a:	f8c9 5000 	str.w	r5, [r9]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800b50e:	3c01      	subs	r4, #1
 800b510:	d1f8      	bne.n	800b504 <xTaskResumeAll.part.0+0x98>
						uxPendedTicks = 0;
 800b512:	6034      	str	r4, [r6, #0]
				if( xYieldPending != pdFALSE )
 800b514:	f8d9 3000 	ldr.w	r3, [r9]
 800b518:	b15b      	cbz	r3, 800b532 <xTaskResumeAll.part.0+0xc6>
					taskYIELD_IF_USING_PREEMPTION();
 800b51a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b51e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b522:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800b526:	f3bf 8f4f 	dsb	sy
 800b52a:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800b52e:	2001      	movs	r0, #1
 800b530:	e000      	b.n	800b534 <xTaskResumeAll.part.0+0xc8>
BaseType_t xAlreadyYielded = pdFALSE;
 800b532:	2000      	movs	r0, #0
 800b534:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
 800b536:	f000 fe03 	bl	800c140 <vPortExitCritical>
}
 800b53a:	9801      	ldr	r0, [sp, #4]
 800b53c:	b003      	add	sp, #12
 800b53e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800b542:	682b      	ldr	r3, [r5, #0]
 800b544:	2b00      	cmp	r3, #0
 800b546:	d1ad      	bne.n	800b4a4 <xTaskResumeAll.part.0+0x38>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b548:	4b0b      	ldr	r3, [pc, #44]	; (800b578 <xTaskResumeAll.part.0+0x10c>)
 800b54a:	681a      	ldr	r2, [r3, #0]
 800b54c:	6812      	ldr	r2, [r2, #0]
 800b54e:	2a00      	cmp	r2, #0
 800b550:	d1ce      	bne.n	800b4f0 <xTaskResumeAll.part.0+0x84>
		xNextTaskUnblockTime = portMAX_DELAY;
 800b552:	4b0a      	ldr	r3, [pc, #40]	; (800b57c <xTaskResumeAll.part.0+0x110>)
 800b554:	f04f 32ff 	mov.w	r2, #4294967295
 800b558:	601a      	str	r2, [r3, #0]
 800b55a:	e7cf      	b.n	800b4fc <xTaskResumeAll.part.0+0x90>
 800b55c:	f8df 9028 	ldr.w	r9, [pc, #40]	; 800b588 <xTaskResumeAll.part.0+0x11c>
 800b560:	e7cc      	b.n	800b4fc <xTaskResumeAll.part.0+0x90>
 800b562:	bf00      	nop
 800b564:	2001a488 	.word	0x2001a488
 800b568:	2001a47c 	.word	0x2001a47c
 800b56c:	2001a4c4 	.word	0x2001a4c4
 800b570:	2001a490 	.word	0x2001a490
 800b574:	2001a010 	.word	0x2001a010
 800b578:	2001a014 	.word	0x2001a014
 800b57c:	2001a4bc 	.word	0x2001a4bc
 800b580:	2001a484 	.word	0x2001a484
 800b584:	2001a01c 	.word	0x2001a01c
 800b588:	2001a508 	.word	0x2001a508

0800b58c <xTaskResumeAll>:
	configASSERT( uxSchedulerSuspended );
 800b58c:	4b07      	ldr	r3, [pc, #28]	; (800b5ac <xTaskResumeAll+0x20>)
 800b58e:	681b      	ldr	r3, [r3, #0]
 800b590:	b953      	cbnz	r3, 800b5a8 <xTaskResumeAll+0x1c>
 800b592:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b596:	b672      	cpsid	i
 800b598:	f383 8811 	msr	BASEPRI, r3
 800b59c:	f3bf 8f6f 	isb	sy
 800b5a0:	f3bf 8f4f 	dsb	sy
 800b5a4:	b662      	cpsie	i
 800b5a6:	e7fe      	b.n	800b5a6 <xTaskResumeAll+0x1a>
 800b5a8:	f7ff bf60 	b.w	800b46c <xTaskResumeAll.part.0>
 800b5ac:	2001a488 	.word	0x2001a488

0800b5b0 <vTaskDelay>:
	{
 800b5b0:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 800b5b2:	b950      	cbnz	r0, 800b5ca <vTaskDelay+0x1a>
			portYIELD_WITHIN_API();
 800b5b4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b5b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b5bc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800b5c0:	f3bf 8f4f 	dsb	sy
 800b5c4:	f3bf 8f6f 	isb	sy
	}
 800b5c8:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800b5ca:	4c12      	ldr	r4, [pc, #72]	; (800b614 <vTaskDelay+0x64>)
 800b5cc:	6821      	ldr	r1, [r4, #0]
 800b5ce:	b151      	cbz	r1, 800b5e6 <vTaskDelay+0x36>
 800b5d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b5d4:	b672      	cpsid	i
 800b5d6:	f383 8811 	msr	BASEPRI, r3
 800b5da:	f3bf 8f6f 	isb	sy
 800b5de:	f3bf 8f4f 	dsb	sy
 800b5e2:	b662      	cpsie	i
 800b5e4:	e7fe      	b.n	800b5e4 <vTaskDelay+0x34>
	++uxSchedulerSuspended;
 800b5e6:	6823      	ldr	r3, [r4, #0]
 800b5e8:	3301      	adds	r3, #1
 800b5ea:	6023      	str	r3, [r4, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800b5ec:	f7ff fc3c 	bl	800ae68 <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 800b5f0:	6823      	ldr	r3, [r4, #0]
 800b5f2:	b953      	cbnz	r3, 800b60a <vTaskDelay+0x5a>
 800b5f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b5f8:	b672      	cpsid	i
 800b5fa:	f383 8811 	msr	BASEPRI, r3
 800b5fe:	f3bf 8f6f 	isb	sy
 800b602:	f3bf 8f4f 	dsb	sy
 800b606:	b662      	cpsie	i
 800b608:	e7fe      	b.n	800b608 <vTaskDelay+0x58>
 800b60a:	f7ff ff2f 	bl	800b46c <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 800b60e:	2800      	cmp	r0, #0
 800b610:	d0d0      	beq.n	800b5b4 <vTaskDelay+0x4>
	}
 800b612:	bd10      	pop	{r4, pc}
 800b614:	2001a488 	.word	0x2001a488

0800b618 <vTaskDelayUntil>:
	{
 800b618:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxPreviousWakeTime );
 800b61a:	2800      	cmp	r0, #0
 800b61c:	d02f      	beq.n	800b67e <vTaskDelayUntil+0x66>
		configASSERT( ( xTimeIncrement > 0U ) );
 800b61e:	b951      	cbnz	r1, 800b636 <vTaskDelayUntil+0x1e>
 800b620:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b624:	b672      	cpsid	i
 800b626:	f383 8811 	msr	BASEPRI, r3
 800b62a:	f3bf 8f6f 	isb	sy
 800b62e:	f3bf 8f4f 	dsb	sy
 800b632:	b662      	cpsie	i
 800b634:	e7fe      	b.n	800b634 <vTaskDelayUntil+0x1c>
		configASSERT( uxSchedulerSuspended == 0 );
 800b636:	4c25      	ldr	r4, [pc, #148]	; (800b6cc <vTaskDelayUntil+0xb4>)
 800b638:	6823      	ldr	r3, [r4, #0]
 800b63a:	bb5b      	cbnz	r3, 800b694 <vTaskDelayUntil+0x7c>
	++uxSchedulerSuspended;
 800b63c:	6823      	ldr	r3, [r4, #0]
 800b63e:	3301      	adds	r3, #1
 800b640:	6023      	str	r3, [r4, #0]
			const TickType_t xConstTickCount = xTickCount;
 800b642:	4b23      	ldr	r3, [pc, #140]	; (800b6d0 <vTaskDelayUntil+0xb8>)
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 800b644:	6802      	ldr	r2, [r0, #0]
			const TickType_t xConstTickCount = xTickCount;
 800b646:	681d      	ldr	r5, [r3, #0]
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 800b648:	1853      	adds	r3, r2, r1
 800b64a:	bf2c      	ite	cs
 800b64c:	2101      	movcs	r1, #1
 800b64e:	2100      	movcc	r1, #0
			if( xConstTickCount < *pxPreviousWakeTime )
 800b650:	42aa      	cmp	r2, r5
			*pxPreviousWakeTime = xTimeToWake;
 800b652:	6003      	str	r3, [r0, #0]
			if( xConstTickCount < *pxPreviousWakeTime )
 800b654:	d929      	bls.n	800b6aa <vTaskDelayUntil+0x92>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 800b656:	b129      	cbz	r1, 800b664 <vTaskDelayUntil+0x4c>
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 800b658:	429d      	cmp	r5, r3
 800b65a:	d203      	bcs.n	800b664 <vTaskDelayUntil+0x4c>
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 800b65c:	2100      	movs	r1, #0
 800b65e:	1b58      	subs	r0, r3, r5
 800b660:	f7ff fc02 	bl	800ae68 <prvAddCurrentTaskToDelayedList>
	configASSERT( uxSchedulerSuspended );
 800b664:	6823      	ldr	r3, [r4, #0]
 800b666:	bb1b      	cbnz	r3, 800b6b0 <vTaskDelayUntil+0x98>
 800b668:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b66c:	b672      	cpsid	i
 800b66e:	f383 8811 	msr	BASEPRI, r3
 800b672:	f3bf 8f6f 	isb	sy
 800b676:	f3bf 8f4f 	dsb	sy
 800b67a:	b662      	cpsie	i
 800b67c:	e7fe      	b.n	800b67c <vTaskDelayUntil+0x64>
 800b67e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b682:	b672      	cpsid	i
 800b684:	f383 8811 	msr	BASEPRI, r3
 800b688:	f3bf 8f6f 	isb	sy
 800b68c:	f3bf 8f4f 	dsb	sy
 800b690:	b662      	cpsie	i
		configASSERT( pxPreviousWakeTime );
 800b692:	e7fe      	b.n	800b692 <vTaskDelayUntil+0x7a>
 800b694:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b698:	b672      	cpsid	i
 800b69a:	f383 8811 	msr	BASEPRI, r3
 800b69e:	f3bf 8f6f 	isb	sy
 800b6a2:	f3bf 8f4f 	dsb	sy
 800b6a6:	b662      	cpsie	i
		configASSERT( uxSchedulerSuspended == 0 );
 800b6a8:	e7fe      	b.n	800b6a8 <vTaskDelayUntil+0x90>
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 800b6aa:	2900      	cmp	r1, #0
 800b6ac:	d0d4      	beq.n	800b658 <vTaskDelayUntil+0x40>
 800b6ae:	e7d5      	b.n	800b65c <vTaskDelayUntil+0x44>
 800b6b0:	f7ff fedc 	bl	800b46c <xTaskResumeAll.part.0>
		if( xAlreadyYielded == pdFALSE )
 800b6b4:	b948      	cbnz	r0, 800b6ca <vTaskDelayUntil+0xb2>
			portYIELD_WITHIN_API();
 800b6b6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800b6ba:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b6be:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 800b6c2:	f3bf 8f4f 	dsb	sy
 800b6c6:	f3bf 8f6f 	isb	sy
	}
 800b6ca:	bd38      	pop	{r3, r4, r5, pc}
 800b6cc:	2001a488 	.word	0x2001a488
 800b6d0:	2001a504 	.word	0x2001a504

0800b6d4 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800b6d4:	4b1d      	ldr	r3, [pc, #116]	; (800b74c <vTaskSwitchContext+0x78>)
 800b6d6:	681b      	ldr	r3, [r3, #0]
 800b6d8:	b11b      	cbz	r3, 800b6e2 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 800b6da:	4b1d      	ldr	r3, [pc, #116]	; (800b750 <vTaskSwitchContext+0x7c>)
 800b6dc:	2201      	movs	r2, #1
 800b6de:	601a      	str	r2, [r3, #0]
 800b6e0:	4770      	bx	lr
		xYieldPending = pdFALSE;
 800b6e2:	4a1b      	ldr	r2, [pc, #108]	; (800b750 <vTaskSwitchContext+0x7c>)
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b6e4:	491b      	ldr	r1, [pc, #108]	; (800b754 <vTaskSwitchContext+0x80>)
{
 800b6e6:	b410      	push	{r4}
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b6e8:	4c1b      	ldr	r4, [pc, #108]	; (800b758 <vTaskSwitchContext+0x84>)
		xYieldPending = pdFALSE;
 800b6ea:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b6ec:	6823      	ldr	r3, [r4, #0]
 800b6ee:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800b6f2:	0098      	lsls	r0, r3, #2
 800b6f4:	0092      	lsls	r2, r2, #2
 800b6f6:	588a      	ldr	r2, [r1, r2]
 800b6f8:	b942      	cbnz	r2, 800b70c <vTaskSwitchContext+0x38>
 800b6fa:	b1c3      	cbz	r3, 800b72e <vTaskSwitchContext+0x5a>
 800b6fc:	3b01      	subs	r3, #1
 800b6fe:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 800b702:	0098      	lsls	r0, r3, #2
 800b704:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 800b708:	2a00      	cmp	r2, #0
 800b70a:	d0f6      	beq.n	800b6fa <vTaskSwitchContext+0x26>
 800b70c:	18c2      	adds	r2, r0, r3
 800b70e:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 800b712:	6841      	ldr	r1, [r0, #4]
 800b714:	4602      	mov	r2, r0
 800b716:	6849      	ldr	r1, [r1, #4]
 800b718:	3208      	adds	r2, #8
 800b71a:	4291      	cmp	r1, r2
 800b71c:	6041      	str	r1, [r0, #4]
 800b71e:	d011      	beq.n	800b744 <vTaskSwitchContext+0x70>
 800b720:	68c9      	ldr	r1, [r1, #12]
 800b722:	4a0e      	ldr	r2, [pc, #56]	; (800b75c <vTaskSwitchContext+0x88>)
 800b724:	6011      	str	r1, [r2, #0]
 800b726:	6023      	str	r3, [r4, #0]
}
 800b728:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b72c:	4770      	bx	lr
 800b72e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b732:	b672      	cpsid	i
 800b734:	f383 8811 	msr	BASEPRI, r3
 800b738:	f3bf 8f6f 	isb	sy
 800b73c:	f3bf 8f4f 	dsb	sy
 800b740:	b662      	cpsie	i
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b742:	e7fe      	b.n	800b742 <vTaskSwitchContext+0x6e>
 800b744:	6849      	ldr	r1, [r1, #4]
 800b746:	6041      	str	r1, [r0, #4]
 800b748:	e7ea      	b.n	800b720 <vTaskSwitchContext+0x4c>
 800b74a:	bf00      	nop
 800b74c:	2001a488 	.word	0x2001a488
 800b750:	2001a508 	.word	0x2001a508
 800b754:	2001a01c 	.word	0x2001a01c
 800b758:	2001a490 	.word	0x2001a490
 800b75c:	2001a010 	.word	0x2001a010

0800b760 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 800b760:	b310      	cbz	r0, 800b7a8 <vTaskPlaceOnEventList+0x48>
{
 800b762:	b570      	push	{r4, r5, r6, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800b764:	4d1d      	ldr	r5, [pc, #116]	; (800b7dc <vTaskPlaceOnEventList+0x7c>)
 800b766:	460c      	mov	r4, r1
 800b768:	6829      	ldr	r1, [r5, #0]
 800b76a:	3118      	adds	r1, #24
 800b76c:	f7fe f95a 	bl	8009a24 <vListInsert>
const TickType_t xConstTickCount = xTickCount;
 800b770:	4b1b      	ldr	r3, [pc, #108]	; (800b7e0 <vTaskPlaceOnEventList+0x80>)
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b772:	2200      	movs	r2, #0
const TickType_t xConstTickCount = xTickCount;
 800b774:	681e      	ldr	r6, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b776:	682b      	ldr	r3, [r5, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b778:	6828      	ldr	r0, [r5, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b77a:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b77e:	3004      	adds	r0, #4
 800b780:	f7fe f968 	bl	8009a54 <uxListRemove>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800b784:	1c63      	adds	r3, r4, #1
 800b786:	d022      	beq.n	800b7ce <vTaskPlaceOnEventList+0x6e>
			xTimeToWake = xConstTickCount + xTicksToWait;
 800b788:	19a4      	adds	r4, r4, r6
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800b78a:	682b      	ldr	r3, [r5, #0]
 800b78c:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800b78e:	d216      	bcs.n	800b7be <vTaskPlaceOnEventList+0x5e>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b790:	4b14      	ldr	r3, [pc, #80]	; (800b7e4 <vTaskPlaceOnEventList+0x84>)
 800b792:	6818      	ldr	r0, [r3, #0]
 800b794:	6829      	ldr	r1, [r5, #0]
 800b796:	3104      	adds	r1, #4
 800b798:	f7fe f944 	bl	8009a24 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800b79c:	4b12      	ldr	r3, [pc, #72]	; (800b7e8 <vTaskPlaceOnEventList+0x88>)
 800b79e:	681a      	ldr	r2, [r3, #0]
 800b7a0:	4294      	cmp	r4, r2
 800b7a2:	d200      	bcs.n	800b7a6 <vTaskPlaceOnEventList+0x46>
					xNextTaskUnblockTime = xTimeToWake;
 800b7a4:	601c      	str	r4, [r3, #0]
}
 800b7a6:	bd70      	pop	{r4, r5, r6, pc}
 800b7a8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b7ac:	b672      	cpsid	i
 800b7ae:	f383 8811 	msr	BASEPRI, r3
 800b7b2:	f3bf 8f6f 	isb	sy
 800b7b6:	f3bf 8f4f 	dsb	sy
 800b7ba:	b662      	cpsie	i
	configASSERT( pxEventList );
 800b7bc:	e7fe      	b.n	800b7bc <vTaskPlaceOnEventList+0x5c>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b7be:	4b0b      	ldr	r3, [pc, #44]	; (800b7ec <vTaskPlaceOnEventList+0x8c>)
 800b7c0:	6818      	ldr	r0, [r3, #0]
 800b7c2:	6829      	ldr	r1, [r5, #0]
}
 800b7c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b7c8:	3104      	adds	r1, #4
 800b7ca:	f7fe b92b 	b.w	8009a24 <vListInsert>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b7ce:	6829      	ldr	r1, [r5, #0]
 800b7d0:	4807      	ldr	r0, [pc, #28]	; (800b7f0 <vTaskPlaceOnEventList+0x90>)
 800b7d2:	3104      	adds	r1, #4
}
 800b7d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b7d8:	f7fe b914 	b.w	8009a04 <vListInsertEnd>
 800b7dc:	2001a010 	.word	0x2001a010
 800b7e0:	2001a504 	.word	0x2001a504
 800b7e4:	2001a014 	.word	0x2001a014
 800b7e8:	2001a4bc 	.word	0x2001a4bc
 800b7ec:	2001a018 	.word	0x2001a018
 800b7f0:	2001a4dc 	.word	0x2001a4dc

0800b7f4 <vTaskPlaceOnEventListRestricted>:
	{
 800b7f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		configASSERT( pxEventList );
 800b7f6:	2800      	cmp	r0, #0
 800b7f8:	d031      	beq.n	800b85e <vTaskPlaceOnEventListRestricted+0x6a>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800b7fa:	4e22      	ldr	r6, [pc, #136]	; (800b884 <vTaskPlaceOnEventListRestricted+0x90>)
 800b7fc:	460c      	mov	r4, r1
 800b7fe:	4615      	mov	r5, r2
 800b800:	6831      	ldr	r1, [r6, #0]
 800b802:	3118      	adds	r1, #24
 800b804:	f7fe f8fe 	bl	8009a04 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 800b808:	b185      	cbz	r5, 800b82c <vTaskPlaceOnEventListRestricted+0x38>
const TickType_t xConstTickCount = xTickCount;
 800b80a:	4b1f      	ldr	r3, [pc, #124]	; (800b888 <vTaskPlaceOnEventListRestricted+0x94>)
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b80c:	2200      	movs	r2, #0
const TickType_t xConstTickCount = xTickCount;
 800b80e:	681b      	ldr	r3, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b810:	6833      	ldr	r3, [r6, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b812:	6830      	ldr	r0, [r6, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b814:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b818:	3004      	adds	r0, #4
 800b81a:	f7fe f91b 	bl	8009a54 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b81e:	6831      	ldr	r1, [r6, #0]
 800b820:	481a      	ldr	r0, [pc, #104]	; (800b88c <vTaskPlaceOnEventListRestricted+0x98>)
 800b822:	3104      	adds	r1, #4
	}
 800b824:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b828:	f7fe b8ec 	b.w	8009a04 <vListInsertEnd>
const TickType_t xConstTickCount = xTickCount;
 800b82c:	4b16      	ldr	r3, [pc, #88]	; (800b888 <vTaskPlaceOnEventListRestricted+0x94>)
 800b82e:	681f      	ldr	r7, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b830:	6833      	ldr	r3, [r6, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b832:	6830      	ldr	r0, [r6, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b834:	f883 505e 	strb.w	r5, [r3, #94]	; 0x5e
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b838:	3004      	adds	r0, #4
 800b83a:	f7fe f90b 	bl	8009a54 <uxListRemove>
			xTimeToWake = xConstTickCount + xTicksToWait;
 800b83e:	19e4      	adds	r4, r4, r7
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800b840:	6833      	ldr	r3, [r6, #0]
 800b842:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800b844:	d216      	bcs.n	800b874 <vTaskPlaceOnEventListRestricted+0x80>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b846:	4b12      	ldr	r3, [pc, #72]	; (800b890 <vTaskPlaceOnEventListRestricted+0x9c>)
 800b848:	6818      	ldr	r0, [r3, #0]
 800b84a:	6831      	ldr	r1, [r6, #0]
 800b84c:	3104      	adds	r1, #4
 800b84e:	f7fe f8e9 	bl	8009a24 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800b852:	4b10      	ldr	r3, [pc, #64]	; (800b894 <vTaskPlaceOnEventListRestricted+0xa0>)
 800b854:	681a      	ldr	r2, [r3, #0]
 800b856:	4294      	cmp	r4, r2
 800b858:	d200      	bcs.n	800b85c <vTaskPlaceOnEventListRestricted+0x68>
					xNextTaskUnblockTime = xTimeToWake;
 800b85a:	601c      	str	r4, [r3, #0]
	}
 800b85c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b85e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b862:	b672      	cpsid	i
 800b864:	f383 8811 	msr	BASEPRI, r3
 800b868:	f3bf 8f6f 	isb	sy
 800b86c:	f3bf 8f4f 	dsb	sy
 800b870:	b662      	cpsie	i
		configASSERT( pxEventList );
 800b872:	e7fe      	b.n	800b872 <vTaskPlaceOnEventListRestricted+0x7e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b874:	4b08      	ldr	r3, [pc, #32]	; (800b898 <vTaskPlaceOnEventListRestricted+0xa4>)
 800b876:	6818      	ldr	r0, [r3, #0]
 800b878:	6831      	ldr	r1, [r6, #0]
	}
 800b87a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b87e:	3104      	adds	r1, #4
 800b880:	f7fe b8d0 	b.w	8009a24 <vListInsert>
 800b884:	2001a010 	.word	0x2001a010
 800b888:	2001a504 	.word	0x2001a504
 800b88c:	2001a4dc 	.word	0x2001a4dc
 800b890:	2001a014 	.word	0x2001a014
 800b894:	2001a4bc 	.word	0x2001a4bc
 800b898:	2001a018 	.word	0x2001a018

0800b89c <xTaskRemoveFromEventList>:
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b89c:	68c3      	ldr	r3, [r0, #12]
{
 800b89e:	b530      	push	{r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b8a0:	68dc      	ldr	r4, [r3, #12]
{
 800b8a2:	b083      	sub	sp, #12
	configASSERT( pxUnblockedTCB );
 800b8a4:	b35c      	cbz	r4, 800b8fe <xTaskRemoveFromEventList+0x62>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800b8a6:	f104 0518 	add.w	r5, r4, #24
 800b8aa:	4628      	mov	r0, r5
 800b8ac:	f7fe f8d2 	bl	8009a54 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b8b0:	4b1a      	ldr	r3, [pc, #104]	; (800b91c <xTaskRemoveFromEventList+0x80>)
 800b8b2:	681b      	ldr	r3, [r3, #0]
 800b8b4:	b17b      	cbz	r3, 800b8d6 <xTaskRemoveFromEventList+0x3a>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800b8b6:	4629      	mov	r1, r5
 800b8b8:	4819      	ldr	r0, [pc, #100]	; (800b920 <xTaskRemoveFromEventList+0x84>)
 800b8ba:	f7fe f8a3 	bl	8009a04 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800b8be:	4b19      	ldr	r3, [pc, #100]	; (800b924 <xTaskRemoveFromEventList+0x88>)
 800b8c0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800b8c2:	681b      	ldr	r3, [r3, #0]
 800b8c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b8c6:	429a      	cmp	r2, r3
 800b8c8:	d924      	bls.n	800b914 <xTaskRemoveFromEventList+0x78>
		xYieldPending = pdTRUE;
 800b8ca:	2301      	movs	r3, #1
 800b8cc:	4a16      	ldr	r2, [pc, #88]	; (800b928 <xTaskRemoveFromEventList+0x8c>)
		xReturn = pdTRUE;
 800b8ce:	4618      	mov	r0, r3
		xYieldPending = pdTRUE;
 800b8d0:	6013      	str	r3, [r2, #0]
}
 800b8d2:	b003      	add	sp, #12
 800b8d4:	bd30      	pop	{r4, r5, pc}
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800b8d6:	1d21      	adds	r1, r4, #4
 800b8d8:	4608      	mov	r0, r1
 800b8da:	9101      	str	r1, [sp, #4]
 800b8dc:	f7fe f8ba 	bl	8009a54 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800b8e0:	4a12      	ldr	r2, [pc, #72]	; (800b92c <xTaskRemoveFromEventList+0x90>)
 800b8e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b8e4:	6810      	ldr	r0, [r2, #0]
 800b8e6:	9901      	ldr	r1, [sp, #4]
 800b8e8:	4283      	cmp	r3, r0
 800b8ea:	d900      	bls.n	800b8ee <xTaskRemoveFromEventList+0x52>
 800b8ec:	6013      	str	r3, [r2, #0]
 800b8ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800b8f2:	480f      	ldr	r0, [pc, #60]	; (800b930 <xTaskRemoveFromEventList+0x94>)
 800b8f4:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 800b8f8:	f7fe f884 	bl	8009a04 <vListInsertEnd>
 800b8fc:	e7df      	b.n	800b8be <xTaskRemoveFromEventList+0x22>
 800b8fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b902:	b672      	cpsid	i
 800b904:	f383 8811 	msr	BASEPRI, r3
 800b908:	f3bf 8f6f 	isb	sy
 800b90c:	f3bf 8f4f 	dsb	sy
 800b910:	b662      	cpsie	i
	configASSERT( pxUnblockedTCB );
 800b912:	e7fe      	b.n	800b912 <xTaskRemoveFromEventList+0x76>
		xReturn = pdFALSE;
 800b914:	2000      	movs	r0, #0
}
 800b916:	b003      	add	sp, #12
 800b918:	bd30      	pop	{r4, r5, pc}
 800b91a:	bf00      	nop
 800b91c:	2001a488 	.word	0x2001a488
 800b920:	2001a4c4 	.word	0x2001a4c4
 800b924:	2001a010 	.word	0x2001a010
 800b928:	2001a508 	.word	0x2001a508
 800b92c:	2001a490 	.word	0x2001a490
 800b930:	2001a01c 	.word	0x2001a01c

0800b934 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800b934:	4a03      	ldr	r2, [pc, #12]	; (800b944 <vTaskInternalSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 800b936:	4b04      	ldr	r3, [pc, #16]	; (800b948 <vTaskInternalSetTimeOutState+0x14>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800b938:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800b93a:	681b      	ldr	r3, [r3, #0]
 800b93c:	e9c0 2300 	strd	r2, r3, [r0]
}
 800b940:	4770      	bx	lr
 800b942:	bf00      	nop
 800b944:	2001a4c0 	.word	0x2001a4c0
 800b948:	2001a504 	.word	0x2001a504

0800b94c <xTaskCheckForTimeOut>:
	configASSERT( pxTimeOut );
 800b94c:	2800      	cmp	r0, #0
 800b94e:	d033      	beq.n	800b9b8 <xTaskCheckForTimeOut+0x6c>
{
 800b950:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b952:	460d      	mov	r5, r1
 800b954:	b083      	sub	sp, #12
	configASSERT( pxTicksToWait );
 800b956:	b321      	cbz	r1, 800b9a2 <xTaskCheckForTimeOut+0x56>
	taskENTER_CRITICAL();
 800b958:	4604      	mov	r4, r0
 800b95a:	f000 fbcb 	bl	800c0f4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800b95e:	4a24      	ldr	r2, [pc, #144]	; (800b9f0 <xTaskCheckForTimeOut+0xa4>)
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
 800b960:	4b24      	ldr	r3, [pc, #144]	; (800b9f4 <xTaskCheckForTimeOut+0xa8>)
		const TickType_t xConstTickCount = xTickCount;
 800b962:	6816      	ldr	r6, [r2, #0]
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
 800b964:	6819      	ldr	r1, [r3, #0]
 800b966:	f891 005e 	ldrb.w	r0, [r1, #94]	; 0x5e
 800b96a:	bb80      	cbnz	r0, 800b9ce <xTaskCheckForTimeOut+0x82>
			if( *pxTicksToWait == portMAX_DELAY )
 800b96c:	682b      	ldr	r3, [r5, #0]
 800b96e:	1c59      	adds	r1, r3, #1
 800b970:	d032      	beq.n	800b9d8 <xTaskCheckForTimeOut+0x8c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800b972:	f8df e084 	ldr.w	lr, [pc, #132]	; 800b9f8 <xTaskCheckForTimeOut+0xac>
 800b976:	6820      	ldr	r0, [r4, #0]
 800b978:	f8de 7000 	ldr.w	r7, [lr]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800b97c:	6861      	ldr	r1, [r4, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800b97e:	42b8      	cmp	r0, r7
 800b980:	d001      	beq.n	800b986 <xTaskCheckForTimeOut+0x3a>
 800b982:	42b1      	cmp	r1, r6
 800b984:	d932      	bls.n	800b9ec <xTaskCheckForTimeOut+0xa0>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800b986:	eba6 0c01 	sub.w	ip, r6, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800b98a:	4563      	cmp	r3, ip
 800b98c:	d92a      	bls.n	800b9e4 <xTaskCheckForTimeOut+0x98>
			*pxTicksToWait -= xElapsedTime;
 800b98e:	1b9b      	subs	r3, r3, r6
			xReturn = pdFALSE;
 800b990:	2000      	movs	r0, #0
			*pxTicksToWait -= xElapsedTime;
 800b992:	440b      	add	r3, r1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800b994:	f8de 1000 	ldr.w	r1, [lr]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800b998:	6812      	ldr	r2, [r2, #0]
			*pxTicksToWait -= xElapsedTime;
 800b99a:	602b      	str	r3, [r5, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800b99c:	e9c4 1200 	strd	r1, r2, [r4]
			xReturn = pdFALSE;
 800b9a0:	e01a      	b.n	800b9d8 <xTaskCheckForTimeOut+0x8c>
 800b9a2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b9a6:	b672      	cpsid	i
 800b9a8:	f383 8811 	msr	BASEPRI, r3
 800b9ac:	f3bf 8f6f 	isb	sy
 800b9b0:	f3bf 8f4f 	dsb	sy
 800b9b4:	b662      	cpsie	i
	configASSERT( pxTicksToWait );
 800b9b6:	e7fe      	b.n	800b9b6 <xTaskCheckForTimeOut+0x6a>
 800b9b8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b9bc:	b672      	cpsid	i
 800b9be:	f383 8811 	msr	BASEPRI, r3
 800b9c2:	f3bf 8f6f 	isb	sy
 800b9c6:	f3bf 8f4f 	dsb	sy
 800b9ca:	b662      	cpsie	i
	configASSERT( pxTimeOut );
 800b9cc:	e7fe      	b.n	800b9cc <xTaskCheckForTimeOut+0x80>
				pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b9ce:	681b      	ldr	r3, [r3, #0]
 800b9d0:	2200      	movs	r2, #0
				xReturn = pdTRUE;
 800b9d2:	2001      	movs	r0, #1
				pxCurrentTCB->ucDelayAborted = pdFALSE;
 800b9d4:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
				xReturn = pdTRUE;
 800b9d8:	9001      	str	r0, [sp, #4]
	taskEXIT_CRITICAL();
 800b9da:	f000 fbb1 	bl	800c140 <vPortExitCritical>
}
 800b9de:	9801      	ldr	r0, [sp, #4]
 800b9e0:	b003      	add	sp, #12
 800b9e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
			*pxTicksToWait = 0;
 800b9e4:	2300      	movs	r3, #0
			xReturn = pdTRUE;
 800b9e6:	2001      	movs	r0, #1
			*pxTicksToWait = 0;
 800b9e8:	602b      	str	r3, [r5, #0]
			xReturn = pdTRUE;
 800b9ea:	e7f5      	b.n	800b9d8 <xTaskCheckForTimeOut+0x8c>
			xReturn = pdTRUE;
 800b9ec:	2001      	movs	r0, #1
 800b9ee:	e7f3      	b.n	800b9d8 <xTaskCheckForTimeOut+0x8c>
 800b9f0:	2001a504 	.word	0x2001a504
 800b9f4:	2001a010 	.word	0x2001a010
 800b9f8:	2001a4c0 	.word	0x2001a4c0

0800b9fc <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800b9fc:	4b01      	ldr	r3, [pc, #4]	; (800ba04 <vTaskMissedYield+0x8>)
 800b9fe:	2201      	movs	r2, #1
 800ba00:	601a      	str	r2, [r3, #0]
}
 800ba02:	4770      	bx	lr
 800ba04:	2001a508 	.word	0x2001a508

0800ba08 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 800ba08:	4b01      	ldr	r3, [pc, #4]	; (800ba10 <xTaskGetCurrentTaskHandle+0x8>)
 800ba0a:	6818      	ldr	r0, [r3, #0]
	}
 800ba0c:	4770      	bx	lr
 800ba0e:	bf00      	nop
 800ba10:	2001a010 	.word	0x2001a010

0800ba14 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 800ba14:	4b05      	ldr	r3, [pc, #20]	; (800ba2c <xTaskGetSchedulerState+0x18>)
 800ba16:	681b      	ldr	r3, [r3, #0]
 800ba18:	b133      	cbz	r3, 800ba28 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800ba1a:	4b05      	ldr	r3, [pc, #20]	; (800ba30 <xTaskGetSchedulerState+0x1c>)
 800ba1c:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
 800ba1e:	2b00      	cmp	r3, #0
 800ba20:	bf0c      	ite	eq
 800ba22:	2002      	moveq	r0, #2
 800ba24:	2000      	movne	r0, #0
 800ba26:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800ba28:	2001      	movs	r0, #1
	}
 800ba2a:	4770      	bx	lr
 800ba2c:	2001a4d8 	.word	0x2001a4d8
 800ba30:	2001a488 	.word	0x2001a488

0800ba34 <xTaskPriorityInherit>:
	{
 800ba34:	b570      	push	{r4, r5, r6, lr}
		if( pxMutexHolder != NULL )
 800ba36:	4604      	mov	r4, r0
	{
 800ba38:	b082      	sub	sp, #8
		if( pxMutexHolder != NULL )
 800ba3a:	b1c8      	cbz	r0, 800ba70 <xTaskPriorityInherit+0x3c>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 800ba3c:	4d1d      	ldr	r5, [pc, #116]	; (800bab4 <xTaskPriorityInherit+0x80>)
 800ba3e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800ba40:	682a      	ldr	r2, [r5, #0]
 800ba42:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800ba44:	4293      	cmp	r3, r2
 800ba46:	d215      	bcs.n	800ba74 <xTaskPriorityInherit+0x40>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800ba48:	6982      	ldr	r2, [r0, #24]
 800ba4a:	2a00      	cmp	r2, #0
 800ba4c:	db04      	blt.n	800ba58 <xTaskPriorityInherit+0x24>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba4e:	682a      	ldr	r2, [r5, #0]
 800ba50:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800ba52:	f1c2 0238 	rsb	r2, r2, #56	; 0x38
 800ba56:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 800ba58:	4e17      	ldr	r6, [pc, #92]	; (800bab8 <xTaskPriorityInherit+0x84>)
 800ba5a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800ba5e:	6962      	ldr	r2, [r4, #20]
 800ba60:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800ba64:	429a      	cmp	r2, r3
 800ba66:	d00e      	beq.n	800ba86 <xTaskPriorityInherit+0x52>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ba68:	682b      	ldr	r3, [r5, #0]
				xReturn = pdTRUE;
 800ba6a:	2001      	movs	r0, #1
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ba6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ba6e:	62e3      	str	r3, [r4, #44]	; 0x2c
	}
 800ba70:	b002      	add	sp, #8
 800ba72:	bd70      	pop	{r4, r5, r6, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 800ba74:	682b      	ldr	r3, [r5, #0]
 800ba76:	6d00      	ldr	r0, [r0, #80]	; 0x50
 800ba78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ba7a:	4298      	cmp	r0, r3
 800ba7c:	bf2c      	ite	cs
 800ba7e:	2000      	movcs	r0, #0
 800ba80:	2001      	movcc	r0, #1
	}
 800ba82:	b002      	add	sp, #8
 800ba84:	bd70      	pop	{r4, r5, r6, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ba86:	1d21      	adds	r1, r4, #4
 800ba88:	4608      	mov	r0, r1
 800ba8a:	9101      	str	r1, [sp, #4]
 800ba8c:	f7fd ffe2 	bl	8009a54 <uxListRemove>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ba90:	682a      	ldr	r2, [r5, #0]
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800ba92:	4b0a      	ldr	r3, [pc, #40]	; (800babc <xTaskPriorityInherit+0x88>)
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ba94:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800ba96:	681a      	ldr	r2, [r3, #0]
 800ba98:	9901      	ldr	r1, [sp, #4]
 800ba9a:	4290      	cmp	r0, r2
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800ba9c:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800ba9e:	d900      	bls.n	800baa2 <xTaskPriorityInherit+0x6e>
 800baa0:	6018      	str	r0, [r3, #0]
 800baa2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800baa6:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 800baaa:	f7fd ffab 	bl	8009a04 <vListInsertEnd>
				xReturn = pdTRUE;
 800baae:	2001      	movs	r0, #1
 800bab0:	e7de      	b.n	800ba70 <xTaskPriorityInherit+0x3c>
 800bab2:	bf00      	nop
 800bab4:	2001a010 	.word	0x2001a010
 800bab8:	2001a01c 	.word	0x2001a01c
 800babc:	2001a490 	.word	0x2001a490

0800bac0 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 800bac0:	b338      	cbz	r0, 800bb12 <xTaskPriorityDisinherit+0x52>
			configASSERT( pxTCB == pxCurrentTCB );
 800bac2:	4b21      	ldr	r3, [pc, #132]	; (800bb48 <xTaskPriorityDisinherit+0x88>)
	{
 800bac4:	b510      	push	{r4, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 800bac6:	681c      	ldr	r4, [r3, #0]
	{
 800bac8:	b082      	sub	sp, #8
			configASSERT( pxTCB == pxCurrentTCB );
 800baca:	4284      	cmp	r4, r0
 800bacc:	d00a      	beq.n	800bae4 <xTaskPriorityDisinherit+0x24>
 800bace:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bad2:	b672      	cpsid	i
 800bad4:	f383 8811 	msr	BASEPRI, r3
 800bad8:	f3bf 8f6f 	isb	sy
 800badc:	f3bf 8f4f 	dsb	sy
 800bae0:	b662      	cpsie	i
 800bae2:	e7fe      	b.n	800bae2 <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 800bae4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800bae6:	b14b      	cbz	r3, 800bafc <xTaskPriorityDisinherit+0x3c>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800bae8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			( pxTCB->uxMutexesHeld )--;
 800baea:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800baec:	6d22      	ldr	r2, [r4, #80]	; 0x50
			( pxTCB->uxMutexesHeld )--;
 800baee:	6563      	str	r3, [r4, #84]	; 0x54
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800baf0:	4291      	cmp	r1, r2
 800baf2:	d000      	beq.n	800baf6 <xTaskPriorityDisinherit+0x36>
 800baf4:	b17b      	cbz	r3, 800bb16 <xTaskPriorityDisinherit+0x56>
	BaseType_t xReturn = pdFALSE;
 800baf6:	2000      	movs	r0, #0
	}
 800baf8:	b002      	add	sp, #8
 800bafa:	bd10      	pop	{r4, pc}
 800bafc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bb00:	b672      	cpsid	i
 800bb02:	f383 8811 	msr	BASEPRI, r3
 800bb06:	f3bf 8f6f 	isb	sy
 800bb0a:	f3bf 8f4f 	dsb	sy
 800bb0e:	b662      	cpsie	i
			configASSERT( pxTCB->uxMutexesHeld );
 800bb10:	e7fe      	b.n	800bb10 <xTaskPriorityDisinherit+0x50>
	BaseType_t xReturn = pdFALSE;
 800bb12:	2000      	movs	r0, #0
	}
 800bb14:	4770      	bx	lr
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800bb16:	1d21      	adds	r1, r4, #4
 800bb18:	4608      	mov	r0, r1
 800bb1a:	9101      	str	r1, [sp, #4]
 800bb1c:	f7fd ff9a 	bl	8009a54 <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800bb20:	6d20      	ldr	r0, [r4, #80]	; 0x50
					prvAddTaskToReadyList( pxTCB );
 800bb22:	4b0a      	ldr	r3, [pc, #40]	; (800bb4c <xTaskPriorityDisinherit+0x8c>)
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb24:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
					prvAddTaskToReadyList( pxTCB );
 800bb28:	9901      	ldr	r1, [sp, #4]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800bb2a:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb2c:	61a2      	str	r2, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 800bb2e:	681a      	ldr	r2, [r3, #0]
 800bb30:	4290      	cmp	r0, r2
 800bb32:	d900      	bls.n	800bb36 <xTaskPriorityDisinherit+0x76>
 800bb34:	6018      	str	r0, [r3, #0]
 800bb36:	4b06      	ldr	r3, [pc, #24]	; (800bb50 <xTaskPriorityDisinherit+0x90>)
 800bb38:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800bb3c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800bb40:	f7fd ff60 	bl	8009a04 <vListInsertEnd>
					xReturn = pdTRUE;
 800bb44:	2001      	movs	r0, #1
		return xReturn;
 800bb46:	e7d7      	b.n	800baf8 <xTaskPriorityDisinherit+0x38>
 800bb48:	2001a010 	.word	0x2001a010
 800bb4c:	2001a490 	.word	0x2001a490
 800bb50:	2001a01c 	.word	0x2001a01c

0800bb54 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 800bb54:	2800      	cmp	r0, #0
 800bb56:	d042      	beq.n	800bbde <vTaskPriorityDisinheritAfterTimeout+0x8a>
			configASSERT( pxTCB->uxMutexesHeld );
 800bb58:	6d43      	ldr	r3, [r0, #84]	; 0x54
	{
 800bb5a:	b530      	push	{r4, r5, lr}
 800bb5c:	4604      	mov	r4, r0
 800bb5e:	b083      	sub	sp, #12
			configASSERT( pxTCB->uxMutexesHeld );
 800bb60:	b153      	cbz	r3, 800bb78 <vTaskPriorityDisinheritAfterTimeout+0x24>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 800bb62:	6d00      	ldr	r0, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != uxPriorityToUse )
 800bb64:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bb66:	4281      	cmp	r1, r0
 800bb68:	bf38      	it	cc
 800bb6a:	4601      	movcc	r1, r0
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 800bb6c:	2b01      	cmp	r3, #1
 800bb6e:	d101      	bne.n	800bb74 <vTaskPriorityDisinheritAfterTimeout+0x20>
 800bb70:	428a      	cmp	r2, r1
 800bb72:	d10c      	bne.n	800bb8e <vTaskPriorityDisinheritAfterTimeout+0x3a>
	}
 800bb74:	b003      	add	sp, #12
 800bb76:	bd30      	pop	{r4, r5, pc}
 800bb78:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bb7c:	b672      	cpsid	i
 800bb7e:	f383 8811 	msr	BASEPRI, r3
 800bb82:	f3bf 8f6f 	isb	sy
 800bb86:	f3bf 8f4f 	dsb	sy
 800bb8a:	b662      	cpsie	i
			configASSERT( pxTCB->uxMutexesHeld );
 800bb8c:	e7fe      	b.n	800bb8c <vTaskPriorityDisinheritAfterTimeout+0x38>
					configASSERT( pxTCB != pxCurrentTCB );
 800bb8e:	4b1a      	ldr	r3, [pc, #104]	; (800bbf8 <vTaskPriorityDisinheritAfterTimeout+0xa4>)
 800bb90:	681b      	ldr	r3, [r3, #0]
 800bb92:	42a3      	cmp	r3, r4
 800bb94:	d024      	beq.n	800bbe0 <vTaskPriorityDisinheritAfterTimeout+0x8c>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800bb96:	69a3      	ldr	r3, [r4, #24]
					pxTCB->uxPriority = uxPriorityToUse;
 800bb98:	62e1      	str	r1, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800bb9a:	2b00      	cmp	r3, #0
 800bb9c:	db02      	blt.n	800bba4 <vTaskPriorityDisinheritAfterTimeout+0x50>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb9e:	f1c1 0138 	rsb	r1, r1, #56	; 0x38
 800bba2:	61a1      	str	r1, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800bba4:	4d15      	ldr	r5, [pc, #84]	; (800bbfc <vTaskPriorityDisinheritAfterTimeout+0xa8>)
 800bba6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800bbaa:	6961      	ldr	r1, [r4, #20]
 800bbac:	eb05 0382 	add.w	r3, r5, r2, lsl #2
 800bbb0:	4299      	cmp	r1, r3
 800bbb2:	d1df      	bne.n	800bb74 <vTaskPriorityDisinheritAfterTimeout+0x20>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800bbb4:	1d21      	adds	r1, r4, #4
 800bbb6:	4608      	mov	r0, r1
 800bbb8:	9101      	str	r1, [sp, #4]
 800bbba:	f7fd ff4b 	bl	8009a54 <uxListRemove>
						prvAddTaskToReadyList( pxTCB );
 800bbbe:	4b10      	ldr	r3, [pc, #64]	; (800bc00 <vTaskPriorityDisinheritAfterTimeout+0xac>)
 800bbc0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800bbc2:	681a      	ldr	r2, [r3, #0]
 800bbc4:	9901      	ldr	r1, [sp, #4]
 800bbc6:	4290      	cmp	r0, r2
 800bbc8:	d900      	bls.n	800bbcc <vTaskPriorityDisinheritAfterTimeout+0x78>
 800bbca:	6018      	str	r0, [r3, #0]
 800bbcc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800bbd0:	eb05 0080 	add.w	r0, r5, r0, lsl #2
	}
 800bbd4:	b003      	add	sp, #12
 800bbd6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
						prvAddTaskToReadyList( pxTCB );
 800bbda:	f7fd bf13 	b.w	8009a04 <vListInsertEnd>
 800bbde:	4770      	bx	lr
 800bbe0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bbe4:	b672      	cpsid	i
 800bbe6:	f383 8811 	msr	BASEPRI, r3
 800bbea:	f3bf 8f6f 	isb	sy
 800bbee:	f3bf 8f4f 	dsb	sy
 800bbf2:	b662      	cpsie	i
					configASSERT( pxTCB != pxCurrentTCB );
 800bbf4:	e7fe      	b.n	800bbf4 <vTaskPriorityDisinheritAfterTimeout+0xa0>
 800bbf6:	bf00      	nop
 800bbf8:	2001a010 	.word	0x2001a010
 800bbfc:	2001a01c 	.word	0x2001a01c
 800bc00:	2001a490 	.word	0x2001a490

0800bc04 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 800bc04:	4b04      	ldr	r3, [pc, #16]	; (800bc18 <pvTaskIncrementMutexHeldCount+0x14>)
 800bc06:	681a      	ldr	r2, [r3, #0]
 800bc08:	b11a      	cbz	r2, 800bc12 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 800bc0a:	6819      	ldr	r1, [r3, #0]
 800bc0c:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 800bc0e:	3201      	adds	r2, #1
 800bc10:	654a      	str	r2, [r1, #84]	; 0x54
		return pxCurrentTCB;
 800bc12:	6818      	ldr	r0, [r3, #0]
	}
 800bc14:	4770      	bx	lr
 800bc16:	bf00      	nop
 800bc18:	2001a010 	.word	0x2001a010

0800bc1c <prvSwitchTimerLists>:
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 800bc1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800bc20:	4e23      	ldr	r6, [pc, #140]	; (800bcb0 <prvSwitchTimerLists+0x94>)
 800bc22:	b085      	sub	sp, #20
	if( xTimerQueue != NULL )
 800bc24:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800bcb8 <prvSwitchTimerLists+0x9c>
		xMessage.xMessageID = xCommandID;
 800bc28:	f04f 0800 	mov.w	r8, #0

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800bc2c:	e00d      	b.n	800bc4a <prvSwitchTimerLists+0x2e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800bc2e:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800bc30:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800bc32:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800bc34:	1d25      	adds	r5, r4, #4
 800bc36:	4628      	mov	r0, r5
 800bc38:	f7fd ff0c 	bl	8009a54 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800bc3c:	6a23      	ldr	r3, [r4, #32]
 800bc3e:	4620      	mov	r0, r4
 800bc40:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800bc42:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800bc46:	075b      	lsls	r3, r3, #29
 800bc48:	d40a      	bmi.n	800bc60 <prvSwitchTimerLists+0x44>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800bc4a:	6833      	ldr	r3, [r6, #0]
 800bc4c:	681a      	ldr	r2, [r3, #0]
 800bc4e:	2a00      	cmp	r2, #0
 800bc50:	d1ed      	bne.n	800bc2e <prvSwitchTimerLists+0x12>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 800bc52:	4a18      	ldr	r2, [pc, #96]	; (800bcb4 <prvSwitchTimerLists+0x98>)
 800bc54:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 800bc56:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 800bc58:	6031      	str	r1, [r6, #0]
}
 800bc5a:	b005      	add	sp, #20
 800bc5c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800bc60:	69a3      	ldr	r3, [r4, #24]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800bc62:	4629      	mov	r1, r5
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800bc64:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
 800bc66:	429f      	cmp	r7, r3
 800bc68:	d205      	bcs.n	800bc76 <prvSwitchTimerLists+0x5a>
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800bc6a:	6830      	ldr	r0, [r6, #0]
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800bc6c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800bc6e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800bc70:	f7fd fed8 	bl	8009a24 <vListInsert>
 800bc74:	e7e9      	b.n	800bc4a <prvSwitchTimerLists+0x2e>
	if( xTimerQueue != NULL )
 800bc76:	f8d9 3000 	ldr.w	r3, [r9]
 800bc7a:	b16b      	cbz	r3, 800bc98 <prvSwitchTimerLists+0x7c>
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800bc7c:	9402      	str	r4, [sp, #8]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800bc7e:	e9cd 8700 	strd	r8, r7, [sp]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800bc82:	f7ff fec7 	bl	800ba14 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800bc86:	2300      	movs	r3, #0
 800bc88:	4669      	mov	r1, sp
 800bc8a:	f8d9 0000 	ldr.w	r0, [r9]
 800bc8e:	461a      	mov	r2, r3
 800bc90:	f7fe f8ae 	bl	8009df0 <xQueueGenericSend>
				configASSERT( xResult );
 800bc94:	2800      	cmp	r0, #0
 800bc96:	d1d8      	bne.n	800bc4a <prvSwitchTimerLists+0x2e>
 800bc98:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bc9c:	b672      	cpsid	i
 800bc9e:	f383 8811 	msr	BASEPRI, r3
 800bca2:	f3bf 8f6f 	isb	sy
 800bca6:	f3bf 8f4f 	dsb	sy
 800bcaa:	b662      	cpsie	i
 800bcac:	e7fe      	b.n	800bcac <prvSwitchTimerLists+0x90>
 800bcae:	bf00      	nop
 800bcb0:	2001a50c 	.word	0x2001a50c
 800bcb4:	2001a510 	.word	0x2001a510
 800bcb8:	2001a630 	.word	0x2001a630

0800bcbc <prvTimerTask>:
{
 800bcbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bcc0:	4ea2      	ldr	r6, [pc, #648]	; (800bf4c <prvTimerTask+0x290>)
 800bcc2:	b089      	sub	sp, #36	; 0x24
 800bcc4:	4da2      	ldr	r5, [pc, #648]	; (800bf50 <prvTimerTask+0x294>)
					portYIELD_WITHIN_API();
 800bcc6:	f04f 29e0 	mov.w	r9, #3758153728	; 0xe000e000
 800bcca:	4ca2      	ldr	r4, [pc, #648]	; (800bf54 <prvTimerTask+0x298>)
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800bccc:	6833      	ldr	r3, [r6, #0]
 800bcce:	681f      	ldr	r7, [r3, #0]
 800bcd0:	2f00      	cmp	r7, #0
 800bcd2:	f000 80b4 	beq.w	800be3e <prvTimerTask+0x182>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800bcd6:	68db      	ldr	r3, [r3, #12]
 800bcd8:	681f      	ldr	r7, [r3, #0]
	vTaskSuspendAll();
 800bcda:	f7ff faf9 	bl	800b2d0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 800bcde:	f7ff faff 	bl	800b2e0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 800bce2:	682a      	ldr	r2, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 800bce4:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 800bce6:	4290      	cmp	r0, r2
 800bce8:	f0c0 80b1 	bcc.w	800be4e <prvTimerTask+0x192>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800bcec:	4287      	cmp	r7, r0
	xLastTime = xTimeNow;
 800bcee:	6028      	str	r0, [r5, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800bcf0:	f200 80d2 	bhi.w	800be98 <prvTimerTask+0x1dc>
				( void ) xTaskResumeAll();
 800bcf4:	f7ff fc4a 	bl	800b58c <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800bcf8:	6832      	ldr	r2, [r6, #0]
 800bcfa:	68d2      	ldr	r2, [r2, #12]
 800bcfc:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800bd00:	f10b 0804 	add.w	r8, fp, #4
 800bd04:	4640      	mov	r0, r8
 800bd06:	f7fd fea5 	bl	8009a54 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800bd0a:	f89b 0028 	ldrb.w	r0, [fp, #40]	; 0x28
 800bd0e:	0741      	lsls	r1, r0, #29
 800bd10:	f100 80d2 	bmi.w	800beb8 <prvTimerTask+0x1fc>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800bd14:	f020 0001 	bic.w	r0, r0, #1
 800bd18:	f88b 0028 	strb.w	r0, [fp, #40]	; 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800bd1c:	f8db 3020 	ldr.w	r3, [fp, #32]
 800bd20:	4658      	mov	r0, fp
 800bd22:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800bd24:	2200      	movs	r2, #0
 800bd26:	4669      	mov	r1, sp
 800bd28:	6820      	ldr	r0, [r4, #0]
 800bd2a:	f7fe fb6b 	bl	800a404 <xQueueReceive>
 800bd2e:	2800      	cmp	r0, #0
 800bd30:	d0cc      	beq.n	800bccc <prvTimerTask+0x10>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 800bd32:	9b00      	ldr	r3, [sp, #0]
 800bd34:	2b00      	cmp	r3, #0
 800bd36:	db79      	blt.n	800be2c <prvTimerTask+0x170>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 800bd38:	9f02      	ldr	r7, [sp, #8]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800bd3a:	697b      	ldr	r3, [r7, #20]
 800bd3c:	b113      	cbz	r3, 800bd44 <prvTimerTask+0x88>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800bd3e:	1d38      	adds	r0, r7, #4
 800bd40:	f7fd fe88 	bl	8009a54 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 800bd44:	f7ff facc 	bl	800b2e0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 800bd48:	682b      	ldr	r3, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 800bd4a:	4680      	mov	r8, r0
	if( xTimeNow < xLastTime )
 800bd4c:	4298      	cmp	r0, r3
 800bd4e:	f0c0 8085 	bcc.w	800be5c <prvTimerTask+0x1a0>
			switch( xMessage.xMessageID )
 800bd52:	9b00      	ldr	r3, [sp, #0]
	xLastTime = xTimeNow;
 800bd54:	f8c5 8000 	str.w	r8, [r5]
			switch( xMessage.xMessageID )
 800bd58:	2b09      	cmp	r3, #9
 800bd5a:	d8e3      	bhi.n	800bd24 <prvTimerTask+0x68>
 800bd5c:	e8df f003 	tbb	[pc, r3]
 800bd60:	56050505 	.word	0x56050505
 800bd64:	05055d40 	.word	0x05055d40
 800bd68:	4056      	.short	0x4056
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800bd6a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800bd6e:	69ba      	ldr	r2, [r7, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800bd70:	f043 0301 	orr.w	r3, r3, #1
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800bd74:	613f      	str	r7, [r7, #16]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800bd76:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800bd7a:	9b01      	ldr	r3, [sp, #4]
 800bd7c:	1899      	adds	r1, r3, r2
 800bd7e:	bf2c      	ite	cs
 800bd80:	2001      	movcs	r0, #1
 800bd82:	2000      	movcc	r0, #0
	if( xNextExpiryTime <= xTimeNow )
 800bd84:	4541      	cmp	r1, r8
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800bd86:	6079      	str	r1, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
 800bd88:	f200 8088 	bhi.w	800be9c <prvTimerTask+0x1e0>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bd8c:	eba8 0303 	sub.w	r3, r8, r3
 800bd90:	429a      	cmp	r2, r3
 800bd92:	f200 80c4 	bhi.w	800bf1e <prvTimerTask+0x262>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800bd96:	6a3b      	ldr	r3, [r7, #32]
 800bd98:	4638      	mov	r0, r7
 800bd9a:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800bd9c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800bda0:	075b      	lsls	r3, r3, #29
 800bda2:	d5bf      	bpl.n	800bd24 <prvTimerTask+0x68>
	if( xTimerQueue != NULL )
 800bda4:	6823      	ldr	r3, [r4, #0]
 800bda6:	b183      	cbz	r3, 800bdca <prvTimerTask+0x10e>
		xMessage.xMessageID = xCommandID;
 800bda8:	2200      	movs	r2, #0
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800bdaa:	69bb      	ldr	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800bdac:	9706      	str	r7, [sp, #24]
		xMessage.xMessageID = xCommandID;
 800bdae:	9204      	str	r2, [sp, #16]
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800bdb0:	9a01      	ldr	r2, [sp, #4]
 800bdb2:	4413      	add	r3, r2
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800bdb4:	9305      	str	r3, [sp, #20]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800bdb6:	f7ff fe2d 	bl	800ba14 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800bdba:	2300      	movs	r3, #0
 800bdbc:	a904      	add	r1, sp, #16
 800bdbe:	6820      	ldr	r0, [r4, #0]
 800bdc0:	461a      	mov	r2, r3
 800bdc2:	f7fe f815 	bl	8009df0 <xQueueGenericSend>
							configASSERT( xResult );
 800bdc6:	2800      	cmp	r0, #0
 800bdc8:	d1ac      	bne.n	800bd24 <prvTimerTask+0x68>
 800bdca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bdce:	b672      	cpsid	i
 800bdd0:	f383 8811 	msr	BASEPRI, r3
 800bdd4:	f3bf 8f6f 	isb	sy
 800bdd8:	f3bf 8f4f 	dsb	sy
 800bddc:	b662      	cpsie	i
 800bdde:	e7fe      	b.n	800bdde <prvTimerTask+0x122>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800bde0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800bde4:	f043 0301 	orr.w	r3, r3, #1
 800bde8:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 800bdec:	9b01      	ldr	r3, [sp, #4]
 800bdee:	61bb      	str	r3, [r7, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800bdf0:	2b00      	cmp	r3, #0
 800bdf2:	f000 80a0 	beq.w	800bf36 <prvTimerTask+0x27a>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800bdf6:	4443      	add	r3, r8
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800bdf8:	1d39      	adds	r1, r7, #4
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800bdfa:	613f      	str	r7, [r7, #16]
	if( xNextExpiryTime <= xTimeNow )
 800bdfc:	4543      	cmp	r3, r8
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800bdfe:	607b      	str	r3, [r7, #4]
	if( xNextExpiryTime <= xTimeNow )
 800be00:	d856      	bhi.n	800beb0 <prvTimerTask+0x1f4>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800be02:	4b55      	ldr	r3, [pc, #340]	; (800bf58 <prvTimerTask+0x29c>)
 800be04:	6818      	ldr	r0, [r3, #0]
 800be06:	f7fd fe0d 	bl	8009a24 <vListInsert>
	return xProcessTimerNow;
 800be0a:	e78b      	b.n	800bd24 <prvTimerTask+0x68>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800be0c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800be10:	f023 0301 	bic.w	r3, r3, #1
 800be14:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
					break;
 800be18:	e784      	b.n	800bd24 <prvTimerTask+0x68>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800be1a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800be1e:	079a      	lsls	r2, r3, #30
 800be20:	d574      	bpl.n	800bf0c <prvTimerTask+0x250>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800be22:	f023 0301 	bic.w	r3, r3, #1
 800be26:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 800be2a:	e77b      	b.n	800bd24 <prvTimerTask+0x68>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 800be2c:	9b01      	ldr	r3, [sp, #4]
 800be2e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800be32:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800be34:	9b00      	ldr	r3, [sp, #0]
 800be36:	2b00      	cmp	r3, #0
 800be38:	f6ff af74 	blt.w	800bd24 <prvTimerTask+0x68>
 800be3c:	e77c      	b.n	800bd38 <prvTimerTask+0x7c>
	vTaskSuspendAll();
 800be3e:	f7ff fa47 	bl	800b2d0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 800be42:	f7ff fa4d 	bl	800b2e0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 800be46:	682a      	ldr	r2, [r5, #0]
	xTimeNow = xTaskGetTickCount();
 800be48:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 800be4a:	4282      	cmp	r2, r0
 800be4c:	d909      	bls.n	800be62 <prvTimerTask+0x1a6>
		prvSwitchTimerLists();
 800be4e:	f7ff fee5 	bl	800bc1c <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 800be52:	f8c5 a000 	str.w	sl, [r5]
			( void ) xTaskResumeAll();
 800be56:	f7ff fb99 	bl	800b58c <xTaskResumeAll>
 800be5a:	e763      	b.n	800bd24 <prvTimerTask+0x68>
		prvSwitchTimerLists();
 800be5c:	f7ff fede 	bl	800bc1c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 800be60:	e777      	b.n	800bd52 <prvTimerTask+0x96>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800be62:	4b3d      	ldr	r3, [pc, #244]	; (800bf58 <prvTimerTask+0x29c>)
	xLastTime = xTimeNow;
 800be64:	f8c5 a000 	str.w	sl, [r5]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800be68:	681a      	ldr	r2, [r3, #0]
 800be6a:	6812      	ldr	r2, [r2, #0]
 800be6c:	fab2 f282 	clz	r2, r2
 800be70:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800be72:	eba7 010a 	sub.w	r1, r7, sl
 800be76:	6820      	ldr	r0, [r4, #0]
 800be78:	f7fe ff0a 	bl	800ac90 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 800be7c:	f7ff fb86 	bl	800b58c <xTaskResumeAll>
 800be80:	2800      	cmp	r0, #0
 800be82:	f47f af4f 	bne.w	800bd24 <prvTimerTask+0x68>
					portYIELD_WITHIN_API();
 800be86:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800be8a:	f8c9 3d04 	str.w	r3, [r9, #3332]	; 0xd04
 800be8e:	f3bf 8f4f 	dsb	sy
 800be92:	f3bf 8f6f 	isb	sy
 800be96:	e745      	b.n	800bd24 <prvTimerTask+0x68>
 800be98:	2200      	movs	r2, #0
 800be9a:	e7ea      	b.n	800be72 <prvTimerTask+0x1b6>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800be9c:	4543      	cmp	r3, r8
 800be9e:	d902      	bls.n	800bea6 <prvTimerTask+0x1ea>
 800bea0:	2800      	cmp	r0, #0
 800bea2:	f43f af78 	beq.w	800bd96 <prvTimerTask+0xda>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800bea6:	1d39      	adds	r1, r7, #4
 800bea8:	6830      	ldr	r0, [r6, #0]
 800beaa:	f7fd fdbb 	bl	8009a24 <vListInsert>
	return xProcessTimerNow;
 800beae:	e739      	b.n	800bd24 <prvTimerTask+0x68>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800beb0:	6830      	ldr	r0, [r6, #0]
 800beb2:	f7fd fdb7 	bl	8009a24 <vListInsert>
 800beb6:	e735      	b.n	800bd24 <prvTimerTask+0x68>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800beb8:	f8db 2018 	ldr.w	r2, [fp, #24]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800bebc:	f8cb b010 	str.w	fp, [fp, #16]
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800bec0:	18b8      	adds	r0, r7, r2
	if( xNextExpiryTime <= xTimeNow )
 800bec2:	4582      	cmp	sl, r0
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800bec4:	f8cb 0004 	str.w	r0, [fp, #4]
	if( xNextExpiryTime <= xTimeNow )
 800bec8:	d324      	bcc.n	800bf14 <prvTimerTask+0x258>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800beca:	ebaa 0307 	sub.w	r3, sl, r7
 800bece:	429a      	cmp	r2, r3
 800bed0:	d82b      	bhi.n	800bf2a <prvTimerTask+0x26e>
	if( xTimerQueue != NULL )
 800bed2:	6823      	ldr	r3, [r4, #0]
 800bed4:	b17b      	cbz	r3, 800bef6 <prvTimerTask+0x23a>
		xMessage.xMessageID = xCommandID;
 800bed6:	2300      	movs	r3, #0
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800bed8:	9705      	str	r7, [sp, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800beda:	f8cd b018 	str.w	fp, [sp, #24]
		xMessage.xMessageID = xCommandID;
 800bede:	9304      	str	r3, [sp, #16]
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800bee0:	f7ff fd98 	bl	800ba14 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800bee4:	2300      	movs	r3, #0
 800bee6:	a904      	add	r1, sp, #16
 800bee8:	6820      	ldr	r0, [r4, #0]
 800beea:	461a      	mov	r2, r3
 800beec:	f7fd ff80 	bl	8009df0 <xQueueGenericSend>
			configASSERT( xResult );
 800bef0:	2800      	cmp	r0, #0
 800bef2:	f47f af13 	bne.w	800bd1c <prvTimerTask+0x60>
 800bef6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800befa:	b672      	cpsid	i
 800befc:	f383 8811 	msr	BASEPRI, r3
 800bf00:	f3bf 8f6f 	isb	sy
 800bf04:	f3bf 8f4f 	dsb	sy
 800bf08:	b662      	cpsie	i
 800bf0a:	e7fe      	b.n	800bf0a <prvTimerTask+0x24e>
							vPortFree( pxTimer );
 800bf0c:	4638      	mov	r0, r7
 800bf0e:	f000 fafb 	bl	800c508 <vPortFree>
 800bf12:	e707      	b.n	800bd24 <prvTimerTask+0x68>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800bf14:	4641      	mov	r1, r8
 800bf16:	6830      	ldr	r0, [r6, #0]
 800bf18:	f7fd fd84 	bl	8009a24 <vListInsert>
	return xProcessTimerNow;
 800bf1c:	e6fe      	b.n	800bd1c <prvTimerTask+0x60>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800bf1e:	4b0e      	ldr	r3, [pc, #56]	; (800bf58 <prvTimerTask+0x29c>)
 800bf20:	1d39      	adds	r1, r7, #4
 800bf22:	6818      	ldr	r0, [r3, #0]
 800bf24:	f7fd fd7e 	bl	8009a24 <vListInsert>
	return xProcessTimerNow;
 800bf28:	e6fc      	b.n	800bd24 <prvTimerTask+0x68>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800bf2a:	4b0b      	ldr	r3, [pc, #44]	; (800bf58 <prvTimerTask+0x29c>)
 800bf2c:	4641      	mov	r1, r8
 800bf2e:	6818      	ldr	r0, [r3, #0]
 800bf30:	f7fd fd78 	bl	8009a24 <vListInsert>
	return xProcessTimerNow;
 800bf34:	e6f2      	b.n	800bd1c <prvTimerTask+0x60>
 800bf36:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bf3a:	b672      	cpsid	i
 800bf3c:	f383 8811 	msr	BASEPRI, r3
 800bf40:	f3bf 8f6f 	isb	sy
 800bf44:	f3bf 8f4f 	dsb	sy
 800bf48:	b662      	cpsie	i
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800bf4a:	e7fe      	b.n	800bf4a <prvTimerTask+0x28e>
 800bf4c:	2001a50c 	.word	0x2001a50c
 800bf50:	2001a5dc 	.word	0x2001a5dc
 800bf54:	2001a630 	.word	0x2001a630
 800bf58:	2001a510 	.word	0x2001a510

0800bf5c <xTimerCreateTimerTask>:
{
 800bf5c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 800bf5e:	4c24      	ldr	r4, [pc, #144]	; (800bff0 <xTimerCreateTimerTask+0x94>)
{
 800bf60:	b089      	sub	sp, #36	; 0x24
	taskENTER_CRITICAL();
 800bf62:	f000 f8c7 	bl	800c0f4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 800bf66:	6825      	ldr	r5, [r4, #0]
 800bf68:	b345      	cbz	r5, 800bfbc <xTimerCreateTimerTask+0x60>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800bf6a:	f000 f8e9 	bl	800c140 <vPortExitCritical>
	if( xTimerQueue != NULL )
 800bf6e:	6823      	ldr	r3, [r4, #0]
 800bf70:	b1cb      	cbz	r3, 800bfa6 <xTimerCreateTimerTask+0x4a>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 800bf72:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800bf74:	aa07      	add	r2, sp, #28
 800bf76:	a906      	add	r1, sp, #24
 800bf78:	a805      	add	r0, sp, #20
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 800bf7a:	2502      	movs	r5, #2
			StackType_t *pxTimerTaskStackBuffer = NULL;
 800bf7c:	e9cd 4405 	strd	r4, r4, [sp, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800bf80:	f7fd fd20 	bl	80099c4 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 800bf84:	4623      	mov	r3, r4
 800bf86:	9a07      	ldr	r2, [sp, #28]
 800bf88:	9500      	str	r5, [sp, #0]
 800bf8a:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
 800bf8e:	e9cd 1001 	strd	r1, r0, [sp, #4]
 800bf92:	4918      	ldr	r1, [pc, #96]	; (800bff4 <xTimerCreateTimerTask+0x98>)
 800bf94:	4818      	ldr	r0, [pc, #96]	; (800bff8 <xTimerCreateTimerTask+0x9c>)
 800bf96:	f7ff f88d 	bl	800b0b4 <xTaskCreateStatic>
 800bf9a:	4b18      	ldr	r3, [pc, #96]	; (800bffc <xTimerCreateTimerTask+0xa0>)
 800bf9c:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
 800bf9e:	b110      	cbz	r0, 800bfa6 <xTimerCreateTimerTask+0x4a>
}
 800bfa0:	2001      	movs	r0, #1
 800bfa2:	b009      	add	sp, #36	; 0x24
 800bfa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bfa6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bfaa:	b672      	cpsid	i
 800bfac:	f383 8811 	msr	BASEPRI, r3
 800bfb0:	f3bf 8f6f 	isb	sy
 800bfb4:	f3bf 8f4f 	dsb	sy
 800bfb8:	b662      	cpsie	i
	configASSERT( xReturn );
 800bfba:	e7fe      	b.n	800bfba <xTimerCreateTimerTask+0x5e>
			vListInitialise( &xActiveTimerList1 );
 800bfbc:	4f10      	ldr	r7, [pc, #64]	; (800c000 <xTimerCreateTimerTask+0xa4>)
			vListInitialise( &xActiveTimerList2 );
 800bfbe:	4e11      	ldr	r6, [pc, #68]	; (800c004 <xTimerCreateTimerTask+0xa8>)
			vListInitialise( &xActiveTimerList1 );
 800bfc0:	4638      	mov	r0, r7
 800bfc2:	f7fd fd0f 	bl	80099e4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800bfc6:	4630      	mov	r0, r6
 800bfc8:	f7fd fd0c 	bl	80099e4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800bfcc:	4a0e      	ldr	r2, [pc, #56]	; (800c008 <xTimerCreateTimerTask+0xac>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800bfce:	9500      	str	r5, [sp, #0]
 800bfd0:	2110      	movs	r1, #16
			pxCurrentTimerList = &xActiveTimerList1;
 800bfd2:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800bfd4:	200a      	movs	r0, #10
			pxOverflowTimerList = &xActiveTimerList2;
 800bfd6:	4a0d      	ldr	r2, [pc, #52]	; (800c00c <xTimerCreateTimerTask+0xb0>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800bfd8:	4b0d      	ldr	r3, [pc, #52]	; (800c010 <xTimerCreateTimerTask+0xb4>)
			pxOverflowTimerList = &xActiveTimerList2;
 800bfda:	6016      	str	r6, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800bfdc:	4a0d      	ldr	r2, [pc, #52]	; (800c014 <xTimerCreateTimerTask+0xb8>)
 800bfde:	f7fd fd8f 	bl	8009b00 <xQueueGenericCreateStatic>
 800bfe2:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 800bfe4:	2800      	cmp	r0, #0
 800bfe6:	d0c0      	beq.n	800bf6a <xTimerCreateTimerTask+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800bfe8:	490b      	ldr	r1, [pc, #44]	; (800c018 <xTimerCreateTimerTask+0xbc>)
 800bfea:	f7fe fdf7 	bl	800abdc <vQueueAddToRegistry>
 800bfee:	e7bc      	b.n	800bf6a <xTimerCreateTimerTask+0xe>
 800bff0:	2001a630 	.word	0x2001a630
 800bff4:	08016f78 	.word	0x08016f78
 800bff8:	0800bcbd 	.word	0x0800bcbd
 800bffc:	2001a634 	.word	0x2001a634
 800c000:	2001a5b4 	.word	0x2001a5b4
 800c004:	2001a5c8 	.word	0x2001a5c8
 800c008:	2001a50c 	.word	0x2001a50c
 800c00c:	2001a510 	.word	0x2001a510
 800c010:	2001a5e0 	.word	0x2001a5e0
 800c014:	2001a514 	.word	0x2001a514
 800c018:	08016f70 	.word	0x08016f70

0800c01c <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800c01c:	4808      	ldr	r0, [pc, #32]	; (800c040 <prvPortStartFirstTask+0x24>)
 800c01e:	6800      	ldr	r0, [r0, #0]
 800c020:	6800      	ldr	r0, [r0, #0]
 800c022:	f380 8808 	msr	MSP, r0
 800c026:	f04f 0000 	mov.w	r0, #0
 800c02a:	f380 8814 	msr	CONTROL, r0
 800c02e:	b662      	cpsie	i
 800c030:	b661      	cpsie	f
 800c032:	f3bf 8f4f 	dsb	sy
 800c036:	f3bf 8f6f 	isb	sy
 800c03a:	df00      	svc	0
 800c03c:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 800c03e:	0000      	.short	0x0000
 800c040:	e000ed08 	.word	0xe000ed08

0800c044 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 800c044:	f8df 000c 	ldr.w	r0, [pc, #12]	; 800c054 <vPortEnableVFP+0x10>
 800c048:	6801      	ldr	r1, [r0, #0]
 800c04a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c04e:	6001      	str	r1, [r0, #0]
 800c050:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 800c052:	0000      	.short	0x0000
 800c054:	e000ed88 	.word	0xe000ed88

0800c058 <prvTaskExitError>:
	configASSERT( uxCriticalNesting == ~0UL );
 800c058:	4b10      	ldr	r3, [pc, #64]	; (800c09c <prvTaskExitError+0x44>)
{
 800c05a:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 800c05c:	2200      	movs	r2, #0
	configASSERT( uxCriticalNesting == ~0UL );
 800c05e:	681b      	ldr	r3, [r3, #0]
volatile uint32_t ulDummy = 0;
 800c060:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 800c062:	3301      	adds	r3, #1
 800c064:	d00a      	beq.n	800c07c <prvTaskExitError+0x24>
 800c066:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c06a:	b672      	cpsid	i
 800c06c:	f383 8811 	msr	BASEPRI, r3
 800c070:	f3bf 8f6f 	isb	sy
 800c074:	f3bf 8f4f 	dsb	sy
 800c078:	b662      	cpsie	i
 800c07a:	e7fe      	b.n	800c07a <prvTaskExitError+0x22>
 800c07c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c080:	b672      	cpsid	i
 800c082:	f383 8811 	msr	BASEPRI, r3
 800c086:	f3bf 8f6f 	isb	sy
 800c08a:	f3bf 8f4f 	dsb	sy
 800c08e:	b662      	cpsie	i
	while( ulDummy == 0 )
 800c090:	9b01      	ldr	r3, [sp, #4]
 800c092:	2b00      	cmp	r3, #0
 800c094:	d0fc      	beq.n	800c090 <prvTaskExitError+0x38>
}
 800c096:	b002      	add	sp, #8
 800c098:	4770      	bx	lr
 800c09a:	bf00      	nop
 800c09c:	20000690 	.word	0x20000690

0800c0a0 <pxPortInitialiseStack>:
{
 800c0a0:	4603      	mov	r3, r0
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800c0a2:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c0a6:	4809      	ldr	r0, [pc, #36]	; (800c0cc <pxPortInitialiseStack+0x2c>)
{
 800c0a8:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c0aa:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c0ae:	f843 0c0c 	str.w	r0, [r3, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c0b2:	f843 2c20 	str.w	r2, [r3, #-32]
}
 800c0b6:	f1a3 0044 	sub.w	r0, r3, #68	; 0x44
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800c0ba:	e943 1402 	strd	r1, r4, [r3, #-8]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800c0be:	f06f 0102 	mvn.w	r1, #2
}
 800c0c2:	f85d 4b04 	ldr.w	r4, [sp], #4
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800c0c6:	f843 1c24 	str.w	r1, [r3, #-36]
}
 800c0ca:	4770      	bx	lr
 800c0cc:	0800c059 	.word	0x0800c059

0800c0d0 <SVC_Handler>:
	__asm volatile (
 800c0d0:	4b07      	ldr	r3, [pc, #28]	; (800c0f0 <pxCurrentTCBConst2>)
 800c0d2:	6819      	ldr	r1, [r3, #0]
 800c0d4:	6808      	ldr	r0, [r1, #0]
 800c0d6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c0da:	f380 8809 	msr	PSP, r0
 800c0de:	f3bf 8f6f 	isb	sy
 800c0e2:	f04f 0000 	mov.w	r0, #0
 800c0e6:	f380 8811 	msr	BASEPRI, r0
 800c0ea:	4770      	bx	lr
 800c0ec:	f3af 8000 	nop.w

0800c0f0 <pxCurrentTCBConst2>:
 800c0f0:	2001a010 	.word	0x2001a010

0800c0f4 <vPortEnterCritical>:
 800c0f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0f8:	b672      	cpsid	i
 800c0fa:	f383 8811 	msr	BASEPRI, r3
 800c0fe:	f3bf 8f6f 	isb	sy
 800c102:	f3bf 8f4f 	dsb	sy
 800c106:	b662      	cpsie	i
	uxCriticalNesting++;
 800c108:	4a0c      	ldr	r2, [pc, #48]	; (800c13c <vPortEnterCritical+0x48>)
 800c10a:	6813      	ldr	r3, [r2, #0]
 800c10c:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800c10e:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800c110:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800c112:	d000      	beq.n	800c116 <vPortEnterCritical+0x22>
}
 800c114:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800c116:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800c11a:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
 800c11e:	b2db      	uxtb	r3, r3
 800c120:	2b00      	cmp	r3, #0
 800c122:	d0f7      	beq.n	800c114 <vPortEnterCritical+0x20>
 800c124:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c128:	b672      	cpsid	i
 800c12a:	f383 8811 	msr	BASEPRI, r3
 800c12e:	f3bf 8f6f 	isb	sy
 800c132:	f3bf 8f4f 	dsb	sy
 800c136:	b662      	cpsie	i
 800c138:	e7fe      	b.n	800c138 <vPortEnterCritical+0x44>
 800c13a:	bf00      	nop
 800c13c:	20000690 	.word	0x20000690

0800c140 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 800c140:	4a09      	ldr	r2, [pc, #36]	; (800c168 <vPortExitCritical+0x28>)
 800c142:	6813      	ldr	r3, [r2, #0]
 800c144:	b953      	cbnz	r3, 800c15c <vPortExitCritical+0x1c>
 800c146:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c14a:	b672      	cpsid	i
 800c14c:	f383 8811 	msr	BASEPRI, r3
 800c150:	f3bf 8f6f 	isb	sy
 800c154:	f3bf 8f4f 	dsb	sy
 800c158:	b662      	cpsie	i
 800c15a:	e7fe      	b.n	800c15a <vPortExitCritical+0x1a>
	uxCriticalNesting--;
 800c15c:	3b01      	subs	r3, #1
 800c15e:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800c160:	b90b      	cbnz	r3, 800c166 <vPortExitCritical+0x26>
	__asm volatile
 800c162:	f383 8811 	msr	BASEPRI, r3
}
 800c166:	4770      	bx	lr
 800c168:	20000690 	.word	0x20000690
 800c16c:	00000000 	.word	0x00000000

0800c170 <PendSV_Handler>:
	__asm volatile
 800c170:	f3ef 8009 	mrs	r0, PSP
 800c174:	f3bf 8f6f 	isb	sy
 800c178:	4b15      	ldr	r3, [pc, #84]	; (800c1d0 <pxCurrentTCBConst>)
 800c17a:	681a      	ldr	r2, [r3, #0]
 800c17c:	f01e 0f10 	tst.w	lr, #16
 800c180:	bf08      	it	eq
 800c182:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 800c186:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c18a:	6010      	str	r0, [r2, #0]
 800c18c:	e92d 0009 	stmdb	sp!, {r0, r3}
 800c190:	f04f 0050 	mov.w	r0, #80	; 0x50
 800c194:	b672      	cpsid	i
 800c196:	f380 8811 	msr	BASEPRI, r0
 800c19a:	f3bf 8f4f 	dsb	sy
 800c19e:	f3bf 8f6f 	isb	sy
 800c1a2:	b662      	cpsie	i
 800c1a4:	f7ff fa96 	bl	800b6d4 <vTaskSwitchContext>
 800c1a8:	f04f 0000 	mov.w	r0, #0
 800c1ac:	f380 8811 	msr	BASEPRI, r0
 800c1b0:	bc09      	pop	{r0, r3}
 800c1b2:	6819      	ldr	r1, [r3, #0]
 800c1b4:	6808      	ldr	r0, [r1, #0]
 800c1b6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c1ba:	f01e 0f10 	tst.w	lr, #16
 800c1be:	bf08      	it	eq
 800c1c0:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 800c1c4:	f380 8809 	msr	PSP, r0
 800c1c8:	f3bf 8f6f 	isb	sy
 800c1cc:	4770      	bx	lr
 800c1ce:	bf00      	nop

0800c1d0 <pxCurrentTCBConst>:
 800c1d0:	2001a010 	.word	0x2001a010

0800c1d4 <xPortSysTickHandler>:
{
 800c1d4:	b508      	push	{r3, lr}
	__asm volatile
 800c1d6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c1da:	b672      	cpsid	i
 800c1dc:	f383 8811 	msr	BASEPRI, r3
 800c1e0:	f3bf 8f6f 	isb	sy
 800c1e4:	f3bf 8f4f 	dsb	sy
 800c1e8:	b662      	cpsie	i
		if( xTaskIncrementTick() != pdFALSE )
 800c1ea:	f7ff f887 	bl	800b2fc <xTaskIncrementTick>
 800c1ee:	b128      	cbz	r0, 800c1fc <xPortSysTickHandler+0x28>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800c1f0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800c1f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c1f8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
 800c1fc:	2300      	movs	r3, #0
 800c1fe:	f383 8811 	msr	BASEPRI, r3
}
 800c202:	bd08      	pop	{r3, pc}

0800c204 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800c204:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 800c208:	2100      	movs	r1, #0
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c20a:	4b06      	ldr	r3, [pc, #24]	; (800c224 <vPortSetupTimerInterrupt+0x20>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800c20c:	6111      	str	r1, [r2, #16]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c20e:	4806      	ldr	r0, [pc, #24]	; (800c228 <vPortSetupTimerInterrupt+0x24>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800c210:	6191      	str	r1, [r2, #24]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800c212:	2107      	movs	r1, #7
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c214:	681b      	ldr	r3, [r3, #0]
 800c216:	fba0 0303 	umull	r0, r3, r0, r3
 800c21a:	099b      	lsrs	r3, r3, #6
 800c21c:	3b01      	subs	r3, #1
 800c21e:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800c220:	6111      	str	r1, [r2, #16]
}
 800c222:	4770      	bx	lr
 800c224:	20000680 	.word	0x20000680
 800c228:	10624dd3 	.word	0x10624dd3

0800c22c <xPortStartScheduler>:
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800c22c:	4b3d      	ldr	r3, [pc, #244]	; (800c324 <xPortStartScheduler+0xf8>)
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800c22e:	f04f 0cff 	mov.w	ip, #255	; 0xff
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800c232:	483d      	ldr	r0, [pc, #244]	; (800c328 <xPortStartScheduler+0xfc>)
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800c234:	493d      	ldr	r1, [pc, #244]	; (800c32c <xPortStartScheduler+0x100>)
{
 800c236:	b570      	push	{r4, r5, r6, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800c238:	781a      	ldrb	r2, [r3, #0]
{
 800c23a:	b084      	sub	sp, #16
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800c23c:	b2d2      	uxtb	r2, r2
 800c23e:	9202      	str	r2, [sp, #8]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800c240:	2207      	movs	r2, #7
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800c242:	f883 c000 	strb.w	ip, [r3]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800c246:	781b      	ldrb	r3, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800c248:	6002      	str	r2, [r0, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800c24a:	b2db      	uxtb	r3, r3
 800c24c:	f88d 3007 	strb.w	r3, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800c250:	f89d 3007 	ldrb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800c254:	f89d 2007 	ldrb.w	r2, [sp, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800c258:	f003 0350 	and.w	r3, r3, #80	; 0x50
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800c25c:	0612      	lsls	r2, r2, #24
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800c25e:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800c260:	d50f      	bpl.n	800c282 <xPortStartScheduler+0x56>
 800c262:	2206      	movs	r2, #6
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800c264:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c268:	4611      	mov	r1, r2
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800c26a:	3a01      	subs	r2, #1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800c26c:	005b      	lsls	r3, r3, #1
 800c26e:	b2db      	uxtb	r3, r3
 800c270:	f88d 3007 	strb.w	r3, [sp, #7]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800c274:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c278:	061b      	lsls	r3, r3, #24
 800c27a:	d4f3      	bmi.n	800c264 <xPortStartScheduler+0x38>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800c27c:	2903      	cmp	r1, #3
 800c27e:	d00b      	beq.n	800c298 <xPortStartScheduler+0x6c>
 800c280:	6001      	str	r1, [r0, #0]
	__asm volatile
 800c282:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c286:	b672      	cpsid	i
 800c288:	f383 8811 	msr	BASEPRI, r3
 800c28c:	f3bf 8f6f 	isb	sy
 800c290:	f3bf 8f4f 	dsb	sy
 800c294:	b662      	cpsie	i
 800c296:	e7fe      	b.n	800c296 <xPortStartScheduler+0x6a>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800c298:	9b02      	ldr	r3, [sp, #8]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800c29a:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800c29e:	f44f 7140 	mov.w	r1, #768	; 0x300
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800c2a2:	4a20      	ldr	r2, [pc, #128]	; (800c324 <xPortStartScheduler+0xf8>)
 800c2a4:	b2db      	uxtb	r3, r3
	uxCriticalNesting = 0;
 800c2a6:	4e22      	ldr	r6, [pc, #136]	; (800c330 <xPortStartScheduler+0x104>)
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800c2a8:	6001      	str	r1, [r0, #0]
	uxCriticalNesting = 0;
 800c2aa:	2500      	movs	r5, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800c2ac:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800c2ae:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 800c2b2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800c2b6:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800c2ba:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 800c2be:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 800c2c2:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
 800c2c6:	f7ff ff9d 	bl	800c204 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800c2ca:	6035      	str	r5, [r6, #0]
	vPortEnableVFP();
 800c2cc:	f7ff feba 	bl	800c044 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800c2d0:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
 800c2d4:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 800c2d8:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
 800c2dc:	f7ff fe9e 	bl	800c01c <prvPortStartFirstTask>
	vTaskSwitchContext();
 800c2e0:	f7ff f9f8 	bl	800b6d4 <vTaskSwitchContext>
	configASSERT( uxCriticalNesting == ~0UL );
 800c2e4:	6833      	ldr	r3, [r6, #0]
volatile uint32_t ulDummy = 0;
 800c2e6:	9503      	str	r5, [sp, #12]
	configASSERT( uxCriticalNesting == ~0UL );
 800c2e8:	3301      	adds	r3, #1
 800c2ea:	d00a      	beq.n	800c302 <xPortStartScheduler+0xd6>
 800c2ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c2f0:	b672      	cpsid	i
 800c2f2:	f383 8811 	msr	BASEPRI, r3
 800c2f6:	f3bf 8f6f 	isb	sy
 800c2fa:	f3bf 8f4f 	dsb	sy
 800c2fe:	b662      	cpsie	i
 800c300:	e7fe      	b.n	800c300 <xPortStartScheduler+0xd4>
 800c302:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c306:	b672      	cpsid	i
 800c308:	f383 8811 	msr	BASEPRI, r3
 800c30c:	f3bf 8f6f 	isb	sy
 800c310:	f3bf 8f4f 	dsb	sy
 800c314:	b662      	cpsie	i
	while( ulDummy == 0 )
 800c316:	9b03      	ldr	r3, [sp, #12]
 800c318:	2b00      	cmp	r3, #0
 800c31a:	d0fc      	beq.n	800c316 <xPortStartScheduler+0xea>
}
 800c31c:	2000      	movs	r0, #0
 800c31e:	b004      	add	sp, #16
 800c320:	bd70      	pop	{r4, r5, r6, pc}
 800c322:	bf00      	nop
 800c324:	e000e400 	.word	0xe000e400
 800c328:	2001a63c 	.word	0x2001a63c
 800c32c:	2001a638 	.word	0x2001a638
 800c330:	20000690 	.word	0x20000690

0800c334 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800c334:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800c338:	2b0f      	cmp	r3, #15
 800c33a:	d910      	bls.n	800c35e <vPortValidateInterruptPriority+0x2a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800c33c:	4913      	ldr	r1, [pc, #76]	; (800c38c <vPortValidateInterruptPriority+0x58>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800c33e:	4a14      	ldr	r2, [pc, #80]	; (800c390 <vPortValidateInterruptPriority+0x5c>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800c340:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800c342:	7812      	ldrb	r2, [r2, #0]
 800c344:	429a      	cmp	r2, r3
 800c346:	d90a      	bls.n	800c35e <vPortValidateInterruptPriority+0x2a>
 800c348:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c34c:	b672      	cpsid	i
 800c34e:	f383 8811 	msr	BASEPRI, r3
 800c352:	f3bf 8f6f 	isb	sy
 800c356:	f3bf 8f4f 	dsb	sy
 800c35a:	b662      	cpsie	i
 800c35c:	e7fe      	b.n	800c35c <vPortValidateInterruptPriority+0x28>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800c35e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800c362:	4a0c      	ldr	r2, [pc, #48]	; (800c394 <vPortValidateInterruptPriority+0x60>)
 800c364:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 800c368:	6812      	ldr	r2, [r2, #0]
 800c36a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800c36e:	4293      	cmp	r3, r2
 800c370:	d90a      	bls.n	800c388 <vPortValidateInterruptPriority+0x54>
 800c372:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c376:	b672      	cpsid	i
 800c378:	f383 8811 	msr	BASEPRI, r3
 800c37c:	f3bf 8f6f 	isb	sy
 800c380:	f3bf 8f4f 	dsb	sy
 800c384:	b662      	cpsie	i
 800c386:	e7fe      	b.n	800c386 <vPortValidateInterruptPriority+0x52>
	}
 800c388:	4770      	bx	lr
 800c38a:	bf00      	nop
 800c38c:	e000e3f0 	.word	0xe000e3f0
 800c390:	2001a638 	.word	0x2001a638
 800c394:	2001a63c 	.word	0x2001a63c

0800c398 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800c398:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c39c:	4606      	mov	r6, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
 800c39e:	f7fe ff97 	bl	800b2d0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800c3a2:	4b53      	ldr	r3, [pc, #332]	; (800c4f0 <pvPortMalloc+0x158>)
 800c3a4:	681d      	ldr	r5, [r3, #0]
 800c3a6:	2d00      	cmp	r5, #0
 800c3a8:	d06e      	beq.n	800c488 <pvPortMalloc+0xf0>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800c3aa:	4b52      	ldr	r3, [pc, #328]	; (800c4f4 <pvPortMalloc+0x15c>)
 800c3ac:	681f      	ldr	r7, [r3, #0]
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800c3ae:	423e      	tst	r6, r7
 800c3b0:	d130      	bne.n	800c414 <pvPortMalloc+0x7c>
 800c3b2:	b37e      	cbz	r6, 800c414 <pvPortMalloc+0x7c>
			{
				xWantedSize += xHeapStructSize;
 800c3b4:	f106 0408 	add.w	r4, r6, #8

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c3b8:	0776      	lsls	r6, r6, #29
 800c3ba:	d002      	beq.n	800c3c2 <pvPortMalloc+0x2a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800c3bc:	f024 0407 	bic.w	r4, r4, #7
 800c3c0:	3408      	adds	r4, #8
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800c3c2:	b33c      	cbz	r4, 800c414 <pvPortMalloc+0x7c>
 800c3c4:	f8df c13c 	ldr.w	ip, [pc, #316]	; 800c504 <pvPortMalloc+0x16c>
 800c3c8:	f8dc 6000 	ldr.w	r6, [ip]
 800c3cc:	42a6      	cmp	r6, r4
 800c3ce:	d321      	bcc.n	800c414 <pvPortMalloc+0x7c>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
 800c3d0:	4849      	ldr	r0, [pc, #292]	; (800c4f8 <pvPortMalloc+0x160>)
 800c3d2:	6803      	ldr	r3, [r0, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800c3d4:	e003      	b.n	800c3de <pvPortMalloc+0x46>
 800c3d6:	681a      	ldr	r2, [r3, #0]
 800c3d8:	b122      	cbz	r2, 800c3e4 <pvPortMalloc+0x4c>
 800c3da:	4618      	mov	r0, r3
 800c3dc:	4613      	mov	r3, r2
 800c3de:	6859      	ldr	r1, [r3, #4]
 800c3e0:	42a1      	cmp	r1, r4
 800c3e2:	d3f8      	bcc.n	800c3d6 <pvPortMalloc+0x3e>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 800c3e4:	42ab      	cmp	r3, r5
 800c3e6:	d015      	beq.n	800c414 <pvPortMalloc+0x7c>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c3e8:	4698      	mov	r8, r3
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c3ea:	1b0a      	subs	r2, r1, r4
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c3ec:	f858 eb08 	ldr.w	lr, [r8], #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c3f0:	2a10      	cmp	r2, #16
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c3f2:	f8c0 e000 	str.w	lr, [r0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c3f6:	d92b      	bls.n	800c450 <pvPortMalloc+0xb8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800c3f8:	1919      	adds	r1, r3, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800c3fa:	0748      	lsls	r0, r1, #29
 800c3fc:	d011      	beq.n	800c422 <pvPortMalloc+0x8a>
 800c3fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c402:	b672      	cpsid	i
 800c404:	f383 8811 	msr	BASEPRI, r3
 800c408:	f3bf 8f6f 	isb	sy
 800c40c:	f3bf 8f4f 	dsb	sy
 800c410:	b662      	cpsie	i
 800c412:	e7fe      	b.n	800c412 <pvPortMalloc+0x7a>
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800c414:	f04f 0800 	mov.w	r8, #0
 800c418:	f7ff f8b8 	bl	800b58c <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
 800c41c:	4640      	mov	r0, r8
 800c41e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800c422:	604a      	str	r2, [r1, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c424:	4a34      	ldr	r2, [pc, #208]	; (800c4f8 <pvPortMalloc+0x160>)
						pxBlock->xBlockSize = xWantedSize;
 800c426:	605c      	str	r4, [r3, #4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c428:	4614      	mov	r4, r2
 800c42a:	6812      	ldr	r2, [r2, #0]
 800c42c:	4291      	cmp	r1, r2
 800c42e:	d8fb      	bhi.n	800c428 <pvPortMalloc+0x90>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800c430:	6860      	ldr	r0, [r4, #4]
 800c432:	eb04 0e00 	add.w	lr, r4, r0
 800c436:	4571      	cmp	r1, lr
 800c438:	d04b      	beq.n	800c4d2 <pvPortMalloc+0x13a>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800c43a:	f8d1 e004 	ldr.w	lr, [r1, #4]
 800c43e:	eb01 000e 	add.w	r0, r1, lr
 800c442:	4282      	cmp	r2, r0
 800c444:	d04c      	beq.n	800c4e0 <pvPortMalloc+0x148>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c446:	600a      	str	r2, [r1, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800c448:	428c      	cmp	r4, r1
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c44a:	bf18      	it	ne
 800c44c:	6021      	strne	r1, [r4, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c44e:	6859      	ldr	r1, [r3, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c450:	4a2a      	ldr	r2, [pc, #168]	; (800c4fc <pvPortMalloc+0x164>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c452:	1a76      	subs	r6, r6, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c454:	4339      	orrs	r1, r7
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c456:	6810      	ldr	r0, [r2, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c458:	f8cc 6000 	str.w	r6, [ip]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c45c:	4286      	cmp	r6, r0
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800c45e:	bf38      	it	cc
 800c460:	6016      	strcc	r6, [r2, #0]
					pxBlock->pxNextFreeBlock = NULL;
 800c462:	2200      	movs	r2, #0
 800c464:	e9c3 2100 	strd	r2, r1, [r3]
	( void ) xTaskResumeAll();
 800c468:	f7ff f890 	bl	800b58c <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800c46c:	f018 0f07 	tst.w	r8, #7
 800c470:	d0d4      	beq.n	800c41c <pvPortMalloc+0x84>
 800c472:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c476:	b672      	cpsid	i
 800c478:	f383 8811 	msr	BASEPRI, r3
 800c47c:	f3bf 8f6f 	isb	sy
 800c480:	f3bf 8f4f 	dsb	sy
 800c484:	b662      	cpsie	i
 800c486:	e7fe      	b.n	800c486 <pvPortMalloc+0xee>
	uxAddress = ( size_t ) ucHeap;
 800c488:	491d      	ldr	r1, [pc, #116]	; (800c500 <pvPortMalloc+0x168>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c48a:	074f      	lsls	r7, r1, #29
 800c48c:	d11a      	bne.n	800c4c4 <pvPortMalloc+0x12c>
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800c48e:	460a      	mov	r2, r1
 800c490:	f501 3152 	add.w	r1, r1, #215040	; 0x34800
 800c494:	4610      	mov	r0, r2
	uxAddress -= xHeapStructSize;
 800c496:	f1a1 0508 	sub.w	r5, r1, #8
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c49a:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c49e:	4916      	ldr	r1, [pc, #88]	; (800c4f8 <pvPortMalloc+0x160>)
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c4a0:	f025 0507 	bic.w	r5, r5, #7
	pxEnd = ( void * ) uxAddress;
 800c4a4:	601d      	str	r5, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c4a6:	1aab      	subs	r3, r5, r2
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c4a8:	4a14      	ldr	r2, [pc, #80]	; (800c4fc <pvPortMalloc+0x164>)
 800c4aa:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c4ac:	4a15      	ldr	r2, [pc, #84]	; (800c504 <pvPortMalloc+0x16c>)
 800c4ae:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c4b0:	4a10      	ldr	r2, [pc, #64]	; (800c4f4 <pvPortMalloc+0x15c>)
 800c4b2:	6017      	str	r7, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800c4b4:	2200      	movs	r2, #0
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c4b6:	e9c1 0200 	strd	r0, r2, [r1]
	pxEnd->pxNextFreeBlock = NULL;
 800c4ba:	e9c5 2200 	strd	r2, r2, [r5]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800c4be:	e9c0 5300 	strd	r5, r3, [r0]
}
 800c4c2:	e774      	b.n	800c3ae <pvPortMalloc+0x16>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800c4c4:	1dca      	adds	r2, r1, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c4c6:	f501 3152 	add.w	r1, r1, #215040	; 0x34800
 800c4ca:	f022 0207 	bic.w	r2, r2, #7
	pucAlignedHeap = ( uint8_t * ) uxAddress;
 800c4ce:	4610      	mov	r0, r2
 800c4d0:	e7e1      	b.n	800c496 <pvPortMalloc+0xfe>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800c4d2:	6849      	ldr	r1, [r1, #4]
 800c4d4:	eb00 0e01 	add.w	lr, r0, r1
 800c4d8:	4621      	mov	r1, r4
 800c4da:	f8c4 e004 	str.w	lr, [r4, #4]
		pxBlockToInsert = pxIterator;
 800c4de:	e7ae      	b.n	800c43e <pvPortMalloc+0xa6>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c4e0:	42aa      	cmp	r2, r5
 800c4e2:	d0b0      	beq.n	800c446 <pvPortMalloc+0xae>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c4e4:	6850      	ldr	r0, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c4e6:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c4e8:	4470      	add	r0, lr
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c4ea:	600a      	str	r2, [r1, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c4ec:	6048      	str	r0, [r1, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c4ee:	e7ab      	b.n	800c448 <pvPortMalloc+0xb0>
 800c4f0:	2001a640 	.word	0x2001a640
 800c4f4:	2004ee44 	.word	0x2004ee44
 800c4f8:	2004ee50 	.word	0x2004ee50
 800c4fc:	2004ee4c 	.word	0x2004ee4c
 800c500:	2001a644 	.word	0x2001a644
 800c504:	2004ee48 	.word	0x2004ee48

0800c508 <vPortFree>:
	if( pv != NULL )
 800c508:	b1f0      	cbz	r0, 800c548 <vPortFree+0x40>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c50a:	4a2b      	ldr	r2, [pc, #172]	; (800c5b8 <vPortFree+0xb0>)
 800c50c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 800c510:	6812      	ldr	r2, [r2, #0]
 800c512:	4213      	tst	r3, r2
 800c514:	d00d      	beq.n	800c532 <vPortFree+0x2a>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800c516:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800c51a:	b1b1      	cbz	r1, 800c54a <vPortFree+0x42>
 800c51c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c520:	b672      	cpsid	i
 800c522:	f383 8811 	msr	BASEPRI, r3
 800c526:	f3bf 8f6f 	isb	sy
 800c52a:	f3bf 8f4f 	dsb	sy
 800c52e:	b662      	cpsie	i
 800c530:	e7fe      	b.n	800c530 <vPortFree+0x28>
 800c532:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c536:	b672      	cpsid	i
 800c538:	f383 8811 	msr	BASEPRI, r3
 800c53c:	f3bf 8f6f 	isb	sy
 800c540:	f3bf 8f4f 	dsb	sy
 800c544:	b662      	cpsie	i
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c546:	e7fe      	b.n	800c546 <vPortFree+0x3e>
 800c548:	4770      	bx	lr
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c54a:	ea23 0302 	bic.w	r3, r3, r2
{
 800c54e:	b530      	push	{r4, r5, lr}
 800c550:	b083      	sub	sp, #12
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c552:	f840 3c04 	str.w	r3, [r0, #-4]
		puc -= xHeapStructSize;
 800c556:	f1a0 0408 	sub.w	r4, r0, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c55a:	4d18      	ldr	r5, [pc, #96]	; (800c5bc <vPortFree+0xb4>)
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c55c:	9001      	str	r0, [sp, #4]
				vTaskSuspendAll();
 800c55e:	f7fe feb7 	bl	800b2d0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c562:	9801      	ldr	r0, [sp, #4]
 800c564:	682a      	ldr	r2, [r5, #0]
 800c566:	f850 1c04 	ldr.w	r1, [r0, #-4]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c56a:	4b15      	ldr	r3, [pc, #84]	; (800c5c0 <vPortFree+0xb8>)
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c56c:	440a      	add	r2, r1
 800c56e:	602a      	str	r2, [r5, #0]
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c570:	461a      	mov	r2, r3
 800c572:	681b      	ldr	r3, [r3, #0]
 800c574:	429c      	cmp	r4, r3
 800c576:	d8fb      	bhi.n	800c570 <vPortFree+0x68>
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800c578:	6850      	ldr	r0, [r2, #4]
 800c57a:	eb02 0c00 	add.w	ip, r2, r0
 800c57e:	4564      	cmp	r4, ip
 800c580:	d015      	beq.n	800c5ae <vPortFree+0xa6>
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800c582:	1860      	adds	r0, r4, r1
 800c584:	4283      	cmp	r3, r0
 800c586:	d008      	beq.n	800c59a <vPortFree+0x92>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c588:	6023      	str	r3, [r4, #0]
	if( pxIterator != pxBlockToInsert )
 800c58a:	42a2      	cmp	r2, r4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c58c:	bf18      	it	ne
 800c58e:	6014      	strne	r4, [r2, #0]
}
 800c590:	b003      	add	sp, #12
 800c592:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
				( void ) xTaskResumeAll();
 800c596:	f7fe bff9 	b.w	800b58c <xTaskResumeAll>
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c59a:	480a      	ldr	r0, [pc, #40]	; (800c5c4 <vPortFree+0xbc>)
 800c59c:	6800      	ldr	r0, [r0, #0]
 800c59e:	4283      	cmp	r3, r0
 800c5a0:	d0f2      	beq.n	800c588 <vPortFree+0x80>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c5a2:	e9d3 3000 	ldrd	r3, r0, [r3]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c5a6:	4401      	add	r1, r0
 800c5a8:	e9c4 3100 	strd	r3, r1, [r4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c5ac:	e7ed      	b.n	800c58a <vPortFree+0x82>
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800c5ae:	4401      	add	r1, r0
 800c5b0:	4614      	mov	r4, r2
 800c5b2:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 800c5b4:	e7e5      	b.n	800c582 <vPortFree+0x7a>
 800c5b6:	bf00      	nop
 800c5b8:	2004ee44 	.word	0x2004ee44
 800c5bc:	2004ee48 	.word	0x2004ee48
 800c5c0:	2004ee50 	.word	0x2004ee50
 800c5c4:	2001a640 	.word	0x2001a640

0800c5c8 <xPortGetFreeHeapSize>:
	return xFreeBytesRemaining;
 800c5c8:	4b01      	ldr	r3, [pc, #4]	; (800c5d0 <xPortGetFreeHeapSize+0x8>)
}
 800c5ca:	6818      	ldr	r0, [r3, #0]
 800c5cc:	4770      	bx	lr
 800c5ce:	bf00      	nop
 800c5d0:	2004ee48 	.word	0x2004ee48

0800c5d4 <xPortGetMinimumEverFreeHeapSize>:
	return xMinimumEverFreeBytesRemaining;
 800c5d4:	4b01      	ldr	r3, [pc, #4]	; (800c5dc <xPortGetMinimumEverFreeHeapSize+0x8>)
}
 800c5d6:	6818      	ldr	r0, [r3, #0]
 800c5d8:	4770      	bx	lr
 800c5da:	bf00      	nop
 800c5dc:	2004ee4c 	.word	0x2004ee4c

0800c5e0 <MP3InitDecoder>:
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 800c5e0:	f001 bcd0 	b.w	800df84 <xmp3_AllocateBuffers>

0800c5e4 <MP3FindSyncWord>:
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 800c5e4:	2901      	cmp	r1, #1
 800c5e6:	dd13      	ble.n	800c610 <MP3FindSyncWord+0x2c>
 800c5e8:	1e82      	subs	r2, r0, #2
 800c5ea:	1e43      	subs	r3, r0, #1
 800c5ec:	f1c0 0c01 	rsb	ip, r0, #1
 800c5f0:	4411      	add	r1, r2
 800c5f2:	e001      	b.n	800c5f8 <MP3FindSyncWord+0x14>
 800c5f4:	428b      	cmp	r3, r1
 800c5f6:	d00b      	beq.n	800c610 <MP3FindSyncWord+0x2c>
 800c5f8:	eb0c 0003 	add.w	r0, ip, r3
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 800c5fc:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 800c600:	2aff      	cmp	r2, #255	; 0xff
 800c602:	d1f7      	bne.n	800c5f4 <MP3FindSyncWord+0x10>
 800c604:	785a      	ldrb	r2, [r3, #1]
 800c606:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 800c60a:	2ae0      	cmp	r2, #224	; 0xe0
 800c60c:	d1f2      	bne.n	800c5f4 <MP3FindSyncWord+0x10>
			return i;
	}

	return -1;
}
 800c60e:	4770      	bx	lr
	return -1;
 800c610:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c614:	4770      	bx	lr
 800c616:	bf00      	nop

0800c618 <MP3GetNextFrameInfo>:
 **************************************************************************************/
int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo)
 800c618:	b348      	cbz	r0, 800c66e <MP3GetNextFrameInfo+0x56>
{
 800c61a:	b570      	push	{r4, r5, r6, lr}
 800c61c:	460c      	mov	r4, r1
 800c61e:	4611      	mov	r1, r2
 800c620:	4605      	mov	r5, r0
		return ERR_MP3_NULL_POINTER;

	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
 800c622:	f000 fb15 	bl	800cc50 <xmp3_UnpackFrameHeader>
 800c626:	3001      	adds	r0, #1
 800c628:	d01e      	beq.n	800c668 <MP3GetNextFrameInfo+0x50>
 800c62a:	f8d5 27d0 	ldr.w	r2, [r5, #2000]	; 0x7d0
 800c62e:	2a03      	cmp	r2, #3
 800c630:	d11a      	bne.n	800c668 <MP3GetNextFrameInfo+0x50>
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 800c632:	f8d5 37b8 	ldr.w	r3, [r5, #1976]	; 0x7b8
		return ERR_MP3_INVALID_FRAMEHEADER;

	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);

	return ERR_MP3_NONE;
 800c636:	2000      	movs	r0, #0
		mp3FrameInfo->nChans = mp3DecInfo->nChans;
 800c638:	f8d5 67bc 	ldr.w	r6, [r5, #1980]	; 0x7bc
 800c63c:	e9c4 3600 	strd	r3, r6, [r4]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 800c640:	f8d5 37c0 	ldr.w	r3, [r5, #1984]	; 0x7c0
 800c644:	60a3      	str	r3, [r4, #8]
		mp3FrameInfo->bitsPerSample = 16;
 800c646:	2310      	movs	r3, #16
 800c648:	60e3      	str	r3, [r4, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800c64a:	f895 17d4 	ldrb.w	r1, [r5, #2004]	; 0x7d4
		mp3FrameInfo->layer = mp3DecInfo->layer;
 800c64e:	6162      	str	r2, [r4, #20]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800c650:	eb01 0341 	add.w	r3, r1, r1, lsl #1
 800c654:	4a07      	ldr	r2, [pc, #28]	; (800c674 <MP3GetNextFrameInfo+0x5c>)
		mp3FrameInfo->version = mp3DecInfo->version;
 800c656:	61a1      	str	r1, [r4, #24]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 800c658:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 800c65c:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
 800c660:	fb06 f303 	mul.w	r3, r6, r3
 800c664:	6123      	str	r3, [r4, #16]
}
 800c666:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_MP3_INVALID_FRAMEHEADER;
 800c668:	f06f 0005 	mvn.w	r0, #5
}
 800c66c:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_MP3_NULL_POINTER;
 800c66e:	f06f 0004 	mvn.w	r0, #4
}
 800c672:	4770      	bx	lr
 800c674:	080170b4 	.word	0x080170b4

0800c678 <MP3Decode>:

	#ifdef PROFILE
	long time;
	#endif

	if (!mp3DecInfo)
 800c678:	2800      	cmp	r0, #0
 800c67a:	f000 8223 	beq.w	800cac4 <MP3Decode+0x44c>
{
 800c67e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c682:	4689      	mov	r9, r1
		return ERR_MP3_NULL_POINTER;

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 800c684:	6809      	ldr	r1, [r1, #0]
 800c686:	4692      	mov	sl, r2
 800c688:	4680      	mov	r8, r0
{
 800c68a:	ed2d 8b02 	vpush	{d8}
 800c68e:	b087      	sub	sp, #28
 800c690:	ee08 3a10 	vmov	s16, r3
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 800c694:	f000 fadc 	bl	800cc50 <xmp3_UnpackFrameHeader>
	if (fhBytes < 0)
 800c698:	1e07      	subs	r7, r0, #0
 800c69a:	f2c0 81cd 	blt.w	800ca38 <MP3Decode+0x3c0>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
	*inbuf += fhBytes;
 800c69e:	f8d9 1000 	ldr.w	r1, [r9]

#ifdef PROFILE
	time = systime_get();
#endif
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 800c6a2:	4640      	mov	r0, r8
	*inbuf += fhBytes;
 800c6a4:	4439      	add	r1, r7
 800c6a6:	f8c9 1000 	str.w	r1, [r9]
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 800c6aa:	f000 fbbf 	bl	800ce2c <xmp3_UnpackSideInfo>
	if (siBytes < 0) {
 800c6ae:	2800      	cmp	r0, #0
 800c6b0:	f2c0 8220 	blt.w	800caf4 <MP3Decode+0x47c>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
		return ERR_MP3_INVALID_SIDEINFO;
	}
	*inbuf += siBytes;
	*bytesLeft -= (fhBytes + siBytes);
 800c6b4:	f8da 3000 	ldr.w	r3, [sl]
 800c6b8:	1839      	adds	r1, r7, r0
	*inbuf += siBytes;
 800c6ba:	f8d9 2000 	ldr.w	r2, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 800c6be:	1a59      	subs	r1, r3, r1
	*inbuf += siBytes;
 800c6c0:	eb02 0e00 	add.w	lr, r2, r0
 800c6c4:	f8c9 e000 	str.w	lr, [r9]
	*bytesLeft -= (fhBytes + siBytes);
 800c6c8:	f8ca 1000 	str.w	r1, [sl]
	printf("UnpackSideInfo: %i ms\n", time);
#endif


	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 800c6cc:	f8d8 37b8 	ldr.w	r3, [r8, #1976]	; 0x7b8
 800c6d0:	2b00      	cmp	r3, #0
 800c6d2:	f000 8095 	beq.w	800c800 <MP3Decode+0x188>
 800c6d6:	f8d8 37b0 	ldr.w	r3, [r8, #1968]	; 0x7b0
 800c6da:	b14b      	cbz	r3, 800c6f0 <MP3Decode+0x78>
				return ERR_MP3_FREE_BITRATE_SYNC;
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 800c6dc:	f8d8 47b4 	ldr.w	r4, [r8, #1972]	; 0x7b4
 800c6e0:	4640      	mov	r0, r8
 800c6e2:	f000 faa9 	bl	800cc38 <xmp3_CheckPadBit>
 800c6e6:	4404      	add	r4, r0
 800c6e8:	f8c8 47cc 	str.w	r4, [r8, #1996]	; 0x7cc
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
		mp3DecInfo->nSlots = *bytesLeft;
 800c6ec:	f8da 1000 	ldr.w	r1, [sl]
	if (useSize) {
 800c6f0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800c6f2:	2b00      	cmp	r3, #0
 800c6f4:	f000 80f3 	beq.w	800c8de <MP3Decode+0x266>
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800c6f8:	f8d8 37d8 	ldr.w	r3, [r8, #2008]	; 0x7d8
		mp3DecInfo->nSlots = *bytesLeft;
 800c6fc:	f8c8 17cc 	str.w	r1, [r8, #1996]	; 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 800c700:	2b00      	cmp	r3, #0
 800c702:	f040 8187 	bne.w	800ca14 <MP3Decode+0x39c>
 800c706:	2900      	cmp	r1, #0
 800c708:	f340 8184 	ble.w	800ca14 <MP3Decode+0x39c>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_FRAMEHEADER;
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 800c70c:	f8c8 17dc 	str.w	r1, [r8, #2012]	; 0x7dc
		mainPtr = *inbuf;
 800c710:	f8d9 7000 	ldr.w	r7, [r9]
		*inbuf += mp3DecInfo->nSlots;
		*bytesLeft -= (mp3DecInfo->nSlots);
 800c714:	f8da 3000 	ldr.w	r3, [sl]
 800c718:	1a5b      	subs	r3, r3, r1
		*inbuf += mp3DecInfo->nSlots;
 800c71a:	4439      	add	r1, r7
 800c71c:	f8c9 1000 	str.w	r1, [r9]
		*bytesLeft -= (mp3DecInfo->nSlots);
 800c720:	f8ca 3000 	str.w	r3, [sl]
	time = systime_get() - time;
	printf("data buffer filling: %i ms\n", time);
#endif

	}
	bitOffset = 0;
 800c724:	2000      	movs	r0, #0
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800c726:	f8d8 37c4 	ldr.w	r3, [r8, #1988]	; 0x7c4
	mainBits = mp3DecInfo->mainDataBytes * 8;
 800c72a:	f8d8 57dc 	ldr.w	r5, [r8, #2012]	; 0x7dc
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800c72e:	4283      	cmp	r3, r0
	bitOffset = 0;
 800c730:	9005      	str	r0, [sp, #20]
	mainBits = mp3DecInfo->mainDataBytes * 8;
 800c732:	ea4f 05c5 	mov.w	r5, r5, lsl #3
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800c736:	dd5e      	ble.n	800c7f6 <MP3Decode+0x17e>
 800c738:	f508 63fc 	add.w	r3, r8, #2016	; 0x7e0
 800c73c:	4682      	mov	sl, r0
 800c73e:	46b9      	mov	r9, r7
 800c740:	9303      	str	r3, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c742:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c746:	2b00      	cmp	r3, #0
 800c748:	f340 80fa 	ble.w	800c940 <MP3Decode+0x2c8>
 800c74c:	f04f 0b00 	mov.w	fp, #0

			#ifdef PROFILE
				time = systime_get();
			#endif
			/* unpack scale factors and compute size of scale factor block */
			prevBitOffset = bitOffset;
 800c750:	9b03      	ldr	r3, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c752:	f8cd a008 	str.w	sl, [sp, #8]
 800c756:	46ca      	mov	sl, r9
 800c758:	465f      	mov	r7, fp
			prevBitOffset = bitOffset;
 800c75a:	9c05      	ldr	r4, [sp, #20]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c75c:	469b      	mov	fp, r3
 800c75e:	e008      	b.n	800c772 <MP3Decode+0xfa>
				time = systime_get() - time;
				printf("Huffman: %i ms\n", time);
			#endif

			mainPtr += offset;
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800c760:	9c05      	ldr	r4, [sp, #20]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c762:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800c766:	4426      	add	r6, r4
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c768:	42bb      	cmp	r3, r7
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800c76a:	eba9 0506 	sub.w	r5, r9, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c76e:	f340 80e4 	ble.w	800c93a <MP3Decode+0x2c2>
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 800c772:	9e02      	ldr	r6, [sp, #8]
 800c774:	4651      	mov	r1, sl
 800c776:	462b      	mov	r3, r5
 800c778:	aa05      	add	r2, sp, #20
 800c77a:	9600      	str	r6, [sp, #0]
 800c77c:	4640      	mov	r0, r8
 800c77e:	9701      	str	r7, [sp, #4]
 800c780:	f005 fc86 	bl	8012090 <xmp3_UnpackScaleFactors>
 800c784:	4686      	mov	lr, r0
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800c786:	9e05      	ldr	r6, [sp, #20]
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800c788:	aa05      	add	r2, sp, #20
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800c78a:	ebc4 09ce 	rsb	r9, r4, lr, lsl #3
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 800c78e:	f85b cb04 	ldr.w	ip, [fp], #4
			mainPtr += offset;
 800c792:	44f2      	add	sl, lr
			if (offset < 0 || mainBits < huffBlockBits) {
 800c794:	f1be 0f00 	cmp.w	lr, #0
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 800c798:	44b1      	add	r9, r6
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800c79a:	4640      	mov	r0, r8
 800c79c:	4651      	mov	r1, sl
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 800c79e:	ebac 0309 	sub.w	r3, ip, r9
			mainBits -= sfBlockBits;
 800c7a2:	eba5 0909 	sub.w	r9, r5, r9
			if (offset < 0 || mainBits < huffBlockBits) {
 800c7a6:	f2c0 80fd 	blt.w	800c9a4 <MP3Decode+0x32c>
 800c7aa:	45ac      	cmp	ip, r5
 800c7ac:	bfd4      	ite	le
 800c7ae:	2500      	movle	r5, #0
 800c7b0:	2501      	movgt	r5, #1
 800c7b2:	2d00      	cmp	r5, #0
 800c7b4:	f040 80f6 	bne.w	800c9a4 <MP3Decode+0x32c>
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800c7b8:	9c02      	ldr	r4, [sp, #8]
 800c7ba:	9701      	str	r7, [sp, #4]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800c7bc:	3701      	adds	r7, #1
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 800c7be:	9400      	str	r4, [sp, #0]
 800c7c0:	f002 fd4c 	bl	800f25c <xmp3_DecodeHuffman>
			if (offset < 0) {
 800c7c4:	2800      	cmp	r0, #0
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 800c7c6:	ebc6 06c0 	rsb	r6, r6, r0, lsl #3
			mainPtr += offset;
 800c7ca:	4482      	add	sl, r0
			if (offset < 0) {
 800c7cc:	dac8      	bge.n	800c760 <MP3Decode+0xe8>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800c7ce:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800c7d2:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800c7d6:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c7da:	fb01 f202 	mul.w	r2, r1, r2
 800c7de:	fb03 f202 	mul.w	r2, r3, r2
 800c7e2:	2a00      	cmp	r2, #0
 800c7e4:	dd05      	ble.n	800c7f2 <MP3Decode+0x17a>
		outbuf[i] = 0;
 800c7e6:	0052      	lsls	r2, r2, #1
 800c7e8:	4629      	mov	r1, r5
 800c7ea:	ee18 0a10 	vmov	r0, s16
 800c7ee:	f006 fcc3 	bl	8013178 <memset>
				return ERR_MP3_INVALID_HUFFCODES;
 800c7f2:	f06f 0008 	mvn.w	r0, #8
			printf("Subband: %i ms\n", time);
		#endif

	}
	return ERR_MP3_NONE;
}
 800c7f6:	b007      	add	sp, #28
 800c7f8:	ecbd 8b02 	vpop	{d8}
 800c7fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!mp3DecInfo->freeBitrateFlag) {
 800c800:	f8d8 37b0 	ldr.w	r3, [r8, #1968]	; 0x7b0
 800c804:	2b00      	cmp	r3, #0
 800c806:	f47f af69 	bne.w	800c6dc <MP3Decode+0x64>
			mp3DecInfo->freeBitrateFlag = 1;
 800c80a:	2301      	movs	r3, #1
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800c80c:	eba2 0c07 	sub.w	ip, r2, r7
			mp3DecInfo->freeBitrateFlag = 1;
 800c810:	f8c8 37b0 	str.w	r3, [r8, #1968]	; 0x7b0
	unsigned char *bufPtr = buf;
 800c814:	4673      	mov	r3, lr
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800c816:	f8da 1000 	ldr.w	r1, [sl]
	for (i = 0; i < nBytes - 1; i++) {
 800c81a:	1e4e      	subs	r6, r1, #1
 800c81c:	2e00      	cmp	r6, #0
 800c81e:	dd18      	ble.n	800c852 <MP3Decode+0x1da>
 800c820:	2500      	movs	r5, #0
 800c822:	e002      	b.n	800c82a <MP3Decode+0x1b2>
 800c824:	3501      	adds	r5, #1
 800c826:	42b5      	cmp	r5, r6
 800c828:	d013      	beq.n	800c852 <MP3Decode+0x1da>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 800c82a:	461c      	mov	r4, r3
 800c82c:	f813 2b01 	ldrb.w	r2, [r3], #1
 800c830:	2aff      	cmp	r2, #255	; 0xff
 800c832:	d1f7      	bne.n	800c824 <MP3Decode+0x1ac>
 800c834:	7862      	ldrb	r2, [r4, #1]
 800c836:	f002 02e0 	and.w	r2, r2, #224	; 0xe0
 800c83a:	2ae0      	cmp	r2, #224	; 0xe0
 800c83c:	d1f2      	bne.n	800c824 <MP3Decode+0x1ac>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800c83e:	f89c 3000 	ldrb.w	r3, [ip]
 800c842:	2bff      	cmp	r3, #255	; 0xff
 800c844:	d023      	beq.n	800c88e <MP3Decode+0x216>
		nBytes -= (offset + 3);
 800c846:	3503      	adds	r5, #3
		bufPtr += 3;
 800c848:	1ce3      	adds	r3, r4, #3
		nBytes -= (offset + 3);
 800c84a:	1b49      	subs	r1, r1, r5
	for (i = 0; i < nBytes - 1; i++) {
 800c84c:	1e4e      	subs	r6, r1, #1
 800c84e:	2e00      	cmp	r6, #0
 800c850:	dce6      	bgt.n	800c820 <MP3Decode+0x1a8>
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800c852:	f04f 33ff 	mov.w	r3, #4294967295
 800c856:	f8c8 37b4 	str.w	r3, [r8, #1972]	; 0x7b4
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800c85a:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800c85e:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800c862:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c866:	fb01 f202 	mul.w	r2, r1, r2
 800c86a:	fb03 f202 	mul.w	r2, r3, r2
 800c86e:	2a00      	cmp	r2, #0
 800c870:	f340 80cd 	ble.w	800ca0e <MP3Decode+0x396>
		outbuf[i] = 0;
 800c874:	0052      	lsls	r2, r2, #1
 800c876:	2100      	movs	r1, #0
 800c878:	ee18 0a10 	vmov	r0, s16
 800c87c:	f006 fc7c 	bl	8013178 <memset>
				return ERR_MP3_FREE_BITRATE_SYNC;
 800c880:	f06f 0002 	mvn.w	r0, #2
}
 800c884:	b007      	add	sp, #28
 800c886:	ecbd 8b02 	vpop	{d8}
 800c88a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 800c88e:	7862      	ldrb	r2, [r4, #1]
 800c890:	f89c 3001 	ldrb.w	r3, [ip, #1]
 800c894:	429a      	cmp	r2, r3
 800c896:	d1d6      	bne.n	800c846 <MP3Decode+0x1ce>
 800c898:	f89c 2002 	ldrb.w	r2, [ip, #2]
 800c89c:	78a3      	ldrb	r3, [r4, #2]
 800c89e:	4053      	eors	r3, r2
 800c8a0:	f013 0ffc 	tst.w	r3, #252	; 0xfc
 800c8a4:	d1cf      	bne.n	800c846 <MP3Decode+0x1ce>
			if ((firstFH[2] >> 1) & 0x01)
 800c8a6:	0793      	lsls	r3, r2, #30
				bufPtr--;
 800c8a8:	bf48      	it	mi
 800c8aa:	f104 34ff 	addmi.w	r4, r4, #4294967295
			return bufPtr - buf;
 800c8ae:	eba4 040e 	sub.w	r4, r4, lr
			if (mp3DecInfo->freeBitrateSlots < 0) {
 800c8b2:	2c00      	cmp	r4, #0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 800c8b4:	f8c8 47b4 	str.w	r4, [r8, #1972]	; 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 800c8b8:	dbcf      	blt.n	800c85a <MP3Decode+0x1e2>
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 800c8ba:	193b      	adds	r3, r7, r4
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 800c8bc:	f8d8 27c0 	ldr.w	r2, [r8, #1984]	; 0x7c0
 800c8c0:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 800c8c4:	4403      	add	r3, r0
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 800c8c6:	fb02 f303 	mul.w	r3, r2, r3
 800c8ca:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800c8ce:	00db      	lsls	r3, r3, #3
 800c8d0:	fb01 f202 	mul.w	r2, r1, r2
 800c8d4:	fb93 f3f2 	sdiv	r3, r3, r2
 800c8d8:	f8c8 37b8 	str.w	r3, [r8, #1976]	; 0x7b8
 800c8dc:	e700      	b.n	800c6e0 <MP3Decode+0x68>
		if (mp3DecInfo->nSlots > *bytesLeft) {
 800c8de:	f8d8 07cc 	ldr.w	r0, [r8, #1996]	; 0x7cc
 800c8e2:	4288      	cmp	r0, r1
 800c8e4:	f300 80f1 	bgt.w	800caca <MP3Decode+0x452>
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 800c8e8:	f8d8 37dc 	ldr.w	r3, [r8, #2012]	; 0x7dc
 800c8ec:	f8d8 27d8 	ldr.w	r2, [r8, #2008]	; 0x7d8
 800c8f0:	4293      	cmp	r3, r2
 800c8f2:	f2c0 80a4 	blt.w	800ca3e <MP3Decode+0x3c6>
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 800c8f6:	1a9b      	subs	r3, r3, r2
 800c8f8:	f108 071c 	add.w	r7, r8, #28
 800c8fc:	18f9      	adds	r1, r7, r3
 800c8fe:	4638      	mov	r0, r7
 800c900:	f006 fc20 	bl	8013144 <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 800c904:	f8d8 07d8 	ldr.w	r0, [r8, #2008]	; 0x7d8
 800c908:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800c90c:	4438      	add	r0, r7
 800c90e:	f8d9 1000 	ldr.w	r1, [r9]
 800c912:	f006 fc09 	bl	8013128 <memcpy>
			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 800c916:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800c91a:	f8d8 37d8 	ldr.w	r3, [r8, #2008]	; 0x7d8
 800c91e:	4413      	add	r3, r2
 800c920:	f8c8 37dc 	str.w	r3, [r8, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 800c924:	f8d9 3000 	ldr.w	r3, [r9]
 800c928:	4413      	add	r3, r2
 800c92a:	f8c9 3000 	str.w	r3, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 800c92e:	f8da 3000 	ldr.w	r3, [sl]
 800c932:	1a9b      	subs	r3, r3, r2
 800c934:	f8ca 3000 	str.w	r3, [sl]
			mainPtr = mp3DecInfo->mainBuf;
 800c938:	e6f4      	b.n	800c724 <MP3Decode+0xac>
 800c93a:	46d1      	mov	r9, sl
 800c93c:	f8dd a008 	ldr.w	sl, [sp, #8]
		if (Dequantize(mp3DecInfo, gr) < 0) {
 800c940:	4651      	mov	r1, sl
 800c942:	4640      	mov	r0, r8
 800c944:	f002 f880 	bl	800ea48 <xmp3_Dequantize>
 800c948:	2800      	cmp	r0, #0
 800c94a:	f2c0 80a6 	blt.w	800ca9a <MP3Decode+0x422>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800c94e:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c952:	2b00      	cmp	r3, #0
 800c954:	dd3f      	ble.n	800c9d6 <MP3Decode+0x35e>
 800c956:	2400      	movs	r4, #0
 800c958:	e003      	b.n	800c962 <MP3Decode+0x2ea>
 800c95a:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c95e:	42a3      	cmp	r3, r4
 800c960:	dd39      	ble.n	800c9d6 <MP3Decode+0x35e>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 800c962:	4622      	mov	r2, r4
 800c964:	4651      	mov	r1, sl
 800c966:	4640      	mov	r0, r8
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800c968:	3401      	adds	r4, #1
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 800c96a:	f003 fb09 	bl	800ff80 <xmp3_IMDCT>
 800c96e:	2800      	cmp	r0, #0
 800c970:	daf3      	bge.n	800c95a <MP3Decode+0x2e2>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800c972:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800c976:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800c97a:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c97e:	fb01 f202 	mul.w	r2, r1, r2
 800c982:	fb03 f202 	mul.w	r2, r3, r2
 800c986:	2a00      	cmp	r2, #0
 800c988:	dd05      	ble.n	800c996 <MP3Decode+0x31e>
		outbuf[i] = 0;
 800c98a:	0052      	lsls	r2, r2, #1
 800c98c:	2100      	movs	r1, #0
 800c98e:	ee18 0a10 	vmov	r0, s16
 800c992:	f006 fbf1 	bl	8013178 <memset>
				return ERR_MP3_INVALID_IMDCT;
 800c996:	f06f 000a 	mvn.w	r0, #10
}
 800c99a:	b007      	add	sp, #28
 800c99c:	ecbd 8b02 	vpop	{d8}
 800c9a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800c9a4:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800c9a8:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800c9ac:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800c9b0:	fb01 f202 	mul.w	r2, r1, r2
 800c9b4:	fb03 f202 	mul.w	r2, r3, r2
 800c9b8:	2a00      	cmp	r2, #0
 800c9ba:	dd05      	ble.n	800c9c8 <MP3Decode+0x350>
		outbuf[i] = 0;
 800c9bc:	0052      	lsls	r2, r2, #1
 800c9be:	2100      	movs	r1, #0
 800c9c0:	ee18 0a10 	vmov	r0, s16
 800c9c4:	f006 fbd8 	bl	8013178 <memset>
				return ERR_MP3_INVALID_SCALEFACT;
 800c9c8:	f06f 0007 	mvn.w	r0, #7
}
 800c9cc:	b007      	add	sp, #28
 800c9ce:	ecbd 8b02 	vpop	{d8}
 800c9d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 800c9d6:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800c9da:	4640      	mov	r0, r8
 800c9dc:	fb02 f20a 	mul.w	r2, r2, sl
 800c9e0:	fb02 f303 	mul.w	r3, r2, r3
 800c9e4:	ee18 2a10 	vmov	r2, s16
 800c9e8:	eb02 0143 	add.w	r1, r2, r3, lsl #1
 800c9ec:	f006 fae6 	bl	8012fbc <xmp3_Subband>
 800c9f0:	2800      	cmp	r0, #0
 800c9f2:	f2c0 8094 	blt.w	800cb1e <MP3Decode+0x4a6>
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 800c9f6:	9b03      	ldr	r3, [sp, #12]
 800c9f8:	f10a 0a01 	add.w	sl, sl, #1
 800c9fc:	3308      	adds	r3, #8
 800c9fe:	9303      	str	r3, [sp, #12]
 800ca00:	f8d8 37c4 	ldr.w	r3, [r8, #1988]	; 0x7c4
 800ca04:	4553      	cmp	r3, sl
 800ca06:	f73f ae9c 	bgt.w	800c742 <MP3Decode+0xca>
	return ERR_MP3_NONE;
 800ca0a:	2000      	movs	r0, #0
 800ca0c:	e6f3      	b.n	800c7f6 <MP3Decode+0x17e>
				return ERR_MP3_FREE_BITRATE_SYNC;
 800ca0e:	f06f 0002 	mvn.w	r0, #2
 800ca12:	e6f0      	b.n	800c7f6 <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ca14:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800ca18:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800ca1c:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800ca20:	fb01 f202 	mul.w	r2, r1, r2
 800ca24:	fb03 f202 	mul.w	r2, r3, r2
 800ca28:	2a00      	cmp	r2, #0
 800ca2a:	dd05      	ble.n	800ca38 <MP3Decode+0x3c0>
		outbuf[i] = 0;
 800ca2c:	0052      	lsls	r2, r2, #1
 800ca2e:	2100      	movs	r1, #0
 800ca30:	ee18 0a10 	vmov	r0, s16
 800ca34:	f006 fba0 	bl	8013178 <memset>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 800ca38:	f06f 0005 	mvn.w	r0, #5
 800ca3c:	e6db      	b.n	800c7f6 <MP3Decode+0x17e>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 800ca3e:	4602      	mov	r2, r0
 800ca40:	f108 001c 	add.w	r0, r8, #28
 800ca44:	f8d9 1000 	ldr.w	r1, [r9]
 800ca48:	4418      	add	r0, r3
 800ca4a:	f006 fb6d 	bl	8013128 <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 800ca4e:	f8d8 27cc 	ldr.w	r2, [r8, #1996]	; 0x7cc
 800ca52:	f8d8 37dc 	ldr.w	r3, [r8, #2012]	; 0x7dc
 800ca56:	4413      	add	r3, r2
 800ca58:	f8c8 37dc 	str.w	r3, [r8, #2012]	; 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 800ca5c:	f8d9 3000 	ldr.w	r3, [r9]
 800ca60:	4413      	add	r3, r2
 800ca62:	f8c9 3000 	str.w	r3, [r9]
			*bytesLeft -= (mp3DecInfo->nSlots);
 800ca66:	f8da 3000 	ldr.w	r3, [sl]
 800ca6a:	1a9b      	subs	r3, r3, r2
 800ca6c:	f8ca 3000 	str.w	r3, [sl]
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ca70:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800ca74:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800ca78:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800ca7c:	fb01 f202 	mul.w	r2, r1, r2
 800ca80:	fb03 f202 	mul.w	r2, r3, r2
 800ca84:	2a00      	cmp	r2, #0
 800ca86:	dd05      	ble.n	800ca94 <MP3Decode+0x41c>
		outbuf[i] = 0;
 800ca88:	0052      	lsls	r2, r2, #1
 800ca8a:	9912      	ldr	r1, [sp, #72]	; 0x48
 800ca8c:	ee18 0a10 	vmov	r0, s16
 800ca90:	f006 fb72 	bl	8013178 <memset>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 800ca94:	f06f 0001 	mvn.w	r0, #1
 800ca98:	e6ad      	b.n	800c7f6 <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800ca9a:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800ca9e:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800caa2:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800caa6:	fb01 f202 	mul.w	r2, r1, r2
 800caaa:	fb03 f202 	mul.w	r2, r3, r2
 800caae:	2a00      	cmp	r2, #0
 800cab0:	dd05      	ble.n	800cabe <MP3Decode+0x446>
		outbuf[i] = 0;
 800cab2:	0052      	lsls	r2, r2, #1
 800cab4:	2100      	movs	r1, #0
 800cab6:	ee18 0a10 	vmov	r0, s16
 800caba:	f006 fb5d 	bl	8013178 <memset>
			return ERR_MP3_INVALID_DEQUANTIZE;
 800cabe:	f06f 0009 	mvn.w	r0, #9
 800cac2:	e698      	b.n	800c7f6 <MP3Decode+0x17e>
		return ERR_MP3_NULL_POINTER;
 800cac4:	f06f 0004 	mvn.w	r0, #4
}
 800cac8:	4770      	bx	lr
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800caca:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800cace:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cad2:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cad6:	fb01 f202 	mul.w	r2, r1, r2
 800cada:	fb03 f202 	mul.w	r2, r3, r2
 800cade:	2a00      	cmp	r2, #0
 800cae0:	dd05      	ble.n	800caee <MP3Decode+0x476>
		outbuf[i] = 0;
 800cae2:	0052      	lsls	r2, r2, #1
 800cae4:	9912      	ldr	r1, [sp, #72]	; 0x48
 800cae6:	ee18 0a10 	vmov	r0, s16
 800caea:	f006 fb45 	bl	8013178 <memset>
			return ERR_MP3_INDATA_UNDERFLOW;
 800caee:	f04f 30ff 	mov.w	r0, #4294967295
 800caf2:	e680      	b.n	800c7f6 <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800caf4:	f8d8 27c4 	ldr.w	r2, [r8, #1988]	; 0x7c4
 800caf8:	f8d8 17c8 	ldr.w	r1, [r8, #1992]	; 0x7c8
 800cafc:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cb00:	fb01 f202 	mul.w	r2, r1, r2
 800cb04:	fb03 f202 	mul.w	r2, r3, r2
 800cb08:	2a00      	cmp	r2, #0
 800cb0a:	dd05      	ble.n	800cb18 <MP3Decode+0x4a0>
		outbuf[i] = 0;
 800cb0c:	0052      	lsls	r2, r2, #1
 800cb0e:	2100      	movs	r1, #0
 800cb10:	ee18 0a10 	vmov	r0, s16
 800cb14:	f006 fb30 	bl	8013178 <memset>
		return ERR_MP3_INVALID_SIDEINFO;
 800cb18:	f06f 0006 	mvn.w	r0, #6
 800cb1c:	e66b      	b.n	800c7f6 <MP3Decode+0x17e>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 800cb1e:	f8d8 27c8 	ldr.w	r2, [r8, #1992]	; 0x7c8
 800cb22:	f8d8 17c4 	ldr.w	r1, [r8, #1988]	; 0x7c4
 800cb26:	f8d8 37bc 	ldr.w	r3, [r8, #1980]	; 0x7bc
 800cb2a:	fb01 f202 	mul.w	r2, r1, r2
 800cb2e:	fb03 f202 	mul.w	r2, r3, r2
 800cb32:	2a00      	cmp	r2, #0
 800cb34:	dd05      	ble.n	800cb42 <MP3Decode+0x4ca>
		outbuf[i] = 0;
 800cb36:	0052      	lsls	r2, r2, #1
 800cb38:	2100      	movs	r1, #0
 800cb3a:	ee18 0a10 	vmov	r0, s16
 800cb3e:	f006 fb1b 	bl	8013178 <memset>
			return ERR_MP3_INVALID_SUBBAND;
 800cb42:	f06f 000b 	mvn.w	r0, #11
 800cb46:	e656      	b.n	800c7f6 <MP3Decode+0x17e>

0800cb48 <xmp3_SetBitstreamPointer>:
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
	/* init bitstream */
	bsi->bytePtr = buf;
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800cb48:	2300      	movs	r3, #0
 800cb4a:	e9c0 2300 	strd	r2, r3, [r0]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
	bsi->nBytes = nBytes;
 800cb4e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800cb52:	4770      	bx	lr

0800cb54 <xmp3_GetBits>:
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 800cb54:	f001 011f 	and.w	r1, r1, #31
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cb58:	6843      	ldr	r3, [r0, #4]
{
 800cb5a:	b4f0      	push	{r4, r5, r6, r7}
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cb5c:	f1c1 041f 	rsb	r4, r1, #31
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cb60:	fa03 f201 	lsl.w	r2, r3, r1
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 800cb64:	40e3      	lsrs	r3, r4
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cb66:	6884      	ldr	r4, [r0, #8]
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cb68:	6042      	str	r2, [r0, #4]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cb6a:	1a62      	subs	r2, r4, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cb6c:	085b      	lsrs	r3, r3, #1

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 800cb6e:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cb70:	6082      	str	r2, [r0, #8]
	if (bsi->cachedBits < 0) {
 800cb72:	db02      	blt.n	800cb7a <xmp3_GetBits+0x26>
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
		bsi->iCache <<= lowBits;			/* left-justify cache */
	}

	return data;
}
 800cb74:	4618      	mov	r0, r3
 800cb76:	bcf0      	pop	{r4, r5, r6, r7}
 800cb78:	4770      	bx	lr
	int nBytes = bsi->nBytes;
 800cb7a:	68c5      	ldr	r5, [r0, #12]
		lowBits = -bsi->cachedBits;
 800cb7c:	1b09      	subs	r1, r1, r4
	if (nBytes >= 4) {
 800cb7e:	2d03      	cmp	r5, #3
 800cb80:	dc2f      	bgt.n	800cbe2 <xmp3_GetBits+0x8e>
		bsi->iCache = 0;
 800cb82:	2400      	movs	r4, #0
 800cb84:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800cb86:	2d00      	cmp	r5, #0
 800cb88:	d04a      	beq.n	800cc20 <xmp3_GetBits+0xcc>
			bsi->iCache |= (*bsi->bytePtr++);
 800cb8a:	6806      	ldr	r6, [r0, #0]
		while (nBytes--) {
 800cb8c:	2d01      	cmp	r5, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800cb8e:	f106 0401 	add.w	r4, r6, #1
 800cb92:	6004      	str	r4, [r0, #0]
 800cb94:	7834      	ldrb	r4, [r6, #0]
			bsi->iCache <<= 8;
 800cb96:	ea4f 2404 	mov.w	r4, r4, lsl #8
 800cb9a:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800cb9c:	d00e      	beq.n	800cbbc <xmp3_GetBits+0x68>
			bsi->iCache |= (*bsi->bytePtr++);
 800cb9e:	1cb7      	adds	r7, r6, #2
		while (nBytes--) {
 800cba0:	2d02      	cmp	r5, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800cba2:	6007      	str	r7, [r0, #0]
 800cba4:	7877      	ldrb	r7, [r6, #1]
 800cba6:	ea44 0407 	orr.w	r4, r4, r7
			bsi->iCache <<= 8;
 800cbaa:	ea4f 2404 	mov.w	r4, r4, lsl #8
 800cbae:	6044      	str	r4, [r0, #4]
		while (nBytes--) {
 800cbb0:	d004      	beq.n	800cbbc <xmp3_GetBits+0x68>
			bsi->iCache |= (*bsi->bytePtr++);
 800cbb2:	1cf7      	adds	r7, r6, #3
 800cbb4:	6007      	str	r7, [r0, #0]
 800cbb6:	78b6      	ldrb	r6, [r6, #2]
 800cbb8:	4334      	orrs	r4, r6
			bsi->iCache <<= 8;
 800cbba:	0224      	lsls	r4, r4, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800cbbc:	f1c5 0603 	rsb	r6, r5, #3
 800cbc0:	00f6      	lsls	r6, r6, #3
 800cbc2:	40b4      	lsls	r4, r6
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800cbc4:	f102 0620 	add.w	r6, r2, #32
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800cbc8:	fa04 f101 	lsl.w	r1, r4, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800cbcc:	40f4      	lsrs	r4, r6
 800cbce:	4323      	orrs	r3, r4
		bsi->nBytes = 0;
 800cbd0:	2400      	movs	r4, #0
 800cbd2:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800cbd6:	60c4      	str	r4, [r0, #12]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800cbd8:	e9c0 1201 	strd	r1, r2, [r0, #4]
}
 800cbdc:	bcf0      	pop	{r4, r5, r6, r7}
 800cbde:	4618      	mov	r0, r3
 800cbe0:	4770      	bx	lr
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800cbe2:	6806      	ldr	r6, [r0, #0]
 800cbe4:	3220      	adds	r2, #32
		bsi->nBytes -= 4;
 800cbe6:	3d04      	subs	r5, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800cbe8:	4637      	mov	r7, r6
 800cbea:	1c74      	adds	r4, r6, #1
 800cbec:	6004      	str	r4, [r0, #0]
 800cbee:	f817 4b02 	ldrb.w	r4, [r7], #2
 800cbf2:	0624      	lsls	r4, r4, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800cbf4:	6007      	str	r7, [r0, #0]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800cbf6:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800cbf8:	7877      	ldrb	r7, [r6, #1]
 800cbfa:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800cbfe:	1cf7      	adds	r7, r6, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800cc00:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800cc02:	6007      	str	r7, [r0, #0]
 800cc04:	78b7      	ldrb	r7, [r6, #2]
 800cc06:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800cc0a:	1d37      	adds	r7, r6, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800cc0c:	6044      	str	r4, [r0, #4]
		bsi->iCache |= (*bsi->bytePtr++);
 800cc0e:	6007      	str	r7, [r0, #0]
 800cc10:	78f6      	ldrb	r6, [r6, #3]
		bsi->nBytes -= 4;
 800cc12:	60c5      	str	r5, [r0, #12]
		bsi->iCache |= (*bsi->bytePtr++);
 800cc14:	4334      	orrs	r4, r6
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800cc16:	fa04 f101 	lsl.w	r1, r4, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800cc1a:	40d4      	lsrs	r4, r2
 800cc1c:	4323      	orrs	r3, r4
 800cc1e:	e7db      	b.n	800cbd8 <xmp3_GetBits+0x84>
		while (nBytes--) {
 800cc20:	4629      	mov	r1, r5
 800cc22:	e7d5      	b.n	800cbd0 <xmp3_GetBits+0x7c>

0800cc24 <xmp3_CalcBitsUsed>:
 * Outputs:     none
 *
 * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
 800cc24:	b410      	push	{r4}
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 800cc26:	6804      	ldr	r4, [r0, #0]
	bitsUsed -= bsi->cachedBits;
 800cc28:	6883      	ldr	r3, [r0, #8]
	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 800cc2a:	1a61      	subs	r1, r4, r1
	bitsUsed -= startOffset;

	return bitsUsed;
}
 800cc2c:	f85d 4b04 	ldr.w	r4, [sp], #4
	bitsUsed -= bsi->cachedBits;
 800cc30:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
}
 800cc34:	1a98      	subs	r0, r3, r2
 800cc36:	4770      	bx	lr

0800cc38 <xmp3_CheckPadBit>:
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 800cc38:	b130      	cbz	r0, 800cc48 <xmp3_CheckPadBit+0x10>
 800cc3a:	6803      	ldr	r3, [r0, #0]
 800cc3c:	b123      	cbz	r3, 800cc48 <xmp3_CheckPadBit+0x10>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	return (fh->paddingBit ? 1 : 0);
 800cc3e:	6958      	ldr	r0, [r3, #20]
 800cc40:	3800      	subs	r0, #0
 800cc42:	bf18      	it	ne
 800cc44:	2001      	movne	r0, #1
 800cc46:	4770      	bx	lr
		return -1;
 800cc48:	f04f 30ff 	mov.w	r0, #4294967295
}
 800cc4c:	4770      	bx	lr
 800cc4e:	bf00      	nop

0800cc50 <xmp3_UnpackFrameHeader>:

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800cc50:	2800      	cmp	r0, #0
 800cc52:	f000 80db 	beq.w	800ce0c <xmp3_UnpackFrameHeader+0x1bc>
 800cc56:	6803      	ldr	r3, [r0, #0]
 800cc58:	2b00      	cmp	r3, #0
 800cc5a:	f000 80d7 	beq.w	800ce0c <xmp3_UnpackFrameHeader+0x1bc>
 800cc5e:	780a      	ldrb	r2, [r1, #0]
 800cc60:	2aff      	cmp	r2, #255	; 0xff
 800cc62:	f040 80d3 	bne.w	800ce0c <xmp3_UnpackFrameHeader+0x1bc>
{
 800cc66:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 800cc6a:	784c      	ldrb	r4, [r1, #1]
 800cc6c:	f004 02e0 	and.w	r2, r4, #224	; 0xe0
 800cc70:	2ae0      	cmp	r2, #224	; 0xe0
 800cc72:	f040 80c8 	bne.w	800ce06 <xmp3_UnpackFrameHeader+0x1b6>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 800cc76:	f014 0f18 	tst.w	r4, #24
	verIdx =         (buf[1] >> 3) & 0x03;
 800cc7a:	ea4f 02d4 	mov.w	r2, r4, lsr #3
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 800cc7e:	f040 80b7 	bne.w	800cdf0 <xmp3_UnpackFrameHeader+0x1a0>
 800cc82:	2202      	movs	r2, #2
 800cc84:	701a      	strb	r2, [r3, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 800cc86:	f891 c001 	ldrb.w	ip, [r1, #1]
 800cc8a:	f3cc 0c41 	ubfx	ip, ip, #1, #2
 800cc8e:	f1cc 0904 	rsb	r9, ip, #4
 800cc92:	f8c3 9004 	str.w	r9, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 800cc96:	784d      	ldrb	r5, [r1, #1]
 800cc98:	43ed      	mvns	r5, r5
 800cc9a:	f005 0501 	and.w	r5, r5, #1
 800cc9e:	609d      	str	r5, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 800cca0:	788c      	ldrb	r4, [r1, #2]
 800cca2:	0927      	lsrs	r7, r4, #4
 800cca4:	60df      	str	r7, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 800cca6:	788c      	ldrb	r4, [r1, #2]
 800cca8:	f3c4 0481 	ubfx	r4, r4, #2, #2
 800ccac:	611c      	str	r4, [r3, #16]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
	fh->origFlag =   (buf[3] >> 2) & 0x01;
	fh->emphasis =   (buf[3] >> 0) & 0x03;

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 800ccae:	2c03      	cmp	r4, #3
 800ccb0:	bf18      	it	ne
 800ccb2:	2f0f      	cmpne	r7, #15
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 800ccb4:	788e      	ldrb	r6, [r1, #2]
 800ccb6:	f3c6 0640 	ubfx	r6, r6, #1, #1
 800ccba:	615e      	str	r6, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 800ccbc:	f891 e002 	ldrb.w	lr, [r1, #2]
 800ccc0:	f00e 0e01 	and.w	lr, lr, #1
 800ccc4:	f8c3 e018 	str.w	lr, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 800ccc8:	f891 e003 	ldrb.w	lr, [r1, #3]
 800cccc:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800ccd0:	f883 e01c 	strb.w	lr, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 800ccd4:	f891 8003 	ldrb.w	r8, [r1, #3]
 800ccd8:	f3c8 1801 	ubfx	r8, r8, #4, #2
 800ccdc:	f8c3 8020 	str.w	r8, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 800cce0:	f891 8003 	ldrb.w	r8, [r1, #3]
 800cce4:	f3c8 08c0 	ubfx	r8, r8, #3, #1
 800cce8:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 800ccec:	f891 8003 	ldrb.w	r8, [r1, #3]
 800ccf0:	f3c8 0880 	ubfx	r8, r8, #2, #1
 800ccf4:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 800ccf8:	f891 8003 	ldrb.w	r8, [r1, #3]
 800ccfc:	f008 0803 	and.w	r8, r8, #3
 800cd00:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 800cd04:	d07f      	beq.n	800ce06 <xmp3_UnpackFrameHeader+0x1b6>
 800cd06:	f1a9 0a04 	sub.w	sl, r9, #4
 800cd0a:	faba fa8a 	clz	sl, sl
 800cd0e:	ea4f 1a5a 	mov.w	sl, sl, lsr #5
 800cd12:	f1ba 0f00 	cmp.w	sl, #0
 800cd16:	d176      	bne.n	800ce06 <xmp3_UnpackFrameHeader+0x1b6>
		return -1;

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 800cd18:	f04f 08de 	mov.w	r8, #222	; 0xde
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 800cd1c:	f1be 0f01 	cmp.w	lr, #1
	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 800cd20:	fb08 fb02 	mul.w	fp, r8, r2
 800cd24:	f04f 084a 	mov.w	r8, #74	; 0x4a
 800cd28:	fb18 b804 	smlabb	r8, r8, r4, fp
 800cd2c:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 800ce24 <xmp3_UnpackFrameHeader+0x1d4>
 800cd30:	44d8      	add	r8, fp
 800cd32:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 800cd36:	d05f      	beq.n	800cdf8 <xmp3_UnpackFrameHeader+0x1a8>
		fh->modeExt = 0;

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800cd38:	f1be 0f03 	cmp.w	lr, #3
		fh->modeExt = 0;
 800cd3c:	f8c3 a020 	str.w	sl, [r3, #32]
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800cd40:	d15a      	bne.n	800cdf8 <xmp3_UnpackFrameHeader+0x1a8>
 800cd42:	f04f 0801 	mov.w	r8, #1
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800cd46:	f1cc 0c03 	rsb	ip, ip, #3
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800cd4a:	f8c0 87bc 	str.w	r8, [r0, #1980]	; 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800cd4e:	eb02 0842 	add.w	r8, r2, r2, lsl #1
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800cd52:	2a00      	cmp	r2, #0
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800cd54:	ea4f 0a42 	mov.w	sl, r2, lsl #1
	mp3DecInfo->layer = fh->layer;
 800cd58:	f8c0 97d0 	str.w	r9, [r0, #2000]	; 0x7d0
	mp3DecInfo->version = fh->ver;
 800cd5c:	f880 27d4 	strb.w	r2, [r0, #2004]	; 0x7d4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800cd60:	eb08 090c 	add.w	r9, r8, ip
 800cd64:	4a2b      	ldr	r2, [pc, #172]	; (800ce14 <xmp3_UnpackFrameHeader+0x1c4>)
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800cd66:	bf0c      	ite	eq
 800cd68:	f04f 0b02 	moveq.w	fp, #2
 800cd6c:	f04f 0b01 	movne.w	fp, #1
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800cd70:	f932 9019 	ldrsh.w	r9, [r2, r9, lsl #1]
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 800cd74:	f8c0 b7c4 	str.w	fp, [r0, #1988]	; 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800cd78:	fb99 f2fb 	sdiv	r2, r9, fp
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800cd7c:	eb08 0904 	add.w	r9, r8, r4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 800cd80:	f8c0 27c8 	str.w	r2, [r0, #1992]	; 0x7c8
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 800cd84:	4a24      	ldr	r2, [pc, #144]	; (800ce18 <xmp3_UnpackFrameHeader+0x1c8>)
 800cd86:	f852 2029 	ldr.w	r2, [r2, r9, lsl #2]
 800cd8a:	f8c0 27c0 	str.w	r2, [r0, #1984]	; 0x7c0
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 800cd8e:	b33f      	cbz	r7, 800cde0 <xmp3_UnpackFrameHeader+0x190>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cd90:	ebc8 1808 	rsb	r8, r8, r8, lsl #4
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800cd94:	f1be 0f03 	cmp.w	lr, #3
 800cd98:	bf0c      	ite	eq
 800cd9a:	4652      	moveq	r2, sl
 800cd9c:	f10a 0201 	addne.w	r2, sl, #1
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cda0:	ebcc 1c0c 	rsb	ip, ip, ip, lsl #4
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cda4:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cda8:	44c4      	add	ip, r8
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cdaa:	4444      	add	r4, r8
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cdac:	44bc      	add	ip, r7
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cdae:	443c      	add	r4, r7
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cdb0:	4f1a      	ldr	r7, [pc, #104]	; (800ce1c <xmp3_UnpackFrameHeader+0x1cc>)
 800cdb2:	f937 701c 	ldrsh.w	r7, [r7, ip, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cdb6:	f8df c070 	ldr.w	ip, [pc, #112]	; 800ce28 <xmp3_UnpackFrameHeader+0x1d8>
 800cdba:	f93c 4014 	ldrsh.w	r4, [ip, r4, lsl #1]
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 800cdbe:	ebc7 1c47 	rsb	ip, r7, r7, lsl #5
 800cdc2:	eb07 078c 	add.w	r7, r7, ip, lsl #2
 800cdc6:	00ff      	lsls	r7, r7, #3
 800cdc8:	f8c0 77b8 	str.w	r7, [r0, #1976]	; 0x7b8
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800cdcc:	4f14      	ldr	r7, [pc, #80]	; (800ce20 <xmp3_UnpackFrameHeader+0x1d0>)
 800cdce:	f937 2012 	ldrsh.w	r2, [r7, r2, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cdd2:	1aa2      	subs	r2, r4, r2
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 800cdd4:	1f14      	subs	r4, r2, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 800cdd6:	b105      	cbz	r5, 800cdda <xmp3_UnpackFrameHeader+0x18a>
 800cdd8:	1f94      	subs	r4, r2, #6
 800cdda:	4426      	add	r6, r4
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 800cddc:	f8c0 67cc 	str.w	r6, [r0, #1996]	; 0x7cc
	}

	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
 800cde0:	b16d      	cbz	r5, 800cdfe <xmp3_UnpackFrameHeader+0x1ae>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 800cde2:	888a      	ldrh	r2, [r1, #4]
		return 6;
 800cde4:	2006      	movs	r0, #6
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 800cde6:	ba52      	rev16	r2, r2
 800cde8:	b292      	uxth	r2, r2
 800cdea:	631a      	str	r2, [r3, #48]	; 0x30
	} else {
		fh->CRCWord = 0;
		return 4;
	}
}
 800cdec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800cdf0:	43d2      	mvns	r2, r2
 800cdf2:	f002 0201 	and.w	r2, r2, #1
 800cdf6:	e745      	b.n	800cc84 <xmp3_UnpackFrameHeader+0x34>
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 800cdf8:	f04f 0802 	mov.w	r8, #2
 800cdfc:	e7a3      	b.n	800cd46 <xmp3_UnpackFrameHeader+0xf6>
		return 4;
 800cdfe:	2004      	movs	r0, #4
		fh->CRCWord = 0;
 800ce00:	631d      	str	r5, [r3, #48]	; 0x30
}
 800ce02:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -1;
 800ce06:	f04f 30ff 	mov.w	r0, #4294967295
 800ce0a:	e7ef      	b.n	800cdec <xmp3_UnpackFrameHeader+0x19c>
 800ce0c:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ce10:	4770      	bx	lr
 800ce12:	bf00      	nop
 800ce14:	080170b4 	.word	0x080170b4
 800ce18:	08017090 	.word	0x08017090
 800ce1c:	08016f80 	.word	0x08016f80
 800ce20:	08017364 	.word	0x08017364
 800ce24:	080170c8 	.word	0x080170c8
 800ce28:	08017370 	.word	0x08017370

0800ce2c <xmp3_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 800ce2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ce30:	b08b      	sub	sp, #44	; 0x2c
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 800ce32:	2800      	cmp	r0, #0
 800ce34:	f001 806d 	beq.w	800df12 <xmp3_UnpackSideInfo+0x10e6>
 800ce38:	f8d0 b000 	ldr.w	fp, [r0]
 800ce3c:	4606      	mov	r6, r0
 800ce3e:	f1bb 0f00 	cmp.w	fp, #0
 800ce42:	f001 8066 	beq.w	800df12 <xmp3_UnpackSideInfo+0x10e6>
 800ce46:	6844      	ldr	r4, [r0, #4]
 800ce48:	9404      	str	r4, [sp, #16]
 800ce4a:	2c00      	cmp	r4, #0
 800ce4c:	f001 8061 	beq.w	800df12 <xmp3_UnpackSideInfo+0x10e6>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));

	bsi = &bitStreamInfo;
	if (fh->ver == MPEG1) {
 800ce50:	f89b 8000 	ldrb.w	r8, [fp]
 800ce54:	f1b8 0f00 	cmp.w	r8, #0
 800ce58:	f000 80eb 	beq.w	800d032 <xmp3_UnpackSideInfo+0x206>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
			for (bd = 0; bd < MAX_SCFBD; bd++)
				si->scfsi[ch][bd] = GetBits(bsi, 1);
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800ce5c:	f89b 201c 	ldrb.w	r2, [fp, #28]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 800ce60:	2300      	movs	r3, #0
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 8);
 800ce62:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 800ce64:	9106      	str	r1, [sp, #24]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800ce66:	2a03      	cmp	r2, #3
		si->mainDataBegin = GetBits(bsi, 8);
 800ce68:	f04f 0108 	mov.w	r1, #8
 800ce6c:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 800ce6e:	e9cd 3307 	strd	r3, r3, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 800ce72:	bf0c      	ite	eq
 800ce74:	2309      	moveq	r3, #9
 800ce76:	2311      	movne	r3, #17
 800ce78:	9305      	str	r3, [sp, #20]
	bsi->nBytes = nBytes;
 800ce7a:	9309      	str	r3, [sp, #36]	; 0x24
		si->mainDataBegin = GetBits(bsi, 8);
 800ce7c:	f7ff fe6a 	bl	800cb54 <xmp3_GetBits>
 800ce80:	9c04      	ldr	r4, [sp, #16]
 800ce82:	6020      	str	r0, [r4, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 800ce84:	4628      	mov	r0, r5
 800ce86:	f89b 301c 	ldrb.w	r3, [fp, #28]
 800ce8a:	2b03      	cmp	r3, #3
 800ce8c:	bf0c      	ite	eq
 800ce8e:	2101      	moveq	r1, #1
 800ce90:	2102      	movne	r1, #2
 800ce92:	f7ff fe5f 	bl	800cb54 <xmp3_GetBits>
 800ce96:	6060      	str	r0, [r4, #4]
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800ce98:	f8d6 37c4 	ldr.w	r3, [r6, #1988]	; 0x7c4
 800ce9c:	2b00      	cmp	r3, #0
 800ce9e:	f340 80c0 	ble.w	800d022 <xmp3_UnpackSideInfo+0x1f6>
 800cea2:	9a04      	ldr	r2, [sp, #16]
 800cea4:	46b2      	mov	sl, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cea6:	f8d6 37bc 	ldr.w	r3, [r6, #1980]	; 0x7bc
 800ceaa:	9202      	str	r2, [sp, #8]
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800ceac:	2200      	movs	r2, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ceae:	2b00      	cmp	r3, #0
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800ceb0:	9203      	str	r2, [sp, #12]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ceb2:	f340 80b5 	ble.w	800d020 <xmp3_UnpackSideInfo+0x1f4>
 800ceb6:	9c02      	ldr	r4, [sp, #8]
 800ceb8:	2600      	movs	r6, #0
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */

			sis->part23Length =    GetBits(bsi, 12);
 800ceba:	210c      	movs	r1, #12
 800cebc:	4628      	mov	r0, r5
 800cebe:	f7ff fe49 	bl	800cb54 <xmp3_GetBits>
			sis->nBigvals =        GetBits(bsi, 9);
 800cec2:	2109      	movs	r1, #9
			sis->part23Length =    GetBits(bsi, 12);
 800cec4:	62a0      	str	r0, [r4, #40]	; 0x28
			sis->nBigvals =        GetBits(bsi, 9);
 800cec6:	4628      	mov	r0, r5
 800cec8:	f7ff fe44 	bl	800cb54 <xmp3_GetBits>
			sis->globalGain =      GetBits(bsi, 8);
 800cecc:	2108      	movs	r1, #8
			sis->nBigvals =        GetBits(bsi, 9);
 800cece:	62e0      	str	r0, [r4, #44]	; 0x2c
			sis->globalGain =      GetBits(bsi, 8);
 800ced0:	4628      	mov	r0, r5
 800ced2:	f7ff fe3f 	bl	800cb54 <xmp3_GetBits>
 800ced6:	6320      	str	r0, [r4, #48]	; 0x30
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 800ced8:	f89b 3000 	ldrb.w	r3, [fp]
 800cedc:	4628      	mov	r0, r5
 800cede:	2b00      	cmp	r3, #0
 800cee0:	bf0c      	ite	eq
 800cee2:	2104      	moveq	r1, #4
 800cee4:	2109      	movne	r1, #9
 800cee6:	f7ff fe35 	bl	800cb54 <xmp3_GetBits>
 800ceea:	6360      	str	r0, [r4, #52]	; 0x34
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800ceec:	e9dd 0107 	ldrd	r0, r1, [sp, #28]
 800cef0:	f101 3eff 	add.w	lr, r1, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cef4:	0043      	lsls	r3, r0, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cef6:	0fc0      	lsrs	r0, r0, #31
	if (bsi->cachedBits < 0) {
 800cef8:	f1be 0f00 	cmp.w	lr, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cefc:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cefe:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cf02:	f2c0 8155 	blt.w	800d1b0 <xmp3_UnpackSideInfo+0x384>
			sis->winSwitchFlag =   GetBits(bsi, 1);
 800cf06:	63a0      	str	r0, [r4, #56]	; 0x38

			if(sis->winSwitchFlag) {
 800cf08:	2800      	cmp	r0, #0
 800cf0a:	f000 80d1 	beq.w	800d0b0 <xmp3_UnpackSideInfo+0x284>
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 800cf0e:	2102      	movs	r1, #2
 800cf10:	4628      	mov	r0, r5
 800cf12:	f7ff fe1f 	bl	800cb54 <xmp3_GetBits>
 800cf16:	63e0      	str	r0, [r4, #60]	; 0x3c
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf18:	e9dd 3e07 	ldrd	r3, lr, [sp, #28]
 800cf1c:	f10e 31ff 	add.w	r1, lr, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf20:	005a      	lsls	r2, r3, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf22:	0fdf      	lsrs	r7, r3, #31
	if (bsi->cachedBits < 0) {
 800cf24:	2900      	cmp	r1, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf26:	9207      	str	r2, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf28:	9108      	str	r1, [sp, #32]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf2a:	9701      	str	r7, [sp, #4]
	if (bsi->cachedBits < 0) {
 800cf2c:	f2c0 821a 	blt.w	800d364 <xmp3_UnpackSideInfo+0x538>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf30:	ea4f 6cd2 	mov.w	ip, r2, lsr #27
 800cf34:	463a      	mov	r2, r7
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf36:	019b      	lsls	r3, r3, #6
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 800cf38:	6422      	str	r2, [r4, #64]	; 0x40
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf3a:	1f4a      	subs	r2, r1, #5
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf3c:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800cf3e:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf40:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cf42:	f2c0 81d8 	blt.w	800d2f6 <xmp3_UnpackSideInfo+0x4ca>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf46:	ea4f 6ed3 	mov.w	lr, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf4a:	015b      	lsls	r3, r3, #5
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf4c:	1f51      	subs	r1, r2, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800cf4e:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf52:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800cf54:	2900      	cmp	r1, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf56:	9108      	str	r1, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cf58:	f2c0 83c9 	blt.w	800d6ee <xmp3_UnpackSideInfo+0x8c2>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf5c:	0f5a      	lsrs	r2, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf5e:	00db      	lsls	r3, r3, #3
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800cf60:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf64:	f1a1 0c03 	sub.w	ip, r1, #3
				sis->tableSelect[2] =  0;					/* unused */
 800cf68:	f04f 0e00 	mov.w	lr, #0
	if (bsi->cachedBits < 0) {
 800cf6c:	45f4      	cmp	ip, lr
				sis->tableSelect[2] =  0;					/* unused */
 800cf6e:	f8c4 e04c 	str.w	lr, [r4, #76]	; 0x4c
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf72:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf74:	f8cd c020 	str.w	ip, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cf78:	f2c0 8382 	blt.w	800d680 <xmp3_UnpackSideInfo+0x854>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf7c:	ea4f 7e53 	mov.w	lr, r3, lsr #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf80:	00db      	lsls	r3, r3, #3
				sis->subBlockGain[0] = GetBits(bsi, 3);
 800cf82:	6522      	str	r2, [r4, #80]	; 0x50
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf84:	f1ac 0203 	sub.w	r2, ip, #3
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf88:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800cf8a:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf8c:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cf8e:	f2c0 8341 	blt.w	800d614 <xmp3_UnpackSideInfo+0x7e8>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cf92:	0f59      	lsrs	r1, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf94:	00db      	lsls	r3, r3, #3
				sis->subBlockGain[1] = GetBits(bsi, 3);
 800cf96:	f8c4 e054 	str.w	lr, [r4, #84]	; 0x54
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cf9a:	9307      	str	r3, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cf9c:	1ed3      	subs	r3, r2, #3
	if (bsi->cachedBits < 0) {
 800cf9e:	2b00      	cmp	r3, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfa0:	9308      	str	r3, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cfa2:	f2c0 82fe 	blt.w	800d5a2 <xmp3_UnpackSideInfo+0x776>
				sis->subBlockGain[2] = GetBits(bsi, 3);
 800cfa6:	65a1      	str	r1, [r4, #88]	; 0x58

				/* TODO - check logic */
				if (sis->blockType == 0) {
 800cfa8:	2800      	cmp	r0, #0
 800cfaa:	f040 819a 	bne.w	800d2e2 <xmp3_UnpackSideInfo+0x4b6>
					sis->region0Count = 8;
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
				}
				sis->region1Count = 20 - sis->region0Count;
 800cfae:	6de3      	ldr	r3, [r4, #92]	; 0x5c
					sis->sfCompress = 0;
 800cfb0:	6360      	str	r0, [r4, #52]	; 0x34
				sis->region1Count = 20 - sis->region0Count;
 800cfb2:	f1c3 0314 	rsb	r3, r3, #20
					sis->part23Length = 0;
 800cfb6:	e9c4 000a 	strd	r0, r0, [r4, #40]	; 0x28
				sis->region1Count = 20 - sis->region0Count;
 800cfba:	6623      	str	r3, [r4, #96]	; 0x60
				sis->tableSelect[1] =  GetBits(bsi, 5);
				sis->tableSelect[2] =  GetBits(bsi, 5);
				sis->region0Count =    GetBits(bsi, 4);
				sis->region1Count =    GetBits(bsi, 3);
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800cfbc:	f89b 2000 	ldrb.w	r2, [fp]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfc0:	e9dd 3c07 	ldrd	r3, ip, [sp, #28]
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cfc4:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfc6:	005b      	lsls	r3, r3, #1
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800cfc8:	2a00      	cmp	r2, #0
 800cfca:	f000 80ae 	beq.w	800d12a <xmp3_UnpackSideInfo+0x2fe>
 800cfce:	2200      	movs	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfd0:	f10c 37ff 	add.w	r7, ip, #4294967295
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800cfd4:	6662      	str	r2, [r4, #100]	; 0x64
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfd6:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800cfd8:	2f00      	cmp	r7, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfda:	9708      	str	r7, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cfdc:	f2c0 8147 	blt.w	800d26e <xmp3_UnpackSideInfo+0x442>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800cfe0:	0fd8      	lsrs	r0, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfe2:	005b      	lsls	r3, r3, #1
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfe4:	1e7a      	subs	r2, r7, #1
			sis->sfactScale =        GetBits(bsi, 1);
 800cfe6:	66a1      	str	r1, [r4, #104]	; 0x68
	bsi->iCache <<= nBits;					/* left-justify cache */
 800cfe8:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800cfea:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800cfec:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800cfee:	f2c0 810f 	blt.w	800d210 <xmp3_UnpackSideInfo+0x3e4>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cff2:	3601      	adds	r6, #1
 800cff4:	f8da 37bc 	ldr.w	r3, [sl, #1980]	; 0x7bc
			sis->count1TableSelect = GetBits(bsi, 1);
 800cff8:	66e0      	str	r0, [r4, #108]	; 0x6c
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800cffa:	3448      	adds	r4, #72	; 0x48
 800cffc:	42b3      	cmp	r3, r6
 800cffe:	f73f af5c 	bgt.w	800ceba <xmp3_UnpackSideInfo+0x8e>
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 800d002:	9a03      	ldr	r2, [sp, #12]
 800d004:	3201      	adds	r2, #1
 800d006:	4611      	mov	r1, r2
 800d008:	9203      	str	r2, [sp, #12]
 800d00a:	f8da 27c4 	ldr.w	r2, [sl, #1988]	; 0x7c4
 800d00e:	4291      	cmp	r1, r2
 800d010:	da06      	bge.n	800d020 <xmp3_UnpackSideInfo+0x1f4>
 800d012:	9a02      	ldr	r2, [sp, #8]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800d014:	2b00      	cmp	r3, #0
 800d016:	f102 0290 	add.w	r2, r2, #144	; 0x90
 800d01a:	9202      	str	r2, [sp, #8]
 800d01c:	f73f af4b 	bgt.w	800ceb6 <xmp3_UnpackSideInfo+0x8a>
 800d020:	4656      	mov	r6, sl
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 800d022:	9b04      	ldr	r3, [sp, #16]
 800d024:	681b      	ldr	r3, [r3, #0]
 800d026:	f8c6 37d8 	str.w	r3, [r6, #2008]	; 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
}
 800d02a:	9805      	ldr	r0, [sp, #20]
 800d02c:	b00b      	add	sp, #44	; 0x2c
 800d02e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d032:	f89b 301c 	ldrb.w	r3, [fp, #28]
		si->mainDataBegin = GetBits(bsi, 9);
 800d036:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 800d038:	9106      	str	r1, [sp, #24]
		si->mainDataBegin = GetBits(bsi, 9);
 800d03a:	2109      	movs	r1, #9
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d03c:	2b03      	cmp	r3, #3
		si->mainDataBegin = GetBits(bsi, 9);
 800d03e:	4628      	mov	r0, r5
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d040:	bf0c      	ite	eq
 800d042:	2311      	moveq	r3, #17
 800d044:	2320      	movne	r3, #32
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 800d046:	e9cd 8807 	strd	r8, r8, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 800d04a:	9305      	str	r3, [sp, #20]
	bsi->nBytes = nBytes;
 800d04c:	9309      	str	r3, [sp, #36]	; 0x24
		si->mainDataBegin = GetBits(bsi, 9);
 800d04e:	f7ff fd81 	bl	800cb54 <xmp3_GetBits>
 800d052:	6020      	str	r0, [r4, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 800d054:	4628      	mov	r0, r5
 800d056:	f89b 301c 	ldrb.w	r3, [fp, #28]
 800d05a:	2b03      	cmp	r3, #3
 800d05c:	bf0c      	ite	eq
 800d05e:	2105      	moveq	r1, #5
 800d060:	2103      	movne	r1, #3
 800d062:	f7ff fd77 	bl	800cb54 <xmp3_GetBits>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d066:	f8d6 37bc 	ldr.w	r3, [r6, #1980]	; 0x7bc
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 800d06a:	6060      	str	r0, [r4, #4]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d06c:	2b00      	cmp	r3, #0
 800d06e:	f77f af13 	ble.w	800ce98 <xmp3_UnpackSideInfo+0x6c>
 800d072:	3418      	adds	r4, #24
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d074:	46b4      	mov	ip, r6
 800d076:	4646      	mov	r6, r8
 800d078:	eb04 1e03 	add.w	lr, r4, r3, lsl #4
 800d07c:	e9dd a207 	ldrd	sl, r2, [sp, #28]
 800d080:	4653      	mov	r3, sl
 800d082:	f1a4 0010 	sub.w	r0, r4, #16
 800d086:	ee07 5a90 	vmov	s15, r5
 800d08a:	1e51      	subs	r1, r2, #1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d08c:	0fdf      	lsrs	r7, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d08e:	005b      	lsls	r3, r3, #1
	if (bsi->cachedBits < 0) {
 800d090:	2900      	cmp	r1, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d092:	9108      	str	r1, [sp, #32]
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d094:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d096:	db56      	blt.n	800d146 <xmp3_UnpackSideInfo+0x31a>
 800d098:	460a      	mov	r2, r1
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 800d09a:	f840 7b04 	str.w	r7, [r0], #4
			for (bd = 0; bd < MAX_SCFBD; bd++)
 800d09e:	4284      	cmp	r4, r0
 800d0a0:	d1f3      	bne.n	800d08a <xmp3_UnpackSideInfo+0x25e>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 800d0a2:	3410      	adds	r4, #16
 800d0a4:	ee17 5a90 	vmov	r5, s15
 800d0a8:	4574      	cmp	r4, lr
 800d0aa:	d1ea      	bne.n	800d082 <xmp3_UnpackSideInfo+0x256>
 800d0ac:	4666      	mov	r6, ip
 800d0ae:	e6f3      	b.n	800ce98 <xmp3_UnpackSideInfo+0x6c>
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0b0:	f1ae 0705 	sub.w	r7, lr, #5
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0b4:	0159      	lsls	r1, r3, #5
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d0b6:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	if (bsi->cachedBits < 0) {
 800d0ba:	2f00      	cmp	r7, #0
				sis->mixedBlock = 0;
 800d0bc:	e9c4 000f 	strd	r0, r0, [r4, #60]	; 0x3c
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0c0:	9107      	str	r1, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0c2:	9708      	str	r7, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d0c4:	f2c0 83e3 	blt.w	800d88e <xmp3_UnpackSideInfo+0xa62>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d0c8:	0ec9      	lsrs	r1, r1, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0ca:	029b      	lsls	r3, r3, #10
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0cc:	1f7a      	subs	r2, r7, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 800d0ce:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0d2:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d0d4:	2a00      	cmp	r2, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0d6:	9208      	str	r2, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d0d8:	f2c0 8375 	blt.w	800d7c6 <xmp3_UnpackSideInfo+0x99a>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d0dc:	0ed8      	lsrs	r0, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0de:	015b      	lsls	r3, r3, #5
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0e0:	f1a2 0e05 	sub.w	lr, r2, #5
				sis->tableSelect[1] =  GetBits(bsi, 5);
 800d0e4:	64a1      	str	r1, [r4, #72]	; 0x48
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d0e6:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d0e8:	f1be 0f00 	cmp.w	lr, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d0ec:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d0f0:	f2c0 839a 	blt.w	800d828 <xmp3_UnpackSideInfo+0x9fc>
				sis->region0Count =    GetBits(bsi, 4);
 800d0f4:	2104      	movs	r1, #4
				sis->tableSelect[2] =  GetBits(bsi, 5);
 800d0f6:	64e0      	str	r0, [r4, #76]	; 0x4c
				sis->region0Count =    GetBits(bsi, 4);
 800d0f8:	4628      	mov	r0, r5
 800d0fa:	f7ff fd2b 	bl	800cb54 <xmp3_GetBits>
 800d0fe:	65e0      	str	r0, [r4, #92]	; 0x5c
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d100:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
 800d104:	f1a2 0c03 	sub.w	ip, r2, #3
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d108:	00d9      	lsls	r1, r3, #3
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d10a:	0f58      	lsrs	r0, r3, #29
	if (bsi->cachedBits < 0) {
 800d10c:	f1bc 0f00 	cmp.w	ip, #0
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d110:	9107      	str	r1, [sp, #28]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d112:	f8cd c020 	str.w	ip, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d116:	f2c0 8322 	blt.w	800d75e <xmp3_UnpackSideInfo+0x932>
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d11a:	0fc9      	lsrs	r1, r1, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d11c:	011b      	lsls	r3, r3, #4
				sis->region1Count =    GetBits(bsi, 3);
 800d11e:	6620      	str	r0, [r4, #96]	; 0x60
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 800d120:	f89b 2000 	ldrb.w	r2, [fp]
 800d124:	2a00      	cmp	r2, #0
 800d126:	f47f af52 	bne.w	800cfce <xmp3_UnpackSideInfo+0x1a2>
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d12a:	f10c 3eff 	add.w	lr, ip, #4294967295
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d12e:	9307      	str	r3, [sp, #28]
	if (bsi->cachedBits < 0) {
 800d130:	f1be 0f00 	cmp.w	lr, #0
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 800d134:	f8cd e020 	str.w	lr, [sp, #32]
	if (bsi->cachedBits < 0) {
 800d138:	f2c0 83dd 	blt.w	800d8f6 <xmp3_UnpackSideInfo+0xaca>
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d13c:	460a      	mov	r2, r1
 800d13e:	46f4      	mov	ip, lr
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d140:	0fd9      	lsrs	r1, r3, #31
 800d142:	005b      	lsls	r3, r3, #1
 800d144:	e744      	b.n	800cfd0 <xmp3_UnpackSideInfo+0x1a4>
	int nBytes = bsi->nBytes;
 800d146:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d14a:	f1c2 0801 	rsb	r8, r2, #1
	if (nBytes >= 4) {
 800d14e:	f1b9 0f03 	cmp.w	r9, #3
 800d152:	f340 81f1 	ble.w	800d538 <xmp3_UnpackSideInfo+0x70c>
		bsi->nBytes -= 4;
 800d156:	f1a9 0304 	sub.w	r3, r9, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d15a:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800d15e:	321f      	adds	r2, #31
 800d160:	46ca      	mov	sl, r9
 800d162:	f109 0101 	add.w	r1, r9, #1
 800d166:	9106      	str	r1, [sp, #24]
 800d168:	f81a 1b02 	ldrb.w	r1, [sl], #2
 800d16c:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d16e:	f8cd a018 	str.w	sl, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d172:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d174:	f899 a001 	ldrb.w	sl, [r9, #1]
 800d178:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d17c:	f109 0a03 	add.w	sl, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d180:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d182:	f8cd a018 	str.w	sl, [sp, #24]
 800d186:	f899 a002 	ldrb.w	sl, [r9, #2]
 800d18a:	ea41 2a0a 	orr.w	sl, r1, sl, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d18e:	f109 0104 	add.w	r1, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d192:	f8cd a01c 	str.w	sl, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d196:	9106      	str	r1, [sp, #24]
 800d198:	f899 1003 	ldrb.w	r1, [r9, #3]
		bsi->nBytes -= 4;
 800d19c:	9309      	str	r3, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d19e:	ea41 010a 	orr.w	r1, r1, sl
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d1a2:	fa01 f308 	lsl.w	r3, r1, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d1a6:	40d1      	lsrs	r1, r2
 800d1a8:	430f      	orrs	r7, r1
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d1aa:	e9cd 3207 	strd	r3, r2, [sp, #28]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d1ae:	e774      	b.n	800d09a <xmp3_UnpackSideInfo+0x26e>
	int nBytes = bsi->nBytes;
 800d1b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d1b2:	f1c1 0301 	rsb	r3, r1, #1
	if (nBytes >= 4) {
 800d1b6:	2a03      	cmp	r2, #3
 800d1b8:	f340 814c 	ble.w	800d454 <xmp3_UnpackSideInfo+0x628>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d1bc:	9f06      	ldr	r7, [sp, #24]
 800d1be:	f101 0e1f 	add.w	lr, r1, #31
		bsi->nBytes -= 4;
 800d1c2:	1f11      	subs	r1, r2, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d1c4:	46bc      	mov	ip, r7
 800d1c6:	1c7a      	adds	r2, r7, #1
 800d1c8:	9206      	str	r2, [sp, #24]
 800d1ca:	f81c 2b02 	ldrb.w	r2, [ip], #2
 800d1ce:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d1d0:	f8cd c018 	str.w	ip, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d1d4:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d1d6:	f897 c001 	ldrb.w	ip, [r7, #1]
 800d1da:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d1de:	f107 0c03 	add.w	ip, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d1e2:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d1e4:	f8cd c018 	str.w	ip, [sp, #24]
 800d1e8:	f897 c002 	ldrb.w	ip, [r7, #2]
 800d1ec:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d1f0:	f107 0c04 	add.w	ip, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d1f4:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d1f6:	f8cd c018 	str.w	ip, [sp, #24]
 800d1fa:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d1fc:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d1fe:	433a      	orrs	r2, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d200:	fa02 f303 	lsl.w	r3, r2, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d204:	fa22 f20e 	lsr.w	r2, r2, lr
 800d208:	4310      	orrs	r0, r2
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d20a:	e9cd 3e07 	strd	r3, lr, [sp, #28]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d20e:	e67a      	b.n	800cf06 <xmp3_UnpackSideInfo+0xda>
	int nBytes = bsi->nBytes;
 800d210:	9909      	ldr	r1, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d212:	f1c7 0c01 	rsb	ip, r7, #1
	if (nBytes >= 4) {
 800d216:	2903      	cmp	r1, #3
 800d218:	f340 8154 	ble.w	800d4c4 <xmp3_UnpackSideInfo+0x698>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d21c:	f107 021f 	add.w	r2, r7, #31
 800d220:	9f06      	ldr	r7, [sp, #24]
		bsi->nBytes -= 4;
 800d222:	3904      	subs	r1, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d224:	46be      	mov	lr, r7
 800d226:	1c7b      	adds	r3, r7, #1
 800d228:	9306      	str	r3, [sp, #24]
 800d22a:	f81e 3b02 	ldrb.w	r3, [lr], #2
 800d22e:	061b      	lsls	r3, r3, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d230:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d234:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d236:	f897 e001 	ldrb.w	lr, [r7, #1]
 800d23a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d23e:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d242:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d244:	f8cd e018 	str.w	lr, [sp, #24]
 800d248:	f897 e002 	ldrb.w	lr, [r7, #2]
 800d24c:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d250:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d254:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d256:	f8cd e018 	str.w	lr, [sp, #24]
 800d25a:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d25c:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d25e:	433b      	orrs	r3, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d260:	fa03 f70c 	lsl.w	r7, r3, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d264:	40d3      	lsrs	r3, r2
 800d266:	4318      	orrs	r0, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d268:	e9cd 7207 	strd	r7, r2, [sp, #28]
 800d26c:	e6c1      	b.n	800cff2 <xmp3_UnpackSideInfo+0x1c6>
	int nBytes = bsi->nBytes;
 800d26e:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d272:	f1cc 0001 	rsb	r0, ip, #1
	if (nBytes >= 4) {
 800d276:	f1be 0f03 	cmp.w	lr, #3
 800d27a:	f340 80b0 	ble.w	800d3de <xmp3_UnpackSideInfo+0x5b2>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d27e:	f10c 021f 	add.w	r2, ip, #31
 800d282:	f8dd c018 	ldr.w	ip, [sp, #24]
		bsi->nBytes -= 4;
 800d286:	f1ae 0704 	sub.w	r7, lr, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d28a:	4663      	mov	r3, ip
 800d28c:	f10c 0e01 	add.w	lr, ip, #1
 800d290:	f8cd e018 	str.w	lr, [sp, #24]
 800d294:	f813 8b02 	ldrb.w	r8, [r3], #2
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d298:	9306      	str	r3, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d29a:	ea4f 6308 	mov.w	r3, r8, lsl #24
 800d29e:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d2a0:	f89c 8001 	ldrb.w	r8, [ip, #1]
 800d2a4:	ea43 4808 	orr.w	r8, r3, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d2a8:	f10c 0303 	add.w	r3, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d2ac:	f8cd 801c 	str.w	r8, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d2b0:	9306      	str	r3, [sp, #24]
 800d2b2:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800d2b6:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d2ba:	f10c 0304 	add.w	r3, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d2be:	f8cd 801c 	str.w	r8, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d2c2:	9306      	str	r3, [sp, #24]
 800d2c4:	f89c 3003 	ldrb.w	r3, [ip, #3]
		bsi->nBytes -= 4;
 800d2c8:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d2ca:	4617      	mov	r7, r2
		bsi->iCache |= (*bsi->bytePtr++);
 800d2cc:	ea43 0808 	orr.w	r8, r3, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d2d0:	fa08 f300 	lsl.w	r3, r8, r0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d2d4:	fa28 f802 	lsr.w	r8, r8, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d2d8:	0fd8      	lsrs	r0, r3, #31
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d2da:	ea41 0108 	orr.w	r1, r1, r8
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d2de:	005b      	lsls	r3, r3, #1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d2e0:	e680      	b.n	800cfe4 <xmp3_UnpackSideInfo+0x1b8>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 800d2e2:	2802      	cmp	r0, #2
 800d2e4:	d103      	bne.n	800d2ee <xmp3_UnpackSideInfo+0x4c2>
 800d2e6:	9b01      	ldr	r3, [sp, #4]
 800d2e8:	2b00      	cmp	r3, #0
 800d2ea:	f000 85fc 	beq.w	800dee6 <xmp3_UnpackSideInfo+0x10ba>
					sis->region0Count = 7;
 800d2ee:	2307      	movs	r3, #7
 800d2f0:	65e3      	str	r3, [r4, #92]	; 0x5c
 800d2f2:	230d      	movs	r3, #13
 800d2f4:	e661      	b.n	800cfba <xmp3_UnpackSideInfo+0x18e>
	int nBytes = bsi->nBytes;
 800d2f6:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d2fa:	f1c1 0305 	rsb	r3, r1, #5
	if (nBytes >= 4) {
 800d2fe:	f1b8 0f03 	cmp.w	r8, #3
 800d302:	f340 84eb 	ble.w	800dcdc <xmp3_UnpackSideInfo+0xeb0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d306:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800d30a:	f101 021b 	add.w	r2, r1, #27
		bsi->nBytes -= 4;
 800d30e:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d312:	46ce      	mov	lr, r9
 800d314:	f109 0101 	add.w	r1, r9, #1
 800d318:	9106      	str	r1, [sp, #24]
 800d31a:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800d31e:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d320:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d324:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d326:	f899 e001 	ldrb.w	lr, [r9, #1]
 800d32a:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d32e:	f109 0e03 	add.w	lr, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d332:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d334:	f8cd e018 	str.w	lr, [sp, #24]
 800d338:	f899 e002 	ldrb.w	lr, [r9, #2]
 800d33c:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d340:	f109 0e04 	add.w	lr, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d344:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d346:	f8cd e018 	str.w	lr, [sp, #24]
 800d34a:	f899 e003 	ldrb.w	lr, [r9, #3]
		bsi->nBytes -= 4;
 800d34e:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d352:	ea4e 0e01 	orr.w	lr, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d356:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d35a:	fa2e fe02 	lsr.w	lr, lr, r2
 800d35e:	ea4c 0c0e 	orr.w	ip, ip, lr
 800d362:	e5f0      	b.n	800cf46 <xmp3_UnpackSideInfo+0x11a>
	int nBytes = bsi->nBytes;
 800d364:	9a09      	ldr	r2, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d366:	f1ce 0301 	rsb	r3, lr, #1
	if (nBytes >= 4) {
 800d36a:	2a03      	cmp	r2, #3
 800d36c:	f340 84fa 	ble.w	800dd64 <xmp3_UnpackSideInfo+0xf38>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d370:	f10e 011f 	add.w	r1, lr, #31
 800d374:	f8dd e018 	ldr.w	lr, [sp, #24]
		bsi->nBytes -= 4;
 800d378:	3a04      	subs	r2, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d37a:	46f0      	mov	r8, lr
 800d37c:	f10e 0c01 	add.w	ip, lr, #1
 800d380:	f8cd c018 	str.w	ip, [sp, #24]
 800d384:	f818 cb02 	ldrb.w	ip, [r8], #2
 800d388:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d38c:	f8cd 8018 	str.w	r8, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d390:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d394:	f89e 8001 	ldrb.w	r8, [lr, #1]
 800d398:	ea4c 4c08 	orr.w	ip, ip, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d39c:	f10e 0803 	add.w	r8, lr, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d3a0:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d3a4:	f8cd 8018 	str.w	r8, [sp, #24]
 800d3a8:	f89e 8002 	ldrb.w	r8, [lr, #2]
 800d3ac:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d3b0:	f10e 0804 	add.w	r8, lr, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d3b4:	f8cd c01c 	str.w	ip, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d3b8:	f8cd 8018 	str.w	r8, [sp, #24]
 800d3bc:	f89e e003 	ldrb.w	lr, [lr, #3]
		bsi->nBytes -= 4;
 800d3c0:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d3c2:	ea4e 0c0c 	orr.w	ip, lr, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d3c6:	9a01      	ldr	r2, [sp, #4]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d3c8:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d3cc:	fa2c fc01 	lsr.w	ip, ip, r1
 800d3d0:	ea42 020c 	orr.w	r2, r2, ip
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d3d4:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d3d8:	015b      	lsls	r3, r3, #5
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d3da:	9201      	str	r2, [sp, #4]
 800d3dc:	e5ac      	b.n	800cf38 <xmp3_UnpackSideInfo+0x10c>
		bsi->iCache = 0;
 800d3de:	2300      	movs	r3, #0
 800d3e0:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d3e2:	f1be 0f00 	cmp.w	lr, #0
 800d3e6:	f000 8583 	beq.w	800def0 <xmp3_UnpackSideInfo+0x10c4>
			bsi->iCache |= (*bsi->bytePtr++);
 800d3ea:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d3ec:	f1be 0f01 	cmp.w	lr, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d3f0:	f103 0201 	add.w	r2, r3, #1
 800d3f4:	9206      	str	r2, [sp, #24]
 800d3f6:	f893 8000 	ldrb.w	r8, [r3]
			bsi->iCache <<= 8;
 800d3fa:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800d3fe:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800d402:	d012      	beq.n	800d42a <xmp3_UnpackSideInfo+0x5fe>
			bsi->iCache |= (*bsi->bytePtr++);
 800d404:	1c9a      	adds	r2, r3, #2
		while (nBytes--) {
 800d406:	f1be 0f02 	cmp.w	lr, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d40a:	9206      	str	r2, [sp, #24]
 800d40c:	785a      	ldrb	r2, [r3, #1]
 800d40e:	ea42 0808 	orr.w	r8, r2, r8
			bsi->iCache <<= 8;
 800d412:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800d416:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800d41a:	d006      	beq.n	800d42a <xmp3_UnpackSideInfo+0x5fe>
			bsi->iCache |= (*bsi->bytePtr++);
 800d41c:	1cda      	adds	r2, r3, #3
 800d41e:	9206      	str	r2, [sp, #24]
 800d420:	789b      	ldrb	r3, [r3, #2]
 800d422:	ea43 0808 	orr.w	r8, r3, r8
			bsi->iCache <<= 8;
 800d426:	ea4f 2808 	mov.w	r8, r8, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d42a:	f1ce 0303 	rsb	r3, lr, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d42e:	f10c 021f 	add.w	r2, ip, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d432:	00db      	lsls	r3, r3, #3
 800d434:	fa08 f803 	lsl.w	r8, r8, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d438:	fa08 f300 	lsl.w	r3, r8, r0
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d43c:	fa28 f802 	lsr.w	r8, r8, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d440:	0fd8      	lsrs	r0, r3, #31
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d442:	ea41 0108 	orr.w	r1, r1, r8
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d446:	005b      	lsls	r3, r3, #1
		bsi->nBytes = 0;
 800d448:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 800d44c:	2700      	movs	r7, #0
 800d44e:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d450:	4617      	mov	r7, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d452:	e5c7      	b.n	800cfe4 <xmp3_UnpackSideInfo+0x1b8>
		bsi->iCache = 0;
 800d454:	2700      	movs	r7, #0
 800d456:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800d458:	2a00      	cmp	r2, #0
 800d45a:	f000 8550 	beq.w	800defe <xmp3_UnpackSideInfo+0x10d2>
			bsi->iCache |= (*bsi->bytePtr++);
 800d45e:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800d462:	2a01      	cmp	r2, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d464:	f108 0701 	add.w	r7, r8, #1
 800d468:	9706      	str	r7, [sp, #24]
 800d46a:	f898 7000 	ldrb.w	r7, [r8]
			bsi->iCache <<= 8;
 800d46e:	ea4f 2c07 	mov.w	ip, r7, lsl #8
 800d472:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d476:	d015      	beq.n	800d4a4 <xmp3_UnpackSideInfo+0x678>
			bsi->iCache |= (*bsi->bytePtr++);
 800d478:	f108 0702 	add.w	r7, r8, #2
		while (nBytes--) {
 800d47c:	2a02      	cmp	r2, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d47e:	9706      	str	r7, [sp, #24]
 800d480:	f898 7001 	ldrb.w	r7, [r8, #1]
 800d484:	ea47 070c 	orr.w	r7, r7, ip
			bsi->iCache <<= 8;
 800d488:	ea4f 2c07 	mov.w	ip, r7, lsl #8
 800d48c:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d490:	d008      	beq.n	800d4a4 <xmp3_UnpackSideInfo+0x678>
			bsi->iCache |= (*bsi->bytePtr++);
 800d492:	f108 0703 	add.w	r7, r8, #3
 800d496:	9706      	str	r7, [sp, #24]
 800d498:	f898 7002 	ldrb.w	r7, [r8, #2]
 800d49c:	ea47 070c 	orr.w	r7, r7, ip
			bsi->iCache <<= 8;
 800d4a0:	ea4f 2c07 	mov.w	ip, r7, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d4a4:	f1c2 0703 	rsb	r7, r2, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d4a8:	311f      	adds	r1, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d4aa:	00ff      	lsls	r7, r7, #3
 800d4ac:	fa0c f707 	lsl.w	r7, ip, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d4b0:	fa27 f101 	lsr.w	r1, r7, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d4b4:	fa07 f303 	lsl.w	r3, r7, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d4b8:	4308      	orrs	r0, r1
		bsi->nBytes = 0;
 800d4ba:	eb0e 0ec2 	add.w	lr, lr, r2, lsl #3
 800d4be:	2200      	movs	r2, #0
 800d4c0:	9209      	str	r2, [sp, #36]	; 0x24
 800d4c2:	e6a2      	b.n	800d20a <xmp3_UnpackSideInfo+0x3de>
		bsi->iCache = 0;
 800d4c4:	2300      	movs	r3, #0
 800d4c6:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d4c8:	2900      	cmp	r1, #0
 800d4ca:	f000 8515 	beq.w	800def8 <xmp3_UnpackSideInfo+0x10cc>
			bsi->iCache |= (*bsi->bytePtr++);
 800d4ce:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d4d0:	2901      	cmp	r1, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d4d2:	f103 0e01 	add.w	lr, r3, #1
 800d4d6:	f8cd e018 	str.w	lr, [sp, #24]
 800d4da:	f893 e000 	ldrb.w	lr, [r3]
			bsi->iCache <<= 8;
 800d4de:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800d4e2:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800d4e6:	d016      	beq.n	800d516 <xmp3_UnpackSideInfo+0x6ea>
			bsi->iCache |= (*bsi->bytePtr++);
 800d4e8:	f103 0802 	add.w	r8, r3, #2
		while (nBytes--) {
 800d4ec:	2902      	cmp	r1, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d4ee:	f8cd 8018 	str.w	r8, [sp, #24]
 800d4f2:	f893 8001 	ldrb.w	r8, [r3, #1]
 800d4f6:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800d4fa:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800d4fe:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800d502:	d008      	beq.n	800d516 <xmp3_UnpackSideInfo+0x6ea>
			bsi->iCache |= (*bsi->bytePtr++);
 800d504:	f103 0803 	add.w	r8, r3, #3
 800d508:	f8cd 8018 	str.w	r8, [sp, #24]
 800d50c:	789b      	ldrb	r3, [r3, #2]
 800d50e:	ea43 0e0e 	orr.w	lr, r3, lr
			bsi->iCache <<= 8;
 800d512:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d516:	f107 031f 	add.w	r3, r7, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d51a:	f1c1 0703 	rsb	r7, r1, #3
 800d51e:	00ff      	lsls	r7, r7, #3
 800d520:	fa0e f707 	lsl.w	r7, lr, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d524:	fa27 f303 	lsr.w	r3, r7, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d528:	fa07 f70c 	lsl.w	r7, r7, ip
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d52c:	4318      	orrs	r0, r3
		bsi->nBytes = 0;
 800d52e:	2300      	movs	r3, #0
 800d530:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800d534:	9309      	str	r3, [sp, #36]	; 0x24
 800d536:	e697      	b.n	800d268 <xmp3_UnpackSideInfo+0x43c>
		bsi->iCache = 0;
 800d538:	9607      	str	r6, [sp, #28]
		while (nBytes--) {
 800d53a:	f1b9 0f00 	cmp.w	r9, #0
 800d53e:	f000 84e1 	beq.w	800df04 <xmp3_UnpackSideInfo+0x10d8>
			bsi->iCache |= (*bsi->bytePtr++);
 800d542:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800d544:	f1b9 0f01 	cmp.w	r9, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d548:	f103 0a01 	add.w	sl, r3, #1
 800d54c:	f8cd a018 	str.w	sl, [sp, #24]
 800d550:	f893 a000 	ldrb.w	sl, [r3]
			bsi->iCache <<= 8;
 800d554:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 800d558:	f8cd a01c 	str.w	sl, [sp, #28]
		while (nBytes--) {
 800d55c:	d012      	beq.n	800d584 <xmp3_UnpackSideInfo+0x758>
			bsi->iCache |= (*bsi->bytePtr++);
 800d55e:	1c9d      	adds	r5, r3, #2
		while (nBytes--) {
 800d560:	f1b9 0f02 	cmp.w	r9, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d564:	9506      	str	r5, [sp, #24]
 800d566:	785d      	ldrb	r5, [r3, #1]
 800d568:	ea45 0a0a 	orr.w	sl, r5, sl
			bsi->iCache <<= 8;
 800d56c:	ea4f 2a0a 	mov.w	sl, sl, lsl #8
 800d570:	f8cd a01c 	str.w	sl, [sp, #28]
		while (nBytes--) {
 800d574:	d006      	beq.n	800d584 <xmp3_UnpackSideInfo+0x758>
			bsi->iCache |= (*bsi->bytePtr++);
 800d576:	1cdd      	adds	r5, r3, #3
 800d578:	9506      	str	r5, [sp, #24]
 800d57a:	789b      	ldrb	r3, [r3, #2]
 800d57c:	ea43 030a 	orr.w	r3, r3, sl
			bsi->iCache <<= 8;
 800d580:	ea4f 2a03 	mov.w	sl, r3, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d584:	f1c9 0303 	rsb	r3, r9, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d588:	321f      	adds	r2, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d58a:	00db      	lsls	r3, r3, #3
 800d58c:	fa0a f303 	lsl.w	r3, sl, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d590:	fa23 f202 	lsr.w	r2, r3, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d594:	fa03 f308 	lsl.w	r3, r3, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d598:	4317      	orrs	r7, r2
		bsi->nBytes = 0;
 800d59a:	eb01 02c9 	add.w	r2, r1, r9, lsl #3
 800d59e:	9609      	str	r6, [sp, #36]	; 0x24
 800d5a0:	e603      	b.n	800d1aa <xmp3_UnpackSideInfo+0x37e>
	int nBytes = bsi->nBytes;
 800d5a2:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d5a6:	f1c2 0903 	rsb	r9, r2, #3
	if (nBytes >= 4) {
 800d5aa:	f1be 0f03 	cmp.w	lr, #3
 800d5ae:	f340 81df 	ble.w	800d970 <xmp3_UnpackSideInfo+0xb44>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d5b2:	f8dd c018 	ldr.w	ip, [sp, #24]
 800d5b6:	f102 031d 	add.w	r3, r2, #29
		bsi->nBytes -= 4;
 800d5ba:	f1ae 0e04 	sub.w	lr, lr, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d5be:	46e0      	mov	r8, ip
 800d5c0:	f10c 0201 	add.w	r2, ip, #1
 800d5c4:	9206      	str	r2, [sp, #24]
 800d5c6:	f818 2b02 	ldrb.w	r2, [r8], #2
 800d5ca:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5cc:	f8cd 8018 	str.w	r8, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d5d0:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5d2:	f89c 8001 	ldrb.w	r8, [ip, #1]
 800d5d6:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5da:	f10c 0803 	add.w	r8, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d5de:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5e0:	f8cd 8018 	str.w	r8, [sp, #24]
 800d5e4:	f89c 8002 	ldrb.w	r8, [ip, #2]
 800d5e8:	ea42 2208 	orr.w	r2, r2, r8, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d5ec:	f10c 0804 	add.w	r8, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d5f0:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d5f2:	f8cd 8018 	str.w	r8, [sp, #24]
 800d5f6:	f89c c003 	ldrb.w	ip, [ip, #3]
		bsi->nBytes -= 4;
 800d5fa:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d5fe:	ea4c 0e02 	orr.w	lr, ip, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d602:	fa0e f209 	lsl.w	r2, lr, r9
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d606:	fa2e fe03 	lsr.w	lr, lr, r3
 800d60a:	ea41 010e 	orr.w	r1, r1, lr
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d60e:	e9cd 2307 	strd	r2, r3, [sp, #28]
 800d612:	e4c8      	b.n	800cfa6 <xmp3_UnpackSideInfo+0x17a>
	int nBytes = bsi->nBytes;
 800d614:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d618:	f1cc 0303 	rsb	r3, ip, #3
	if (nBytes >= 4) {
 800d61c:	f1b8 0f03 	cmp.w	r8, #3
 800d620:	f340 81e8 	ble.w	800d9f4 <xmp3_UnpackSideInfo+0xbc8>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d624:	f10c 021d 	add.w	r2, ip, #29
 800d628:	f8dd c018 	ldr.w	ip, [sp, #24]
		bsi->nBytes -= 4;
 800d62c:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d630:	46e1      	mov	r9, ip
 800d632:	f10c 0101 	add.w	r1, ip, #1
 800d636:	9106      	str	r1, [sp, #24]
 800d638:	f819 1b02 	ldrb.w	r1, [r9], #2
 800d63c:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d63e:	f8cd 9018 	str.w	r9, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d642:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d644:	f89c 9001 	ldrb.w	r9, [ip, #1]
 800d648:	ea41 4109 	orr.w	r1, r1, r9, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d64c:	f10c 0903 	add.w	r9, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d650:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d652:	f8cd 9018 	str.w	r9, [sp, #24]
 800d656:	f89c 9002 	ldrb.w	r9, [ip, #2]
 800d65a:	ea41 2909 	orr.w	r9, r1, r9, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d65e:	f10c 0104 	add.w	r1, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d662:	f8cd 901c 	str.w	r9, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d666:	9106      	str	r1, [sp, #24]
 800d668:	f89c 1003 	ldrb.w	r1, [ip, #3]
		bsi->nBytes -= 4;
 800d66c:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d670:	ea41 0109 	orr.w	r1, r1, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d674:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d678:	40d1      	lsrs	r1, r2
 800d67a:	ea4e 0e01 	orr.w	lr, lr, r1
 800d67e:	e488      	b.n	800cf92 <xmp3_UnpackSideInfo+0x166>
	int nBytes = bsi->nBytes;
 800d680:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d684:	f1c1 0303 	rsb	r3, r1, #3
	if (nBytes >= 4) {
 800d688:	f1b8 0f03 	cmp.w	r8, #3
 800d68c:	f340 81f2 	ble.w	800da74 <xmp3_UnpackSideInfo+0xc48>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d690:	f8dd 9018 	ldr.w	r9, [sp, #24]
 800d694:	f101 0c1d 	add.w	ip, r1, #29
		bsi->nBytes -= 4;
 800d698:	f1a8 0804 	sub.w	r8, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d69c:	46ce      	mov	lr, r9
 800d69e:	f109 0101 	add.w	r1, r9, #1
 800d6a2:	9106      	str	r1, [sp, #24]
 800d6a4:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800d6a8:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d6aa:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d6ae:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d6b0:	f899 e001 	ldrb.w	lr, [r9, #1]
 800d6b4:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6b8:	f109 0e03 	add.w	lr, r9, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d6bc:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6be:	f8cd e018 	str.w	lr, [sp, #24]
 800d6c2:	f899 e002 	ldrb.w	lr, [r9, #2]
 800d6c6:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d6ca:	f109 0e04 	add.w	lr, r9, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d6ce:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d6d0:	f8cd e018 	str.w	lr, [sp, #24]
 800d6d4:	f899 e003 	ldrb.w	lr, [r9, #3]
		bsi->nBytes -= 4;
 800d6d8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d6dc:	ea4e 0e01 	orr.w	lr, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d6e0:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d6e4:	fa2e fe0c 	lsr.w	lr, lr, ip
 800d6e8:	ea42 020e 	orr.w	r2, r2, lr
 800d6ec:	e446      	b.n	800cf7c <xmp3_UnpackSideInfo+0x150>
	int nBytes = bsi->nBytes;
 800d6ee:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d6f2:	f1c2 0305 	rsb	r3, r2, #5
	if (nBytes >= 4) {
 800d6f6:	f1bc 0f03 	cmp.w	ip, #3
 800d6fa:	f340 81fc 	ble.w	800daf6 <xmp3_UnpackSideInfo+0xcca>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d6fe:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800d702:	f102 011b 	add.w	r1, r2, #27
		bsi->nBytes -= 4;
 800d706:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d70a:	46c1      	mov	r9, r8
 800d70c:	f108 0201 	add.w	r2, r8, #1
 800d710:	9206      	str	r2, [sp, #24]
 800d712:	f819 2b02 	ldrb.w	r2, [r9], #2
 800d716:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d718:	f8cd 9018 	str.w	r9, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d71c:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d71e:	f898 9001 	ldrb.w	r9, [r8, #1]
 800d722:	ea42 4209 	orr.w	r2, r2, r9, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d726:	f108 0903 	add.w	r9, r8, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d72a:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d72c:	f8cd 9018 	str.w	r9, [sp, #24]
 800d730:	f898 9002 	ldrb.w	r9, [r8, #2]
 800d734:	ea42 2909 	orr.w	r9, r2, r9, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d738:	f108 0204 	add.w	r2, r8, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d73c:	f8cd 901c 	str.w	r9, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d740:	9206      	str	r2, [sp, #24]
 800d742:	f898 2003 	ldrb.w	r2, [r8, #3]
		bsi->nBytes -= 4;
 800d746:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d74a:	ea42 0c09 	orr.w	ip, r2, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d74e:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d752:	fa2c fc01 	lsr.w	ip, ip, r1
 800d756:	ea4e 0e0c 	orr.w	lr, lr, ip
 800d75a:	f7ff bbff 	b.w	800cf5c <xmp3_UnpackSideInfo+0x130>
	int nBytes = bsi->nBytes;
 800d75e:	9f09      	ldr	r7, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d760:	f1c2 0303 	rsb	r3, r2, #3
	if (nBytes >= 4) {
 800d764:	2f03      	cmp	r7, #3
 800d766:	f340 8249 	ble.w	800dbfc <xmp3_UnpackSideInfo+0xdd0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d76a:	f8dd c018 	ldr.w	ip, [sp, #24]
 800d76e:	321d      	adds	r2, #29
		bsi->nBytes -= 4;
 800d770:	3f04      	subs	r7, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d772:	46e6      	mov	lr, ip
 800d774:	f10c 0101 	add.w	r1, ip, #1
 800d778:	9106      	str	r1, [sp, #24]
 800d77a:	f81e 1b02 	ldrb.w	r1, [lr], #2
 800d77e:	0609      	lsls	r1, r1, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d780:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d784:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d786:	f89c e001 	ldrb.w	lr, [ip, #1]
 800d78a:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d78e:	f10c 0e03 	add.w	lr, ip, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d792:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d794:	f8cd e018 	str.w	lr, [sp, #24]
 800d798:	f89c e002 	ldrb.w	lr, [ip, #2]
 800d79c:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d7a0:	f10c 0e04 	add.w	lr, ip, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d7a4:	9107      	str	r1, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d7a6:	f8cd e018 	str.w	lr, [sp, #24]
 800d7aa:	f89c c003 	ldrb.w	ip, [ip, #3]
		bsi->nBytes -= 4;
 800d7ae:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d7b0:	ea4c 0101 	orr.w	r1, ip, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d7b4:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d7b8:	40d1      	lsrs	r1, r2
 800d7ba:	4308      	orrs	r0, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d7bc:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d7be:	005b      	lsls	r3, r3, #1
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 800d7c0:	4694      	mov	ip, r2
 800d7c2:	9208      	str	r2, [sp, #32]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d7c4:	e4ab      	b.n	800d11e <xmp3_UnpackSideInfo+0x2f2>
	int nBytes = bsi->nBytes;
 800d7c6:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d7ca:	f1c7 0305 	rsb	r3, r7, #5
	if (nBytes >= 4) {
 800d7ce:	f1bc 0f03 	cmp.w	ip, #3
 800d7d2:	f340 81d5 	ble.w	800db80 <xmp3_UnpackSideInfo+0xd54>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7d6:	f107 021b 	add.w	r2, r7, #27
 800d7da:	9f06      	ldr	r7, [sp, #24]
		bsi->nBytes -= 4;
 800d7dc:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7e0:	46be      	mov	lr, r7
 800d7e2:	1c78      	adds	r0, r7, #1
 800d7e4:	9006      	str	r0, [sp, #24]
 800d7e6:	f81e 0b02 	ldrb.w	r0, [lr], #2
 800d7ea:	0600      	lsls	r0, r0, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d7ec:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d7f0:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d7f2:	f897 e001 	ldrb.w	lr, [r7, #1]
 800d7f6:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d7fa:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d7fe:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d800:	f8cd e018 	str.w	lr, [sp, #24]
 800d804:	f897 e002 	ldrb.w	lr, [r7, #2]
 800d808:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d80c:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d810:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d812:	f8cd e018 	str.w	lr, [sp, #24]
 800d816:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d818:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d81c:	4338      	orrs	r0, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d81e:	fa00 f303 	lsl.w	r3, r0, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d822:	40d0      	lsrs	r0, r2
 800d824:	4301      	orrs	r1, r0
 800d826:	e459      	b.n	800d0dc <xmp3_UnpackSideInfo+0x2b0>
	int nBytes = bsi->nBytes;
 800d828:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d82c:	f1c2 0105 	rsb	r1, r2, #5
	if (nBytes >= 4) {
 800d830:	f1bc 0f03 	cmp.w	ip, #3
 800d834:	f340 821c 	ble.w	800dc70 <xmp3_UnpackSideInfo+0xe44>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d838:	9f06      	ldr	r7, [sp, #24]
 800d83a:	f102 031b 	add.w	r3, r2, #27
		bsi->nBytes -= 4;
 800d83e:	f1ac 0c04 	sub.w	ip, ip, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d842:	46be      	mov	lr, r7
 800d844:	1c7a      	adds	r2, r7, #1
 800d846:	9206      	str	r2, [sp, #24]
 800d848:	f81e 2b02 	ldrb.w	r2, [lr], #2
 800d84c:	0612      	lsls	r2, r2, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d84e:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d852:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d854:	f897 e001 	ldrb.w	lr, [r7, #1]
 800d858:	ea42 420e 	orr.w	r2, r2, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d85c:	f107 0e03 	add.w	lr, r7, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d860:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d862:	f8cd e018 	str.w	lr, [sp, #24]
 800d866:	f897 e002 	ldrb.w	lr, [r7, #2]
 800d86a:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d86e:	f107 0e04 	add.w	lr, r7, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d872:	9207      	str	r2, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d874:	f8cd e018 	str.w	lr, [sp, #24]
 800d878:	78ff      	ldrb	r7, [r7, #3]
		bsi->nBytes -= 4;
 800d87a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d87e:	433a      	orrs	r2, r7
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d880:	fa02 f101 	lsl.w	r1, r2, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d884:	40da      	lsrs	r2, r3
 800d886:	4310      	orrs	r0, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d888:	e9cd 1307 	strd	r1, r3, [sp, #28]
 800d88c:	e432      	b.n	800d0f4 <xmp3_UnpackSideInfo+0x2c8>
	int nBytes = bsi->nBytes;
 800d88e:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d892:	f1ce 0205 	rsb	r2, lr, #5
	if (nBytes >= 4) {
 800d896:	f1b8 0f03 	cmp.w	r8, #3
 800d89a:	f340 82aa 	ble.w	800ddf2 <xmp3_UnpackSideInfo+0xfc6>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d89e:	9906      	ldr	r1, [sp, #24]
 800d8a0:	f10e 071b 	add.w	r7, lr, #27
		bsi->nBytes -= 4;
 800d8a4:	f1a8 0004 	sub.w	r0, r8, #4
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d8a8:	468e      	mov	lr, r1
 800d8aa:	1c4b      	adds	r3, r1, #1
 800d8ac:	9306      	str	r3, [sp, #24]
 800d8ae:	f81e 3b02 	ldrb.w	r3, [lr], #2
 800d8b2:	061b      	lsls	r3, r3, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d8b4:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800d8b8:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d8ba:	f891 e001 	ldrb.w	lr, [r1, #1]
 800d8be:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d8c2:	f101 0e03 	add.w	lr, r1, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800d8c6:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d8c8:	f8cd e018 	str.w	lr, [sp, #24]
 800d8cc:	f891 e002 	ldrb.w	lr, [r1, #2]
 800d8d0:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800d8d4:	f101 0e04 	add.w	lr, r1, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800d8d8:	9307      	str	r3, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800d8da:	f8cd e018 	str.w	lr, [sp, #24]
 800d8de:	78c9      	ldrb	r1, [r1, #3]
		bsi->nBytes -= 4;
 800d8e0:	9009      	str	r0, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800d8e2:	4319      	orrs	r1, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d8e4:	fa01 f302 	lsl.w	r3, r1, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d8e8:	40f9      	lsrs	r1, r7
 800d8ea:	ea4c 0c01 	orr.w	ip, ip, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d8ee:	0ed9      	lsrs	r1, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d8f0:	015b      	lsls	r3, r3, #5
 800d8f2:	f7ff bbeb 	b.w	800d0cc <xmp3_UnpackSideInfo+0x2a0>
	int nBytes = bsi->nBytes;
 800d8f6:	9809      	ldr	r0, [sp, #36]	; 0x24
		lowBits = -bsi->cachedBits;
 800d8f8:	f1cc 0701 	rsb	r7, ip, #1
	if (nBytes >= 4) {
 800d8fc:	2803      	cmp	r0, #3
 800d8fe:	f300 82ab 	bgt.w	800de58 <xmp3_UnpackSideInfo+0x102c>
		bsi->iCache = 0;
 800d902:	9207      	str	r2, [sp, #28]
		while (nBytes--) {
 800d904:	2800      	cmp	r0, #0
 800d906:	f000 8300 	beq.w	800df0a <xmp3_UnpackSideInfo+0x10de>
			bsi->iCache |= (*bsi->bytePtr++);
 800d90a:	9a06      	ldr	r2, [sp, #24]
		while (nBytes--) {
 800d90c:	2801      	cmp	r0, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d90e:	f102 0301 	add.w	r3, r2, #1
 800d912:	9306      	str	r3, [sp, #24]
 800d914:	7813      	ldrb	r3, [r2, #0]
			bsi->iCache <<= 8;
 800d916:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d91a:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d91c:	d013      	beq.n	800d946 <xmp3_UnpackSideInfo+0xb1a>
			bsi->iCache |= (*bsi->bytePtr++);
 800d91e:	f102 0802 	add.w	r8, r2, #2
		while (nBytes--) {
 800d922:	2802      	cmp	r0, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d924:	f8cd 8018 	str.w	r8, [sp, #24]
 800d928:	f892 8001 	ldrb.w	r8, [r2, #1]
 800d92c:	ea48 0303 	orr.w	r3, r8, r3
			bsi->iCache <<= 8;
 800d930:	ea4f 2303 	mov.w	r3, r3, lsl #8
 800d934:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800d936:	d006      	beq.n	800d946 <xmp3_UnpackSideInfo+0xb1a>
			bsi->iCache |= (*bsi->bytePtr++);
 800d938:	f102 0803 	add.w	r8, r2, #3
 800d93c:	f8cd 8018 	str.w	r8, [sp, #24]
 800d940:	7892      	ldrb	r2, [r2, #2]
 800d942:	4313      	orrs	r3, r2
			bsi->iCache <<= 8;
 800d944:	021b      	lsls	r3, r3, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d946:	f1c0 0803 	rsb	r8, r0, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d94a:	f10c 021f 	add.w	r2, ip, #31
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d94e:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800d952:	fa03 f308 	lsl.w	r3, r3, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d956:	fa03 f707 	lsl.w	r7, r3, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d95a:	fa23 f202 	lsr.w	r2, r3, r2
	bsi->iCache <<= nBits;					/* left-justify cache */
 800d95e:	007b      	lsls	r3, r7, #1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d960:	430a      	orrs	r2, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800d962:	0ff9      	lsrs	r1, r7, #31
		bsi->nBytes = 0;
 800d964:	eb0e 0cc0 	add.w	ip, lr, r0, lsl #3
 800d968:	2000      	movs	r0, #0
 800d96a:	9009      	str	r0, [sp, #36]	; 0x24
	return data;
 800d96c:	f7ff bb30 	b.w	800cfd0 <xmp3_UnpackSideInfo+0x1a4>
		bsi->iCache = 0;
 800d970:	f04f 0c00 	mov.w	ip, #0
 800d974:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d978:	f1be 0f00 	cmp.w	lr, #0
 800d97c:	f000 8297 	beq.w	800deae <xmp3_UnpackSideInfo+0x1082>
			bsi->iCache |= (*bsi->bytePtr++);
 800d980:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800d984:	f1be 0f01 	cmp.w	lr, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800d988:	f108 0c01 	add.w	ip, r8, #1
 800d98c:	f8cd c018 	str.w	ip, [sp, #24]
 800d990:	f898 c000 	ldrb.w	ip, [r8]
			bsi->iCache <<= 8;
 800d994:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800d998:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d99c:	d016      	beq.n	800d9cc <xmp3_UnpackSideInfo+0xba0>
			bsi->iCache |= (*bsi->bytePtr++);
 800d99e:	f108 0702 	add.w	r7, r8, #2
		while (nBytes--) {
 800d9a2:	f1be 0f02 	cmp.w	lr, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800d9a6:	9706      	str	r7, [sp, #24]
 800d9a8:	f898 7001 	ldrb.w	r7, [r8, #1]
 800d9ac:	ea47 0c0c 	orr.w	ip, r7, ip
			bsi->iCache <<= 8;
 800d9b0:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800d9b4:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800d9b8:	d008      	beq.n	800d9cc <xmp3_UnpackSideInfo+0xba0>
			bsi->iCache |= (*bsi->bytePtr++);
 800d9ba:	f108 0703 	add.w	r7, r8, #3
 800d9be:	9706      	str	r7, [sp, #24]
 800d9c0:	f898 8002 	ldrb.w	r8, [r8, #2]
 800d9c4:	ea48 0c0c 	orr.w	ip, r8, ip
			bsi->iCache <<= 8;
 800d9c8:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d9cc:	f1ce 0803 	rsb	r8, lr, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d9d0:	321d      	adds	r2, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800d9d2:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800d9d6:	fa0c fc08 	lsl.w	ip, ip, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d9da:	fa2c f802 	lsr.w	r8, ip, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800d9de:	fa0c f209 	lsl.w	r2, ip, r9
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800d9e2:	ea41 0108 	orr.w	r1, r1, r8
		bsi->nBytes = 0;
 800d9e6:	f04f 0c00 	mov.w	ip, #0
 800d9ea:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 800d9ee:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 800d9f2:	e60c      	b.n	800d60e <xmp3_UnpackSideInfo+0x7e2>
		bsi->iCache = 0;
 800d9f4:	2100      	movs	r1, #0
 800d9f6:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800d9f8:	f1b8 0f00 	cmp.w	r8, #0
 800d9fc:	f000 826a 	beq.w	800ded4 <xmp3_UnpackSideInfo+0x10a8>
			bsi->iCache |= (*bsi->bytePtr++);
 800da00:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800da04:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800da08:	f109 0101 	add.w	r1, r9, #1
 800da0c:	9106      	str	r1, [sp, #24]
 800da0e:	f899 1000 	ldrb.w	r1, [r9]
			bsi->iCache <<= 8;
 800da12:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800da16:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800da18:	d014      	beq.n	800da44 <xmp3_UnpackSideInfo+0xc18>
			bsi->iCache |= (*bsi->bytePtr++);
 800da1a:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800da1e:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800da22:	9706      	str	r7, [sp, #24]
 800da24:	f899 7001 	ldrb.w	r7, [r9, #1]
 800da28:	ea41 0107 	orr.w	r1, r1, r7
			bsi->iCache <<= 8;
 800da2c:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800da30:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800da32:	d007      	beq.n	800da44 <xmp3_UnpackSideInfo+0xc18>
			bsi->iCache |= (*bsi->bytePtr++);
 800da34:	f109 0703 	add.w	r7, r9, #3
 800da38:	9706      	str	r7, [sp, #24]
 800da3a:	f899 9002 	ldrb.w	r9, [r9, #2]
 800da3e:	ea49 0101 	orr.w	r1, r9, r1
			bsi->iCache <<= 8;
 800da42:	0209      	lsls	r1, r1, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800da44:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800da48:	f10c 0c1d 	add.w	ip, ip, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800da4c:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800da50:	fa01 f109 	lsl.w	r1, r1, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800da54:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800da58:	fa21 f10c 	lsr.w	r1, r1, ip
 800da5c:	ea4e 0e01 	orr.w	lr, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800da60:	0f59      	lsrs	r1, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800da62:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800da64:	f04f 0c00 	mov.w	ip, #0
 800da68:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800da6c:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800da70:	f7ff ba91 	b.w	800cf96 <xmp3_UnpackSideInfo+0x16a>
		bsi->iCache = 0;
 800da74:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800da78:	f1b8 0f00 	cmp.w	r8, #0
 800da7c:	f000 8227 	beq.w	800dece <xmp3_UnpackSideInfo+0x10a2>
			bsi->iCache |= (*bsi->bytePtr++);
 800da80:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800da84:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800da88:	f109 0e01 	add.w	lr, r9, #1
 800da8c:	f8cd e018 	str.w	lr, [sp, #24]
 800da90:	f899 e000 	ldrb.w	lr, [r9]
			bsi->iCache <<= 8;
 800da94:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800da98:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800da9c:	d016      	beq.n	800dacc <xmp3_UnpackSideInfo+0xca0>
			bsi->iCache |= (*bsi->bytePtr++);
 800da9e:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800daa2:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800daa6:	9706      	str	r7, [sp, #24]
 800daa8:	f899 7001 	ldrb.w	r7, [r9, #1]
 800daac:	ea47 0e0e 	orr.w	lr, r7, lr
			bsi->iCache <<= 8;
 800dab0:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dab4:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dab8:	d008      	beq.n	800dacc <xmp3_UnpackSideInfo+0xca0>
			bsi->iCache |= (*bsi->bytePtr++);
 800daba:	f109 0703 	add.w	r7, r9, #3
 800dabe:	9706      	str	r7, [sp, #24]
 800dac0:	f899 9002 	ldrb.w	r9, [r9, #2]
 800dac4:	ea49 0e0e 	orr.w	lr, r9, lr
			bsi->iCache <<= 8;
 800dac8:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dacc:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dad0:	311d      	adds	r1, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dad2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800dad6:	fa0e fe09 	lsl.w	lr, lr, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dada:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dade:	fa2e f101 	lsr.w	r1, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dae2:	ea4f 7e53 	mov.w	lr, r3, lsr #29
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dae6:	430a      	orrs	r2, r1
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dae8:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800daea:	2100      	movs	r1, #0
 800daec:	eb0c 0cc8 	add.w	ip, ip, r8, lsl #3
 800daf0:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800daf2:	f7ff ba46 	b.w	800cf82 <xmp3_UnpackSideInfo+0x156>
		bsi->iCache = 0;
 800daf6:	f04f 0800 	mov.w	r8, #0
 800dafa:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800dafe:	f1bc 0f00 	cmp.w	ip, #0
 800db02:	f000 81ed 	beq.w	800dee0 <xmp3_UnpackSideInfo+0x10b4>
			bsi->iCache |= (*bsi->bytePtr++);
 800db06:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800db0a:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800db0e:	f109 0801 	add.w	r8, r9, #1
 800db12:	f8cd 8018 	str.w	r8, [sp, #24]
 800db16:	f899 8000 	ldrb.w	r8, [r9]
			bsi->iCache <<= 8;
 800db1a:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800db1e:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800db22:	d016      	beq.n	800db52 <xmp3_UnpackSideInfo+0xd26>
			bsi->iCache |= (*bsi->bytePtr++);
 800db24:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800db28:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800db2c:	9706      	str	r7, [sp, #24]
 800db2e:	f899 7001 	ldrb.w	r7, [r9, #1]
 800db32:	ea47 0808 	orr.w	r8, r7, r8
			bsi->iCache <<= 8;
 800db36:	ea4f 2808 	mov.w	r8, r8, lsl #8
 800db3a:	f8cd 801c 	str.w	r8, [sp, #28]
		while (nBytes--) {
 800db3e:	d008      	beq.n	800db52 <xmp3_UnpackSideInfo+0xd26>
			bsi->iCache |= (*bsi->bytePtr++);
 800db40:	f109 0703 	add.w	r7, r9, #3
 800db44:	9706      	str	r7, [sp, #24]
 800db46:	f899 9002 	ldrb.w	r9, [r9, #2]
 800db4a:	ea49 0808 	orr.w	r8, r9, r8
			bsi->iCache <<= 8;
 800db4e:	ea4f 2808 	mov.w	r8, r8, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800db52:	f1cc 0903 	rsb	r9, ip, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800db56:	321b      	adds	r2, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800db58:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800db5c:	fa08 f809 	lsl.w	r8, r8, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800db60:	fa08 f303 	lsl.w	r3, r8, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800db64:	fa28 f202 	lsr.w	r2, r8, r2
 800db68:	ea4e 0e02 	orr.w	lr, lr, r2
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800db6c:	0f5a      	lsrs	r2, r3, #29
	bsi->iCache <<= nBits;					/* left-justify cache */
 800db6e:	00db      	lsls	r3, r3, #3
		bsi->nBytes = 0;
 800db70:	eb01 01cc 	add.w	r1, r1, ip, lsl #3
 800db74:	f04f 0c00 	mov.w	ip, #0
 800db78:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800db7c:	f7ff b9f0 	b.w	800cf60 <xmp3_UnpackSideInfo+0x134>
		bsi->iCache = 0;
 800db80:	2000      	movs	r0, #0
 800db82:	9007      	str	r0, [sp, #28]
		while (nBytes--) {
 800db84:	f1bc 0f00 	cmp.w	ip, #0
 800db88:	f000 81a7 	beq.w	800deda <xmp3_UnpackSideInfo+0x10ae>
			bsi->iCache |= (*bsi->bytePtr++);
 800db8c:	9806      	ldr	r0, [sp, #24]
		while (nBytes--) {
 800db8e:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800db92:	f100 0e01 	add.w	lr, r0, #1
 800db96:	f8cd e018 	str.w	lr, [sp, #24]
 800db9a:	f890 e000 	ldrb.w	lr, [r0]
			bsi->iCache <<= 8;
 800db9e:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dba2:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dba6:	d017      	beq.n	800dbd8 <xmp3_UnpackSideInfo+0xdac>
			bsi->iCache |= (*bsi->bytePtr++);
 800dba8:	f100 0802 	add.w	r8, r0, #2
		while (nBytes--) {
 800dbac:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dbb0:	f8cd 8018 	str.w	r8, [sp, #24]
 800dbb4:	f890 8001 	ldrb.w	r8, [r0, #1]
 800dbb8:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800dbbc:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dbc0:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dbc4:	d008      	beq.n	800dbd8 <xmp3_UnpackSideInfo+0xdac>
			bsi->iCache |= (*bsi->bytePtr++);
 800dbc6:	f100 0803 	add.w	r8, r0, #3
 800dbca:	f8cd 8018 	str.w	r8, [sp, #24]
 800dbce:	7880      	ldrb	r0, [r0, #2]
 800dbd0:	ea40 000e 	orr.w	r0, r0, lr
			bsi->iCache <<= 8;
 800dbd4:	ea4f 2e00 	mov.w	lr, r0, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dbd8:	f1cc 0003 	rsb	r0, ip, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dbdc:	371b      	adds	r7, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dbde:	00c0      	lsls	r0, r0, #3
 800dbe0:	fa0e f000 	lsl.w	r0, lr, r0
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dbe4:	fa00 f303 	lsl.w	r3, r0, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dbe8:	40f8      	lsrs	r0, r7
 800dbea:	4301      	orrs	r1, r0
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dbec:	0ed8      	lsrs	r0, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dbee:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800dbf0:	2700      	movs	r7, #0
 800dbf2:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
 800dbf6:	9709      	str	r7, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dbf8:	f7ff ba72 	b.w	800d0e0 <xmp3_UnpackSideInfo+0x2b4>
		bsi->iCache = 0;
 800dbfc:	2100      	movs	r1, #0
 800dbfe:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800dc00:	2f00      	cmp	r7, #0
 800dc02:	f000 815b 	beq.w	800debc <xmp3_UnpackSideInfo+0x1090>
			bsi->iCache |= (*bsi->bytePtr++);
 800dc06:	9906      	ldr	r1, [sp, #24]
		while (nBytes--) {
 800dc08:	2f01      	cmp	r7, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dc0a:	f101 0e01 	add.w	lr, r1, #1
 800dc0e:	f8cd e018 	str.w	lr, [sp, #24]
 800dc12:	f891 e000 	ldrb.w	lr, [r1]
			bsi->iCache <<= 8;
 800dc16:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dc1a:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dc1e:	d016      	beq.n	800dc4e <xmp3_UnpackSideInfo+0xe22>
			bsi->iCache |= (*bsi->bytePtr++);
 800dc20:	f101 0802 	add.w	r8, r1, #2
		while (nBytes--) {
 800dc24:	2f02      	cmp	r7, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dc26:	f8cd 8018 	str.w	r8, [sp, #24]
 800dc2a:	f891 8001 	ldrb.w	r8, [r1, #1]
 800dc2e:	ea48 0e0e 	orr.w	lr, r8, lr
			bsi->iCache <<= 8;
 800dc32:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dc36:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dc3a:	d008      	beq.n	800dc4e <xmp3_UnpackSideInfo+0xe22>
			bsi->iCache |= (*bsi->bytePtr++);
 800dc3c:	f101 0803 	add.w	r8, r1, #3
 800dc40:	f8cd 8018 	str.w	r8, [sp, #24]
 800dc44:	7889      	ldrb	r1, [r1, #2]
 800dc46:	ea41 010e 	orr.w	r1, r1, lr
			bsi->iCache <<= 8;
 800dc4a:	ea4f 2e01 	mov.w	lr, r1, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dc4e:	f1c7 0103 	rsb	r1, r7, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dc52:	321d      	adds	r2, #29
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dc54:	00c9      	lsls	r1, r1, #3
 800dc56:	fa0e f101 	lsl.w	r1, lr, r1
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dc5a:	fa01 f303 	lsl.w	r3, r1, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dc5e:	40d1      	lsrs	r1, r2
 800dc60:	4308      	orrs	r0, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dc62:	0fd9      	lsrs	r1, r3, #31
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dc64:	005b      	lsls	r3, r3, #1
		bsi->nBytes = 0;
 800dc66:	eb0c 02c7 	add.w	r2, ip, r7, lsl #3
 800dc6a:	2700      	movs	r7, #0
 800dc6c:	9709      	str	r7, [sp, #36]	; 0x24
 800dc6e:	e5a7      	b.n	800d7c0 <xmp3_UnpackSideInfo+0x994>
		bsi->iCache = 0;
 800dc70:	2300      	movs	r3, #0
 800dc72:	9307      	str	r3, [sp, #28]
		while (nBytes--) {
 800dc74:	f1bc 0f00 	cmp.w	ip, #0
 800dc78:	f000 811e 	beq.w	800deb8 <xmp3_UnpackSideInfo+0x108c>
			bsi->iCache |= (*bsi->bytePtr++);
 800dc7c:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800dc7e:	f1bc 0f01 	cmp.w	ip, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dc82:	f103 0701 	add.w	r7, r3, #1
 800dc86:	9706      	str	r7, [sp, #24]
 800dc88:	781f      	ldrb	r7, [r3, #0]
			bsi->iCache <<= 8;
 800dc8a:	ea4f 2707 	mov.w	r7, r7, lsl #8
 800dc8e:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800dc90:	d014      	beq.n	800dcbc <xmp3_UnpackSideInfo+0xe90>
			bsi->iCache |= (*bsi->bytePtr++);
 800dc92:	f103 0802 	add.w	r8, r3, #2
		while (nBytes--) {
 800dc96:	f1bc 0f02 	cmp.w	ip, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dc9a:	f8cd 8018 	str.w	r8, [sp, #24]
 800dc9e:	f893 8001 	ldrb.w	r8, [r3, #1]
 800dca2:	ea48 0707 	orr.w	r7, r8, r7
			bsi->iCache <<= 8;
 800dca6:	ea4f 2707 	mov.w	r7, r7, lsl #8
 800dcaa:	9707      	str	r7, [sp, #28]
		while (nBytes--) {
 800dcac:	d006      	beq.n	800dcbc <xmp3_UnpackSideInfo+0xe90>
			bsi->iCache |= (*bsi->bytePtr++);
 800dcae:	f103 0803 	add.w	r8, r3, #3
 800dcb2:	f8cd 8018 	str.w	r8, [sp, #24]
 800dcb6:	789b      	ldrb	r3, [r3, #2]
 800dcb8:	431f      	orrs	r7, r3
			bsi->iCache <<= 8;
 800dcba:	023f      	lsls	r7, r7, #8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dcbc:	f102 031b 	add.w	r3, r2, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dcc0:	f1cc 0203 	rsb	r2, ip, #3
 800dcc4:	00d2      	lsls	r2, r2, #3
 800dcc6:	4097      	lsls	r7, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dcc8:	fa27 f303 	lsr.w	r3, r7, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dccc:	fa07 f101 	lsl.w	r1, r7, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dcd0:	4318      	orrs	r0, r3
		bsi->nBytes = 0;
 800dcd2:	2200      	movs	r2, #0
 800dcd4:	eb0e 03cc 	add.w	r3, lr, ip, lsl #3
 800dcd8:	9209      	str	r2, [sp, #36]	; 0x24
 800dcda:	e5d5      	b.n	800d888 <xmp3_UnpackSideInfo+0xa5c>
		bsi->iCache = 0;
 800dcdc:	f04f 0e00 	mov.w	lr, #0
 800dce0:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dce4:	f1b8 0f00 	cmp.w	r8, #0
 800dce8:	f000 80ee 	beq.w	800dec8 <xmp3_UnpackSideInfo+0x109c>
			bsi->iCache |= (*bsi->bytePtr++);
 800dcec:	f8dd 9018 	ldr.w	r9, [sp, #24]
		while (nBytes--) {
 800dcf0:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dcf4:	f109 0e01 	add.w	lr, r9, #1
 800dcf8:	f8cd e018 	str.w	lr, [sp, #24]
 800dcfc:	f899 e000 	ldrb.w	lr, [r9]
			bsi->iCache <<= 8;
 800dd00:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dd04:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dd08:	d016      	beq.n	800dd38 <xmp3_UnpackSideInfo+0xf0c>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd0a:	f109 0702 	add.w	r7, r9, #2
		while (nBytes--) {
 800dd0e:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dd12:	9706      	str	r7, [sp, #24]
 800dd14:	f899 7001 	ldrb.w	r7, [r9, #1]
 800dd18:	ea47 0e0e 	orr.w	lr, r7, lr
			bsi->iCache <<= 8;
 800dd1c:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 800dd20:	f8cd e01c 	str.w	lr, [sp, #28]
		while (nBytes--) {
 800dd24:	d008      	beq.n	800dd38 <xmp3_UnpackSideInfo+0xf0c>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd26:	f109 0703 	add.w	r7, r9, #3
 800dd2a:	9706      	str	r7, [sp, #24]
 800dd2c:	f899 9002 	ldrb.w	r9, [r9, #2]
 800dd30:	ea49 0e0e 	orr.w	lr, r9, lr
			bsi->iCache <<= 8;
 800dd34:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dd38:	f1c8 0903 	rsb	r9, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dd3c:	311b      	adds	r1, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800dd3e:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800dd42:	fa0e fe09 	lsl.w	lr, lr, r9
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dd46:	fa0e f303 	lsl.w	r3, lr, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dd4a:	fa2e f101 	lsr.w	r1, lr, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dd4e:	ea4f 6ed3 	mov.w	lr, r3, lsr #27
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dd52:	ea4c 0c01 	orr.w	ip, ip, r1
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dd56:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800dd58:	2100      	movs	r1, #0
 800dd5a:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 800dd5e:	9109      	str	r1, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800dd60:	f7ff b8f4 	b.w	800cf4c <xmp3_UnpackSideInfo+0x120>
		bsi->iCache = 0;
 800dd64:	f04f 0c00 	mov.w	ip, #0
 800dd68:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800dd6c:	2a00      	cmp	r2, #0
 800dd6e:	f000 80a8 	beq.w	800dec2 <xmp3_UnpackSideInfo+0x1096>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd72:	f8dd 8018 	ldr.w	r8, [sp, #24]
		while (nBytes--) {
 800dd76:	2a01      	cmp	r2, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800dd78:	f108 0c01 	add.w	ip, r8, #1
 800dd7c:	f8cd c018 	str.w	ip, [sp, #24]
 800dd80:	f898 c000 	ldrb.w	ip, [r8]
			bsi->iCache <<= 8;
 800dd84:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800dd88:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800dd8c:	d017      	beq.n	800ddbe <xmp3_UnpackSideInfo+0xf92>
			bsi->iCache |= (*bsi->bytePtr++);
 800dd8e:	f108 0902 	add.w	r9, r8, #2
		while (nBytes--) {
 800dd92:	2a02      	cmp	r2, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800dd94:	f8cd 9018 	str.w	r9, [sp, #24]
 800dd98:	f898 9001 	ldrb.w	r9, [r8, #1]
 800dd9c:	ea49 0c0c 	orr.w	ip, r9, ip
			bsi->iCache <<= 8;
 800dda0:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
 800dda4:	f8cd c01c 	str.w	ip, [sp, #28]
		while (nBytes--) {
 800dda8:	d009      	beq.n	800ddbe <xmp3_UnpackSideInfo+0xf92>
			bsi->iCache |= (*bsi->bytePtr++);
 800ddaa:	f108 0903 	add.w	r9, r8, #3
 800ddae:	f8cd 9018 	str.w	r9, [sp, #24]
 800ddb2:	f898 8002 	ldrb.w	r8, [r8, #2]
 800ddb6:	ea48 0c0c 	orr.w	ip, r8, ip
			bsi->iCache <<= 8;
 800ddba:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800ddbe:	f1c2 0803 	rsb	r8, r2, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800ddc2:	f10e 0e1f 	add.w	lr, lr, #31
 800ddc6:	9f01      	ldr	r7, [sp, #4]
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800ddc8:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 800ddcc:	fa0c fc08 	lsl.w	ip, ip, r8
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800ddd0:	fa0c f303 	lsl.w	r3, ip, r3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800ddd4:	fa2c fc0e 	lsr.w	ip, ip, lr
 800ddd8:	ea47 070c 	orr.w	r7, r7, ip
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dddc:	ea4f 6cd3 	mov.w	ip, r3, lsr #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dde0:	015b      	lsls	r3, r3, #5
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dde2:	9701      	str	r7, [sp, #4]
		bsi->nBytes = 0;
 800dde4:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
 800dde8:	2200      	movs	r2, #0
 800ddea:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800ddec:	9a01      	ldr	r2, [sp, #4]
 800ddee:	f7ff b8a3 	b.w	800cf38 <xmp3_UnpackSideInfo+0x10c>
		bsi->iCache = 0;
 800ddf2:	9007      	str	r0, [sp, #28]
		while (nBytes--) {
 800ddf4:	f1b8 0f00 	cmp.w	r8, #0
 800ddf8:	d05b      	beq.n	800deb2 <xmp3_UnpackSideInfo+0x1086>
			bsi->iCache |= (*bsi->bytePtr++);
 800ddfa:	9b06      	ldr	r3, [sp, #24]
		while (nBytes--) {
 800ddfc:	f1b8 0f01 	cmp.w	r8, #1
			bsi->iCache |= (*bsi->bytePtr++);
 800de00:	f103 0101 	add.w	r1, r3, #1
 800de04:	9106      	str	r1, [sp, #24]
 800de06:	7819      	ldrb	r1, [r3, #0]
			bsi->iCache <<= 8;
 800de08:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800de0c:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800de0e:	d00f      	beq.n	800de30 <xmp3_UnpackSideInfo+0x1004>
			bsi->iCache |= (*bsi->bytePtr++);
 800de10:	1c98      	adds	r0, r3, #2
		while (nBytes--) {
 800de12:	f1b8 0f02 	cmp.w	r8, #2
			bsi->iCache |= (*bsi->bytePtr++);
 800de16:	9006      	str	r0, [sp, #24]
 800de18:	7858      	ldrb	r0, [r3, #1]
 800de1a:	ea41 0100 	orr.w	r1, r1, r0
			bsi->iCache <<= 8;
 800de1e:	ea4f 2101 	mov.w	r1, r1, lsl #8
 800de22:	9107      	str	r1, [sp, #28]
		while (nBytes--) {
 800de24:	d004      	beq.n	800de30 <xmp3_UnpackSideInfo+0x1004>
			bsi->iCache |= (*bsi->bytePtr++);
 800de26:	1cd8      	adds	r0, r3, #3
 800de28:	9006      	str	r0, [sp, #24]
 800de2a:	789b      	ldrb	r3, [r3, #2]
 800de2c:	4319      	orrs	r1, r3
			bsi->iCache <<= 8;
 800de2e:	0209      	lsls	r1, r1, #8
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800de30:	f1c8 0303 	rsb	r3, r8, #3
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800de34:	f10e 0e1b 	add.w	lr, lr, #27
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 800de38:	00db      	lsls	r3, r3, #3
 800de3a:	4099      	lsls	r1, r3
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800de3c:	fa01 f302 	lsl.w	r3, r1, r2
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800de40:	fa21 f10e 	lsr.w	r1, r1, lr
 800de44:	ea4c 0c01 	orr.w	ip, ip, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800de48:	0ed9      	lsrs	r1, r3, #27
	bsi->iCache <<= nBits;					/* left-justify cache */
 800de4a:	015b      	lsls	r3, r3, #5
		bsi->nBytes = 0;
 800de4c:	2200      	movs	r2, #0
 800de4e:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
 800de52:	9209      	str	r2, [sp, #36]	; 0x24
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800de54:	f7ff b93a 	b.w	800d0cc <xmp3_UnpackSideInfo+0x2a0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800de58:	9a06      	ldr	r2, [sp, #24]
		bsi->nBytes -= 4;
 800de5a:	1f03      	subs	r3, r0, #4
 800de5c:	f10c 0c1f 	add.w	ip, ip, #31
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800de60:	4696      	mov	lr, r2
 800de62:	1c50      	adds	r0, r2, #1
 800de64:	9006      	str	r0, [sp, #24]
 800de66:	f81e 0b02 	ldrb.w	r0, [lr], #2
 800de6a:	0600      	lsls	r0, r0, #24
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800de6c:	f8cd e018 	str.w	lr, [sp, #24]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 800de70:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800de72:	f892 e001 	ldrb.w	lr, [r2, #1]
 800de76:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800de7a:	f102 0e03 	add.w	lr, r2, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 800de7e:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800de80:	f8cd e018 	str.w	lr, [sp, #24]
 800de84:	f892 e002 	ldrb.w	lr, [r2, #2]
 800de88:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 800de8c:	f102 0e04 	add.w	lr, r2, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 800de90:	9007      	str	r0, [sp, #28]
		bsi->iCache |= (*bsi->bytePtr++);
 800de92:	f8cd e018 	str.w	lr, [sp, #24]
 800de96:	78d2      	ldrb	r2, [r2, #3]
		bsi->nBytes -= 4;
 800de98:	9309      	str	r3, [sp, #36]	; 0x24
		bsi->iCache |= (*bsi->bytePtr++);
 800de9a:	4310      	orrs	r0, r2
		bsi->iCache <<= lowBits;			/* left-justify cache */
 800de9c:	fa00 f707 	lsl.w	r7, r0, r7
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dea0:	fa20 f20c 	lsr.w	r2, r0, ip
	bsi->iCache <<= nBits;					/* left-justify cache */
 800dea4:	007b      	lsls	r3, r7, #1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 800dea6:	430a      	orrs	r2, r1
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 800dea8:	0ff9      	lsrs	r1, r7, #31
 800deaa:	f7ff b891 	b.w	800cfd0 <xmp3_UnpackSideInfo+0x1a4>
		while (nBytes--) {
 800deae:	4672      	mov	r2, lr
 800deb0:	e599      	b.n	800d9e6 <xmp3_UnpackSideInfo+0xbba>
 800deb2:	4603      	mov	r3, r0
 800deb4:	4601      	mov	r1, r0
 800deb6:	e7c9      	b.n	800de4c <xmp3_UnpackSideInfo+0x1020>
 800deb8:	4661      	mov	r1, ip
 800deba:	e70a      	b.n	800dcd2 <xmp3_UnpackSideInfo+0xea6>
 800debc:	463b      	mov	r3, r7
 800debe:	4639      	mov	r1, r7
 800dec0:	e6d1      	b.n	800dc66 <xmp3_UnpackSideInfo+0xe3a>
 800dec2:	4613      	mov	r3, r2
 800dec4:	4694      	mov	ip, r2
 800dec6:	e78d      	b.n	800dde4 <xmp3_UnpackSideInfo+0xfb8>
 800dec8:	4643      	mov	r3, r8
 800deca:	46c6      	mov	lr, r8
 800decc:	e744      	b.n	800dd58 <xmp3_UnpackSideInfo+0xf2c>
 800dece:	4643      	mov	r3, r8
 800ded0:	46c6      	mov	lr, r8
 800ded2:	e60a      	b.n	800daea <xmp3_UnpackSideInfo+0xcbe>
 800ded4:	4643      	mov	r3, r8
 800ded6:	4641      	mov	r1, r8
 800ded8:	e5c4      	b.n	800da64 <xmp3_UnpackSideInfo+0xc38>
 800deda:	4663      	mov	r3, ip
 800dedc:	4660      	mov	r0, ip
 800dede:	e687      	b.n	800dbf0 <xmp3_UnpackSideInfo+0xdc4>
 800dee0:	4663      	mov	r3, ip
 800dee2:	4662      	mov	r2, ip
 800dee4:	e644      	b.n	800db70 <xmp3_UnpackSideInfo+0xd44>
					sis->region0Count = 8;
 800dee6:	2308      	movs	r3, #8
 800dee8:	65e3      	str	r3, [r4, #92]	; 0x5c
 800deea:	230c      	movs	r3, #12
 800deec:	f7ff b865 	b.w	800cfba <xmp3_UnpackSideInfo+0x18e>
		while (nBytes--) {
 800def0:	4673      	mov	r3, lr
 800def2:	4670      	mov	r0, lr
 800def4:	f7ff baa8 	b.w	800d448 <xmp3_UnpackSideInfo+0x61c>
 800def8:	460f      	mov	r7, r1
 800defa:	f7ff bb18 	b.w	800d52e <xmp3_UnpackSideInfo+0x702>
 800defe:	4613      	mov	r3, r2
 800df00:	f7ff badb 	b.w	800d4ba <xmp3_UnpackSideInfo+0x68e>
 800df04:	464b      	mov	r3, r9
 800df06:	f7ff bb48 	b.w	800d59a <xmp3_UnpackSideInfo+0x76e>
 800df0a:	460a      	mov	r2, r1
 800df0c:	4603      	mov	r3, r0
 800df0e:	4601      	mov	r1, r0
 800df10:	e528      	b.n	800d964 <xmp3_UnpackSideInfo+0xb38>
		return -1;
 800df12:	f04f 33ff 	mov.w	r3, #4294967295
 800df16:	9305      	str	r3, [sp, #20]
 800df18:	f7ff b887 	b.w	800d02a <xmp3_UnpackSideInfo+0x1fe>

0800df1c <xmp3_FreeBuffers>:
 *
 * Notes:       safe to call even if some buffers were not allocated (uses SAFE_FREE)
 **************************************************************************************/
void FreeBuffers(MP3DecInfo *mp3DecInfo)
{
	if (!mp3DecInfo)
 800df1c:	b380      	cbz	r0, 800df80 <xmp3_FreeBuffers+0x64>
{
 800df1e:	b510      	push	{r4, lr}
 800df20:	4604      	mov	r4, r0
		return;

	SAFE_FREE(mp3DecInfo->FrameHeaderPS);
 800df22:	6800      	ldr	r0, [r0, #0]
 800df24:	b108      	cbz	r0, 800df2a <xmp3_FreeBuffers+0xe>
 800df26:	f7fe faef 	bl	800c508 <vPortFree>
 800df2a:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->SideInfoPS);
 800df2c:	6860      	ldr	r0, [r4, #4]
	SAFE_FREE(mp3DecInfo->FrameHeaderPS);
 800df2e:	6023      	str	r3, [r4, #0]
	SAFE_FREE(mp3DecInfo->SideInfoPS);
 800df30:	b108      	cbz	r0, 800df36 <xmp3_FreeBuffers+0x1a>
 800df32:	f7fe fae9 	bl	800c508 <vPortFree>
 800df36:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->ScaleFactorInfoPS);
 800df38:	68a0      	ldr	r0, [r4, #8]
	SAFE_FREE(mp3DecInfo->SideInfoPS);
 800df3a:	6063      	str	r3, [r4, #4]
	SAFE_FREE(mp3DecInfo->ScaleFactorInfoPS);
 800df3c:	b108      	cbz	r0, 800df42 <xmp3_FreeBuffers+0x26>
 800df3e:	f7fe fae3 	bl	800c508 <vPortFree>
 800df42:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->HuffmanInfoPS);
 800df44:	68e0      	ldr	r0, [r4, #12]
	SAFE_FREE(mp3DecInfo->ScaleFactorInfoPS);
 800df46:	60a3      	str	r3, [r4, #8]
	SAFE_FREE(mp3DecInfo->HuffmanInfoPS);
 800df48:	b108      	cbz	r0, 800df4e <xmp3_FreeBuffers+0x32>
 800df4a:	f7fe fadd 	bl	800c508 <vPortFree>
 800df4e:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->DequantInfoPS);
 800df50:	6920      	ldr	r0, [r4, #16]
	SAFE_FREE(mp3DecInfo->HuffmanInfoPS);
 800df52:	60e3      	str	r3, [r4, #12]
	SAFE_FREE(mp3DecInfo->DequantInfoPS);
 800df54:	b108      	cbz	r0, 800df5a <xmp3_FreeBuffers+0x3e>
 800df56:	f7fe fad7 	bl	800c508 <vPortFree>
 800df5a:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
 800df5c:	6960      	ldr	r0, [r4, #20]
	SAFE_FREE(mp3DecInfo->DequantInfoPS);
 800df5e:	6123      	str	r3, [r4, #16]
	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
 800df60:	b108      	cbz	r0, 800df66 <xmp3_FreeBuffers+0x4a>
 800df62:	f7fe fad1 	bl	800c508 <vPortFree>
 800df66:	2300      	movs	r3, #0
	SAFE_FREE(mp3DecInfo->SubbandInfoPS);
 800df68:	69a0      	ldr	r0, [r4, #24]
	SAFE_FREE(mp3DecInfo->IMDCTInfoPS);
 800df6a:	6163      	str	r3, [r4, #20]
	SAFE_FREE(mp3DecInfo->SubbandInfoPS);
 800df6c:	b108      	cbz	r0, 800df72 <xmp3_FreeBuffers+0x56>
 800df6e:	f7fe facb 	bl	800c508 <vPortFree>
 800df72:	2300      	movs	r3, #0

	SAFE_FREE(mp3DecInfo);
 800df74:	4620      	mov	r0, r4
	SAFE_FREE(mp3DecInfo->SubbandInfoPS);
 800df76:	61a3      	str	r3, [r4, #24]
}
 800df78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SAFE_FREE(mp3DecInfo);
 800df7c:	f7fe bac4 	b.w	800c508 <vPortFree>
 800df80:	4770      	bx	lr
 800df82:	bf00      	nop

0800df84 <xmp3_AllocateBuffers>:
{
 800df84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	mp3DecInfo = (MP3DecInfo *)pvPortMalloc(sizeof(MP3DecInfo));
 800df88:	f44f 60fe 	mov.w	r0, #2032	; 0x7f0
{
 800df8c:	b083      	sub	sp, #12
	mp3DecInfo = (MP3DecInfo *)pvPortMalloc(sizeof(MP3DecInfo));
 800df8e:	f7fe fa03 	bl	800c398 <pvPortMalloc>
	if (!mp3DecInfo)
 800df92:	4604      	mov	r4, r0
 800df94:	2800      	cmp	r0, #0
 800df96:	d06a      	beq.n	800e06e <xmp3_AllocateBuffers+0xea>
		cbuf[i] = 0;
 800df98:	f44f 62fe 	mov.w	r2, #2032	; 0x7f0
 800df9c:	2100      	movs	r1, #0
 800df9e:	f005 f8eb 	bl	8013178 <memset>
	fh =  (FrameHeader *)     pvPortMalloc(sizeof(FrameHeader));
 800dfa2:	2038      	movs	r0, #56	; 0x38
 800dfa4:	f7fe f9f8 	bl	800c398 <pvPortMalloc>
 800dfa8:	4683      	mov	fp, r0
	si =  (SideInfo *)        pvPortMalloc(sizeof(SideInfo));
 800dfaa:	f44f 70a4 	mov.w	r0, #328	; 0x148
 800dfae:	f7fe f9f3 	bl	800c398 <pvPortMalloc>
 800dfb2:	4606      	mov	r6, r0
	sfi = (ScaleFactorInfo *) pvPortMalloc(sizeof(ScaleFactorInfo));
 800dfb4:	f44f 708e 	mov.w	r0, #284	; 0x11c
 800dfb8:	f7fe f9ee 	bl	800c398 <pvPortMalloc>
 800dfbc:	4607      	mov	r7, r0
	hi =  (HuffmanInfo *)     pvPortMalloc(sizeof(HuffmanInfo));
 800dfbe:	f241 2010 	movw	r0, #4624	; 0x1210
 800dfc2:	f7fe f9e9 	bl	800c398 <pvPortMalloc>
 800dfc6:	4680      	mov	r8, r0
	di =  (DequantInfo *)     pvPortMalloc(sizeof(DequantInfo));
 800dfc8:	f44f 7052 	mov.w	r0, #840	; 0x348
 800dfcc:	f7fe f9e4 	bl	800c398 <pvPortMalloc>
 800dfd0:	4682      	mov	sl, r0
	mi =  (IMDCTInfo *)       pvPortMalloc(sizeof(IMDCTInfo));
 800dfd2:	f44f 50d9 	mov.w	r0, #6944	; 0x1b20
 800dfd6:	f7fe f9df 	bl	800c398 <pvPortMalloc>
 800dfda:	4681      	mov	r9, r0
	sbi = (SubbandInfo *)     pvPortMalloc(sizeof(SubbandInfo));
 800dfdc:	f242 2004 	movw	r0, #8708	; 0x2204
 800dfe0:	f7fe f9da 	bl	800c398 <pvPortMalloc>
 800dfe4:	4605      	mov	r5, r0
	mp3DecInfo->SubbandInfoPS =     (void *)sbi;
 800dfe6:	61a0      	str	r0, [r4, #24]
	mp3DecInfo->SideInfoPS =        (void *)si;
 800dfe8:	e9c4 b600 	strd	fp, r6, [r4]
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 800dfec:	e9c4 7802 	strd	r7, r8, [r4, #8]
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 800dff0:	e9c4 a904 	strd	sl, r9, [r4, #16]
	if (!fh || !si || !sfi || !hi || !di || !mi || !sbi) {
 800dff4:	f1bb 0f00 	cmp.w	fp, #0
 800dff8:	d03d      	beq.n	800e076 <xmp3_AllocateBuffers+0xf2>
 800dffa:	2e00      	cmp	r6, #0
 800dffc:	d03b      	beq.n	800e076 <xmp3_AllocateBuffers+0xf2>
 800dffe:	2f00      	cmp	r7, #0
 800e000:	d039      	beq.n	800e076 <xmp3_AllocateBuffers+0xf2>
 800e002:	f1b8 0f00 	cmp.w	r8, #0
 800e006:	d036      	beq.n	800e076 <xmp3_AllocateBuffers+0xf2>
 800e008:	f1b9 0f00 	cmp.w	r9, #0
 800e00c:	bf18      	it	ne
 800e00e:	f1ba 0f00 	cmpne.w	sl, #0
 800e012:	d030      	beq.n	800e076 <xmp3_AllocateBuffers+0xf2>
 800e014:	fab0 f180 	clz	r1, r0
 800e018:	0949      	lsrs	r1, r1, #5
 800e01a:	b360      	cbz	r0, 800e076 <xmp3_AllocateBuffers+0xf2>
		cbuf[i] = 0;
 800e01c:	2238      	movs	r2, #56	; 0x38
 800e01e:	4658      	mov	r0, fp
 800e020:	9101      	str	r1, [sp, #4]
 800e022:	f005 f8a9 	bl	8013178 <memset>
 800e026:	f44f 72a4 	mov.w	r2, #328	; 0x148
 800e02a:	9901      	ldr	r1, [sp, #4]
 800e02c:	4630      	mov	r0, r6
 800e02e:	f005 f8a3 	bl	8013178 <memset>
 800e032:	f44f 728e 	mov.w	r2, #284	; 0x11c
 800e036:	9901      	ldr	r1, [sp, #4]
 800e038:	4638      	mov	r0, r7
 800e03a:	f005 f89d 	bl	8013178 <memset>
 800e03e:	f241 2210 	movw	r2, #4624	; 0x1210
 800e042:	9901      	ldr	r1, [sp, #4]
 800e044:	4640      	mov	r0, r8
 800e046:	f005 f897 	bl	8013178 <memset>
 800e04a:	f44f 7252 	mov.w	r2, #840	; 0x348
 800e04e:	9901      	ldr	r1, [sp, #4]
 800e050:	4650      	mov	r0, sl
 800e052:	f005 f891 	bl	8013178 <memset>
 800e056:	f44f 52d9 	mov.w	r2, #6944	; 0x1b20
 800e05a:	9901      	ldr	r1, [sp, #4]
 800e05c:	4648      	mov	r0, r9
 800e05e:	f005 f88b 	bl	8013178 <memset>
 800e062:	f242 2204 	movw	r2, #8708	; 0x2204
 800e066:	9901      	ldr	r1, [sp, #4]
 800e068:	4628      	mov	r0, r5
 800e06a:	f005 f885 	bl	8013178 <memset>
}
 800e06e:	4620      	mov	r0, r4
 800e070:	b003      	add	sp, #12
 800e072:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		FreeBuffers(mp3DecInfo);	/* safe to call - only frees memory that was successfully allocated */
 800e076:	4620      	mov	r0, r4
		return 0;
 800e078:	2400      	movs	r4, #0
		FreeBuffers(mp3DecInfo);	/* safe to call - only frees memory that was successfully allocated */
 800e07a:	f7ff ff4f 	bl	800df1c <xmp3_FreeBuffers>
}
 800e07e:	4620      	mov	r0, r4
 800e080:	b003      	add	sp, #12
 800e082:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e086:	bf00      	nop

0800e088 <xmp3_FDCT32>:
 * TODO:        code organization and optimization for ARM
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 800e088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e08c:	b087      	sub	sp, #28
 800e08e:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800e090:	9303      	str	r3, [sp, #12]
	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
	if (gb < 6) {
 800e092:	2c05      	cmp	r4, #5
{
 800e094:	e9cd 1201 	strd	r1, r2, [sp, #4]
	if (gb < 6) {
 800e098:	f300 84d1 	bgt.w	800ea3e <xmp3_FDCT32+0x9b6>
		es = 6 - gb;
 800e09c:	f1c4 0b06 	rsb	fp, r4, #6
		for (i = 0; i < 32; i++)
 800e0a0:	1f03      	subs	r3, r0, #4
 800e0a2:	f100 017c 	add.w	r1, r0, #124	; 0x7c
			buf[i] >>= es;
 800e0a6:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800e0aa:	fa42 f20b 	asr.w	r2, r2, fp
		for (i = 0; i < 32; i++)
 800e0ae:	4299      	cmp	r1, r3
			buf[i] >>= es;
 800e0b0:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 32; i++)
 800e0b2:	d1f8      	bne.n	800e0a6 <xmp3_FDCT32+0x1e>
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 800e0b4:	6801      	ldr	r1, [r0, #0]
 800e0b6:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
 800e0b8:	e9d0 450f 	ldrd	r4, r5, [r0, #60]	; 0x3c
 800e0bc:	1a8b      	subs	r3, r1, r2
 800e0be:	440a      	add	r2, r1
	 * For inline assembly, x and y are not assumed to be R0, R1 so it shouldn't matter
	 *   which one is returned. (If this were a function call, returning y (R1) would 
	 *   require an extra "mov r0, r1")
     */
    int zlow;
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800e0c0:	49c9      	ldr	r1, [pc, #804]	; (800e3e8 <xmp3_FDCT32+0x360>)
 800e0c2:	fb81 6303 	smull	r6, r3, r1, r3
 800e0c6:	1b61      	subs	r1, r4, r5
 800e0c8:	005b      	lsls	r3, r3, #1
 800e0ca:	442c      	add	r4, r5
 800e0cc:	4dc7      	ldr	r5, [pc, #796]	; (800e3ec <xmp3_FDCT32+0x364>)
 800e0ce:	fb85 6101 	smull	r6, r1, r5, r1
 800e0d2:	1915      	adds	r5, r2, r4
 800e0d4:	0149      	lsls	r1, r1, #5
 800e0d6:	1b12      	subs	r2, r2, r4
 800e0d8:	4cc5      	ldr	r4, [pc, #788]	; (800e3f0 <xmp3_FDCT32+0x368>)
 800e0da:	6005      	str	r5, [r0, #0]
 800e0dc:	fb84 5202 	smull	r5, r2, r4, r2
 800e0e0:	0052      	lsls	r2, r2, #1
 800e0e2:	63c2      	str	r2, [r0, #60]	; 0x3c
 800e0e4:	185a      	adds	r2, r3, r1
 800e0e6:	1a5b      	subs	r3, r3, r1
 800e0e8:	6402      	str	r2, [r0, #64]	; 0x40
 800e0ea:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(1, 1, 3, 1);
 800e0ee:	6846      	ldr	r6, [r0, #4]
	D32FP(0, 1, 5, 1);
 800e0f0:	005b      	lsls	r3, r3, #1
	D32FP(1, 1, 3, 1);
 800e0f2:	6f82      	ldr	r2, [r0, #120]	; 0x78
	D32FP(0, 1, 5, 1);
 800e0f4:	67c3      	str	r3, [r0, #124]	; 0x7c
	D32FP(1, 1, 3, 1);
 800e0f6:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800e0f8:	1ab3      	subs	r3, r6, r2
 800e0fa:	6c45      	ldr	r5, [r0, #68]	; 0x44
 800e0fc:	4432      	add	r2, r6
 800e0fe:	49bd      	ldr	r1, [pc, #756]	; (800e3f4 <xmp3_FDCT32+0x36c>)
 800e100:	fb81 6303 	smull	r6, r3, r1, r3
 800e104:	1b61      	subs	r1, r4, r5
 800e106:	005b      	lsls	r3, r3, #1
 800e108:	442c      	add	r4, r5
 800e10a:	4dbb      	ldr	r5, [pc, #748]	; (800e3f8 <xmp3_FDCT32+0x370>)
 800e10c:	fb85 6101 	smull	r6, r1, r5, r1
 800e110:	1915      	adds	r5, r2, r4
 800e112:	00c9      	lsls	r1, r1, #3
 800e114:	1b12      	subs	r2, r2, r4
 800e116:	4cb9      	ldr	r4, [pc, #740]	; (800e3fc <xmp3_FDCT32+0x374>)
 800e118:	6045      	str	r5, [r0, #4]
 800e11a:	fb84 5202 	smull	r5, r2, r4, r2
 800e11e:	0052      	lsls	r2, r2, #1
 800e120:	6382      	str	r2, [r0, #56]	; 0x38
 800e122:	185a      	adds	r2, r3, r1
 800e124:	1a5b      	subs	r3, r3, r1
 800e126:	6442      	str	r2, [r0, #68]	; 0x44
 800e128:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(2, 1, 3, 1);
 800e12c:	6886      	ldr	r6, [r0, #8]
	D32FP(1, 1, 3, 1);
 800e12e:	005b      	lsls	r3, r3, #1
	D32FP(2, 1, 3, 1);
 800e130:	6f42      	ldr	r2, [r0, #116]	; 0x74
	D32FP(1, 1, 3, 1);
 800e132:	6783      	str	r3, [r0, #120]	; 0x78
	D32FP(2, 1, 3, 1);
 800e134:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800e136:	1ab3      	subs	r3, r6, r2
 800e138:	6c85      	ldr	r5, [r0, #72]	; 0x48
 800e13a:	4432      	add	r2, r6
 800e13c:	49b0      	ldr	r1, [pc, #704]	; (800e400 <xmp3_FDCT32+0x378>)
 800e13e:	fb81 6303 	smull	r6, r3, r1, r3
 800e142:	1b61      	subs	r1, r4, r5
 800e144:	005b      	lsls	r3, r3, #1
 800e146:	442c      	add	r4, r5
 800e148:	4dae      	ldr	r5, [pc, #696]	; (800e404 <xmp3_FDCT32+0x37c>)
 800e14a:	fb85 6101 	smull	r6, r1, r5, r1
 800e14e:	1915      	adds	r5, r2, r4
 800e150:	00c9      	lsls	r1, r1, #3
 800e152:	1b12      	subs	r2, r2, r4
 800e154:	4cac      	ldr	r4, [pc, #688]	; (800e408 <xmp3_FDCT32+0x380>)
 800e156:	6085      	str	r5, [r0, #8]
 800e158:	fb84 5202 	smull	r5, r2, r4, r2
 800e15c:	0052      	lsls	r2, r2, #1
 800e15e:	6342      	str	r2, [r0, #52]	; 0x34
 800e160:	185a      	adds	r2, r3, r1
 800e162:	1a5b      	subs	r3, r3, r1
 800e164:	6482      	str	r2, [r0, #72]	; 0x48
 800e166:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(3, 1, 2, 1);
 800e16a:	68c6      	ldr	r6, [r0, #12]
	D32FP(2, 1, 3, 1);
 800e16c:	005b      	lsls	r3, r3, #1
	D32FP(3, 1, 2, 1);
 800e16e:	6f02      	ldr	r2, [r0, #112]	; 0x70
	D32FP(2, 1, 3, 1);
 800e170:	6743      	str	r3, [r0, #116]	; 0x74
	D32FP(3, 1, 2, 1);
 800e172:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800e174:	1ab3      	subs	r3, r6, r2
 800e176:	6cc5      	ldr	r5, [r0, #76]	; 0x4c
 800e178:	4432      	add	r2, r6
 800e17a:	49a4      	ldr	r1, [pc, #656]	; (800e40c <xmp3_FDCT32+0x384>)
 800e17c:	fb81 6303 	smull	r6, r3, r1, r3
 800e180:	1b61      	subs	r1, r4, r5
 800e182:	005b      	lsls	r3, r3, #1
 800e184:	442c      	add	r4, r5
 800e186:	4da2      	ldr	r5, [pc, #648]	; (800e410 <xmp3_FDCT32+0x388>)
 800e188:	fb85 6101 	smull	r6, r1, r5, r1
 800e18c:	1915      	adds	r5, r2, r4
 800e18e:	0089      	lsls	r1, r1, #2
 800e190:	1b12      	subs	r2, r2, r4
 800e192:	4ca0      	ldr	r4, [pc, #640]	; (800e414 <xmp3_FDCT32+0x38c>)
 800e194:	60c5      	str	r5, [r0, #12]
 800e196:	fb84 5202 	smull	r5, r2, r4, r2
 800e19a:	0052      	lsls	r2, r2, #1
 800e19c:	6302      	str	r2, [r0, #48]	; 0x30
 800e19e:	185a      	adds	r2, r3, r1
 800e1a0:	1a5b      	subs	r3, r3, r1
 800e1a2:	64c2      	str	r2, [r0, #76]	; 0x4c
 800e1a4:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(4, 1, 2, 1);
 800e1a8:	6906      	ldr	r6, [r0, #16]
	D32FP(3, 1, 2, 1);
 800e1aa:	005b      	lsls	r3, r3, #1
	D32FP(4, 1, 2, 1);
 800e1ac:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
	D32FP(3, 1, 2, 1);
 800e1ae:	6703      	str	r3, [r0, #112]	; 0x70
	D32FP(4, 1, 2, 1);
 800e1b0:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800e1b2:	1ab3      	subs	r3, r6, r2
 800e1b4:	6d05      	ldr	r5, [r0, #80]	; 0x50
 800e1b6:	4432      	add	r2, r6
 800e1b8:	4997      	ldr	r1, [pc, #604]	; (800e418 <xmp3_FDCT32+0x390>)
 800e1ba:	fb81 6303 	smull	r6, r3, r1, r3
 800e1be:	1b61      	subs	r1, r4, r5
 800e1c0:	005b      	lsls	r3, r3, #1
 800e1c2:	442c      	add	r4, r5
 800e1c4:	4d95      	ldr	r5, [pc, #596]	; (800e41c <xmp3_FDCT32+0x394>)
 800e1c6:	fb85 6101 	smull	r6, r1, r5, r1
 800e1ca:	1915      	adds	r5, r2, r4
 800e1cc:	0089      	lsls	r1, r1, #2
 800e1ce:	1b12      	subs	r2, r2, r4
 800e1d0:	4c93      	ldr	r4, [pc, #588]	; (800e420 <xmp3_FDCT32+0x398>)
 800e1d2:	6105      	str	r5, [r0, #16]
 800e1d4:	fb84 5202 	smull	r5, r2, r4, r2
 800e1d8:	0052      	lsls	r2, r2, #1
 800e1da:	62c2      	str	r2, [r0, #44]	; 0x2c
 800e1dc:	185a      	adds	r2, r3, r1
 800e1de:	1a5b      	subs	r3, r3, r1
 800e1e0:	6502      	str	r2, [r0, #80]	; 0x50
 800e1e2:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(5, 1, 1, 2);
 800e1e6:	6946      	ldr	r6, [r0, #20]
	D32FP(4, 1, 2, 1);
 800e1e8:	005b      	lsls	r3, r3, #1
	D32FP(5, 1, 1, 2);
 800e1ea:	6e82      	ldr	r2, [r0, #104]	; 0x68
	D32FP(4, 1, 2, 1);
 800e1ec:	66c3      	str	r3, [r0, #108]	; 0x6c
	D32FP(5, 1, 1, 2);
 800e1ee:	6a84      	ldr	r4, [r0, #40]	; 0x28
 800e1f0:	1ab3      	subs	r3, r6, r2
 800e1f2:	6d45      	ldr	r5, [r0, #84]	; 0x54
 800e1f4:	4432      	add	r2, r6
 800e1f6:	498b      	ldr	r1, [pc, #556]	; (800e424 <xmp3_FDCT32+0x39c>)
 800e1f8:	fb81 6303 	smull	r6, r3, r1, r3
 800e1fc:	1b61      	subs	r1, r4, r5
 800e1fe:	005b      	lsls	r3, r3, #1
 800e200:	442c      	add	r4, r5
 800e202:	4d89      	ldr	r5, [pc, #548]	; (800e428 <xmp3_FDCT32+0x3a0>)
 800e204:	fb85 6101 	smull	r6, r1, r5, r1
 800e208:	1915      	adds	r5, r2, r4
 800e20a:	0049      	lsls	r1, r1, #1
 800e20c:	1b12      	subs	r2, r2, r4
 800e20e:	4c87      	ldr	r4, [pc, #540]	; (800e42c <xmp3_FDCT32+0x3a4>)
 800e210:	6145      	str	r5, [r0, #20]
 800e212:	fb84 5202 	smull	r5, r2, r4, r2
 800e216:	0092      	lsls	r2, r2, #2
 800e218:	6282      	str	r2, [r0, #40]	; 0x28
 800e21a:	185a      	adds	r2, r3, r1
 800e21c:	1a5b      	subs	r3, r3, r1
 800e21e:	6542      	str	r2, [r0, #84]	; 0x54
 800e220:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(6, 1, 1, 2);
 800e224:	6986      	ldr	r6, [r0, #24]
	D32FP(5, 1, 1, 2);
 800e226:	009b      	lsls	r3, r3, #2
	D32FP(6, 1, 1, 2);
 800e228:	6e42      	ldr	r2, [r0, #100]	; 0x64
	D32FP(5, 1, 1, 2);
 800e22a:	6683      	str	r3, [r0, #104]	; 0x68
	D32FP(6, 1, 1, 2);
 800e22c:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800e22e:	1ab3      	subs	r3, r6, r2
 800e230:	6d85      	ldr	r5, [r0, #88]	; 0x58
 800e232:	4432      	add	r2, r6
 800e234:	497e      	ldr	r1, [pc, #504]	; (800e430 <xmp3_FDCT32+0x3a8>)
 800e236:	fb81 6303 	smull	r6, r3, r1, r3
 800e23a:	1b61      	subs	r1, r4, r5
 800e23c:	005b      	lsls	r3, r3, #1
 800e23e:	442c      	add	r4, r5
 800e240:	4d7c      	ldr	r5, [pc, #496]	; (800e434 <xmp3_FDCT32+0x3ac>)
 800e242:	fb85 6101 	smull	r6, r1, r5, r1
 800e246:	1915      	adds	r5, r2, r4
 800e248:	0049      	lsls	r1, r1, #1
 800e24a:	1b12      	subs	r2, r2, r4
 800e24c:	4c7a      	ldr	r4, [pc, #488]	; (800e438 <xmp3_FDCT32+0x3b0>)
 800e24e:	6185      	str	r5, [r0, #24]
 800e250:	fb84 5202 	smull	r5, r2, r4, r2
 800e254:	0092      	lsls	r2, r2, #2
 800e256:	6242      	str	r2, [r0, #36]	; 0x24
 800e258:	185a      	adds	r2, r3, r1
 800e25a:	1a5b      	subs	r3, r3, r1
 800e25c:	6582      	str	r2, [r0, #88]	; 0x58
 800e25e:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(7, 1, 1, 4);
 800e262:	69c6      	ldr	r6, [r0, #28]
	D32FP(6, 1, 1, 2);
 800e264:	009b      	lsls	r3, r3, #2
	D32FP(7, 1, 1, 4);
 800e266:	6e02      	ldr	r2, [r0, #96]	; 0x60
	D32FP(6, 1, 1, 2);
 800e268:	6643      	str	r3, [r0, #100]	; 0x64
	D32FP(7, 1, 1, 4);
 800e26a:	6a04      	ldr	r4, [r0, #32]
 800e26c:	1ab3      	subs	r3, r6, r2
 800e26e:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 800e270:	4432      	add	r2, r6
 800e272:	4972      	ldr	r1, [pc, #456]	; (800e43c <xmp3_FDCT32+0x3b4>)
 800e274:	fb81 6303 	smull	r6, r3, r1, r3
 800e278:	1b61      	subs	r1, r4, r5
 800e27a:	005b      	lsls	r3, r3, #1
 800e27c:	442c      	add	r4, r5
 800e27e:	4d70      	ldr	r5, [pc, #448]	; (800e440 <xmp3_FDCT32+0x3b8>)
 800e280:	fb85 6101 	smull	r6, r1, r5, r1
 800e284:	1915      	adds	r5, r2, r4
 800e286:	0049      	lsls	r1, r1, #1
 800e288:	1b12      	subs	r2, r2, r4
 800e28a:	4c6e      	ldr	r4, [pc, #440]	; (800e444 <xmp3_FDCT32+0x3bc>)
 800e28c:	61c5      	str	r5, [r0, #28]
 800e28e:	fb84 5202 	smull	r5, r2, r4, r2
 800e292:	0112      	lsls	r2, r2, #4
 800e294:	6202      	str	r2, [r0, #32]
 800e296:	185a      	adds	r2, r3, r1
 800e298:	1a5b      	subs	r3, r3, r1
 800e29a:	65c2      	str	r2, [r0, #92]	; 0x5c
 800e29c:	fb84 2303 	smull	r2, r3, r4, r3
 800e2a0:	011b      	lsls	r3, r3, #4
 800e2a2:	f100 02a0 	add.w	r2, r0, #160	; 0xa0
 800e2a6:	f8df a1a4 	ldr.w	sl, [pc, #420]	; 800e44c <xmp3_FDCT32+0x3c4>
 800e2aa:	6603      	str	r3, [r0, #96]	; 0x60

	/* second pass */
	for (i = 4; i > 0; i--) {
 800e2ac:	f100 0320 	add.w	r3, r0, #32
 800e2b0:	9200      	str	r2, [sp, #0]
 800e2b2:	e9cd b004 	strd	fp, r0, [sp, #16]
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 800e2b6:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800e2ba:	f853 6c20 	ldr.w	r6, [r3, #-32]
 800e2be:	e953 5705 	ldrd	r5, r7, [r3, #-20]
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 800e2c2:	1ab1      	subs	r1, r6, r2
 800e2c4:	4416      	add	r6, r2
 800e2c6:	f8da 2060 	ldr.w	r2, [sl, #96]	; 0x60
 800e2ca:	fb82 4101 	smull	r4, r1, r2, r1
 800e2ce:	004c      	lsls	r4, r1, #1
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800e2d0:	1bea      	subs	r2, r5, r7
 800e2d2:	f8da 1064 	ldr.w	r1, [sl, #100]	; 0x64
 800e2d6:	443d      	add	r5, r7
 800e2d8:	fb81 7202 	smull	r7, r2, r1, r2
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e2dc:	eba6 0e05 	sub.w	lr, r6, r5
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 800e2e0:	00d1      	lsls	r1, r2, #3
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e2e2:	442e      	add	r6, r5
 800e2e4:	f8da 5068 	ldr.w	r5, [sl, #104]	; 0x68
 800e2e8:	fb85 2e0e 	smull	r2, lr, r5, lr
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e2ec:	1a62      	subs	r2, r4, r1
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 800e2ee:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e2f2:	4421      	add	r1, r4
 800e2f4:	fb85 4202 	smull	r4, r2, r5, r2

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e2f8:	f853 9c1c 	ldr.w	r9, [r3, #-28]
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 800e2fc:	0052      	lsls	r2, r2, #1
		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e2fe:	f853 cc08 	ldr.w	ip, [r3, #-8]
 800e302:	f853 4c18 	ldr.w	r4, [r3, #-24]
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800e306:	eba9 050c 	sub.w	r5, r9, ip
		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 800e30a:	f853 7c0c 	ldr.w	r7, [r3, #-12]
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 800e30e:	44e1      	add	r9, ip
 800e310:	f8da 006c 	ldr.w	r0, [sl, #108]	; 0x6c
 800e314:	fb80 c505 	smull	ip, r5, r0, r5
 800e318:	ea4f 0c45 	mov.w	ip, r5, lsl #1
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800e31c:	1be5      	subs	r5, r4, r7
 800e31e:	4427      	add	r7, r4
 800e320:	f8da 4070 	ldr.w	r4, [sl, #112]	; 0x70
 800e324:	fb84 8505 	smull	r8, r5, r4, r5
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e328:	eba9 0407 	sub.w	r4, r9, r7
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 800e32c:	006d      	lsls	r5, r5, #1
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e32e:	44b9      	add	r9, r7
 800e330:	f8da 8074 	ldr.w	r8, [sl, #116]	; 0x74
 800e334:	fb88 7404 	smull	r7, r4, r8, r4
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800e338:	ebac 0705 	sub.w	r7, ip, r5
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 800e33c:	00a4      	lsls	r4, r4, #2
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 800e33e:	4465      	add	r5, ip
 800e340:	fb88 c707 	smull	ip, r7, r8, r7
 800e344:	4840      	ldr	r0, [pc, #256]	; (800e448 <xmp3_FDCT32+0x3c0>)
 800e346:	00bf      	lsls	r7, r7, #2

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e348:	eba6 0809 	sub.w	r8, r6, r9
 800e34c:	fb80 c808 	smull	ip, r8, r0, r8
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800e350:	ebae 0c04 	sub.w	ip, lr, r4
 800e354:	fb80 bc0c 	smull	fp, ip, r0, ip
 800e358:	4474      	add	r4, lr
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e35a:	444e      	add	r6, r9
		buf[0] = b0;	    buf[1] = b1;
		buf[2] = b2 + b3;	buf[3] = b3;
 800e35c:	eb04 044c 	add.w	r4, r4, ip, lsl #1
		buf[0] = b0;	    buf[1] = b1;
 800e360:	f843 6c20 	str.w	r6, [r3, #-32]
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 800e364:	ea4f 0648 	mov.w	r6, r8, lsl #1
		buf[2] = b2 + b3;	buf[3] = b3;
 800e368:	f843 4c18 	str.w	r4, [r3, #-24]
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 800e36c:	ea4f 044c 	mov.w	r4, ip, lsl #1
		buf[0] = b0;	    buf[1] = b1;
 800e370:	f843 6c1c 	str.w	r6, [r3, #-28]
		buf[2] = b2 + b3;	buf[3] = b3;
 800e374:	f843 4c14 	str.w	r4, [r3, #-20]

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e378:	1b4c      	subs	r4, r1, r5
 800e37a:	fb80 6404 	smull	r6, r4, r0, r4
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e37e:	1bd6      	subs	r6, r2, r7
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e380:	0064      	lsls	r4, r4, #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e382:	443a      	add	r2, r7
 800e384:	fb80 7606 	smull	r7, r6, r0, r6
		b6 += b7;
 800e388:	eb02 0246 	add.w	r2, r2, r6, lsl #1
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 800e38c:	4429      	add	r1, r5
	for (i = 4; i > 0; i--) {
 800e38e:	3320      	adds	r3, #32
 800e390:	f10a 0a18 	add.w	sl, sl, #24
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e394:	4411      	add	r1, r2
		buf[6] = b5 + b6;	buf[7] = b7;
 800e396:	4422      	add	r2, r4
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e398:	eb04 0446 	add.w	r4, r4, r6, lsl #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 800e39c:	0076      	lsls	r6, r6, #1
		buf[6] = b5 + b6;	buf[7] = b7;
 800e39e:	f843 2c28 	str.w	r2, [r3, #-40]
	for (i = 4; i > 0; i--) {
 800e3a2:	9a00      	ldr	r2, [sp, #0]
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 800e3a4:	f843 1c30 	str.w	r1, [r3, #-48]
 800e3a8:	f843 4c2c 	str.w	r4, [r3, #-44]
		buf[6] = b5 + b6;	buf[7] = b7;
 800e3ac:	f843 6c24 	str.w	r6, [r3, #-36]
	for (i = 4; i > 0; i--) {
 800e3b0:	4293      	cmp	r3, r2
 800e3b2:	d180      	bne.n	800e2b6 <xmp3_FDCT32+0x22e>
		buf += 8;
	}
	buf -= 32;	/* reset */

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e3b4:	e9dd 3102 	ldrd	r3, r1, [sp, #8]
 800e3b8:	e9dd b004 	ldrd	fp, r0, [sp, #16]
 800e3bc:	1a5b      	subs	r3, r3, r1
 800e3be:	f003 0307 	and.w	r3, r3, #7
 800e3c2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800e3c6:	009a      	lsls	r2, r3, #2
 800e3c8:	2900      	cmp	r1, #0
 800e3ca:	f000 832c 	beq.w	800ea26 <xmp3_FDCT32+0x99e>
 800e3ce:	9d01      	ldr	r5, [sp, #4]
	s = buf[ 0];				d[0] = d[8] = s;
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e3d0:	9902      	ldr	r1, [sp, #8]
	s = buf[ 0];				d[0] = d[8] = s;
 800e3d2:	6804      	ldr	r4, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e3d4:	18ae      	adds	r6, r5, r2
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e3d6:	0089      	lsls	r1, r1, #2
 800e3d8:	462f      	mov	r7, r5
	s = buf[ 0];				d[0] = d[8] = s;
 800e3da:	6234      	str	r4, [r6, #32]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e3dc:	f501 5188 	add.w	r1, r1, #4352	; 0x1100
	s = buf[ 0];				d[0] = d[8] = s;
 800e3e0:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e3e4:	2400      	movs	r4, #0
 800e3e6:	e033      	b.n	800e450 <xmp3_FDCT32+0x3c8>
 800e3e8:	4013c251 	.word	0x4013c251
 800e3ec:	518522fb 	.word	0x518522fb
 800e3f0:	404f4672 	.word	0x404f4672
 800e3f4:	40b345bd 	.word	0x40b345bd
 800e3f8:	6d0b20cf 	.word	0x6d0b20cf
 800e3fc:	42e13c10 	.word	0x42e13c10
 800e400:	41fa2d6d 	.word	0x41fa2d6d
 800e404:	41d95790 	.word	0x41d95790
 800e408:	48919f44 	.word	0x48919f44
 800e40c:	43f93421 	.word	0x43f93421
 800e410:	5efc8d96 	.word	0x5efc8d96
 800e414:	52cb0e63 	.word	0x52cb0e63
 800e418:	46cc1bc4 	.word	0x46cc1bc4
 800e41c:	4ad81a97 	.word	0x4ad81a97
 800e420:	64e2402e 	.word	0x64e2402e
 800e424:	4a9d9cf0 	.word	0x4a9d9cf0
 800e428:	7c7d1db3 	.word	0x7c7d1db3
 800e42c:	43e224a9 	.word	0x43e224a9
 800e430:	4fae3711 	.word	0x4fae3711
 800e434:	6b6fcf26 	.word	0x6b6fcf26
 800e438:	6e3c92c1 	.word	0x6e3c92c1
 800e43c:	56601ea7 	.word	0x56601ea7
 800e440:	5f4cf6eb 	.word	0x5f4cf6eb
 800e444:	519e4e04 	.word	0x519e4e04
 800e448:	5a82799a 	.word	0x5a82799a
 800e44c:	08017480 	.word	0x08017480
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
	s = buf[15];				d[0] = d[8] = s;	d += 64;
	s = tmp;					d[0] = d[8] = s;

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e450:	f5a2 627c 	sub.w	r2, r2, #4032	; 0xfc0
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800e454:	187b      	adds	r3, r7, r1
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e456:	4414      	add	r4, r2
	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800e458:	6842      	ldr	r2, [r0, #4]
 800e45a:	621a      	str	r2, [r3, #32]
 800e45c:	507a      	str	r2, [r7, r1]
	tmp = buf[25] + buf[29];
 800e45e:	6f41      	ldr	r1, [r0, #116]	; 0x74
 800e460:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800e462:	440a      	add	r2, r1
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e464:	6c41      	ldr	r1, [r0, #68]	; 0x44
 800e466:	4411      	add	r1, r2
 800e468:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
 800e46c:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 800e470:	6b45      	ldr	r5, [r0, #52]	; 0x34
 800e472:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800e474:	4429      	add	r1, r5
 800e476:	f8c3 1220 	str.w	r1, [r3, #544]	; 0x220
 800e47a:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800e47e:	6d41      	ldr	r1, [r0, #84]	; 0x54
 800e480:	440a      	add	r2, r1
 800e482:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
 800e486:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
	tmp = buf[29] + buf[27];
 800e48a:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 800e48c:	6f42      	ldr	r2, [r0, #116]	; 0x74
 800e48e:	440a      	add	r2, r1
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 800e490:	6941      	ldr	r1, [r0, #20]
 800e492:	f8c3 1420 	str.w	r1, [r3, #1056]	; 0x420
 800e496:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 800e49a:	6d41      	ldr	r1, [r0, #84]	; 0x54
 800e49c:	4411      	add	r1, r2
 800e49e:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
 800e4a2:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 800e4a6:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 800e4a8:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800e4aa:	4429      	add	r1, r5
 800e4ac:	f8c3 1620 	str.w	r1, [r3, #1568]	; 0x620
 800e4b0:	f8c3 1600 	str.w	r1, [r3, #1536]	; 0x600
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800e4b4:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800e4b6:	440a      	add	r2, r1
 800e4b8:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
 800e4bc:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
	tmp = buf[27] + buf[31];
 800e4c0:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 800e4c2:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
 800e4c4:	440a      	add	r2, r1
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 800e4c6:	68c1      	ldr	r1, [r0, #12]
 800e4c8:	f8c3 1820 	str.w	r1, [r3, #2080]	; 0x820
 800e4cc:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 800e4d0:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 800e4d2:	4411      	add	r1, r2
 800e4d4:	f8c3 1920 	str.w	r1, [r3, #2336]	; 0x920
 800e4d8:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 800e4dc:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
 800e4de:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800e4e0:	4429      	add	r1, r5
 800e4e2:	f8c3 1a20 	str.w	r1, [r3, #2592]	; 0xa20
 800e4e6:	f8c3 1a00 	str.w	r1, [r3, #2560]	; 0xa00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800e4ea:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 800e4ec:	440a      	add	r2, r1
 800e4ee:	f8c3 2b20 	str.w	r2, [r3, #2848]	; 0xb20
 800e4f2:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800e4f6:	69c2      	ldr	r2, [r0, #28]
	tmp = buf[31];
 800e4f8:	6fc1      	ldr	r1, [r0, #124]	; 0x7c
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 800e4fa:	f8c3 2c20 	str.w	r2, [r3, #3104]	; 0xc20
 800e4fe:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 800e502:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800e504:	440a      	add	r2, r1
 800e506:	f8c3 2d20 	str.w	r2, [r3, #3360]	; 0xd20
 800e50a:	f8c3 2d00 	str.w	r2, [r3, #3328]	; 0xd00
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800e50e:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
	s = tmp;					d[0] = d[8] = s;
 800e510:	f8c3 1f20 	str.w	r1, [r3, #3872]	; 0xf20
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 800e514:	f8c3 2e20 	str.w	r2, [r3, #3616]	; 0xe20
 800e518:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800e51c:	193a      	adds	r2, r7, r4
	s = tmp;					d[0] = d[8] = s;
 800e51e:	f8c3 1f00 	str.w	r1, [r3, #3840]	; 0xf00

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 800e522:	6841      	ldr	r1, [r0, #4]
 800e524:	6211      	str	r1, [r2, #32]
 800e526:	5139      	str	r1, [r7, r4]

	tmp = buf[30] + buf[25];
 800e528:	6e45      	ldr	r5, [r0, #100]	; 0x64
 800e52a:	6f81      	ldr	r1, [r0, #120]	; 0x78
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e52c:	6c47      	ldr	r7, [r0, #68]	; 0x44
	tmp = buf[30] + buf[25];
 800e52e:	4429      	add	r1, r5
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 800e530:	440f      	add	r7, r1
 800e532:	f8c2 7120 	str.w	r7, [r2, #288]	; 0x120
 800e536:	f8c2 7100 	str.w	r7, [r2, #256]	; 0x100
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 800e53a:	6a47      	ldr	r7, [r0, #36]	; 0x24
 800e53c:	6b85      	ldr	r5, [r0, #56]	; 0x38
 800e53e:	443d      	add	r5, r7
 800e540:	f8c2 5220 	str.w	r5, [r2, #544]	; 0x220
 800e544:	f8c2 5200 	str.w	r5, [r2, #512]	; 0x200
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e548:	6d87      	ldr	r7, [r0, #88]	; 0x58
 800e54a:	4439      	add	r1, r7
 800e54c:	f8c2 1320 	str.w	r1, [r2, #800]	; 0x320
 800e550:	f8c2 1300 	str.w	r1, [r2, #768]	; 0x300
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 800e554:	6981      	ldr	r1, [r0, #24]
 800e556:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
 800e55a:	f8c2 1400 	str.w	r1, [r2, #1024]	; 0x400

	tmp = buf[26] + buf[30];
 800e55e:	6f85      	ldr	r5, [r0, #120]	; 0x78
 800e560:	6e81      	ldr	r1, [r0, #104]	; 0x68
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e562:	6d87      	ldr	r7, [r0, #88]	; 0x58
	tmp = buf[26] + buf[30];
 800e564:	4429      	add	r1, r5
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 800e566:	440f      	add	r7, r1
 800e568:	f8c2 7520 	str.w	r7, [r2, #1312]	; 0x520
 800e56c:	f8c2 7500 	str.w	r7, [r2, #1280]	; 0x500
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 800e570:	6b87      	ldr	r7, [r0, #56]	; 0x38
 800e572:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800e574:	443d      	add	r5, r7
 800e576:	f8c2 5620 	str.w	r5, [r2, #1568]	; 0x620
 800e57a:	f8c2 5600 	str.w	r5, [r2, #1536]	; 0x600
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e57e:	6c87      	ldr	r7, [r0, #72]	; 0x48
 800e580:	4439      	add	r1, r7
 800e582:	f8c2 1720 	str.w	r1, [r2, #1824]	; 0x720
 800e586:	f8c2 1700 	str.w	r1, [r2, #1792]	; 0x700
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 800e58a:	6881      	ldr	r1, [r0, #8]
 800e58c:	f8c2 1820 	str.w	r1, [r2, #2080]	; 0x820
 800e590:	f8c2 1800 	str.w	r1, [r2, #2048]	; 0x800

	tmp = buf[28] + buf[26];
 800e594:	6e85      	ldr	r5, [r0, #104]	; 0x68
 800e596:	6f01      	ldr	r1, [r0, #112]	; 0x70
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e598:	6c87      	ldr	r7, [r0, #72]	; 0x48
	tmp = buf[28] + buf[26];
 800e59a:	4429      	add	r1, r5
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 800e59c:	440f      	add	r7, r1
 800e59e:	f8c2 7920 	str.w	r7, [r2, #2336]	; 0x920
 800e5a2:	f8c2 7900 	str.w	r7, [r2, #2304]	; 0x900
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 800e5a6:	6a87      	ldr	r7, [r0, #40]	; 0x28
 800e5a8:	6b05      	ldr	r5, [r0, #48]	; 0x30
 800e5aa:	443d      	add	r5, r7
 800e5ac:	f8c2 5a20 	str.w	r5, [r2, #2592]	; 0xa20
 800e5b0:	f8c2 5a00 	str.w	r5, [r2, #2560]	; 0xa00
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e5b4:	6d07      	ldr	r7, [r0, #80]	; 0x50
 800e5b6:	4439      	add	r1, r7
 800e5b8:	f8c2 1b20 	str.w	r1, [r2, #2848]	; 0xb20
 800e5bc:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 800e5c0:	6901      	ldr	r1, [r0, #16]
 800e5c2:	f8c2 1c20 	str.w	r1, [r2, #3104]	; 0xc20
 800e5c6:	f8c2 1c00 	str.w	r1, [r2, #3072]	; 0xc00

	tmp = buf[24] + buf[28];
 800e5ca:	6f05      	ldr	r5, [r0, #112]	; 0x70
 800e5cc:	6e01      	ldr	r1, [r0, #96]	; 0x60
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e5ce:	6d07      	ldr	r7, [r0, #80]	; 0x50
	tmp = buf[24] + buf[28];
 800e5d0:	4429      	add	r1, r5
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 800e5d2:	440f      	add	r7, r1
 800e5d4:	f8c2 7d20 	str.w	r7, [r2, #3360]	; 0xd20
 800e5d8:	f8c2 7d00 	str.w	r7, [r2, #3328]	; 0xd00
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 800e5dc:	6a05      	ldr	r5, [r0, #32]
 800e5de:	6b07      	ldr	r7, [r0, #48]	; 0x30
 800e5e0:	443d      	add	r5, r7
 800e5e2:	f8c2 5e20 	str.w	r5, [r2, #3616]	; 0xe20
 800e5e6:	f8c2 5e00 	str.w	r5, [r2, #3584]	; 0xe00
	s = buf[16] + tmp;			d[0] = d[8] = s;
 800e5ea:	6c05      	ldr	r5, [r0, #64]	; 0x40
 800e5ec:	4429      	add	r1, r5
 800e5ee:	f8c2 1f20 	str.w	r1, [r2, #3872]	; 0xf20
 800e5f2:	f8c2 1f00 	str.w	r1, [r2, #3840]	; 0xf00

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 800e5f6:	f1bb 0f00 	cmp.w	fp, #0
 800e5fa:	f000 8211 	beq.w	800ea20 <xmp3_FDCT32+0x998>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 800e5fe:	f1cb 011f 	rsb	r1, fp, #31
 800e602:	6835      	ldr	r5, [r6, #0]
 800e604:	fa45 f001 	asr.w	r0, r5, r1
 800e608:	17ef      	asrs	r7, r5, #31
 800e60a:	ebb0 7fe5 	cmp.w	r0, r5, asr #31
 800e60e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800e612:	fa20 f00b 	lsr.w	r0, r0, fp
 800e616:	f100 30ff 	add.w	r0, r0, #4294967295
 800e61a:	bf18      	it	ne
 800e61c:	ea80 0507 	eorne.w	r5, r0, r7
 800e620:	fa05 f50b 	lsl.w	r5, r5, fp
 800e624:	6235      	str	r5, [r6, #32]
 800e626:	6035      	str	r5, [r6, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
		for (i = 16; i <= 31; i++) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800e628:	681d      	ldr	r5, [r3, #0]
 800e62a:	fa45 f601 	asr.w	r6, r5, r1
 800e62e:	17ef      	asrs	r7, r5, #31
 800e630:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e634:	bf18      	it	ne
 800e636:	ea80 0507 	eorne.w	r5, r0, r7
 800e63a:	fa05 f50b 	lsl.w	r5, r5, fp
 800e63e:	621d      	str	r5, [r3, #32]
 800e640:	601d      	str	r5, [r3, #0]
 800e642:	f8d3 5100 	ldr.w	r5, [r3, #256]	; 0x100
 800e646:	fa45 f601 	asr.w	r6, r5, r1
 800e64a:	17ef      	asrs	r7, r5, #31
 800e64c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e650:	bf18      	it	ne
 800e652:	ea80 0507 	eorne.w	r5, r0, r7
 800e656:	fa05 f50b 	lsl.w	r5, r5, fp
 800e65a:	f8c3 5120 	str.w	r5, [r3, #288]	; 0x120
 800e65e:	f8c3 5100 	str.w	r5, [r3, #256]	; 0x100
 800e662:	f8d3 5200 	ldr.w	r5, [r3, #512]	; 0x200
 800e666:	fa45 f601 	asr.w	r6, r5, r1
 800e66a:	17ef      	asrs	r7, r5, #31
 800e66c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e670:	bf18      	it	ne
 800e672:	ea80 0507 	eorne.w	r5, r0, r7
 800e676:	fa05 f50b 	lsl.w	r5, r5, fp
 800e67a:	f8c3 5220 	str.w	r5, [r3, #544]	; 0x220
 800e67e:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
 800e682:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
 800e686:	fa45 f601 	asr.w	r6, r5, r1
 800e68a:	17ef      	asrs	r7, r5, #31
 800e68c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e690:	bf18      	it	ne
 800e692:	ea80 0507 	eorne.w	r5, r0, r7
 800e696:	fa05 f50b 	lsl.w	r5, r5, fp
 800e69a:	f8c3 5320 	str.w	r5, [r3, #800]	; 0x320
 800e69e:	f8c3 5300 	str.w	r5, [r3, #768]	; 0x300
 800e6a2:	f8d3 5400 	ldr.w	r5, [r3, #1024]	; 0x400
 800e6a6:	fa45 f601 	asr.w	r6, r5, r1
 800e6aa:	17ef      	asrs	r7, r5, #31
 800e6ac:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e6b0:	bf18      	it	ne
 800e6b2:	ea80 0507 	eorne.w	r5, r0, r7
 800e6b6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e6ba:	f8c3 5420 	str.w	r5, [r3, #1056]	; 0x420
 800e6be:	f8c3 5400 	str.w	r5, [r3, #1024]	; 0x400
 800e6c2:	f8d3 5500 	ldr.w	r5, [r3, #1280]	; 0x500
 800e6c6:	fa45 f601 	asr.w	r6, r5, r1
 800e6ca:	17ef      	asrs	r7, r5, #31
 800e6cc:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e6d0:	bf18      	it	ne
 800e6d2:	ea80 0507 	eorne.w	r5, r0, r7
 800e6d6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e6da:	f8c3 5520 	str.w	r5, [r3, #1312]	; 0x520
 800e6de:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
 800e6e2:	f8d3 5600 	ldr.w	r5, [r3, #1536]	; 0x600
 800e6e6:	fa45 f601 	asr.w	r6, r5, r1
 800e6ea:	17ef      	asrs	r7, r5, #31
 800e6ec:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e6f0:	bf18      	it	ne
 800e6f2:	ea80 0507 	eorne.w	r5, r0, r7
 800e6f6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e6fa:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
 800e6fe:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
 800e702:	f8d3 5700 	ldr.w	r5, [r3, #1792]	; 0x700
 800e706:	fa45 f601 	asr.w	r6, r5, r1
 800e70a:	17ef      	asrs	r7, r5, #31
 800e70c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e710:	bf18      	it	ne
 800e712:	ea80 0507 	eorne.w	r5, r0, r7
 800e716:	fa05 f50b 	lsl.w	r5, r5, fp
 800e71a:	f8c3 5720 	str.w	r5, [r3, #1824]	; 0x720
 800e71e:	f8c3 5700 	str.w	r5, [r3, #1792]	; 0x700
 800e722:	f8d3 5800 	ldr.w	r5, [r3, #2048]	; 0x800
 800e726:	fa45 f601 	asr.w	r6, r5, r1
 800e72a:	17ef      	asrs	r7, r5, #31
 800e72c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e730:	bf18      	it	ne
 800e732:	ea80 0507 	eorne.w	r5, r0, r7
 800e736:	fa05 f50b 	lsl.w	r5, r5, fp
 800e73a:	f8c3 5820 	str.w	r5, [r3, #2080]	; 0x820
 800e73e:	f8c3 5800 	str.w	r5, [r3, #2048]	; 0x800
 800e742:	f8d3 5900 	ldr.w	r5, [r3, #2304]	; 0x900
 800e746:	fa45 f601 	asr.w	r6, r5, r1
 800e74a:	17ef      	asrs	r7, r5, #31
 800e74c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e750:	bf18      	it	ne
 800e752:	ea80 0507 	eorne.w	r5, r0, r7
 800e756:	fa05 f50b 	lsl.w	r5, r5, fp
 800e75a:	f8c3 5920 	str.w	r5, [r3, #2336]	; 0x920
 800e75e:	f8c3 5900 	str.w	r5, [r3, #2304]	; 0x900
 800e762:	f8d3 5a00 	ldr.w	r5, [r3, #2560]	; 0xa00
 800e766:	fa45 f601 	asr.w	r6, r5, r1
 800e76a:	17ef      	asrs	r7, r5, #31
 800e76c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e770:	bf18      	it	ne
 800e772:	ea80 0507 	eorne.w	r5, r0, r7
 800e776:	fa05 f50b 	lsl.w	r5, r5, fp
 800e77a:	f8c3 5a20 	str.w	r5, [r3, #2592]	; 0xa20
 800e77e:	f8c3 5a00 	str.w	r5, [r3, #2560]	; 0xa00
 800e782:	f8d3 5b00 	ldr.w	r5, [r3, #2816]	; 0xb00
 800e786:	fa45 f601 	asr.w	r6, r5, r1
 800e78a:	17ef      	asrs	r7, r5, #31
 800e78c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e790:	bf18      	it	ne
 800e792:	ea80 0507 	eorne.w	r5, r0, r7
 800e796:	fa05 f50b 	lsl.w	r5, r5, fp
 800e79a:	f8c3 5b20 	str.w	r5, [r3, #2848]	; 0xb20
 800e79e:	f8c3 5b00 	str.w	r5, [r3, #2816]	; 0xb00
 800e7a2:	f8d3 5c00 	ldr.w	r5, [r3, #3072]	; 0xc00
 800e7a6:	fa45 f601 	asr.w	r6, r5, r1
 800e7aa:	17ef      	asrs	r7, r5, #31
 800e7ac:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e7b0:	bf18      	it	ne
 800e7b2:	ea80 0507 	eorne.w	r5, r0, r7
 800e7b6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e7ba:	f8c3 5c20 	str.w	r5, [r3, #3104]	; 0xc20
 800e7be:	f8c3 5c00 	str.w	r5, [r3, #3072]	; 0xc00
 800e7c2:	f8d3 5d00 	ldr.w	r5, [r3, #3328]	; 0xd00
 800e7c6:	fa45 f601 	asr.w	r6, r5, r1
 800e7ca:	17ef      	asrs	r7, r5, #31
 800e7cc:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e7d0:	bf18      	it	ne
 800e7d2:	ea80 0507 	eorne.w	r5, r0, r7
 800e7d6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e7da:	f8c3 5d20 	str.w	r5, [r3, #3360]	; 0xd20
 800e7de:	f8c3 5d00 	str.w	r5, [r3, #3328]	; 0xd00
 800e7e2:	f8d3 5e00 	ldr.w	r5, [r3, #3584]	; 0xe00
 800e7e6:	fa45 f601 	asr.w	r6, r5, r1
 800e7ea:	17ef      	asrs	r7, r5, #31
 800e7ec:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e7f0:	bf18      	it	ne
 800e7f2:	ea80 0507 	eorne.w	r5, r0, r7
 800e7f6:	fa05 f50b 	lsl.w	r5, r5, fp
 800e7fa:	f8c3 5e20 	str.w	r5, [r3, #3616]	; 0xe20
 800e7fe:	f8c3 5e00 	str.w	r5, [r3, #3584]	; 0xe00
 800e802:	f8d3 5f00 	ldr.w	r5, [r3, #3840]	; 0xf00
 800e806:	fa45 f601 	asr.w	r6, r5, r1
 800e80a:	17ef      	asrs	r7, r5, #31
 800e80c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800e810:	bf18      	it	ne
 800e812:	ea80 0507 	eorne.w	r5, r0, r7
 800e816:	fa05 f50b 	lsl.w	r5, r5, fp
 800e81a:	f8c3 5f20 	str.w	r5, [r3, #3872]	; 0xf20
 800e81e:	f8c3 5f00 	str.w	r5, [r3, #3840]	; 0xf00
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		for (i = 15; i >= 0; i--) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 800e822:	9b01      	ldr	r3, [sp, #4]
 800e824:	591b      	ldr	r3, [r3, r4]
 800e826:	fa43 f501 	asr.w	r5, r3, r1
 800e82a:	17de      	asrs	r6, r3, #31
 800e82c:	ebb5 7fe3 	cmp.w	r5, r3, asr #31
 800e830:	9d01      	ldr	r5, [sp, #4]
 800e832:	bf18      	it	ne
 800e834:	ea80 0306 	eorne.w	r3, r0, r6
 800e838:	fa03 f30b 	lsl.w	r3, r3, fp
 800e83c:	6213      	str	r3, [r2, #32]
 800e83e:	512b      	str	r3, [r5, r4]
 800e840:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 800e844:	fa43 f401 	asr.w	r4, r3, r1
 800e848:	17dd      	asrs	r5, r3, #31
 800e84a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e84e:	bf18      	it	ne
 800e850:	ea80 0305 	eorne.w	r3, r0, r5
 800e854:	fa03 f30b 	lsl.w	r3, r3, fp
 800e858:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
 800e85c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 800e860:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800e864:	fa43 f401 	asr.w	r4, r3, r1
 800e868:	17dd      	asrs	r5, r3, #31
 800e86a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e86e:	bf18      	it	ne
 800e870:	ea85 0300 	eorne.w	r3, r5, r0
 800e874:	fa03 f30b 	lsl.w	r3, r3, fp
 800e878:	f8c2 3220 	str.w	r3, [r2, #544]	; 0x220
 800e87c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
 800e880:	f8d2 3300 	ldr.w	r3, [r2, #768]	; 0x300
 800e884:	fa43 f401 	asr.w	r4, r3, r1
 800e888:	17dd      	asrs	r5, r3, #31
 800e88a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e88e:	bf18      	it	ne
 800e890:	ea80 0305 	eorne.w	r3, r0, r5
 800e894:	fa03 f30b 	lsl.w	r3, r3, fp
 800e898:	f8c2 3320 	str.w	r3, [r2, #800]	; 0x320
 800e89c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
 800e8a0:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 800e8a4:	fa43 f401 	asr.w	r4, r3, r1
 800e8a8:	17dd      	asrs	r5, r3, #31
 800e8aa:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e8ae:	bf18      	it	ne
 800e8b0:	ea80 0305 	eorne.w	r3, r0, r5
 800e8b4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e8b8:	f8c2 3420 	str.w	r3, [r2, #1056]	; 0x420
 800e8bc:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 800e8c0:	f8d2 3500 	ldr.w	r3, [r2, #1280]	; 0x500
 800e8c4:	fa43 f401 	asr.w	r4, r3, r1
 800e8c8:	17dd      	asrs	r5, r3, #31
 800e8ca:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e8ce:	bf18      	it	ne
 800e8d0:	ea80 0305 	eorne.w	r3, r0, r5
 800e8d4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e8d8:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
 800e8dc:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
 800e8e0:	f8d2 3600 	ldr.w	r3, [r2, #1536]	; 0x600
 800e8e4:	fa43 f401 	asr.w	r4, r3, r1
 800e8e8:	17dd      	asrs	r5, r3, #31
 800e8ea:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e8ee:	bf18      	it	ne
 800e8f0:	ea80 0305 	eorne.w	r3, r0, r5
 800e8f4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e8f8:	f8c2 3620 	str.w	r3, [r2, #1568]	; 0x620
 800e8fc:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
 800e900:	f8d2 3700 	ldr.w	r3, [r2, #1792]	; 0x700
 800e904:	fa43 f401 	asr.w	r4, r3, r1
 800e908:	17dd      	asrs	r5, r3, #31
 800e90a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e90e:	bf18      	it	ne
 800e910:	ea80 0305 	eorne.w	r3, r0, r5
 800e914:	fa03 f30b 	lsl.w	r3, r3, fp
 800e918:	f8c2 3720 	str.w	r3, [r2, #1824]	; 0x720
 800e91c:	f8c2 3700 	str.w	r3, [r2, #1792]	; 0x700
 800e920:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 800e924:	fa43 f401 	asr.w	r4, r3, r1
 800e928:	17dd      	asrs	r5, r3, #31
 800e92a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e92e:	bf18      	it	ne
 800e930:	ea80 0305 	eorne.w	r3, r0, r5
 800e934:	fa03 f30b 	lsl.w	r3, r3, fp
 800e938:	f8c2 3820 	str.w	r3, [r2, #2080]	; 0x820
 800e93c:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 800e940:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 800e944:	fa43 f401 	asr.w	r4, r3, r1
 800e948:	17dd      	asrs	r5, r3, #31
 800e94a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e94e:	bf18      	it	ne
 800e950:	ea80 0305 	eorne.w	r3, r0, r5
 800e954:	fa03 f30b 	lsl.w	r3, r3, fp
 800e958:	f8c2 3920 	str.w	r3, [r2, #2336]	; 0x920
 800e95c:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
 800e960:	f8d2 3a00 	ldr.w	r3, [r2, #2560]	; 0xa00
 800e964:	fa43 f401 	asr.w	r4, r3, r1
 800e968:	17dd      	asrs	r5, r3, #31
 800e96a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e96e:	bf18      	it	ne
 800e970:	ea80 0305 	eorne.w	r3, r0, r5
 800e974:	fa03 f30b 	lsl.w	r3, r3, fp
 800e978:	f8c2 3a20 	str.w	r3, [r2, #2592]	; 0xa20
 800e97c:	f8c2 3a00 	str.w	r3, [r2, #2560]	; 0xa00
 800e980:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800e984:	fa43 f401 	asr.w	r4, r3, r1
 800e988:	17dd      	asrs	r5, r3, #31
 800e98a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e98e:	bf18      	it	ne
 800e990:	ea80 0305 	eorne.w	r3, r0, r5
 800e994:	fa03 f30b 	lsl.w	r3, r3, fp
 800e998:	f8c2 3b20 	str.w	r3, [r2, #2848]	; 0xb20
 800e99c:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800e9a0:	f8d2 3c00 	ldr.w	r3, [r2, #3072]	; 0xc00
 800e9a4:	fa43 f401 	asr.w	r4, r3, r1
 800e9a8:	17dd      	asrs	r5, r3, #31
 800e9aa:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e9ae:	bf18      	it	ne
 800e9b0:	ea85 0300 	eorne.w	r3, r5, r0
 800e9b4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e9b8:	f8c2 3c20 	str.w	r3, [r2, #3104]	; 0xc20
 800e9bc:	f8c2 3c00 	str.w	r3, [r2, #3072]	; 0xc00
 800e9c0:	f8d2 3d00 	ldr.w	r3, [r2, #3328]	; 0xd00
 800e9c4:	fa43 f401 	asr.w	r4, r3, r1
 800e9c8:	17dd      	asrs	r5, r3, #31
 800e9ca:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e9ce:	bf18      	it	ne
 800e9d0:	ea80 0305 	eorne.w	r3, r0, r5
 800e9d4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e9d8:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
 800e9dc:	f8c2 3d00 	str.w	r3, [r2, #3328]	; 0xd00
 800e9e0:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 800e9e4:	fa43 f401 	asr.w	r4, r3, r1
 800e9e8:	17dd      	asrs	r5, r3, #31
 800e9ea:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 800e9ee:	bf18      	it	ne
 800e9f0:	ea80 0305 	eorne.w	r3, r0, r5
 800e9f4:	fa03 f30b 	lsl.w	r3, r3, fp
 800e9f8:	f8c2 3e20 	str.w	r3, [r2, #3616]	; 0xe20
 800e9fc:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
 800ea00:	f8d2 3f00 	ldr.w	r3, [r2, #3840]	; 0xf00
 800ea04:	fa43 f101 	asr.w	r1, r3, r1
 800ea08:	17dc      	asrs	r4, r3, #31
 800ea0a:	ebb1 7fe3 	cmp.w	r1, r3, asr #31
 800ea0e:	bf18      	it	ne
 800ea10:	ea80 0304 	eorne.w	r3, r0, r4
 800ea14:	fa03 f30b 	lsl.w	r3, r3, fp
 800ea18:	f8c2 3f20 	str.w	r3, [r2, #3872]	; 0xf20
 800ea1c:	f8c2 3f00 	str.w	r3, [r2, #3840]	; 0xf00
		}
	}
}
 800ea20:	b007      	add	sp, #28
 800ea22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ea26:	9b02      	ldr	r3, [sp, #8]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ea28:	f44f 5488 	mov.w	r4, #4352	; 0x1100
 800ea2c:	9f01      	ldr	r7, [sp, #4]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ea2e:	0099      	lsls	r1, r3, #2
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ea30:	f502 5388 	add.w	r3, r2, #4352	; 0x1100
	s = buf[ 0];				d[0] = d[8] = s;
 800ea34:	6805      	ldr	r5, [r0, #0]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 800ea36:	18fe      	adds	r6, r7, r3
	s = buf[ 0];				d[0] = d[8] = s;
 800ea38:	6235      	str	r5, [r6, #32]
 800ea3a:	50fd      	str	r5, [r7, r3]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 800ea3c:	e508      	b.n	800e450 <xmp3_FDCT32+0x3c8>
	es = 0;
 800ea3e:	f04f 0b00 	mov.w	fp, #0
 800ea42:	f7ff bb37 	b.w	800e0b4 <xmp3_FDCT32+0x2c>
 800ea46:	bf00      	nop

0800ea48 <xmp3_Dequantize>:
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ea48:	2800      	cmp	r0, #0
 800ea4a:	f000 819e 	beq.w	800ed8a <xmp3_Dequantize+0x342>
{
 800ea4e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ea52:	6807      	ldr	r7, [r0, #0]
{
 800ea54:	b08f      	sub	sp, #60	; 0x3c
 800ea56:	4604      	mov	r4, r0
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ea58:	2f00      	cmp	r7, #0
 800ea5a:	f000 8193 	beq.w	800ed84 <xmp3_Dequantize+0x33c>
 800ea5e:	6843      	ldr	r3, [r0, #4]
 800ea60:	9306      	str	r3, [sp, #24]
 800ea62:	2b00      	cmp	r3, #0
 800ea64:	f000 818e 	beq.w	800ed84 <xmp3_Dequantize+0x33c>
 800ea68:	f8d0 a008 	ldr.w	sl, [r0, #8]
 800ea6c:	f1ba 0f00 	cmp.w	sl, #0
 800ea70:	f000 8188 	beq.w	800ed84 <xmp3_Dequantize+0x33c>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800ea74:	68c6      	ldr	r6, [r0, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 800ea76:	2e00      	cmp	r6, #0
 800ea78:	f000 8184 	beq.w	800ed84 <xmp3_Dequantize+0x33c>
 800ea7c:	460d      	mov	r5, r1
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 800ea7e:	6901      	ldr	r1, [r0, #16]
 800ea80:	2900      	cmp	r1, #0
 800ea82:	f000 817f 	beq.w	800ed84 <xmp3_Dequantize+0x33c>
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ea86:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
	cbi = di->cbi;
 800ea8a:	f501 7246 	add.w	r2, r1, #792	; 0x318
	mOut[0] = mOut[1] = 0;
 800ea8e:	f04f 0800 	mov.w	r8, #0
 800ea92:	f04f 0900 	mov.w	r9, #0
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ea96:	2b00      	cmp	r3, #0
	cbi = di->cbi;
 800ea98:	9207      	str	r2, [sp, #28]
	mOut[0] = mOut[1] = 0;
 800ea9a:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ea9e:	f340 8092 	ble.w	800ebc6 <xmp3_Dequantize+0x17e>
 800eaa2:	eb05 09c5 	add.w	r9, r5, r5, lsl #3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eaa6:	9806      	ldr	r0, [sp, #24]
 800eaa8:	9202      	str	r2, [sp, #8]
 800eaaa:	ebc5 1b45 	rsb	fp, r5, r5, lsl #5
 800eaae:	ea4f 1909 	mov.w	r9, r9, lsl #4
 800eab2:	f506 5890 	add.w	r8, r6, #4608	; 0x1200
 800eab6:	463b      	mov	r3, r7
 800eab8:	9109      	str	r1, [sp, #36]	; 0x24
 800eaba:	f109 0228 	add.w	r2, r9, #40	; 0x28
 800eabe:	4402      	add	r2, r0
 800eac0:	4630      	mov	r0, r6
 800eac2:	9200      	str	r2, [sp, #0]
 800eac4:	eb0a 028b 	add.w	r2, sl, fp, lsl #2
 800eac8:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800eacc:	9201      	str	r2, [sp, #4]
 800eace:	4642      	mov	r2, r8
 800ead0:	f000 fa58 	bl	800ef84 <xmp3_DequantChannel>
 800ead4:	f506 5380 	add.w	r3, r6, #4096	; 0x1000
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ead8:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eada:	9308      	str	r3, [sp, #32]
 800eadc:	f8c3 0208 	str.w	r0, [r3, #520]	; 0x208
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eae0:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800eae4:	2b01      	cmp	r3, #1
 800eae6:	dd6e      	ble.n	800ebc6 <xmp3_Dequantize+0x17e>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eae8:	f10b 033e 	add.w	r3, fp, #62	; 0x3e
 800eaec:	9806      	ldr	r0, [sp, #24]
 800eaee:	f241 2204 	movw	r2, #4612	; 0x1204
 800eaf2:	4453      	add	r3, sl
 800eaf4:	4432      	add	r2, r6
 800eaf6:	9301      	str	r3, [sp, #4]
 800eaf8:	f109 0370 	add.w	r3, r9, #112	; 0x70
 800eafc:	4403      	add	r3, r0
 800eafe:	f506 6010 	add.w	r0, r6, #2304	; 0x900
 800eb02:	9300      	str	r3, [sp, #0]
 800eb04:	f501 734c 	add.w	r3, r1, #816	; 0x330
 800eb08:	9302      	str	r3, [sp, #8]
 800eb0a:	463b      	mov	r3, r7
 800eb0c:	f000 fa3a 	bl	800ef84 <xmp3_DequantChannel>
 800eb10:	9b08      	ldr	r3, [sp, #32]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eb12:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eb14:	f8c3 020c 	str.w	r0, [r3, #524]	; 0x20c
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eb18:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800eb1c:	2b02      	cmp	r3, #2
 800eb1e:	dd52      	ble.n	800ebc6 <xmp3_Dequantize+0x17e>
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eb20:	f10b 037c 	add.w	r3, fp, #124	; 0x7c
 800eb24:	9a06      	ldr	r2, [sp, #24]
 800eb26:	4640      	mov	r0, r8
 800eb28:	4453      	add	r3, sl
 800eb2a:	9301      	str	r3, [sp, #4]
 800eb2c:	f109 03b8 	add.w	r3, r9, #184	; 0xb8
 800eb30:	4413      	add	r3, r2
 800eb32:	f241 2208 	movw	r2, #4616	; 0x1208
 800eb36:	9300      	str	r3, [sp, #0]
 800eb38:	f501 7352 	add.w	r3, r1, #840	; 0x348
 800eb3c:	4432      	add	r2, r6
 800eb3e:	9302      	str	r3, [sp, #8]
 800eb40:	463b      	mov	r3, r7
 800eb42:	f000 fa1f 	bl	800ef84 <xmp3_DequantChannel>
 800eb46:	9b08      	ldr	r3, [sp, #32]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eb48:	9909      	ldr	r1, [sp, #36]	; 0x24
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eb4a:	f8c3 0210 	str.w	r0, [r3, #528]	; 0x210
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eb4e:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	; 0x7bc
 800eb52:	2b03      	cmp	r3, #3
 800eb54:	dd37      	ble.n	800ebc6 <xmp3_Dequantize+0x17e>
 800eb56:	f10b 08ba 	add.w	r8, fp, #186	; 0xba
 800eb5a:	f509 7980 	add.w	r9, r9, #256	; 0x100
 800eb5e:	9a06      	ldr	r2, [sp, #24]
 800eb60:	f506 5bd8 	add.w	fp, r6, #6912	; 0x1b00
 800eb64:	950b      	str	r5, [sp, #44]	; 0x2c
 800eb66:	4625      	mov	r5, r4
 800eb68:	eb02 0309 	add.w	r3, r2, r9
 800eb6c:	eb0a 0208 	add.w	r2, sl, r8
 800eb70:	f241 2914 	movw	r9, #4628	; 0x1214
 800eb74:	f04f 0803 	mov.w	r8, #3
 800eb78:	9208      	str	r2, [sp, #32]
 800eb7a:	f501 7258 	add.w	r2, r1, #864	; 0x360
 800eb7e:	44b1      	add	r9, r6
 800eb80:	4614      	mov	r4, r2
 800eb82:	e9cd a609 	strd	sl, r6, [sp, #36]	; 0x24
 800eb86:	468a      	mov	sl, r1
 800eb88:	461e      	mov	r6, r3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eb8a:	9b08      	ldr	r3, [sp, #32]
 800eb8c:	f1a9 0208 	sub.w	r2, r9, #8
 800eb90:	4658      	mov	r0, fp
 800eb92:	9402      	str	r4, [sp, #8]
 800eb94:	4651      	mov	r1, sl
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eb96:	f108 0801 	add.w	r8, r8, #1
 800eb9a:	3418      	adds	r4, #24
 800eb9c:	f50b 6b10 	add.w	fp, fp, #2304	; 0x900
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800eba0:	e9cd 6300 	strd	r6, r3, [sp]
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800eba4:	333e      	adds	r3, #62	; 0x3e
 800eba6:	3648      	adds	r6, #72	; 0x48
 800eba8:	9308      	str	r3, [sp, #32]
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 800ebaa:	463b      	mov	r3, r7
 800ebac:	f000 f9ea 	bl	800ef84 <xmp3_DequantChannel>
 800ebb0:	f849 0b04 	str.w	r0, [r9], #4
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 800ebb4:	f8d5 27bc 	ldr.w	r2, [r5, #1980]	; 0x7bc
 800ebb8:	4542      	cmp	r2, r8
 800ebba:	dce6      	bgt.n	800eb8a <xmp3_Dequantize+0x142>
 800ebbc:	4651      	mov	r1, sl
 800ebbe:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800ebc0:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 800ebc4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 800ebc6:	6a38      	ldr	r0, [r7, #32]
 800ebc8:	2800      	cmp	r0, #0
 800ebca:	d06a      	beq.n	800eca2 <xmp3_Dequantize+0x25a>
 800ebcc:	f506 5480 	add.w	r4, r6, #4096	; 0x1000
 800ebd0:	f8d4 3208 	ldr.w	r3, [r4, #520]	; 0x208
 800ebd4:	2b00      	cmp	r3, #0
 800ebd6:	dd67      	ble.n	800eca8 <xmp3_Dequantize+0x260>
 800ebd8:	f8d4 320c 	ldr.w	r3, [r4, #524]	; 0x20c
 800ebdc:	2b00      	cmp	r3, #0
 800ebde:	dd63      	ble.n	800eca8 <xmp3_Dequantize+0x260>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 800ebe0:	0843      	lsrs	r3, r0, #1
 800ebe2:	f000 80d5 	beq.w	800ed90 <xmp3_Dequantize+0x348>
		if (fh->modeExt & 0x01) {
 800ebe6:	07c2      	lsls	r2, r0, #31
 800ebe8:	d50b      	bpl.n	800ec02 <xmp3_Dequantize+0x1ba>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 800ebea:	f8d1 3330 	ldr.w	r3, [r1, #816]	; 0x330
 800ebee:	2b00      	cmp	r3, #0
 800ebf0:	f040 80b0 	bne.w	800ed54 <xmp3_Dequantize+0x30c>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 800ebf4:	f8d1 3344 	ldr.w	r3, [r1, #836]	; 0x344
 800ebf8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ebfa:	3301      	adds	r3, #1
 800ebfc:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800ec00:	e004      	b.n	800ec0c <xmp3_Dequantize+0x1c4>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800ec02:	e9d4 3180 	ldrd	r3, r1, [r4, #512]	; 0x200
 800ec06:	4299      	cmp	r1, r3
 800ec08:	bfb8      	it	lt
 800ec0a:	4619      	movlt	r1, r3
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 800ec0c:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800ec10:	4630      	mov	r0, r6
 800ec12:	4642      	mov	r2, r8
 800ec14:	f003 feae 	bl	8012974 <xmp3_MidSideProc>
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 800ec18:	6a38      	ldr	r0, [r7, #32]
 800ec1a:	07c3      	lsls	r3, r0, #31
 800ec1c:	d51e      	bpl.n	800ec5c <xmp3_Dequantize+0x214>
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
 800ec1e:	783b      	ldrb	r3, [r7, #0]
		nSamps = hi->nonZeroBound[0];
 800ec20:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
		if (fh->ver == MPEG1) {
 800ec24:	2b00      	cmp	r3, #0
 800ec26:	d179      	bne.n	800ed1c <xmp3_Dequantize+0x2d4>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 800ec28:	9b06      	ldr	r3, [sp, #24]
 800ec2a:	eb05 02c5 	add.w	r2, r5, r5, lsl #3
 800ec2e:	ebc5 1545 	rsb	r5, r5, r5, lsl #5
 800ec32:	f8cd 800c 	str.w	r8, [sp, #12]
 800ec36:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800ec3a:	ea4f 0c60 	mov.w	ip, r0, asr #1
 800ec3e:	4630      	mov	r0, r6
 800ec40:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800ec44:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
 800ec48:	9d07      	ldr	r5, [sp, #28]
 800ec4a:	9202      	str	r2, [sp, #8]
 800ec4c:	333e      	adds	r3, #62	; 0x3e
 800ec4e:	463a      	mov	r2, r7
 800ec50:	f8cd c004 	str.w	ip, [sp, #4]
 800ec54:	9500      	str	r5, [sp, #0]
 800ec56:	f003 febf 	bl	80129d8 <xmp3_IntensityProcMPEG1>
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 800ec5a:	6a38      	ldr	r0, [r7, #32]
 800ec5c:	b308      	cbz	r0, 800eca2 <xmp3_Dequantize+0x25a>
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800ec5e:	9b0c      	ldr	r3, [sp, #48]	; 0x30

static __inline int CLZ(int x)
{
	int numZeros;

	if (!x)
 800ec60:	2b00      	cmp	r3, #0
 800ec62:	f000 8081 	beq.w	800ed68 <xmp3_Dequantize+0x320>
		return (sizeof(int) * 8);

	numZeros = 0;
	while (!(x & 0x80000000)) {
 800ec66:	f2c0 8087 	blt.w	800ed78 <xmp3_Dequantize+0x330>
	numZeros = 0;
 800ec6a:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 800ec6c:	005b      	lsls	r3, r3, #1
 800ec6e:	4611      	mov	r1, r2
		numZeros++;
 800ec70:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 800ec74:	d5fa      	bpl.n	800ec6c <xmp3_Dequantize+0x224>
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800ec76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800ec78:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
	if (!x)
 800ec7c:	2b00      	cmp	r3, #0
 800ec7e:	d079      	beq.n	800ed74 <xmp3_Dequantize+0x32c>
	while (!(x & 0x80000000)) {
 800ec80:	db7d      	blt.n	800ed7e <xmp3_Dequantize+0x336>
	numZeros = 0;
 800ec82:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 800ec84:	005b      	lsls	r3, r3, #1
 800ec86:	4611      	mov	r1, r2
		numZeros++;
 800ec88:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 800ec8c:	d5fa      	bpl.n	800ec84 <xmp3_Dequantize+0x23c>
		hi->nonZeroBound[0] = nSamps;
		hi->nonZeroBound[1] = nSamps;
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 800ec8e:	2000      	movs	r0, #0
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800ec90:	f8c4 120c 	str.w	r1, [r4, #524]	; 0x20c
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 800ec94:	e9d4 2380 	ldrd	r2, r3, [r4, #512]	; 0x200
 800ec98:	4293      	cmp	r3, r2
 800ec9a:	bfb8      	it	lt
 800ec9c:	4613      	movlt	r3, r2
		hi->nonZeroBound[1] = nSamps;
 800ec9e:	e9c4 3380 	strd	r3, r3, [r4, #512]	; 0x200
}
 800eca2:	b00f      	add	sp, #60	; 0x3c
 800eca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800eca8:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 800ecac:	2a00      	cmp	r2, #0
 800ecae:	dd17      	ble.n	800ece0 <xmp3_Dequantize+0x298>
 800ecb0:	1f33      	subs	r3, r6, #4
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800ecb2:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ecb6:	f8df e0e0 	ldr.w	lr, [pc, #224]	; 800ed98 <xmp3_Dequantize+0x350>
 800ecba:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 800ecbe:	e003      	b.n	800ecc8 <xmp3_Dequantize+0x280>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ecc0:	4563      	cmp	r3, ip
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ecc2:	f8c3 e000 	str.w	lr, [r3]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ecc6:	d00b      	beq.n	800ece0 <xmp3_Dequantize+0x298>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 800ecc8:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800eccc:	f1b2 4f40 	cmp.w	r2, #3221225472	; 0xc0000000
 800ecd0:	ddf6      	ble.n	800ecc0 <xmp3_Dequantize+0x278>
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 800ecd2:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800ecd6:	bfa8      	it	ge
 800ecd8:	f8c3 8000 	strge.w	r8, [r3]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 800ecdc:	4563      	cmp	r3, ip
 800ecde:	d1f3      	bne.n	800ecc8 <xmp3_Dequantize+0x280>
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800ece0:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
 800ece4:	2a00      	cmp	r2, #0
 800ece6:	f77f af7b 	ble.w	800ebe0 <xmp3_Dequantize+0x198>
 800ecea:	f606 03fc 	addw	r3, r6, #2300	; 0x8fc
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800ecee:	f06f 4840 	mvn.w	r8, #3221225472	; 0xc0000000
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800ecf2:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 800ed98 <xmp3_Dequantize+0x350>
 800ecf6:	eb03 0c82 	add.w	ip, r3, r2, lsl #2
 800ecfa:	e004      	b.n	800ed06 <xmp3_Dequantize+0x2be>
 800ecfc:	f8c3 e000 	str.w	lr, [r3]
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 800ed00:	459c      	cmp	ip, r3
 800ed02:	f43f af6d 	beq.w	800ebe0 <xmp3_Dequantize+0x198>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 800ed06:	f853 2f04 	ldr.w	r2, [r3, #4]!
 800ed0a:	f1b2 4f40 	cmp.w	r2, #3221225472	; 0xc0000000
 800ed0e:	ddf5      	ble.n	800ecfc <xmp3_Dequantize+0x2b4>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 800ed10:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800ed14:	bfa8      	it	ge
 800ed16:	f8c3 8000 	strge.w	r8, [r3]
 800ed1a:	e7f1      	b.n	800ed00 <xmp3_Dequantize+0x2b8>
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 800ed1c:	1042      	asrs	r2, r0, #1
 800ed1e:	4630      	mov	r0, r6
 800ed20:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 800ed24:	9e06      	ldr	r6, [sp, #24]
 800ed26:	f8cd 8010 	str.w	r8, [sp, #16]
 800ed2a:	ebc5 1545 	rsb	r5, r5, r5, lsl #5
 800ed2e:	eb06 1303 	add.w	r3, r6, r3, lsl #4
 800ed32:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800ed36:	9202      	str	r2, [sp, #8]
 800ed38:	9a07      	ldr	r2, [sp, #28]
 800ed3a:	9303      	str	r3, [sp, #12]
 800ed3c:	eb0a 0385 	add.w	r3, sl, r5, lsl #2
 800ed40:	9200      	str	r2, [sp, #0]
 800ed42:	f10a 02f8 	add.w	r2, sl, #248	; 0xf8
 800ed46:	333e      	adds	r3, #62	; 0x3e
 800ed48:	9201      	str	r2, [sp, #4]
 800ed4a:	463a      	mov	r2, r7
 800ed4c:	f003 fffe 	bl	8012d4c <xmp3_IntensityProcMPEG2>
	if (fh->modeExt) {
 800ed50:	6a38      	ldr	r0, [r7, #32]
 800ed52:	e783      	b.n	800ec5c <xmp3_Dequantize+0x214>
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 800ed54:	f8d1 2340 	ldr.w	r2, [r1, #832]	; 0x340
 800ed58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ed5a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800ed5e:	f9b3 1030 	ldrsh.w	r1, [r3, #48]	; 0x30
 800ed62:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800ed66:	e751      	b.n	800ec0c <xmp3_Dequantize+0x1c4>
		hi->gb[1] = CLZ(mOut[1]) - 1;
 800ed68:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ed6a:	211f      	movs	r1, #31
	if (!x)
 800ed6c:	2b00      	cmp	r3, #0
		hi->gb[0] = CLZ(mOut[0]) - 1;
 800ed6e:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
 800ed72:	d185      	bne.n	800ec80 <xmp3_Dequantize+0x238>
 800ed74:	211f      	movs	r1, #31
 800ed76:	e78a      	b.n	800ec8e <xmp3_Dequantize+0x246>
	while (!(x & 0x80000000)) {
 800ed78:	f04f 31ff 	mov.w	r1, #4294967295
 800ed7c:	e77b      	b.n	800ec76 <xmp3_Dequantize+0x22e>
 800ed7e:	f04f 31ff 	mov.w	r1, #4294967295
 800ed82:	e784      	b.n	800ec8e <xmp3_Dequantize+0x246>
		return -1;
 800ed84:	f04f 30ff 	mov.w	r0, #4294967295
 800ed88:	e78b      	b.n	800eca2 <xmp3_Dequantize+0x25a>
 800ed8a:	f04f 30ff 	mov.w	r0, #4294967295
}
 800ed8e:	4770      	bx	lr
 800ed90:	2001      	movs	r0, #1
 800ed92:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800ed96:	e742      	b.n	800ec1e <xmp3_Dequantize+0x1d6>
 800ed98:	c0000001 	.word	0xc0000001

0800ed9c <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 800ed9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int mask = 0;
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
	scalef = pow14[scale & 0x3];
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800eda0:	ea4f 08a3 	mov.w	r8, r3, asr #2
	tab16 = pow43_14[scale & 0x3];
 800eda4:	f003 0503 	and.w	r5, r3, #3
 800eda8:	4b63      	ldr	r3, [pc, #396]	; (800ef38 <DequantBlock+0x19c>)
{
 800edaa:	b089      	sub	sp, #36	; 0x24

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 800edac:	4644      	mov	r4, r8
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800edae:	46c3      	mov	fp, r8
	tab16 = pow43_14[scale & 0x3];
 800edb0:	eb03 1985 	add.w	r9, r3, r5, lsl #6
	scalef = pow14[scale & 0x3];
 800edb4:	4b61      	ldr	r3, [pc, #388]	; (800ef3c <DequantBlock+0x1a0>)
	shift = MIN(scalei + 3, 31);
 800edb6:	2c1c      	cmp	r4, #28
{
 800edb8:	4686      	mov	lr, r0
	scalef = pow14[scale & 0x3];
 800edba:	f853 a025 	ldr.w	sl, [r3, r5, lsl #2]
	shift = MAX(shift, 0);
	tab4[0] = 0;
 800edbe:	f04f 0000 	mov.w	r0, #0
	shift = MIN(scalei + 3, 31);
 800edc2:	bfa8      	it	ge
 800edc4:	241c      	movge	r4, #28
	tab4[1] = tab16[1] >> shift;
 800edc6:	f8d9 3004 	ldr.w	r3, [r9, #4]
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800edca:	f1b8 0f1f 	cmp.w	r8, #31
	tab4[0] = 0;
 800edce:	9004      	str	r0, [sp, #16]
	shift = MIN(scalei + 3, 31);
 800edd0:	f104 0403 	add.w	r4, r4, #3
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 800edd4:	bfa8      	it	ge
 800edd6:	f04f 0b1f 	movge.w	fp, #31
	shift = MAX(shift, 0);
 800edda:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
	tab4[1] = tab16[1] >> shift;
 800edde:	4123      	asrs	r3, r4
 800ede0:	9305      	str	r3, [sp, #20]
	tab4[2] = tab16[2] >> shift;
 800ede2:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800ede6:	4123      	asrs	r3, r4
 800ede8:	9306      	str	r3, [sp, #24]
	tab4[3] = tab16[3] >> shift;
 800edea:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800edee:	4123      	asrs	r3, r4
 800edf0:	9307      	str	r3, [sp, #28]
				if (x < 0x20000000)
					x <<= 2, shift += 2;
				if (x < 0x40000000)
					x <<= 1, shift += 1;

				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 800edf2:	465b      	mov	r3, fp
 800edf4:	46c3      	mov	fp, r8
 800edf6:	46c8      	mov	r8, r9
 800edf8:	46d1      	mov	r9, sl
 800edfa:	469a      	mov	sl, r3
 800edfc:	e00e      	b.n	800ee1c <DequantBlock+0x80>
			y = tab4[x];
 800edfe:	ac08      	add	r4, sp, #32
 800ee00:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 800ee04:	f855 4c10 	ldr.w	r4, [r5, #-16]
			}
		}

		/* sign and store */
		mask |= y;
		*outbuf++ = (sx < 0) ? -y : y;
 800ee08:	2b00      	cmp	r3, #0
		mask |= y;
 800ee0a:	ea40 0004 	orr.w	r0, r0, r4
		*outbuf++ = (sx < 0) ? -y : y;
 800ee0e:	bfb8      	it	lt
 800ee10:	4264      	neglt	r4, r4

	} while (--num);
 800ee12:	3a01      	subs	r2, #1
		*outbuf++ = (sx < 0) ? -y : y;
 800ee14:	f841 4b04 	str.w	r4, [r1], #4
	} while (--num);
 800ee18:	f000 8083 	beq.w	800ef22 <DequantBlock+0x186>
		sx = *inbuf++;
 800ee1c:	f85e 3b04 	ldr.w	r3, [lr], #4
		if (x < 4) {
 800ee20:	4c47      	ldr	r4, [pc, #284]	; (800ef40 <DequantBlock+0x1a4>)
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 800ee22:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
		if (x < 4) {
 800ee26:	401c      	ands	r4, r3
 800ee28:	2c00      	cmp	r4, #0
 800ee2a:	d0e8      	beq.n	800edfe <DequantBlock+0x62>
		} else if (x < 16) {
 800ee2c:	4c45      	ldr	r4, [pc, #276]	; (800ef44 <DequantBlock+0x1a8>)
 800ee2e:	401c      	ands	r4, r3
 800ee30:	b93c      	cbnz	r4, 800ee42 <DequantBlock+0xa6>
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800ee32:	f1bb 0f00 	cmp.w	fp, #0
			y = tab16[x];
 800ee36:	f858 4025 	ldr.w	r4, [r8, r5, lsl #2]
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800ee3a:	db75      	blt.n	800ef28 <DequantBlock+0x18c>
 800ee3c:	fa44 f40a 	asr.w	r4, r4, sl
 800ee40:	e7e2      	b.n	800ee08 <DequantBlock+0x6c>
			if (x < 64) {
 800ee42:	4c41      	ldr	r4, [pc, #260]	; (800ef48 <DequantBlock+0x1ac>)
 800ee44:	401c      	ands	r4, r3
 800ee46:	b974      	cbnz	r4, 800ee66 <DequantBlock+0xca>
				y = pow43[x-16];
 800ee48:	4c40      	ldr	r4, [pc, #256]	; (800ef4c <DequantBlock+0x1b0>)
 800ee4a:	3d10      	subs	r5, #16
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800ee4c:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
 800ee50:	464c      	mov	r4, r9
 800ee52:	fb85 6404 	smull	r6, r4, r5, r4
 800ee56:	4625      	mov	r5, r4
				shift = scalei - 3;
 800ee58:	f1aa 0403 	sub.w	r4, sl, #3
			if (shift < 0) {
 800ee5c:	2c00      	cmp	r4, #0
 800ee5e:	db55      	blt.n	800ef0c <DequantBlock+0x170>
				y >>= shift;
 800ee60:	fa45 f404 	asr.w	r4, r5, r4
 800ee64:	e7d0      	b.n	800ee08 <DequantBlock+0x6c>
				x <<= 17;
 800ee66:	046c      	lsls	r4, r5, #17
				if (x < 0x08000000)
 800ee68:	f1b4 6f00 	cmp.w	r4, #134217728	; 0x8000000
 800ee6c:	da60      	bge.n	800ef30 <DequantBlock+0x194>
					x <<= 4, shift += 4;
 800ee6e:	056c      	lsls	r4, r5, #21
 800ee70:	2604      	movs	r6, #4
 800ee72:	2506      	movs	r5, #6
 800ee74:	9600      	str	r6, [sp, #0]
				if (x < 0x20000000)
 800ee76:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 800ee7a:	da01      	bge.n	800ee80 <DequantBlock+0xe4>
					x <<= 2, shift += 2;
 800ee7c:	00a4      	lsls	r4, r4, #2
 800ee7e:	9500      	str	r5, [sp, #0]
				if (x < 0x40000000)
 800ee80:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800ee84:	da03      	bge.n	800ee8e <DequantBlock+0xf2>
					x <<= 1, shift += 1;
 800ee86:	9d00      	ldr	r5, [sp, #0]
 800ee88:	0064      	lsls	r4, r4, #1
 800ee8a:	3501      	adds	r5, #1
 800ee8c:	9500      	str	r5, [sp, #0]
				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 800ee8e:	4d30      	ldr	r5, [pc, #192]	; (800ef50 <DequantBlock+0x1b4>)
 800ee90:	4e30      	ldr	r6, [pc, #192]	; (800ef54 <DequantBlock+0x1b8>)
 800ee92:	42ac      	cmp	r4, r5
 800ee94:	4d30      	ldr	r5, [pc, #192]	; (800ef58 <DequantBlock+0x1bc>)
 800ee96:	4f31      	ldr	r7, [pc, #196]	; (800ef5c <DequantBlock+0x1c0>)
 800ee98:	bfc8      	it	gt
 800ee9a:	46ac      	movgt	ip, r5
 800ee9c:	4d30      	ldr	r5, [pc, #192]	; (800ef60 <DequantBlock+0x1c4>)
 800ee9e:	bfd8      	it	le
 800eea0:	46b4      	movle	ip, r6
 800eea2:	4e30      	ldr	r6, [pc, #192]	; (800ef64 <DequantBlock+0x1c8>)
 800eea4:	bfd8      	it	le
 800eea6:	462e      	movle	r6, r5
 800eea8:	4d2f      	ldr	r5, [pc, #188]	; (800ef68 <DequantBlock+0x1cc>)
 800eeaa:	bfd8      	it	le
 800eeac:	462f      	movle	r7, r5
 800eeae:	4d2f      	ldr	r5, [pc, #188]	; (800ef6c <DequantBlock+0x1d0>)
 800eeb0:	9703      	str	r7, [sp, #12]
 800eeb2:	4f2f      	ldr	r7, [pc, #188]	; (800ef70 <DequantBlock+0x1d4>)
 800eeb4:	bfd8      	it	le
 800eeb6:	462f      	movle	r7, r5
 800eeb8:	4d2e      	ldr	r5, [pc, #184]	; (800ef74 <DequantBlock+0x1d8>)
 800eeba:	9702      	str	r7, [sp, #8]
 800eebc:	4f2e      	ldr	r7, [pc, #184]	; (800ef78 <DequantBlock+0x1dc>)
 800eebe:	bfd8      	it	le
 800eec0:	462f      	movle	r7, r5
 800eec2:	4625      	mov	r5, r4
 800eec4:	9701      	str	r7, [sp, #4]
 800eec6:	fb86 7505 	smull	r7, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[1];
 800eeca:	4465      	add	r5, ip
 800eecc:	4626      	mov	r6, r4
 800eece:	fb85 c606 	smull	ip, r6, r5, r6
				y = MULSHIFT32(y, x) + coef[2];
 800eed2:	9f01      	ldr	r7, [sp, #4]
 800eed4:	4625      	mov	r5, r4
 800eed6:	443e      	add	r6, r7
 800eed8:	fb86 c505 	smull	ip, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[3];
 800eedc:	9f02      	ldr	r7, [sp, #8]
 800eede:	443d      	add	r5, r7
 800eee0:	fb85 6404 	smull	r6, r4, r5, r4
				y = MULSHIFT32(y, x) + coef[4];
 800eee4:	9f03      	ldr	r7, [sp, #12]
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800eee6:	4d25      	ldr	r5, [pc, #148]	; (800ef7c <DequantBlock+0x1e0>)
				y = MULSHIFT32(y, x) + coef[4];
 800eee8:	443c      	add	r4, r7
 800eeea:	9f00      	ldr	r7, [sp, #0]
 800eeec:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 800eef0:	fb84 6505 	smull	r6, r5, r4, r5
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 800eef4:	00ed      	lsls	r5, r5, #3
 800eef6:	464c      	mov	r4, r9
 800eef8:	fb85 6404 	smull	r6, r4, r5, r4
 800eefc:	4625      	mov	r5, r4
				shift = scalei - pow2exp[shift];
 800eefe:	4c20      	ldr	r4, [pc, #128]	; (800ef80 <DequantBlock+0x1e4>)
 800ef00:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
 800ef04:	ebaa 0404 	sub.w	r4, sl, r4
			if (shift < 0) {
 800ef08:	2c00      	cmp	r4, #0
 800ef0a:	daa9      	bge.n	800ee60 <DequantBlock+0xc4>
				shift = -shift;
 800ef0c:	4266      	negs	r6, r4
				if (y > (0x7fffffff >> shift))
 800ef0e:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 800ef12:	fa44 f706 	asr.w	r7, r4, r6
 800ef16:	42af      	cmp	r7, r5
 800ef18:	f6ff af76 	blt.w	800ee08 <DequantBlock+0x6c>
					y <<= shift;
 800ef1c:	fa05 f406 	lsl.w	r4, r5, r6
 800ef20:	e772      	b.n	800ee08 <DequantBlock+0x6c>

	return mask;
}
 800ef22:	b009      	add	sp, #36	; 0x24
 800ef24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 800ef28:	f1ca 0500 	rsb	r5, sl, #0
 800ef2c:	40ac      	lsls	r4, r5
 800ef2e:	e76b      	b.n	800ee08 <DequantBlock+0x6c>
				shift = 0;
 800ef30:	2600      	movs	r6, #0
 800ef32:	2502      	movs	r5, #2
 800ef34:	9600      	str	r6, [sp, #0]
 800ef36:	e79e      	b.n	800ee76 <DequantBlock+0xda>
 800ef38:	08017650 	.word	0x08017650
 800ef3c:	08017540 	.word	0x08017540
 800ef40:	7ffffffc 	.word	0x7ffffffc
 800ef44:	7ffffff0 	.word	0x7ffffff0
 800ef48:	7fffffc0 	.word	0x7fffffc0
 800ef4c:	08017590 	.word	0x08017590
 800ef50:	5a827999 	.word	0x5a827999
 800ef54:	b02e4828 	.word	0xb02e4828
 800ef58:	d333f6a4 	.word	0xd333f6a4
 800ef5c:	fef577b4 	.word	0xfef577b4
 800ef60:	29a0bda9 	.word	0x29a0bda9
 800ef64:	10852163 	.word	0x10852163
 800ef68:	ff581859 	.word	0xff581859
 800ef6c:	236c498d 	.word	0x236c498d
 800ef70:	27c2cef0 	.word	0x27c2cef0
 800ef74:	5957aa1b 	.word	0x5957aa1b
 800ef78:	46e9408b 	.word	0x46e9408b
 800ef7c:	08017570 	.word	0x08017570
 800ef80:	08017550 	.word	0x08017550

0800ef84 <xmp3_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 800ef84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ef88:	b091      	sub	sp, #68	; 0x44
 800ef8a:	930a      	str	r3, [sp, #40]	; 0x28
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 800ef8c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
{
 800ef8e:	9007      	str	r0, [sp, #28]
	if (sis->blockType == 2) {
 800ef90:	695b      	ldr	r3, [r3, #20]
{
 800ef92:	9109      	str	r1, [sp, #36]	; 0x24
	if (sis->blockType == 2) {
 800ef94:	2b02      	cmp	r3, #2
{
 800ef96:	9206      	str	r2, [sp, #24]
	if (sis->blockType == 2) {
 800ef98:	f000 8146 	beq.w	800f228 <xmp3_DequantChannel+0x2a4>
		cbEndS = 13;
	} else {
		/* long block */
		cbStartL = 0;
		cbEndL =   22;
		cbStartS = 13;
 800ef9c:	230d      	movs	r3, #13
		cbEndL =   22;
 800ef9e:	f04f 0a16 	mov.w	sl, #22
		cbStartS = 13;
 800efa2:	9303      	str	r3, [sp, #12]

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800efa4:	9b1a      	ldr	r3, [sp, #104]	; 0x68

	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
 800efa6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800efa8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	globalGain = sis->globalGain;
 800efaa:	6892      	ldr	r2, [r2, #8]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800efac:	3301      	adds	r3, #1
	globalGain = sis->globalGain;
 800efae:	9208      	str	r2, [sp, #32]
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 800efb0:	005b      	lsls	r3, r3, #1
 800efb2:	9301      	str	r3, [sp, #4]
	if (fh->modeExt >> 1)
 800efb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800efb6:	6a1b      	ldr	r3, [r3, #32]
 800efb8:	085b      	lsrs	r3, r3, #1
 800efba:	d101      	bne.n	800efc0 <xmp3_DequantChannel+0x3c>
		 globalGain -= 2;
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 800efbc:	3202      	adds	r2, #2
 800efbe:	9208      	str	r2, [sp, #32]

	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {
 800efc0:	2300      	movs	r3, #0
 800efc2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800efc4:	f8cd a010 	str.w	sl, [sp, #16]
 800efc8:	461c      	mov	r4, r3
 800efca:	461e      	mov	r6, r3
 800efcc:	f102 38ff 	add.w	r8, r2, #4294967295
 800efd0:	9305      	str	r3, [sp, #20]

		nonZero = 0;
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800efd2:	9a08      	ldr	r2, [sp, #32]
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800efd4:	f104 0901 	add.w	r9, r4, #1
 800efd8:	9302      	str	r3, [sp, #8]
	for (cb = 0; cb < cbEndL; cb++) {
 800efda:	9b04      	ldr	r3, [sp, #16]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800efdc:	f1c2 07d2 	rsb	r7, r2, #210	; 0xd2
 800efe0:	4d9d      	ldr	r5, [pc, #628]	; (800f258 <xmp3_DequantChannel+0x2d4>)
	for (cb = 0; cb < cbEndL; cb++) {
 800efe2:	429c      	cmp	r4, r3
 800efe4:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 800efe8:	f8dd b068 	ldr.w	fp, [sp, #104]	; 0x68
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800efec:	9700      	str	r7, [sp, #0]
	for (cb = 0; cb < cbEndL; cb++) {
 800efee:	d02e      	beq.n	800f04e <xmp3_DequantChannel+0xca>
 800eff0:	f8da 2034 	ldr.w	r2, [sl, #52]	; 0x34

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800eff4:	9b07      	ldr	r3, [sp, #28]
 800eff6:	eb02 0e44 	add.w	lr, r2, r4, lsl #1
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800effa:	f932 c014 	ldrsh.w	ip, [r2, r4, lsl #1]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800effe:	f8db 003c 	ldr.w	r0, [fp, #60]	; 0x3c
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f002:	eb03 0186 	add.w	r1, r3, r6, lsl #2
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f006:	f9be 2002 	ldrsh.w	r2, [lr, #2]
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f00a:	f818 3f01 	ldrb.w	r3, [r8, #1]!
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f00e:	eba2 020c 	sub.w	r2, r2, ip
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f012:	b108      	cbz	r0, 800f018 <xmp3_DequantChannel+0x94>
 800f014:	7828      	ldrb	r0, [r5, #0]
 800f016:	4403      	add	r3, r0
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f018:	9801      	ldr	r0, [sp, #4]
		i += nSamps;
 800f01a:	4416      	add	r6, r2
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 800f01c:	fb03 7300 	mla	r3, r3, r0, r7
 800f020:	4608      	mov	r0, r1
 800f022:	f7ff febb 	bl	800ed9c <DequantBlock>

		/* update highest non-zero critical band */
		if (nonZero) 
 800f026:	2800      	cmp	r0, #0
 800f028:	f000 80c9 	beq.w	800f1be <xmp3_DequantChannel+0x23a>
			cbMax[0] = cb;
		gbMask |= nonZero;
 800f02c:	9b02      	ldr	r3, [sp, #8]

		if (i >= *nonZeroBound) 
 800f02e:	3501      	adds	r5, #1
 800f030:	9405      	str	r4, [sp, #20]
		gbMask |= nonZero;
 800f032:	4303      	orrs	r3, r0
 800f034:	9302      	str	r3, [sp, #8]
		if (i >= *nonZeroBound) 
 800f036:	9b06      	ldr	r3, [sp, #24]
 800f038:	681b      	ldr	r3, [r3, #0]
 800f03a:	42b3      	cmp	r3, r6
 800f03c:	f340 80d7 	ble.w	800f1ee <xmp3_DequantChannel+0x26a>
	for (cb = 0; cb < cbEndL; cb++) {
 800f040:	464c      	mov	r4, r9
 800f042:	9b04      	ldr	r3, [sp, #16]
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 800f044:	f104 0901 	add.w	r9, r4, #1
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 800f048:	9700      	str	r7, [sp, #0]
	for (cb = 0; cb < cbEndL; cb++) {
 800f04a:	429c      	cmp	r4, r3
 800f04c:	d1d0      	bne.n	800eff0 <xmp3_DequantChannel+0x6c>
			break;
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
	cbi->cbEndL  = cbMax[0];
 800f04e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800f050:	9a05      	ldr	r2, [sp, #20]
 800f052:	f8dd b008 	ldr.w	fp, [sp, #8]
 800f056:	615a      	str	r2, [r3, #20]
	cbi->cbType = 0;			/* long only */
 800f058:	2300      	movs	r3, #0
 800f05a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800f05c:	6013      	str	r3, [r2, #0]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f05e:	6053      	str	r3, [r2, #4]
	cbi->cbEndSMax = 0;
 800f060:	6113      	str	r3, [r2, #16]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f062:	e9c2 3302 	strd	r3, r3, [r2, #8]

	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 800f066:	9b03      	ldr	r3, [sp, #12]
 800f068:	2b0b      	cmp	r3, #11
 800f06a:	f300 80b0 	bgt.w	800f1ce <xmp3_DequantChannel+0x24a>
 800f06e:	9b08      	ldr	r3, [sp, #32]
 800f070:	f1c3 03d2 	rsb	r3, r3, #210	; 0xd2
 800f074:	9300      	str	r3, [sp, #0]
		return CLZ(gbMask) - 1;
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 800f076:	9b03      	ldr	r3, [sp, #12]
 800f078:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 800f07a:	930e      	str	r3, [sp, #56]	; 0x38
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f07c:	9602      	str	r6, [sp, #8]
 800f07e:	f8cd b010 	str.w	fp, [sp, #16]
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 800f082:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 800f086:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800f08a:	3317      	adds	r3, #23
 800f08c:	18d3      	adds	r3, r2, r3
 800f08e:	9305      	str	r3, [sp, #20]
 800f090:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f092:	3328      	adds	r3, #40	; 0x28
 800f094:	930b      	str	r3, [sp, #44]	; 0x2c

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f096:	9b03      	ldr	r3, [sp, #12]
 800f098:	f10d 0830 	add.w	r8, sp, #48	; 0x30
 800f09c:	9902      	ldr	r1, [sp, #8]
 800f09e:	461a      	mov	r2, r3
 800f0a0:	9308      	str	r3, [sp, #32]
 800f0a2:	3301      	adds	r3, #1
 800f0a4:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
		for (w = 0; w < 3; w++) {
			nonZero =  0;
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f0a8:	9e09      	ldr	r6, [sp, #36]	; 0x24
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f0aa:	9303      	str	r3, [sp, #12]
 800f0ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f0ae:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800f0b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800f0b4:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 800f0b8:	9a07      	ldr	r2, [sp, #28]
 800f0ba:	eb02 0481 	add.w	r4, r2, r1, lsl #2
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f0be:	f9b3 1030 	ldrsh.w	r1, [r3, #48]	; 0x30
 800f0c2:	f9b3 202e 	ldrsh.w	r2, [r3, #46]	; 0x2e
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f0c6:	4627      	mov	r7, r4
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 800f0c8:	eba1 0b02 	sub.w	fp, r1, r2
		for (w = 0; w < 3; w++) {
 800f0cc:	ea4f 058b 	mov.w	r5, fp, lsl #2
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 800f0d0:	9900      	ldr	r1, [sp, #0]
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f0d2:	4638      	mov	r0, r7
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 800f0d4:	f85a 3b04 	ldr.w	r3, [sl], #4
 800f0d8:	f819 2b01 	ldrb.w	r2, [r9], #1
 800f0dc:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 800f0e0:	9901      	ldr	r1, [sp, #4]
 800f0e2:	fb01 3302 	mla	r3, r1, r2, r3
 800f0e6:	465a      	mov	r2, fp
 800f0e8:	4631      	mov	r1, r6
 800f0ea:	f7ff fe57 	bl	800ed9c <DequantBlock>

			/* update highest non-zero critical band */
			if (nonZero)
 800f0ee:	2800      	cmp	r0, #0
 800f0f0:	f000 8091 	beq.w	800f216 <xmp3_DequantChannel+0x292>
				cbMax[w] = cb;
 800f0f4:	9b08      	ldr	r3, [sp, #32]
		for (w = 0; w < 3; w++) {
 800f0f6:	442f      	add	r7, r5
 800f0f8:	442e      	add	r6, r5
				cbMax[w] = cb;
 800f0fa:	f848 3b04 	str.w	r3, [r8], #4
			gbMask |= nonZero;
 800f0fe:	9b04      	ldr	r3, [sp, #16]
 800f100:	4303      	orrs	r3, r0
 800f102:	9304      	str	r3, [sp, #16]
		for (w = 0; w < 3; w++) {
 800f104:	ab0f      	add	r3, sp, #60	; 0x3c
 800f106:	4598      	cmp	r8, r3
 800f108:	d1e2      	bne.n	800f0d0 <xmp3_DequantChannel+0x14c>
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
		i += 3*nSamps;
 800f10a:	9a02      	ldr	r2, [sp, #8]
 800f10c:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
		for (j = 0; j < nSamps; j++) {
 800f110:	f1bb 0f00 	cmp.w	fp, #0
		i += 3*nSamps;
 800f114:	ea4f 014b 	mov.w	r1, fp, lsl #1
 800f118:	441a      	add	r2, r3
 800f11a:	9202      	str	r2, [sp, #8]
		for (j = 0; j < nSamps; j++) {
 800f11c:	dd1b      	ble.n	800f156 <xmp3_DequantChannel+0x1d2>
 800f11e:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
 800f122:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 800f126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f128:	445a      	add	r2, fp
 800f12a:	3901      	subs	r1, #1
 800f12c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 800f130:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800f134:	3b04      	subs	r3, #4
 800f136:	441d      	add	r5, r3
			buf[j][0] = workBuf[0*nSamps + j];
 800f138:	f853 0f04 	ldr.w	r0, [r3, #4]!
		for (j = 0; j < nSamps; j++) {
 800f13c:	340c      	adds	r4, #12
			buf[j][0] = workBuf[0*nSamps + j];
 800f13e:	f844 0c0c 	str.w	r0, [r4, #-12]
		for (j = 0; j < nSamps; j++) {
 800f142:	429d      	cmp	r5, r3
			buf[j][1] = workBuf[1*nSamps + j];
 800f144:	f852 0f04 	ldr.w	r0, [r2, #4]!
 800f148:	f844 0c08 	str.w	r0, [r4, #-8]
			buf[j][2] = workBuf[2*nSamps + j];
 800f14c:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800f150:	f844 0c04 	str.w	r0, [r4, #-4]
		for (j = 0; j < nSamps; j++) {
 800f154:	d1f0      	bne.n	800f138 <xmp3_DequantChannel+0x1b4>
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f156:	9b05      	ldr	r3, [sp, #20]
 800f158:	9a02      	ldr	r2, [sp, #8]
 800f15a:	3303      	adds	r3, #3
 800f15c:	9305      	str	r3, [sp, #20]
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 800f15e:	9b06      	ldr	r3, [sp, #24]
 800f160:	681b      	ldr	r3, [r3, #0]
	for (cb = cbStartS; cb < cbEndS; cb++) {
 800f162:	4293      	cmp	r3, r2
 800f164:	dd02      	ble.n	800f16c <xmp3_DequantChannel+0x1e8>
 800f166:	9b03      	ldr	r3, [sp, #12]
 800f168:	2b0c      	cmp	r3, #12
 800f16a:	dd94      	ble.n	800f096 <xmp3_DequantChannel+0x112>
	 * however, the original nzb is no longer necessarily true
	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
     * so update nonZeroBound to i
	 */
	*nonZeroBound = i;
 800f16c:	9b06      	ldr	r3, [sp, #24]
 800f16e:	f8dd b010 	ldr.w	fp, [sp, #16]
 800f172:	601a      	str	r2, [r3, #0]

	ASSERT(*nonZeroBound <= MAX_NSAMP);

	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f174:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f176:	6999      	ldr	r1, [r3, #24]

	cbi->cbEndS[0] = cbMax[0];
	cbi->cbEndS[1] = cbMax[1];
 800f178:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f17c:	2900      	cmp	r1, #0
	cbi->cbEndS[0] = cbMax[0];
 800f17e:	991c      	ldr	r1, [sp, #112]	; 0x70
	cbi->cbEndS[1] = cbMax[1];
 800f180:	e9c1 3201 	strd	r3, r2, [r1, #4]
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f184:	bf14      	ite	ne
 800f186:	2102      	movne	r1, #2
 800f188:	2101      	moveq	r1, #1
	cbi->cbEndS[2] = cbMax[2];

	cbi->cbEndSMax = cbMax[0];
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 800f18a:	4293      	cmp	r3, r2
 800f18c:	bfb8      	it	lt
 800f18e:	4613      	movlt	r3, r2
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 800f190:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800f192:	6011      	str	r1, [r2, #0]
	cbi->cbEndS[2] = cbMax[2];
 800f194:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800f196:	991c      	ldr	r1, [sp, #112]	; 0x70
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800f198:	4293      	cmp	r3, r2
	cbi->cbEndS[2] = cbMax[2];
 800f19a:	60ca      	str	r2, [r1, #12]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 800f19c:	bfb8      	it	lt
 800f19e:	4613      	movlt	r3, r2
	if (!x)
 800f1a0:	f1bb 0f00 	cmp.w	fp, #0
 800f1a4:	610b      	str	r3, [r1, #16]
 800f1a6:	d032      	beq.n	800f20e <xmp3_DequantChannel+0x28a>
	while (!(x & 0x80000000)) {
 800f1a8:	db53      	blt.n	800f252 <xmp3_DequantChannel+0x2ce>
	numZeros = 0;
 800f1aa:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 800f1ac:	ea5f 0b4b 	movs.w	fp, fp, lsl #1
 800f1b0:	4618      	mov	r0, r3
		numZeros++;
 800f1b2:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 800f1b6:	d5f9      	bpl.n	800f1ac <xmp3_DequantChannel+0x228>

	return CLZ(gbMask) - 1;
}
 800f1b8:	b011      	add	sp, #68	; 0x44
 800f1ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (i >= *nonZeroBound) 
 800f1be:	9b06      	ldr	r3, [sp, #24]
 800f1c0:	3501      	adds	r5, #1
 800f1c2:	681b      	ldr	r3, [r3, #0]
 800f1c4:	42b3      	cmp	r3, r6
 800f1c6:	f77f af42 	ble.w	800f04e <xmp3_DequantChannel+0xca>
	for (cb = 0; cb < cbEndL; cb++) {
 800f1ca:	464c      	mov	r4, r9
 800f1cc:	e739      	b.n	800f042 <xmp3_DequantChannel+0xbe>
	if (!x)
 800f1ce:	f1bb 0f00 	cmp.w	fp, #0
 800f1d2:	d01c      	beq.n	800f20e <xmp3_DequantChannel+0x28a>
	while (!(x & 0x80000000)) {
 800f1d4:	f1bb 0f00 	cmp.w	fp, #0
 800f1d8:	db3b      	blt.n	800f252 <xmp3_DequantChannel+0x2ce>
	numZeros = 0;
 800f1da:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 800f1dc:	ea5f 0b4b 	movs.w	fp, fp, lsl #1
 800f1e0:	4618      	mov	r0, r3
		numZeros++;
 800f1e2:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 800f1e6:	d5f9      	bpl.n	800f1dc <xmp3_DequantChannel+0x258>
}
 800f1e8:	b011      	add	sp, #68	; 0x44
 800f1ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	cbi->cbEndL  = cbMax[0];
 800f1ee:	9b1c      	ldr	r3, [sp, #112]	; 0x70
	cbi->cbType = 0;			/* long only */
 800f1f0:	9a1c      	ldr	r2, [sp, #112]	; 0x70
	cbi->cbEndL  = cbMax[0];
 800f1f2:	615c      	str	r4, [r3, #20]
	cbi->cbType = 0;			/* long only */
 800f1f4:	2300      	movs	r3, #0
	cbi->cbEndL  = cbMax[0];
 800f1f6:	f8dd b008 	ldr.w	fp, [sp, #8]
	cbi->cbType = 0;			/* long only */
 800f1fa:	6013      	str	r3, [r2, #0]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f1fc:	6053      	str	r3, [r2, #4]
	cbi->cbEndSMax = 0;
 800f1fe:	6113      	str	r3, [r2, #16]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 800f200:	e9c2 3302 	strd	r3, r3, [r2, #8]
	if (cbStartS >= 12) 
 800f204:	9b03      	ldr	r3, [sp, #12]
 800f206:	2b0b      	cmp	r3, #11
 800f208:	f77f af35 	ble.w	800f076 <xmp3_DequantChannel+0xf2>
 800f20c:	e7e2      	b.n	800f1d4 <xmp3_DequantChannel+0x250>
 800f20e:	201f      	movs	r0, #31
}
 800f210:	b011      	add	sp, #68	; 0x44
 800f212:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (w = 0; w < 3; w++) {
 800f216:	f108 0804 	add.w	r8, r8, #4
 800f21a:	ab0f      	add	r3, sp, #60	; 0x3c
 800f21c:	442f      	add	r7, r5
 800f21e:	442e      	add	r6, r5
 800f220:	4543      	cmp	r3, r8
 800f222:	f47f af55 	bne.w	800f0d0 <xmp3_DequantChannel+0x14c>
 800f226:	e770      	b.n	800f10a <xmp3_DequantChannel+0x186>
		if (sis->mixedBlock) { 
 800f228:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800f22a:	f8d3 a018 	ldr.w	sl, [r3, #24]
 800f22e:	f1ba 0f00 	cmp.w	sl, #0
 800f232:	d00b      	beq.n	800f24c <xmp3_DequantChannel+0x2c8>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 800f234:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f236:	781b      	ldrb	r3, [r3, #0]
			cbStartS = 3; 
 800f238:	2b00      	cmp	r3, #0
 800f23a:	f04f 0303 	mov.w	r3, #3
 800f23e:	bf0c      	ite	eq
 800f240:	f04f 0a08 	moveq.w	sl, #8
 800f244:	f04f 0a06 	movne.w	sl, #6
 800f248:	9303      	str	r3, [sp, #12]
 800f24a:	e6ab      	b.n	800efa4 <xmp3_DequantChannel+0x20>
			cbStartS = 0;
 800f24c:	f8cd a00c 	str.w	sl, [sp, #12]
 800f250:	e6a8      	b.n	800efa4 <xmp3_DequantChannel+0x20>
 800f252:	f04f 30ff 	mov.w	r0, #4294967295
	return CLZ(gbMask) - 1;
 800f256:	e7af      	b.n	800f1b8 <xmp3_DequantChannel+0x234>
 800f258:	08017750 	.word	0x08017750

0800f25c <xmp3_DecodeHuffman>:
 *                byte located at buf + offset)
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 800f25c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f260:	b097      	sub	sp, #92	; 0x5c
 800f262:	910e      	str	r1, [sp, #56]	; 0x38
 800f264:	e9cd 3207 	strd	r3, r2, [sp, #28]
	SideInfoSub *sis;
	ScaleFactorInfo *sfi;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
 800f268:	2800      	cmp	r0, #0
 800f26a:	f000 839f 	beq.w	800f9ac <xmp3_DecodeHuffman+0x750>
 800f26e:	6801      	ldr	r1, [r0, #0]
 800f270:	2900      	cmp	r1, #0
 800f272:	f000 839b 	beq.w	800f9ac <xmp3_DecodeHuffman+0x750>
 800f276:	6844      	ldr	r4, [r0, #4]
 800f278:	9409      	str	r4, [sp, #36]	; 0x24
 800f27a:	2c00      	cmp	r4, #0
 800f27c:	f000 8396 	beq.w	800f9ac <xmp3_DecodeHuffman+0x750>
 800f280:	461d      	mov	r5, r3
 800f282:	6883      	ldr	r3, [r0, #8]
 800f284:	2b00      	cmp	r3, #0
 800f286:	f000 8391 	beq.w	800f9ac <xmp3_DecodeHuffman+0x750>
 800f28a:	68c2      	ldr	r2, [r0, #12]
 800f28c:	920d      	str	r2, [sp, #52]	; 0x34
 800f28e:	2a00      	cmp	r2, #0
 800f290:	f000 838c 	beq.w	800f9ac <xmp3_DecodeHuffman+0x750>
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
	sis = &si->sis[gr][ch];
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);

	if (huffBlockBits < 0)
 800f294:	2d00      	cmp	r5, #0
 800f296:	f2c0 838c 	blt.w	800f9b2 <xmp3_DecodeHuffman+0x756>
		return -2;

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800f29a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800f29c:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 800f2a0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f2a2:	0112      	lsls	r2, r2, #4
 800f2a4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 800f2a8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800f2ac:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f2ae:	00db      	lsls	r3, r3, #3
 800f2b0:	4422      	add	r2, r4
 800f2b2:	930c      	str	r3, [sp, #48]	; 0x30
 800f2b4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800f2b6:	00db      	lsls	r3, r3, #3
 800f2b8:	930b      	str	r3, [sp, #44]	; 0x2c
 800f2ba:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800f2bc:	2b00      	cmp	r3, #0
 800f2be:	f040 82cb 	bne.w	800f858 <xmp3_DecodeHuffman+0x5fc>
				r1Start = fh->sfBand->l[6] + 2*w;
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f2c2:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 800f2c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f2c6:	9920      	ldr	r1, [sp, #128]	; 0x80
 800f2c8:	9821      	ldr	r0, [sp, #132]	; 0x84
 800f2ca:	440b      	add	r3, r1
 800f2cc:	990c      	ldr	r1, [sp, #48]	; 0x30
 800f2ce:	011b      	lsls	r3, r3, #4
 800f2d0:	4401      	add	r1, r0
 800f2d2:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800f2d6:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f2d8:	440b      	add	r3, r1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f2da:	e9d3 1317 	ldrd	r1, r3, [r3, #92]	; 0x5c
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f2de:	3101      	adds	r1, #1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f2e0:	440b      	add	r3, r1
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f2e2:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 800f2e6:	3301      	adds	r3, #1
 800f2e8:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f2ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f2ee:	9a20      	ldr	r2, [sp, #128]	; 0x80
 800f2f0:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800f2f2:	189c      	adds	r4, r3, r2
 800f2f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f2f6:	9a21      	ldr	r2, [sp, #132]	; 0x84
 800f2f8:	0124      	lsls	r4, r4, #4
 800f2fa:	9f09      	ldr	r7, [sp, #36]	; 0x24
 800f2fc:	189a      	adds	r2, r3, r2
 800f2fe:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800f300:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	rEnd[2] = MIN(r2Start, rEnd[3]);
	rEnd[1] = MIN(r1Start, rEnd[3]);
	rEnd[0] = 0;

	/* rounds up to first all-zero pair (we don't check last pair for (x,y) == (non-zero, zero)) */
	hi->nonZeroBound[ch] = rEnd[3];
 800f304:	f503 5680 	add.w	r6, r3, #4096	; 0x1000
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f308:	eb04 03c2 	add.w	r3, r4, r2, lsl #3
 800f30c:	461c      	mov	r4, r3
 800f30e:	443b      	add	r3, r7
	hi->nonZeroBound[ch] = rEnd[3];
 800f310:	9610      	str	r6, [sp, #64]	; 0x40
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f312:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f314:	3444      	adds	r4, #68	; 0x44
 800f316:	005b      	lsls	r3, r3, #1
 800f318:	193c      	adds	r4, r7, r4
 800f31a:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 800f31e:	9406      	str	r4, [sp, #24]
 800f320:	bfa8      	it	ge
 800f322:	f44f 7310 	movge.w	r3, #576	; 0x240
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f326:	4298      	cmp	r0, r3
	hi->nonZeroBound[ch] = rEnd[3];
 800f328:	f8c6 3200 	str.w	r3, [r6, #512]	; 0x200
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f32c:	9311      	str	r3, [sp, #68]	; 0x44
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f32e:	bfa8      	it	ge
 800f330:	4618      	movge	r0, r3
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f332:	4299      	cmp	r1, r3
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 800f334:	9315      	str	r3, [sp, #84]	; 0x54
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f336:	bfa8      	it	ge
 800f338:	4619      	movge	r1, r3
	rEnd[0] = 0;
 800f33a:	2300      	movs	r3, #0
	rEnd[2] = MIN(r2Start, rEnd[3]);
 800f33c:	9014      	str	r0, [sp, #80]	; 0x50
	rEnd[0] = 0;
 800f33e:	9312      	str	r3, [sp, #72]	; 0x48

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
	for (i = 0; i < 3; i++) {
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f340:	eb05 2302 	add.w	r3, r5, r2, lsl #8
	rEnd[1] = MIN(r1Start, rEnd[3]);
 800f344:	9113      	str	r1, [sp, #76]	; 0x4c
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f346:	930a      	str	r3, [sp, #40]	; 0x28
 800f348:	0193      	lsls	r3, r2, #6
 800f34a:	930f      	str	r3, [sp, #60]	; 0x3c
 800f34c:	9b08      	ldr	r3, [sp, #32]
 800f34e:	681a      	ldr	r2, [r3, #0]
 800f350:	ab12      	add	r3, sp, #72	; 0x48
 800f352:	9305      	str	r3, [sp, #20]
 800f354:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f356:	9304      	str	r3, [sp, #16]
 800f358:	9b05      	ldr	r3, [sp, #20]
 800f35a:	681c      	ldr	r4, [r3, #0]
 800f35c:	f853 6f04 	ldr.w	r6, [r3, #4]!
 800f360:	1b36      	subs	r6, r6, r4
 800f362:	9305      	str	r3, [sp, #20]
	if(nVals <= 0)
 800f364:	2e00      	cmp	r6, #0
 800f366:	f340 80a1 	ble.w	800f4ac <xmp3_DecodeHuffman+0x250>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f36a:	9b06      	ldr	r3, [sp, #24]
	cachedBits = (8 - bitOffset) & 0x07;
 800f36c:	4252      	negs	r2, r2
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f36e:	9904      	ldr	r1, [sp, #16]
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f370:	6818      	ldr	r0, [r3, #0]
	if (cachedBits)
 800f372:	f012 0207 	ands.w	r2, r2, #7
	tabType = huffTabLookup[tabIdx].tabType;
 800f376:	4bac      	ldr	r3, [pc, #688]	; (800f628 <xmp3_DecodeHuffman+0x3cc>)
 800f378:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800f37c:	791b      	ldrb	r3, [r3, #4]
 800f37e:	9300      	str	r3, [sp, #0]
	if (cachedBits)
 800f380:	f000 822a 	beq.w	800f7d8 <xmp3_DecodeHuffman+0x57c>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f384:	f811 5b01 	ldrb.w	r5, [r1], #1
 800f388:	f1c2 0320 	rsb	r3, r2, #32
 800f38c:	fa05 f303 	lsl.w	r3, r5, r3
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f390:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800f392:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	if (tabType == noBits) {
 800f396:	9d00      	ldr	r5, [sp, #0]
 800f398:	2d00      	cmp	r5, #0
 800f39a:	f000 8225 	beq.w	800f7e8 <xmp3_DecodeHuffman+0x58c>
	bitsLeft -= cachedBits;
 800f39e:	9d07      	ldr	r5, [sp, #28]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f3a0:	4ca2      	ldr	r4, [pc, #648]	; (800f62c <xmp3_DecodeHuffman+0x3d0>)
	bitsLeft -= cachedBits;
 800f3a2:	1aaf      	subs	r7, r5, r2
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f3a4:	4da2      	ldr	r5, [pc, #648]	; (800f630 <xmp3_DecodeHuffman+0x3d4>)
 800f3a6:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
 800f3aa:	eb05 0b44 	add.w	fp, r5, r4, lsl #1
	} else if (tabType == oneShot) {
 800f3ae:	9d00      	ldr	r5, [sp, #0]
 800f3b0:	2d01      	cmp	r5, #1
 800f3b2:	f000 81b8 	beq.w	800f726 <xmp3_DecodeHuffman+0x4ca>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 800f3b6:	1eac      	subs	r4, r5, #2
 800f3b8:	2c01      	cmp	r4, #1
 800f3ba:	f200 8208 	bhi.w	800f7ce <xmp3_DecodeHuffman+0x572>
	linBits = huffTabLookup[tabIdx].linBits;
 800f3be:	4c9a      	ldr	r4, [pc, #616]	; (800f628 <xmp3_DecodeHuffman+0x3cc>)
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f3c0:	465d      	mov	r5, fp
	linBits = huffTabLookup[tabIdx].linBits;
 800f3c2:	f854 a030 	ldr.w	sl, [r4, r0, lsl #3]
		padBits = 0;
 800f3c6:	2000      	movs	r0, #0
 800f3c8:	9001      	str	r0, [sp, #4]
					minBits = linBits + 1;
 800f3ca:	f10a 0001 	add.w	r0, sl, #1
 800f3ce:	9002      	str	r0, [sp, #8]
					y += (int)(cache >> (32 - linBits));
 800f3d0:	f1ca 0020 	rsb	r0, sl, #32
 800f3d4:	9003      	str	r0, [sp, #12]
			if (bitsLeft >= 16) {
 800f3d6:	2f0f      	cmp	r7, #15
 800f3d8:	f340 821f 	ble.w	800f81a <xmp3_DecodeHuffman+0x5be>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f3dc:	7848      	ldrb	r0, [r1, #1]
 800f3de:	f1c2 0410 	rsb	r4, r2, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f3e2:	f1c2 0e18 	rsb	lr, r2, #24
				cachedBits += 16;
 800f3e6:	3210      	adds	r2, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f3e8:	fa00 f404 	lsl.w	r4, r0, r4
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f3ec:	f811 0b02 	ldrb.w	r0, [r1], #2
			while (nVals > 0 && cachedBits >= 11 ) {
 800f3f0:	2a0a      	cmp	r2, #10
				bitsLeft -= 16;
 800f3f2:	f1a7 0710 	sub.w	r7, r7, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f3f6:	fa00 f00e 	lsl.w	r0, r0, lr
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f3fa:	ea40 0004 	orr.w	r0, r0, r4
 800f3fe:	ea43 0300 	orr.w	r3, r3, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 800f402:	dde8      	ble.n	800f3d6 <xmp3_DecodeHuffman+0x17a>
				maxBits = GetMaxbits(tCurr[0]);
 800f404:	882c      	ldrh	r4, [r5, #0]
 800f406:	f004 040f 	and.w	r4, r4, #15
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 800f40a:	f1c4 0020 	rsb	r0, r4, #32
 800f40e:	fa23 f000 	lsr.w	r0, r3, r0
 800f412:	3001      	adds	r0, #1
 800f414:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
				if (!len) {
 800f418:	ea5f 3e10 	movs.w	lr, r0, lsr #12
 800f41c:	f000 817e 	beq.w	800f71c <xmp3_DecodeHuffman+0x4c0>
				if (x == 15 && tabType == loopLinbits) {
 800f420:	9c00      	ldr	r4, [sp, #0]
				x = GetCWX(cw);
 800f422:	f3c0 1503 	ubfx	r5, r0, #4, #4
				cachedBits -= len;
 800f426:	eba2 020e 	sub.w	r2, r2, lr
				cache <<= len;
 800f42a:	fa03 f30e 	lsl.w	r3, r3, lr
				if (x == 15 && tabType == loopLinbits) {
 800f42e:	f1a4 0903 	sub.w	r9, r4, #3
 800f432:	2d0f      	cmp	r5, #15
				y = GetCWY(cw);
 800f434:	f3c0 2003 	ubfx	r0, r0, #8, #4
				if (x == 15 && tabType == loopLinbits) {
 800f438:	fab9 f989 	clz	r9, r9
 800f43c:	ea4f 1959 	mov.w	r9, r9, lsr #5
 800f440:	d103      	bne.n	800f44a <xmp3_DecodeHuffman+0x1ee>
 800f442:	f1b9 0f00 	cmp.w	r9, #0
 800f446:	f040 80fb 	bne.w	800f640 <xmp3_DecodeHuffman+0x3e4>
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f44a:	b125      	cbz	r5, 800f456 <xmp3_DecodeHuffman+0x1fa>
 800f44c:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 800f450:	3a01      	subs	r2, #1
 800f452:	005b      	lsls	r3, r3, #1
 800f454:	4325      	orrs	r5, r4
				if (y == 15 && tabType == loopLinbits) {
 800f456:	280f      	cmp	r0, #15
 800f458:	d103      	bne.n	800f462 <xmp3_DecodeHuffman+0x206>
 800f45a:	f1b9 0f00 	cmp.w	r9, #0
 800f45e:	f040 8128 	bne.w	800f6b2 <xmp3_DecodeHuffman+0x456>
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800f462:	b120      	cbz	r0, 800f46e <xmp3_DecodeHuffman+0x212>
 800f464:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 800f468:	3a01      	subs	r2, #1
 800f46a:	005b      	lsls	r3, r3, #1
 800f46c:	4320      	orrs	r0, r4
				if (cachedBits < padBits)
 800f46e:	9c01      	ldr	r4, [sp, #4]
 800f470:	42a2      	cmp	r2, r4
 800f472:	f2c0 81ac 	blt.w	800f7ce <xmp3_DecodeHuffman+0x572>
				*xy++ = x;
 800f476:	4664      	mov	r4, ip
				nVals -= 2;
 800f478:	3e02      	subs	r6, #2
				*xy++ = x;
 800f47a:	f844 5b08 	str.w	r5, [r4], #8
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 800f47e:	465d      	mov	r5, fp
				*xy++ = y;
 800f480:	f8cc 0004 	str.w	r0, [ip, #4]
 800f484:	46a4      	mov	ip, r4
			while (nVals > 0 && cachedBits >= 11 ) {
 800f486:	2e00      	cmp	r6, #0
 800f488:	dd03      	ble.n	800f492 <xmp3_DecodeHuffman+0x236>
 800f48a:	2a0a      	cmp	r2, #10
 800f48c:	dcba      	bgt.n	800f404 <xmp3_DecodeHuffman+0x1a8>
		while (nVals > 0) {
 800f48e:	2e00      	cmp	r6, #0
 800f490:	dca1      	bgt.n	800f3d6 <xmp3_DecodeHuffman+0x17a>
		bitsLeft += (cachedBits - padBits);
 800f492:	9b01      	ldr	r3, [sp, #4]
 800f494:	1ad2      	subs	r2, r2, r3
		return (startBits - bitsLeft);
 800f496:	9b07      	ldr	r3, [sp, #28]
		bitsLeft += (cachedBits - padBits);
 800f498:	443a      	add	r2, r7
		return (startBits - bitsLeft);
 800f49a:	1a9b      	subs	r3, r3, r2
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 800f49c:	9907      	ldr	r1, [sp, #28]
 800f49e:	428b      	cmp	r3, r1
 800f4a0:	f200 8195 	bhi.w	800f7ce <xmp3_DecodeHuffman+0x572>
			return -3;

		/* update bitstream position */
		buf += (bitsUsed + *bitOffset) >> 3;
 800f4a4:	9207      	str	r2, [sp, #28]
 800f4a6:	9a08      	ldr	r2, [sp, #32]
 800f4a8:	6812      	ldr	r2, [r2, #0]
 800f4aa:	441a      	add	r2, r3
 800f4ac:	9b04      	ldr	r3, [sp, #16]
	for (i = 0; i < 3; i++) {
 800f4ae:	a915      	add	r1, sp, #84	; 0x54
		buf += (bitsUsed + *bitOffset) >> 3;
 800f4b0:	eb03 03e2 	add.w	r3, r3, r2, asr #3
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800f4b4:	f002 0207 	and.w	r2, r2, #7
		buf += (bitsUsed + *bitOffset) >> 3;
 800f4b8:	9304      	str	r3, [sp, #16]
	for (i = 0; i < 3; i++) {
 800f4ba:	9b06      	ldr	r3, [sp, #24]
 800f4bc:	3304      	adds	r3, #4
 800f4be:	9306      	str	r3, [sp, #24]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 800f4c0:	9b08      	ldr	r3, [sp, #32]
 800f4c2:	601a      	str	r2, [r3, #0]
	for (i = 0; i < 3; i++) {
 800f4c4:	9b05      	ldr	r3, [sp, #20]
 800f4c6:	4299      	cmp	r1, r3
 800f4c8:	f47f af46 	bne.w	800f358 <xmp3_DecodeHuffman+0xfc>
	if (bitsLeft <= 0)
 800f4cc:	9b07      	ldr	r3, [sp, #28]
 800f4ce:	2b00      	cmp	r3, #0
 800f4d0:	f000 822f 	beq.w	800f932 <xmp3_DecodeHuffman+0x6d6>
		bitsLeft -= bitsUsed;
	}

	/* decode Huffman quads (if any) */
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f4d4:	9b20      	ldr	r3, [sp, #128]	; 0x80
	cachedBits = (8 - bitOffset) & 0x07;
 800f4d6:	4252      	negs	r2, r2
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f4d8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f4da:	9821      	ldr	r0, [sp, #132]	; 0x84
	if (cachedBits)
 800f4dc:	f012 0207 	ands.w	r2, r2, #7
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f4e0:	4419      	add	r1, r3
 800f4e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f4e4:	ea4f 1101 	mov.w	r1, r1, lsl #4
 800f4e8:	4403      	add	r3, r0
 800f4ea:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800f4ee:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f4f0:	4419      	add	r1, r3
 800f4f2:	6ecb      	ldr	r3, [r1, #108]	; 0x6c
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 800f4f4:	494f      	ldr	r1, [pc, #316]	; (800f634 <xmp3_DecodeHuffman+0x3d8>)
 800f4f6:	f851 a023 	ldr.w	sl, [r1, r3, lsl #2]
	maxBits = quadTabMaxBits[tabIdx];
 800f4fa:	494f      	ldr	r1, [pc, #316]	; (800f638 <xmp3_DecodeHuffman+0x3dc>)
 800f4fc:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f500:	9b04      	ldr	r3, [sp, #16]
	if (cachedBits)
 800f502:	f040 81c2 	bne.w	800f88a <xmp3_DecodeHuffman+0x62e>
	cache = 0;
 800f506:	4611      	mov	r1, r2
		buf += (bitsUsed + *bitOffset) >> 3;
 800f508:	9300      	str	r3, [sp, #0]
	while (i < (nVals - 3)) {
 800f50a:	f240 2e3d 	movw	lr, #573	; 0x23d
 800f50e:	9b11      	ldr	r3, [sp, #68]	; 0x44
	bitsLeft -= cachedBits;
 800f510:	9c07      	ldr	r4, [sp, #28]
	while (i < (nVals - 3)) {
 800f512:	ebae 0e03 	sub.w	lr, lr, r3
	bitsLeft -= cachedBits;
 800f516:	eba4 0b02 	sub.w	fp, r4, r2
	while (i < (nVals - 3)) {
 800f51a:	f1be 0f00 	cmp.w	lr, #0
 800f51e:	f340 8243 	ble.w	800f9a8 <xmp3_DecodeHuffman+0x74c>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f522:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	i = padBits = 0;
 800f524:	f04f 0c00 	mov.w	ip, #0
			cw = tBase[cache >> (32 - maxBits)];
 800f528:	f1c0 0820 	rsb	r8, r0, #32
 800f52c:	f8df 910c 	ldr.w	r9, [pc, #268]	; 800f63c <xmp3_DecodeHuffman+0x3e0>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f530:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	i = padBits = 0;
 800f534:	4667      	mov	r7, ip
		if (bitsLeft >= 16) {
 800f536:	f1bb 0f0f 	cmp.w	fp, #15
 800f53a:	f340 81ae 	ble.w	800f89a <xmp3_DecodeHuffman+0x63e>
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f53e:	9800      	ldr	r0, [sp, #0]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f540:	f1c2 0418 	rsb	r4, r2, #24
			bitsLeft -= 16;
 800f544:	f1ab 0b10 	sub.w	fp, fp, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f548:	7845      	ldrb	r5, [r0, #1]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f54a:	f810 6b02 	ldrb.w	r6, [r0], #2
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f54e:	9000      	str	r0, [sp, #0]
 800f550:	f1c2 0010 	rsb	r0, r2, #16
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f554:	fa06 f404 	lsl.w	r4, r6, r4
			cachedBits += 16;
 800f558:	3210      	adds	r2, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f55a:	fa05 f000 	lsl.w	r0, r5, r0
 800f55e:	4320      	orrs	r0, r4
 800f560:	4301      	orrs	r1, r0
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f562:	f103 0010 	add.w	r0, r3, #16
 800f566:	e003      	b.n	800f570 <xmp3_DecodeHuffman+0x314>
 800f568:	2a09      	cmp	r2, #9
 800f56a:	f100 0010 	add.w	r0, r0, #16
 800f56e:	dde2      	ble.n	800f536 <xmp3_DecodeHuffman+0x2da>
			cw = tBase[cache >> (32 - maxBits)];
 800f570:	fa21 f308 	lsr.w	r3, r1, r8
 800f574:	4453      	add	r3, sl
 800f576:	f819 3003 	ldrb.w	r3, [r9, r3]
			len = GetHLenQ(cw);
 800f57a:	091c      	lsrs	r4, r3, #4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800f57c:	f013 0608 	ands.w	r6, r3, #8
			cachedBits -= len;
 800f580:	eba2 1213 	sub.w	r2, r2, r3, lsr #4
			cache <<= len;
 800f584:	fa01 f104 	lsl.w	r1, r1, r4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 800f588:	d005      	beq.n	800f596 <xmp3_DecodeHuffman+0x33a>
 800f58a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800f58e:	3a01      	subs	r2, #1
 800f590:	0049      	lsls	r1, r1, #1
 800f592:	f046 0601 	orr.w	r6, r6, #1
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 800f596:	f013 0504 	ands.w	r5, r3, #4
 800f59a:	d005      	beq.n	800f5a8 <xmp3_DecodeHuffman+0x34c>
 800f59c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800f5a0:	3a01      	subs	r2, #1
 800f5a2:	0049      	lsls	r1, r1, #1
 800f5a4:	f045 0501 	orr.w	r5, r5, #1
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f5a8:	f013 0402 	ands.w	r4, r3, #2
 800f5ac:	d005      	beq.n	800f5ba <xmp3_DecodeHuffman+0x35e>
 800f5ae:	f001 4400 	and.w	r4, r1, #2147483648	; 0x80000000
 800f5b2:	3a01      	subs	r2, #1
 800f5b4:	0049      	lsls	r1, r1, #1
 800f5b6:	f044 0401 	orr.w	r4, r4, #1
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800f5ba:	f013 0301 	ands.w	r3, r3, #1
 800f5be:	d005      	beq.n	800f5cc <xmp3_DecodeHuffman+0x370>
 800f5c0:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
 800f5c4:	3a01      	subs	r2, #1
 800f5c6:	0049      	lsls	r1, r1, #1
 800f5c8:	f043 0301 	orr.w	r3, r3, #1
			if (cachedBits < padBits)
 800f5cc:	4562      	cmp	r2, ip
 800f5ce:	db07      	blt.n	800f5e0 <xmp3_DecodeHuffman+0x384>
			i += 4;
 800f5d0:	3704      	adds	r7, #4
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f5d2:	45be      	cmp	lr, r7
			*vwxy++ = y;
 800f5d4:	e940 4302 	strd	r4, r3, [r0, #-8]
			*vwxy++ = w;
 800f5d8:	e940 6504 	strd	r6, r5, [r0, #-16]
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 800f5dc:	4603      	mov	r3, r0
 800f5de:	dcc3      	bgt.n	800f568 <xmp3_DecodeHuffman+0x30c>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f5e0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800f5e2:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800f5e6:	443b      	add	r3, r7

	ASSERT(hi->nonZeroBound[ch] <= MAX_NSAMP);
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800f5e8:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 800f5ec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++)
 800f5f0:	da0a      	bge.n	800f608 <xmp3_DecodeHuffman+0x3ac>
		hi->huffDecBuf[ch][i] = 0;
 800f5f2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800f5f4:	2100      	movs	r1, #0
 800f5f6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f5f8:	4418      	add	r0, r3
 800f5fa:	f5c3 7310 	rsb	r3, r3, #576	; 0x240
 800f5fe:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 800f602:	009a      	lsls	r2, r3, #2
 800f604:	f003 fdb8 	bl	8013178 <memset>

	/* If bits used for 576 samples < huffBlockBits, then the extras are considered
	 *  to be stuffing bits (throw away, but need to return correct bitstream position)
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
 800f608:	9908      	ldr	r1, [sp, #32]
 800f60a:	9a07      	ldr	r2, [sp, #28]
 800f60c:	680b      	ldr	r3, [r1, #0]
 800f60e:	9804      	ldr	r0, [sp, #16]
 800f610:	441a      	add	r2, r3
 800f612:	4613      	mov	r3, r2
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800f614:	f002 0207 	and.w	r2, r2, #7
	buf += (bitsLeft + *bitOffset) >> 3;
 800f618:	eb00 00e3 	add.w	r0, r0, r3, asr #3

	return (buf - startBuf);
 800f61c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 800f61e:	600a      	str	r2, [r1, #0]
	return (buf - startBuf);
 800f620:	1ac0      	subs	r0, r0, r3
}
 800f622:	b017      	add	sp, #92	; 0x5c
 800f624:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f628:	08017768 	.word	0x08017768
 800f62c:	08017868 	.word	0x08017868
 800f630:	080178e8 	.word	0x080178e8
 800f634:	08019a14 	.word	0x08019a14
 800f638:	08019a0c 	.word	0x08019a0c
 800f63c:	08019a1c 	.word	0x08019a1c
					minBits = linBits + 1 + (y ? 1 : 0);
 800f640:	9c02      	ldr	r4, [sp, #8]
					if (cachedBits + bitsLeft < minBits)
 800f642:	19d5      	adds	r5, r2, r7
					minBits = linBits + 1 + (y ? 1 : 0);
 800f644:	2800      	cmp	r0, #0
 800f646:	bf18      	it	ne
 800f648:	3401      	addne	r4, #1
					if (cachedBits + bitsLeft < minBits)
 800f64a:	42ac      	cmp	r4, r5
 800f64c:	f300 80bf 	bgt.w	800f7ce <xmp3_DecodeHuffman+0x572>
					while (cachedBits < minBits) {
 800f650:	42a2      	cmp	r2, r4
 800f652:	f280 814a 	bge.w	800f8ea <xmp3_DecodeHuffman+0x68e>
 800f656:	ea6f 0802 	mvn.w	r8, r2
 800f65a:	f1c2 0518 	rsb	r5, r2, #24
 800f65e:	44a0      	add	r8, r4
 800f660:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 800f664:	f108 0e01 	add.w	lr, r8, #1
 800f668:	448e      	add	lr, r1
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f66a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800f66e:	40ac      	lsls	r4, r5
					while (cachedBits < minBits) {
 800f670:	4571      	cmp	r1, lr
 800f672:	f1a5 0508 	sub.w	r5, r5, #8
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f676:	ea43 0304 	orr.w	r3, r3, r4
					while (cachedBits < minBits) {
 800f67a:	d1f6      	bne.n	800f66a <xmp3_DecodeHuffman+0x40e>
					if (bitsLeft < 0) {
 800f67c:	3208      	adds	r2, #8
 800f67e:	3f08      	subs	r7, #8
						cachedBits += 8;
 800f680:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
						bitsLeft -= 8;
 800f684:	ebc8 7848 	rsb	r8, r8, r8, lsl #29
					if (bitsLeft < 0) {
 800f688:	eb17 07c8 	adds.w	r7, r7, r8, lsl #3
 800f68c:	d507      	bpl.n	800f69e <xmp3_DecodeHuffman+0x442>
						cachedBits += bitsLeft;
 800f68e:	443a      	add	r2, r7
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f690:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
						bitsLeft = 0;
 800f694:	2700      	movs	r7, #0
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f696:	1e51      	subs	r1, r2, #1
 800f698:	fa44 f101 	asr.w	r1, r4, r1
 800f69c:	400b      	ands	r3, r1
					x += (int)(cache >> (32 - linBits));
 800f69e:	9c03      	ldr	r4, [sp, #12]
					cachedBits -= linBits;
 800f6a0:	eba2 020a 	sub.w	r2, r2, sl
					cache <<= linBits;
 800f6a4:	4671      	mov	r1, lr
					x += (int)(cache >> (32 - linBits));
 800f6a6:	fa23 f504 	lsr.w	r5, r3, r4
					cache <<= linBits;
 800f6aa:	fa03 f30a 	lsl.w	r3, r3, sl
					x += (int)(cache >> (32 - linBits));
 800f6ae:	350f      	adds	r5, #15
					cache <<= linBits;
 800f6b0:	e6cb      	b.n	800f44a <xmp3_DecodeHuffman+0x1ee>
					if (cachedBits + bitsLeft < minBits)
 800f6b2:	18b8      	adds	r0, r7, r2
 800f6b4:	9c02      	ldr	r4, [sp, #8]
 800f6b6:	4284      	cmp	r4, r0
 800f6b8:	f300 8089 	bgt.w	800f7ce <xmp3_DecodeHuffman+0x572>
					while (cachedBits < minBits) {
 800f6bc:	4294      	cmp	r4, r2
 800f6be:	f340 8116 	ble.w	800f8ee <xmp3_DecodeHuffman+0x692>
 800f6c2:	ebaa 0802 	sub.w	r8, sl, r2
 800f6c6:	f1c2 0418 	rsb	r4, r2, #24
 800f6ca:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 800f6ce:	f108 0e01 	add.w	lr, r8, #1
 800f6d2:	448e      	add	lr, r1
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f6d4:	f811 0b01 	ldrb.w	r0, [r1], #1
 800f6d8:	40a0      	lsls	r0, r4
					while (cachedBits < minBits) {
 800f6da:	4571      	cmp	r1, lr
 800f6dc:	f1a4 0408 	sub.w	r4, r4, #8
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f6e0:	ea43 0300 	orr.w	r3, r3, r0
					while (cachedBits < minBits) {
 800f6e4:	d1f6      	bne.n	800f6d4 <xmp3_DecodeHuffman+0x478>
					if (bitsLeft < 0) {
 800f6e6:	3208      	adds	r2, #8
 800f6e8:	3f08      	subs	r7, #8
						cachedBits += 8;
 800f6ea:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
						bitsLeft -= 8;
 800f6ee:	ebc8 7848 	rsb	r8, r8, r8, lsl #29
					if (bitsLeft < 0) {
 800f6f2:	eb17 07c8 	adds.w	r7, r7, r8, lsl #3
 800f6f6:	d507      	bpl.n	800f708 <xmp3_DecodeHuffman+0x4ac>
						cachedBits += bitsLeft;
 800f6f8:	443a      	add	r2, r7
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f6fa:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
						bitsLeft = 0;
 800f6fe:	2700      	movs	r7, #0
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f700:	1e51      	subs	r1, r2, #1
 800f702:	fa40 f101 	asr.w	r1, r0, r1
 800f706:	400b      	ands	r3, r1
					y += (int)(cache >> (32 - linBits));
 800f708:	9803      	ldr	r0, [sp, #12]
					cachedBits -= linBits;
 800f70a:	eba2 020a 	sub.w	r2, r2, sl
					cache <<= linBits;
 800f70e:	4671      	mov	r1, lr
					y += (int)(cache >> (32 - linBits));
 800f710:	fa23 f000 	lsr.w	r0, r3, r0
					cache <<= linBits;
 800f714:	fa03 f30a 	lsl.w	r3, r3, sl
					y += (int)(cache >> (32 - linBits));
 800f718:	300f      	adds	r0, #15
					cache <<= linBits;
 800f71a:	e6a2      	b.n	800f462 <xmp3_DecodeHuffman+0x206>
					tCurr += cw;
 800f71c:	eb05 0540 	add.w	r5, r5, r0, lsl #1
					cachedBits -= maxBits;
 800f720:	1b12      	subs	r2, r2, r4
					cache <<= maxBits;
 800f722:	40a3      	lsls	r3, r4
					continue;
 800f724:	e6af      	b.n	800f486 <xmp3_DecodeHuffman+0x22a>
		maxBits = GetMaxbits(tBase[0]);
 800f726:	48a4      	ldr	r0, [pc, #656]	; (800f9b8 <xmp3_DecodeHuffman+0x75c>)
		padBits = 0;
 800f728:	f04f 0900 	mov.w	r9, #0
		maxBits = GetMaxbits(tBase[0]);
 800f72c:	f830 8014 	ldrh.w	r8, [r0, r4, lsl #1]
 800f730:	f008 080f 	and.w	r8, r8, #15
				cw = tBase[cache >> (32 - maxBits)];
 800f734:	f1c8 0820 	rsb	r8, r8, #32
			if (bitsLeft >= 16) {
 800f738:	2f0f      	cmp	r7, #15
 800f73a:	f340 80da 	ble.w	800f8f2 <xmp3_DecodeHuffman+0x696>
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f73e:	f1c2 0518 	rsb	r5, r2, #24
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f742:	784c      	ldrb	r4, [r1, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f744:	f811 0b02 	ldrb.w	r0, [r1], #2
				bitsLeft -= 16;
 800f748:	3f10      	subs	r7, #16
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f74a:	40a8      	lsls	r0, r5
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f74c:	f1c2 0510 	rsb	r5, r2, #16
				cachedBits += 16;
 800f750:	3210      	adds	r2, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f752:	40ac      	lsls	r4, r5
 800f754:	4320      	orrs	r0, r4
 800f756:	4303      	orrs	r3, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 800f758:	2e00      	cmp	r6, #0
 800f75a:	f340 80fe 	ble.w	800f95a <xmp3_DecodeHuffman+0x6fe>
 800f75e:	f10c 0408 	add.w	r4, ip, #8
 800f762:	468e      	mov	lr, r1
 800f764:	e00b      	b.n	800f77e <xmp3_DecodeHuffman+0x522>
				*xy++ = x;
 800f766:	f844 1c08 	str.w	r1, [r4, #-8]
			while (nVals > 0 && cachedBits >= 11 ) {
 800f76a:	2e00      	cmp	r6, #0
 800f76c:	f104 0408 	add.w	r4, r4, #8
				*xy++ = y;
 800f770:	f844 0c0c 	str.w	r0, [r4, #-12]
			while (nVals > 0 && cachedBits >= 11 ) {
 800f774:	f340 80f1 	ble.w	800f95a <xmp3_DecodeHuffman+0x6fe>
 800f778:	2a0a      	cmp	r2, #10
 800f77a:	f340 80ea 	ble.w	800f952 <xmp3_DecodeHuffman+0x6f6>
				cw = tBase[cache >> (32 - maxBits)];
 800f77e:	fa23 f008 	lsr.w	r0, r3, r8
 800f782:	3001      	adds	r0, #1
 800f784:	f83b 0010 	ldrh.w	r0, [fp, r0, lsl #1]
				len = GetHLen(cw);
 800f788:	ea4f 3c10 	mov.w	ip, r0, lsr #12
				cachedBits -= len;
 800f78c:	f3c0 1503 	ubfx	r5, r0, #4, #4
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f790:	f010 0ff0 	tst.w	r0, #240	; 0xf0
				cachedBits -= len;
 800f794:	eba2 3210 	sub.w	r2, r2, r0, lsr #12
				cache <<= len;
 800f798:	fa03 f30c 	lsl.w	r3, r3, ip
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 800f79c:	4629      	mov	r1, r5
 800f79e:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800f7a2:	d003      	beq.n	800f7ac <xmp3_DecodeHuffman+0x550>
 800f7a4:	005b      	lsls	r3, r3, #1
 800f7a6:	3a01      	subs	r2, #1
 800f7a8:	ea4c 0105 	orr.w	r1, ip, r5
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 800f7ac:	f3c0 2503 	ubfx	r5, r0, #8, #4
 800f7b0:	f410 6f70 	tst.w	r0, #3840	; 0xf00
 800f7b4:	f003 4c00 	and.w	ip, r3, #2147483648	; 0x80000000
 800f7b8:	4628      	mov	r0, r5
 800f7ba:	d003      	beq.n	800f7c4 <xmp3_DecodeHuffman+0x568>
 800f7bc:	ea4c 0005 	orr.w	r0, ip, r5
 800f7c0:	005b      	lsls	r3, r3, #1
 800f7c2:	3a01      	subs	r2, #1
				if (cachedBits < padBits)
 800f7c4:	454a      	cmp	r2, r9
				nVals -= 2;
 800f7c6:	f1a6 0602 	sub.w	r6, r6, #2
 800f7ca:	46a4      	mov	ip, r4
				if (cachedBits < padBits)
 800f7cc:	dacb      	bge.n	800f766 <xmp3_DecodeHuffman+0x50a>
			return -3;
 800f7ce:	f06f 0002 	mvn.w	r0, #2
}
 800f7d2:	b017      	add	sp, #92	; 0x5c
 800f7d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f7d8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	cache = 0;
 800f7da:	4613      	mov	r3, r2
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 800f7dc:	eb05 0c84 	add.w	ip, r5, r4, lsl #2
	if (tabType == noBits) {
 800f7e0:	9d00      	ldr	r5, [sp, #0]
 800f7e2:	2d00      	cmp	r5, #0
 800f7e4:	f47f addb 	bne.w	800f39e <xmp3_DecodeHuffman+0x142>
 800f7e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800f7ea:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f7ec:	18e3      	adds	r3, r4, r3
 800f7ee:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800f7f2:	1e72      	subs	r2, r6, #1
 800f7f4:	0759      	lsls	r1, r3, #29
 800f7f6:	f040 809e 	bne.w	800f936 <xmp3_DecodeHuffman+0x6da>
 800f7fa:	2a13      	cmp	r2, #19
 800f7fc:	f240 809b 	bls.w	800f936 <xmp3_DecodeHuffman+0x6da>
 800f800:	0851      	lsrs	r1, r2, #1
			xy[i+0] = 0;
 800f802:	2400      	movs	r4, #0
	if (tabType == noBits) {
 800f804:	462a      	mov	r2, r5
			xy[i+0] = 0;
 800f806:	2500      	movs	r5, #0
 800f808:	3101      	adds	r1, #1
			xy[i+1] = 0;
 800f80a:	3201      	adds	r2, #1
 800f80c:	428a      	cmp	r2, r1
			xy[i+0] = 0;
 800f80e:	e8e3 4502 	strd	r4, r5, [r3], #8
		for (i = 0; i < nVals; i+=2) {
 800f812:	d3fa      	bcc.n	800f80a <xmp3_DecodeHuffman+0x5ae>
		buf += (bitsUsed + *bitOffset) >> 3;
 800f814:	9b08      	ldr	r3, [sp, #32]
 800f816:	681a      	ldr	r2, [r3, #0]
 800f818:	e648      	b.n	800f4ac <xmp3_DecodeHuffman+0x250>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800f81a:	18b8      	adds	r0, r7, r2
 800f81c:	2800      	cmp	r0, #0
 800f81e:	ddd6      	ble.n	800f7ce <xmp3_DecodeHuffman+0x572>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f820:	2f00      	cmp	r7, #0
 800f822:	dd06      	ble.n	800f832 <xmp3_DecodeHuffman+0x5d6>
 800f824:	f1c2 0e18 	rsb	lr, r2, #24
 800f828:	f811 4b01 	ldrb.w	r4, [r1], #1
 800f82c:	fa04 f40e 	lsl.w	r4, r4, lr
 800f830:	4323      	orrs	r3, r4
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f832:	2f08      	cmp	r7, #8
 800f834:	dd05      	ble.n	800f842 <xmp3_DecodeHuffman+0x5e6>
 800f836:	f1c2 0410 	rsb	r4, r2, #16
 800f83a:	f811 2b01 	ldrb.w	r2, [r1], #1
 800f83e:	40a2      	lsls	r2, r4
 800f840:	4313      	orrs	r3, r2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f842:	1e44      	subs	r4, r0, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800f844:	f100 020b 	add.w	r2, r0, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f848:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
				bitsLeft = 0;
 800f84c:	2700      	movs	r7, #0
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f84e:	4120      	asrs	r0, r4
 800f850:	4003      	ands	r3, r0
				padBits = 11;
 800f852:	200b      	movs	r0, #11
 800f854:	9001      	str	r0, [sp, #4]
 800f856:	e5d5      	b.n	800f404 <xmp3_DecodeHuffman+0x1a8>
	if (sis->winSwitchFlag && sis->blockType == 2) {
 800f858:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800f85a:	2b02      	cmp	r3, #2
 800f85c:	f47f ad31 	bne.w	800f2c2 <xmp3_DecodeHuffman+0x66>
		if (sis->mixedBlock == 0) {
 800f860:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800f862:	2b00      	cmp	r3, #0
 800f864:	d17f      	bne.n	800f966 <xmp3_DecodeHuffman+0x70a>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800f866:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800f868:	f1a3 33aa 	sub.w	r3, r3, #2863311530	; 0xaaaaaaaa
 800f86c:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800f86e:	3201      	adds	r2, #1
 800f870:	fb83 0302 	smull	r0, r3, r3, r2
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800f874:	f44f 7010 	mov.w	r0, #576	; 0x240
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 800f878:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 800f87c:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800f880:	f9b3 102e 	ldrsh.w	r1, [r3, #46]	; 0x2e
 800f884:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800f888:	e530      	b.n	800f2ec <xmp3_DecodeHuffman+0x90>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 800f88a:	f813 4b01 	ldrb.w	r4, [r3], #1
 800f88e:	f1c2 0120 	rsb	r1, r2, #32
 800f892:	9300      	str	r3, [sp, #0]
 800f894:	fa04 f101 	lsl.w	r1, r4, r1
 800f898:	e637      	b.n	800f50a <xmp3_DecodeHuffman+0x2ae>
			if (cachedBits + bitsLeft <= 0) return i;
 800f89a:	eb02 000b 	add.w	r0, r2, fp
 800f89e:	2800      	cmp	r0, #0
 800f8a0:	f77f ae9e 	ble.w	800f5e0 <xmp3_DecodeHuffman+0x384>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f8a4:	f1bb 0f00 	cmp.w	fp, #0
 800f8a8:	dd08      	ble.n	800f8bc <xmp3_DecodeHuffman+0x660>
 800f8aa:	9c00      	ldr	r4, [sp, #0]
 800f8ac:	f1c2 0518 	rsb	r5, r2, #24
 800f8b0:	f814 6b01 	ldrb.w	r6, [r4], #1
 800f8b4:	fa06 f505 	lsl.w	r5, r6, r5
 800f8b8:	9400      	str	r4, [sp, #0]
 800f8ba:	4329      	orrs	r1, r5
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f8bc:	f1bb 0f08 	cmp.w	fp, #8
 800f8c0:	dd07      	ble.n	800f8d2 <xmp3_DecodeHuffman+0x676>
 800f8c2:	9c00      	ldr	r4, [sp, #0]
 800f8c4:	f1c2 0510 	rsb	r5, r2, #16
 800f8c8:	f814 2b01 	ldrb.w	r2, [r4], #1
 800f8cc:	40aa      	lsls	r2, r5
 800f8ce:	9400      	str	r4, [sp, #0]
 800f8d0:	4311      	orrs	r1, r2
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f8d2:	1e44      	subs	r4, r0, #1
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800f8d4:	f100 020a 	add.w	r2, r0, #10
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f8d8:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
			padBits = 10;
 800f8dc:	f04f 0c0a 	mov.w	ip, #10
			bitsLeft = 0;
 800f8e0:	f04f 0b00 	mov.w	fp, #0
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f8e4:	4120      	asrs	r0, r4
 800f8e6:	4001      	ands	r1, r0
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800f8e8:	e63b      	b.n	800f562 <xmp3_DecodeHuffman+0x306>
					while (cachedBits < minBits) {
 800f8ea:	468e      	mov	lr, r1
 800f8ec:	e6d7      	b.n	800f69e <xmp3_DecodeHuffman+0x442>
					while (cachedBits < minBits) {
 800f8ee:	468e      	mov	lr, r1
 800f8f0:	e70a      	b.n	800f708 <xmp3_DecodeHuffman+0x4ac>
				if (cachedBits + bitsLeft <= 0)	return -1;
 800f8f2:	18bc      	adds	r4, r7, r2
 800f8f4:	2c00      	cmp	r4, #0
 800f8f6:	f77f af6a 	ble.w	800f7ce <xmp3_DecodeHuffman+0x572>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 800f8fa:	2f00      	cmp	r7, #0
 800f8fc:	dd05      	ble.n	800f90a <xmp3_DecodeHuffman+0x6ae>
 800f8fe:	f1c2 0518 	rsb	r5, r2, #24
 800f902:	f811 0b01 	ldrb.w	r0, [r1], #1
 800f906:	40a8      	lsls	r0, r5
 800f908:	4303      	orrs	r3, r0
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 800f90a:	2f08      	cmp	r7, #8
 800f90c:	dd05      	ble.n	800f91a <xmp3_DecodeHuffman+0x6be>
 800f90e:	f1c2 0010 	rsb	r0, r2, #16
 800f912:	f811 2b01 	ldrb.w	r2, [r1], #1
 800f916:	4082      	lsls	r2, r0
 800f918:	4313      	orrs	r3, r2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f91a:	1e60      	subs	r0, r4, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800f91c:	f104 020b 	add.w	r2, r4, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f920:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
				padBits = 11;
 800f924:	f04f 090b 	mov.w	r9, #11
				bitsLeft = 0;
 800f928:	2700      	movs	r7, #0
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 800f92a:	fa44 f000 	asr.w	r0, r4, r0
 800f92e:	4003      	ands	r3, r0
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 800f930:	e712      	b.n	800f758 <xmp3_DecodeHuffman+0x4fc>
 800f932:	461f      	mov	r7, r3
 800f934:	e654      	b.n	800f5e0 <xmp3_DecodeHuffman+0x384>
		for (i = 0; i < nVals; i+=2) {
 800f936:	2300      	movs	r3, #0
 800f938:	f10c 0204 	add.w	r2, ip, #4
			xy[i+0] = 0;
 800f93c:	2100      	movs	r1, #0
 800f93e:	f84c 1023 	str.w	r1, [ip, r3, lsl #2]
			xy[i+1] = 0;
 800f942:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (i = 0; i < nVals; i+=2) {
 800f946:	3302      	adds	r3, #2
 800f948:	429e      	cmp	r6, r3
 800f94a:	dcf7      	bgt.n	800f93c <xmp3_DecodeHuffman+0x6e0>
		buf += (bitsUsed + *bitOffset) >> 3;
 800f94c:	9b08      	ldr	r3, [sp, #32]
 800f94e:	681a      	ldr	r2, [r3, #0]
 800f950:	e5ac      	b.n	800f4ac <xmp3_DecodeHuffman+0x250>
		while (nVals > 0) {
 800f952:	2e00      	cmp	r6, #0
 800f954:	4671      	mov	r1, lr
 800f956:	f73f aeef 	bgt.w	800f738 <xmp3_DecodeHuffman+0x4dc>
		bitsLeft += (cachedBits - padBits);
 800f95a:	eba2 0209 	sub.w	r2, r2, r9
		return (startBits - bitsLeft);
 800f95e:	9b07      	ldr	r3, [sp, #28]
		bitsLeft += (cachedBits - padBits);
 800f960:	443a      	add	r2, r7
		return (startBits - bitsLeft);
 800f962:	1a9b      	subs	r3, r3, r2
 800f964:	e59a      	b.n	800f49c <xmp3_DecodeHuffman+0x240>
			if (fh->ver == MPEG1) {
 800f966:	780b      	ldrb	r3, [r1, #0]
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f968:	6b4a      	ldr	r2, [r1, #52]	; 0x34
			if (fh->ver == MPEG1) {
 800f96a:	b98b      	cbnz	r3, 800f990 <xmp3_DecodeHuffman+0x734>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f96c:	9920      	ldr	r1, [sp, #128]	; 0x80
 800f96e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f970:	9821      	ldr	r0, [sp, #132]	; 0x84
 800f972:	440b      	add	r3, r1
 800f974:	990c      	ldr	r1, [sp, #48]	; 0x30
 800f976:	011b      	lsls	r3, r3, #4
 800f978:	4401      	add	r1, r0
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800f97a:	f44f 7010 	mov.w	r0, #576	; 0x240
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 800f97e:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800f982:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f984:	440b      	add	r3, r1
 800f986:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800f988:	3301      	adds	r3, #1
 800f98a:	f932 1013 	ldrsh.w	r1, [r2, r3, lsl #1]
 800f98e:	e4ad      	b.n	800f2ec <xmp3_DecodeHuffman+0x90>
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800f990:	f9b2 1034 	ldrsh.w	r1, [r2, #52]	; 0x34
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 800f994:	f44f 7010 	mov.w	r0, #576	; 0x240
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 800f998:	f9b2 3036 	ldrsh.w	r3, [r2, #54]	; 0x36
 800f99c:	1a5b      	subs	r3, r3, r1
				r1Start = fh->sfBand->l[6] + 2*w;
 800f99e:	f9b2 100c 	ldrsh.w	r1, [r2, #12]
 800f9a2:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800f9a6:	e4a1      	b.n	800f2ec <xmp3_DecodeHuffman+0x90>
		return 0;
 800f9a8:	2700      	movs	r7, #0
 800f9aa:	e619      	b.n	800f5e0 <xmp3_DecodeHuffman+0x384>
		return -1;
 800f9ac:	f04f 30ff 	mov.w	r0, #4294967295
 800f9b0:	e70f      	b.n	800f7d2 <xmp3_DecodeHuffman+0x576>
		return -2;
 800f9b2:	f06f 0001 	mvn.w	r0, #1
 800f9b6:	e70c      	b.n	800f7d2 <xmp3_DecodeHuffman+0x576>
 800f9b8:	080178e8 	.word	0x080178e8

0800f9bc <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 800f9bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f9c0:	b08b      	sub	sp, #44	; 0x2c
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
 800f9c2:	bba3      	cbnz	r3, 800fa2e <FreqInvertRescale+0x72>
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 800f9c4:	f012 0601 	ands.w	r6, r2, #1
 800f9c8:	d02d      	beq.n	800fa26 <FreqInvertRescale+0x6a>
			y += NBANDS;
			y0 = *y;	y += 2*NBANDS;
			y1 = *y;	y += 2*NBANDS;
			y2 = *y;	y += 2*NBANDS;
 800f9ca:	f8d0 1280 	ldr.w	r1, [r0, #640]	; 0x280
			*y = -y5;	y += 2*NBANDS;
			*y = -y6;	y += 2*NBANDS;
			*y = -y7;	y += 2*NBANDS;
			*y = -y8;	y += 2*NBANDS;
		}
		return 0;
 800f9ce:	461e      	mov	r6, r3
			y3 = *y;	y += 2*NBANDS;
 800f9d0:	f8d0 2380 	ldr.w	r2, [r0, #896]	; 0x380
			*y = -y2;	y += 2*NBANDS;
 800f9d4:	4249      	negs	r1, r1
			y6 = *y;	y += 2*NBANDS;
 800f9d6:	f8d0 3680 	ldr.w	r3, [r0, #1664]	; 0x680
			*y = -y3;	y += 2*NBANDS;
 800f9da:	4252      	negs	r2, r2
			y1 = *y;	y += 2*NBANDS;
 800f9dc:	f8d0 4180 	ldr.w	r4, [r0, #384]	; 0x180
			*y = -y2;	y += 2*NBANDS;
 800f9e0:	f8c0 1280 	str.w	r1, [r0, #640]	; 0x280
			*y = -y6;	y += 2*NBANDS;
 800f9e4:	425b      	negs	r3, r3
			y4 = *y;	y += 2*NBANDS;
 800f9e6:	f8d0 1480 	ldr.w	r1, [r0, #1152]	; 0x480
			*y = -y1;	y += 2*NBANDS;
 800f9ea:	4264      	negs	r4, r4
			*y = -y3;	y += 2*NBANDS;
 800f9ec:	f8c0 2380 	str.w	r2, [r0, #896]	; 0x380
			y5 = *y;	y += 2*NBANDS;
 800f9f0:	f8d0 2580 	ldr.w	r2, [r0, #1408]	; 0x580
			*y = -y4;	y += 2*NBANDS;
 800f9f4:	4249      	negs	r1, r1
			*y = -y6;	y += 2*NBANDS;
 800f9f6:	f8c0 3680 	str.w	r3, [r0, #1664]	; 0x680
			*y = -y5;	y += 2*NBANDS;
 800f9fa:	4252      	negs	r2, r2
			y8 = *y;	y += 2*NBANDS;
 800f9fc:	f8d0 3880 	ldr.w	r3, [r0, #2176]	; 0x880
			*y = -y4;	y += 2*NBANDS;
 800fa00:	f8c0 1480 	str.w	r1, [r0, #1152]	; 0x480
			*y = -y5;	y += 2*NBANDS;
 800fa04:	f8c0 2580 	str.w	r2, [r0, #1408]	; 0x580
			*y = -y8;	y += 2*NBANDS;
 800fa08:	425b      	negs	r3, r3
			y7 = *y;	y += 2*NBANDS;
 800fa0a:	f8d0 1780 	ldr.w	r1, [r0, #1920]	; 0x780
			*y = -y0;	y += 2*NBANDS;
 800fa0e:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
			*y = -y7;	y += 2*NBANDS;
 800fa12:	4249      	negs	r1, r1
			*y = -y1;	y += 2*NBANDS;
 800fa14:	f8c0 4180 	str.w	r4, [r0, #384]	; 0x180
			*y = -y0;	y += 2*NBANDS;
 800fa18:	4252      	negs	r2, r2
			*y = -y8;	y += 2*NBANDS;
 800fa1a:	f8c0 3880 	str.w	r3, [r0, #2176]	; 0x880
			*y = -y7;	y += 2*NBANDS;
 800fa1e:	f8c0 1780 	str.w	r1, [r0, #1920]	; 0x780
			*y = -y0;	y += 2*NBANDS;
 800fa22:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		}
		return mOut;
	}
}
 800fa26:	4630      	mov	r0, r6
 800fa28:	b00b      	add	sp, #44	; 0x2c
 800fa2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (blockIdx & 0x01) {
 800fa2e:	07d2      	lsls	r2, r2, #31
 800fa30:	d54b      	bpl.n	800faca <FreqInvertRescale+0x10e>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fa32:	f04f 4e00 	mov.w	lr, #2147483648	; 0x80000000
 800fa36:	f1c3 0c1f 	rsb	ip, r3, #31
 800fa3a:	f100 0780 	add.w	r7, r0, #128	; 0x80
 800fa3e:	f500 6810 	add.w	r8, r0, #2304	; 0x900
 800fa42:	fa2e fe03 	lsr.w	lr, lr, r3
		mOut = 0;
 800fa46:	2600      	movs	r6, #0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fa48:	f10e 3eff 	add.w	lr, lr, #4294967295
 800fa4c:	f857 2c80 	ldr.w	r2, [r7, #-128]
 800fa50:	fa42 f90c 	asr.w	r9, r2, ip
 800fa54:	ea4f 7ae2 	mov.w	sl, r2, asr #31
 800fa58:	ebb9 7fe2 	cmp.w	r9, r2, asr #31
 800fa5c:	bf18      	it	ne
 800fa5e:	ea8e 020a 	eorne.w	r2, lr, sl
 800fa62:	409a      	lsls	r2, r3
 800fa64:	f847 2c80 	str.w	r2, [r7, #-128]
	__asm__ volatile (
 800fa68:	ea82 74e2 	eor.w	r4, r2, r2, asr #31
 800fa6c:	eba4 74e2 	sub.w	r4, r4, r2, asr #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fa70:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
 800fa74:	4252      	negs	r2, r2
 800fa76:	fa42 f90c 	asr.w	r9, r2, ip
 800fa7a:	ea4f 7ae2 	mov.w	sl, r2, asr #31
 800fa7e:	ebb9 7fe2 	cmp.w	r9, r2, asr #31
 800fa82:	bf18      	it	ne
 800fa84:	ea8e 020a 	eorne.w	r2, lr, sl
 800fa88:	409a      	lsls	r2, r3
 800fa8a:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 800fa8e:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
 800fa92:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fa96:	680a      	ldr	r2, [r1, #0]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fa98:	ea44 0905 	orr.w	r9, r4, r5
 800fa9c:	f500 7080 	add.w	r0, r0, #256	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800faa0:	fa42 fa0c 	asr.w	sl, r2, ip
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800faa4:	ea46 0609 	orr.w	r6, r6, r9
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800faa8:	ea4f 79e2 	mov.w	r9, r2, asr #31
 800faac:	ebba 7fe2 	cmp.w	sl, r2, asr #31
 800fab0:	ea8e 0909 	eor.w	r9, lr, r9
 800fab4:	f000 81e8 	beq.w	800fe88 <FreqInvertRescale+0x4cc>
 800fab8:	fa09 f203 	lsl.w	r2, r9, r3
			for (i = 0; i < 18; i+=2) {
 800fabc:	4540      	cmp	r0, r8
 800fabe:	f507 7780 	add.w	r7, r7, #256	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fac2:	f841 2b04 	str.w	r2, [r1], #4
			for (i = 0; i < 18; i+=2) {
 800fac6:	d1c1      	bne.n	800fa4c <FreqInvertRescale+0x90>
 800fac8:	e7ad      	b.n	800fa26 <FreqInvertRescale+0x6a>
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800faca:	6804      	ldr	r4, [r0, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800facc:	f1c3 021f 	rsb	r2, r3, #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fad0:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800fad4:	fa44 f502 	asr.w	r5, r4, r2
 800fad8:	17e6      	asrs	r6, r4, #31
 800fada:	fa2c fc03 	lsr.w	ip, ip, r3
 800fade:	ebb5 7fe4 	cmp.w	r5, r4, asr #31
 800fae2:	f10c 3cff 	add.w	ip, ip, #4294967295
 800fae6:	bf18      	it	ne
 800fae8:	ea8c 0406 	eorne.w	r4, ip, r6
 800faec:	fa04 f503 	lsl.w	r5, r4, r3
 800faf0:	2400      	movs	r4, #0
 800faf2:	6005      	str	r5, [r0, #0]
 800faf4:	ea85 74e5 	eor.w	r4, r5, r5, asr #31
 800faf8:	eba4 74e5 	sub.w	r4, r4, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fafc:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 800fb00:	f04f 0e00 	mov.w	lr, #0
 800fb04:	fa45 f602 	asr.w	r6, r5, r2
 800fb08:	17ef      	asrs	r7, r5, #31
 800fb0a:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fb0e:	bf18      	it	ne
 800fb10:	ea8c 0507 	eorne.w	r5, ip, r7
 800fb14:	409d      	lsls	r5, r3
 800fb16:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
 800fb1a:	ea85 7ee5 	eor.w	lr, r5, r5, asr #31
 800fb1e:	ebae 7ee5 	sub.w	lr, lr, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fb22:	680d      	ldr	r5, [r1, #0]
 800fb24:	ea4e 0604 	orr.w	r6, lr, r4
 800fb28:	9600      	str	r6, [sp, #0]
 800fb2a:	fa45 f602 	asr.w	r6, r5, r2
 800fb2e:	17ef      	asrs	r7, r5, #31
 800fb30:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fb34:	bf18      	it	ne
 800fb36:	ea87 050c 	eorne.w	r5, r7, ip
 800fb3a:	409d      	lsls	r5, r3
 800fb3c:	600d      	str	r5, [r1, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fb3e:	f8d0 5100 	ldr.w	r5, [r0, #256]	; 0x100
 800fb42:	fa45 f602 	asr.w	r6, r5, r2
 800fb46:	17ef      	asrs	r7, r5, #31
 800fb48:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fb4c:	bf18      	it	ne
 800fb4e:	ea8c 0507 	eorne.w	r5, ip, r7
 800fb52:	409d      	lsls	r5, r3
 800fb54:	f8c0 5100 	str.w	r5, [r0, #256]	; 0x100
 800fb58:	ea85 74e5 	eor.w	r4, r5, r5, asr #31
 800fb5c:	eba4 74e5 	sub.w	r4, r4, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fb60:	f8d0 5180 	ldr.w	r5, [r0, #384]	; 0x180
 800fb64:	fa45 f602 	asr.w	r6, r5, r2
 800fb68:	17ef      	asrs	r7, r5, #31
 800fb6a:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fb6e:	bf18      	it	ne
 800fb70:	ea8c 0507 	eorne.w	r5, ip, r7
 800fb74:	409d      	lsls	r5, r3
 800fb76:	f8c0 5180 	str.w	r5, [r0, #384]	; 0x180
 800fb7a:	ea85 7ee5 	eor.w	lr, r5, r5, asr #31
 800fb7e:	ebae 7ee5 	sub.w	lr, lr, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fb82:	684d      	ldr	r5, [r1, #4]
 800fb84:	fa45 f602 	asr.w	r6, r5, r2
 800fb88:	17ef      	asrs	r7, r5, #31
 800fb8a:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fb8e:	bf18      	it	ne
 800fb90:	ea8c 0507 	eorne.w	r5, ip, r7
 800fb94:	409d      	lsls	r5, r3
 800fb96:	604d      	str	r5, [r1, #4]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fb98:	f8d0 5200 	ldr.w	r5, [r0, #512]	; 0x200
 800fb9c:	fa45 f602 	asr.w	r6, r5, r2
 800fba0:	17ef      	asrs	r7, r5, #31
 800fba2:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fba6:	4626      	mov	r6, r4
 800fba8:	bf18      	it	ne
 800fbaa:	ea8c 0507 	eorne.w	r5, ip, r7
 800fbae:	409d      	lsls	r5, r3
 800fbb0:	f8c0 5200 	str.w	r5, [r0, #512]	; 0x200
 800fbb4:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fbb8:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fbbc:	f8d0 5280 	ldr.w	r5, [r0, #640]	; 0x280
 800fbc0:	9602      	str	r6, [sp, #8]
 800fbc2:	fa45 f602 	asr.w	r6, r5, r2
 800fbc6:	17ef      	asrs	r7, r5, #31
 800fbc8:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fbcc:	4676      	mov	r6, lr
 800fbce:	bf18      	it	ne
 800fbd0:	ea8c 0507 	eorne.w	r5, ip, r7
 800fbd4:	409d      	lsls	r5, r3
 800fbd6:	f8c0 5280 	str.w	r5, [r0, #640]	; 0x280
 800fbda:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fbde:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fbe2:	688d      	ldr	r5, [r1, #8]
 800fbe4:	9603      	str	r6, [sp, #12]
 800fbe6:	fa45 f602 	asr.w	r6, r5, r2
 800fbea:	17ef      	asrs	r7, r5, #31
 800fbec:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fbf0:	bf18      	it	ne
 800fbf2:	ea8c 0507 	eorne.w	r5, ip, r7
 800fbf6:	409d      	lsls	r5, r3
 800fbf8:	608d      	str	r5, [r1, #8]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fbfa:	f8d0 5300 	ldr.w	r5, [r0, #768]	; 0x300
 800fbfe:	fa45 f602 	asr.w	r6, r5, r2
 800fc02:	17ef      	asrs	r7, r5, #31
 800fc04:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fc08:	4626      	mov	r6, r4
 800fc0a:	bf18      	it	ne
 800fc0c:	ea8c 0507 	eorne.w	r5, ip, r7
 800fc10:	409d      	lsls	r5, r3
 800fc12:	f8c0 5300 	str.w	r5, [r0, #768]	; 0x300
 800fc16:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fc1a:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fc1e:	f8d0 5380 	ldr.w	r5, [r0, #896]	; 0x380
 800fc22:	9604      	str	r6, [sp, #16]
 800fc24:	fa45 f602 	asr.w	r6, r5, r2
 800fc28:	17ef      	asrs	r7, r5, #31
 800fc2a:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fc2e:	4676      	mov	r6, lr
 800fc30:	bf18      	it	ne
 800fc32:	ea8c 0507 	eorne.w	r5, ip, r7
 800fc36:	409d      	lsls	r5, r3
 800fc38:	f8c0 5380 	str.w	r5, [r0, #896]	; 0x380
 800fc3c:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fc40:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fc44:	68cd      	ldr	r5, [r1, #12]
 800fc46:	9605      	str	r6, [sp, #20]
 800fc48:	fa45 f602 	asr.w	r6, r5, r2
 800fc4c:	17ef      	asrs	r7, r5, #31
 800fc4e:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fc52:	bf18      	it	ne
 800fc54:	ea8c 0507 	eorne.w	r5, ip, r7
 800fc58:	409d      	lsls	r5, r3
 800fc5a:	60cd      	str	r5, [r1, #12]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fc5c:	f8d0 5400 	ldr.w	r5, [r0, #1024]	; 0x400
 800fc60:	fa45 f602 	asr.w	r6, r5, r2
 800fc64:	17ef      	asrs	r7, r5, #31
 800fc66:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fc6a:	4626      	mov	r6, r4
 800fc6c:	bf18      	it	ne
 800fc6e:	ea8c 0507 	eorne.w	r5, ip, r7
 800fc72:	409d      	lsls	r5, r3
 800fc74:	f8c0 5400 	str.w	r5, [r0, #1024]	; 0x400
 800fc78:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fc7c:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fc80:	f8d0 5480 	ldr.w	r5, [r0, #1152]	; 0x480
 800fc84:	9606      	str	r6, [sp, #24]
 800fc86:	fa45 f602 	asr.w	r6, r5, r2
 800fc8a:	17ef      	asrs	r7, r5, #31
 800fc8c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fc90:	4676      	mov	r6, lr
 800fc92:	bf18      	it	ne
 800fc94:	ea8c 0507 	eorne.w	r5, ip, r7
 800fc98:	409d      	lsls	r5, r3
 800fc9a:	f8c0 5480 	str.w	r5, [r0, #1152]	; 0x480
 800fc9e:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fca2:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fca6:	690d      	ldr	r5, [r1, #16]
 800fca8:	9607      	str	r6, [sp, #28]
 800fcaa:	fa45 f602 	asr.w	r6, r5, r2
 800fcae:	17ef      	asrs	r7, r5, #31
 800fcb0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fcb4:	bf18      	it	ne
 800fcb6:	ea8c 0507 	eorne.w	r5, ip, r7
 800fcba:	409d      	lsls	r5, r3
 800fcbc:	610d      	str	r5, [r1, #16]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fcbe:	f8d0 5500 	ldr.w	r5, [r0, #1280]	; 0x500
 800fcc2:	fa45 f602 	asr.w	r6, r5, r2
 800fcc6:	17ef      	asrs	r7, r5, #31
 800fcc8:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fccc:	4626      	mov	r6, r4
 800fcce:	bf18      	it	ne
 800fcd0:	ea8c 0507 	eorne.w	r5, ip, r7
 800fcd4:	409d      	lsls	r5, r3
 800fcd6:	f8c0 5500 	str.w	r5, [r0, #1280]	; 0x500
 800fcda:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fcde:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fce2:	f8d0 5580 	ldr.w	r5, [r0, #1408]	; 0x580
 800fce6:	9608      	str	r6, [sp, #32]
 800fce8:	fa45 f602 	asr.w	r6, r5, r2
 800fcec:	17ef      	asrs	r7, r5, #31
 800fcee:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fcf2:	4676      	mov	r6, lr
 800fcf4:	bf18      	it	ne
 800fcf6:	ea8c 0507 	eorne.w	r5, ip, r7
 800fcfa:	409d      	lsls	r5, r3
 800fcfc:	f8c0 5580 	str.w	r5, [r0, #1408]	; 0x580
 800fd00:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fd04:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fd08:	694d      	ldr	r5, [r1, #20]
 800fd0a:	46a3      	mov	fp, r4
 800fd0c:	9609      	str	r6, [sp, #36]	; 0x24
 800fd0e:	fa45 f602 	asr.w	r6, r5, r2
 800fd12:	17ef      	asrs	r7, r5, #31
 800fd14:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fd18:	bf18      	it	ne
 800fd1a:	ea8c 0507 	eorne.w	r5, ip, r7
 800fd1e:	409d      	lsls	r5, r3
 800fd20:	614d      	str	r5, [r1, #20]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fd22:	f8d0 5600 	ldr.w	r5, [r0, #1536]	; 0x600
 800fd26:	fa45 f602 	asr.w	r6, r5, r2
 800fd2a:	17ef      	asrs	r7, r5, #31
 800fd2c:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fd30:	bf18      	it	ne
 800fd32:	ea8c 0507 	eorne.w	r5, ip, r7
 800fd36:	409d      	lsls	r5, r3
 800fd38:	f8c0 5600 	str.w	r5, [r0, #1536]	; 0x600
 800fd3c:	ea85 7be5 	eor.w	fp, r5, r5, asr #31
 800fd40:	ebab 7be5 	sub.w	fp, fp, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fd44:	f8d0 5680 	ldr.w	r5, [r0, #1664]	; 0x680
 800fd48:	46f1      	mov	r9, lr
 800fd4a:	fa45 f602 	asr.w	r6, r5, r2
 800fd4e:	17ef      	asrs	r7, r5, #31
 800fd50:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fd54:	bf18      	it	ne
 800fd56:	ea8c 0507 	eorne.w	r5, ip, r7
 800fd5a:	409d      	lsls	r5, r3
 800fd5c:	f8c0 5680 	str.w	r5, [r0, #1664]	; 0x680
 800fd60:	ea85 79e5 	eor.w	r9, r5, r5, asr #31
 800fd64:	eba9 79e5 	sub.w	r9, r9, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fd68:	698d      	ldr	r5, [r1, #24]
 800fd6a:	46a0      	mov	r8, r4
 800fd6c:	fa45 f602 	asr.w	r6, r5, r2
 800fd70:	17ef      	asrs	r7, r5, #31
 800fd72:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fd76:	bf18      	it	ne
 800fd78:	ea8c 0507 	eorne.w	r5, ip, r7
 800fd7c:	409d      	lsls	r5, r3
 800fd7e:	618d      	str	r5, [r1, #24]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fd80:	f8d0 5700 	ldr.w	r5, [r0, #1792]	; 0x700
 800fd84:	fa45 f602 	asr.w	r6, r5, r2
 800fd88:	17ef      	asrs	r7, r5, #31
 800fd8a:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fd8e:	bf18      	it	ne
 800fd90:	ea8c 0507 	eorne.w	r5, ip, r7
 800fd94:	409d      	lsls	r5, r3
 800fd96:	f8c0 5700 	str.w	r5, [r0, #1792]	; 0x700
 800fd9a:	ea85 78e5 	eor.w	r8, r5, r5, asr #31
 800fd9e:	eba8 78e5 	sub.w	r8, r8, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fda2:	f8d0 5780 	ldr.w	r5, [r0, #1920]	; 0x780
 800fda6:	fa45 f602 	asr.w	r6, r5, r2
 800fdaa:	17ef      	asrs	r7, r5, #31
 800fdac:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fdb0:	bf18      	it	ne
 800fdb2:	ea8c 0507 	eorne.w	r5, ip, r7
 800fdb6:	4677      	mov	r7, lr
 800fdb8:	409d      	lsls	r5, r3
 800fdba:	f8c0 5780 	str.w	r5, [r0, #1920]	; 0x780
 800fdbe:	ea85 77e5 	eor.w	r7, r5, r5, asr #31
 800fdc2:	eba7 77e5 	sub.w	r7, r7, r5, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fdc6:	69cd      	ldr	r5, [r1, #28]
 800fdc8:	fa45 f602 	asr.w	r6, r5, r2
 800fdcc:	ea4f 7ae5 	mov.w	sl, r5, asr #31
 800fdd0:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fdd4:	bf18      	it	ne
 800fdd6:	ea8c 050a 	eorne.w	r5, ip, sl
 800fdda:	409d      	lsls	r5, r3
 800fddc:	61cd      	str	r5, [r1, #28]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fdde:	f8d0 5800 	ldr.w	r5, [r0, #2048]	; 0x800
 800fde2:	fa45 f602 	asr.w	r6, r5, r2
 800fde6:	ea4f 7ae5 	mov.w	sl, r5, asr #31
 800fdea:	ebb6 7fe5 	cmp.w	r6, r5, asr #31
 800fdee:	4626      	mov	r6, r4
 800fdf0:	bf18      	it	ne
 800fdf2:	ea8c 050a 	eorne.w	r5, ip, sl
 800fdf6:	409d      	lsls	r5, r3
 800fdf8:	f8c0 5800 	str.w	r5, [r0, #2048]	; 0x800
 800fdfc:	ea85 76e5 	eor.w	r6, r5, r5, asr #31
 800fe00:	eba6 76e5 	sub.w	r6, r6, r5, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 800fe04:	f8d0 5880 	ldr.w	r5, [r0, #2176]	; 0x880
 800fe08:	9601      	str	r6, [sp, #4]
 800fe0a:	fa45 fa02 	asr.w	sl, r5, r2
 800fe0e:	17ee      	asrs	r6, r5, #31
 800fe10:	ebba 7fe5 	cmp.w	sl, r5, asr #31
 800fe14:	bf18      	it	ne
 800fe16:	ea8c 0506 	eorne.w	r5, ip, r6
 800fe1a:	409d      	lsls	r5, r3
 800fe1c:	f8c0 5880 	str.w	r5, [r0, #2176]	; 0x880
 800fe20:	4670      	mov	r0, lr
 800fe22:	ea85 70e5 	eor.w	r0, r5, r5, asr #31
 800fe26:	eba0 70e5 	sub.w	r0, r0, r5, asr #31
 800fe2a:	9d00      	ldr	r5, [sp, #0]
 800fe2c:	9e01      	ldr	r6, [sp, #4]
 800fe2e:	4325      	orrs	r5, r4
 800fe30:	ea45 040e 	orr.w	r4, r5, lr
 800fe34:	9d02      	ldr	r5, [sp, #8]
 800fe36:	432c      	orrs	r4, r5
 800fe38:	9d03      	ldr	r5, [sp, #12]
 800fe3a:	432c      	orrs	r4, r5
 800fe3c:	9d04      	ldr	r5, [sp, #16]
 800fe3e:	432c      	orrs	r4, r5
 800fe40:	9d05      	ldr	r5, [sp, #20]
 800fe42:	432c      	orrs	r4, r5
 800fe44:	9d06      	ldr	r5, [sp, #24]
 800fe46:	432c      	orrs	r4, r5
 800fe48:	9d07      	ldr	r5, [sp, #28]
 800fe4a:	432c      	orrs	r4, r5
 800fe4c:	9d08      	ldr	r5, [sp, #32]
 800fe4e:	432c      	orrs	r4, r5
 800fe50:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800fe52:	432c      	orrs	r4, r5
 800fe54:	ea44 040b 	orr.w	r4, r4, fp
 800fe58:	ea44 0909 	orr.w	r9, r4, r9
 800fe5c:	ea49 0808 	orr.w	r8, r9, r8
 800fe60:	ea48 0707 	orr.w	r7, r8, r7
 800fe64:	433e      	orrs	r6, r7
 800fe66:	4306      	orrs	r6, r0
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fe68:	6a08      	ldr	r0, [r1, #32]
 800fe6a:	fa40 f202 	asr.w	r2, r0, r2
 800fe6e:	17c4      	asrs	r4, r0, #31
 800fe70:	ebb2 7fe0 	cmp.w	r2, r0, asr #31
 800fe74:	bf18      	it	ne
 800fe76:	ea8c 0004 	eorne.w	r0, ip, r4
 800fe7a:	fa00 f303 	lsl.w	r3, r0, r3
}
 800fe7e:	4630      	mov	r0, r6
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fe80:	620b      	str	r3, [r1, #32]
}
 800fe82:	b00b      	add	sp, #44	; 0x2c
 800fe84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fe88:	409a      	lsls	r2, r3
			for (i = 0; i < 18; i+=2) {
 800fe8a:	4540      	cmp	r0, r8
 800fe8c:	f507 7780 	add.w	r7, r7, #256	; 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 800fe90:	f841 2b04 	str.w	r2, [r1], #4
			for (i = 0; i < 18; i+=2) {
 800fe94:	f47f adda 	bne.w	800fa4c <FreqInvertRescale+0x90>
 800fe98:	e5c5      	b.n	800fa26 <FreqInvertRescale+0x6a>
 800fe9a:	bf00      	nop

0800fe9c <WinPrevious.part.0>:
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800fe9c:	4b37      	ldr	r3, [pc, #220]	; (800ff7c <WinPrevious.part.0+0xe0>)
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 800fe9e:	6882      	ldr	r2, [r0, #8]
static void WinPrevious(int *xPrev, int *xPrevWin, int btPrev)
 800fea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800fea4:	f8d3 7138 	ldr.w	r7, [r3, #312]	; 0x138
 800fea8:	fb87 4202 	smull	r4, r2, r7, r2
 800feac:	6984      	ldr	r4, [r0, #24]
 800feae:	f8d3 5120 	ldr.w	r5, [r3, #288]	; 0x120
 800feb2:	fb85 6404 	smull	r6, r4, r5, r4
 800feb6:	4422      	add	r2, r4
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800feb8:	f8d3 613c 	ldr.w	r6, [r3, #316]	; 0x13c
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 800febc:	600a      	str	r2, [r1, #0]
 800febe:	6842      	ldr	r2, [r0, #4]
 800fec0:	fb86 4202 	smull	r4, r2, r6, r2
 800fec4:	69c4      	ldr	r4, [r0, #28]
 800fec6:	f8d3 5124 	ldr.w	r5, [r3, #292]	; 0x124
 800feca:	fb85 c404 	smull	ip, r4, r5, r4
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800fece:	4422      	add	r2, r4
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800fed0:	f8d3 5140 	ldr.w	r5, [r3, #320]	; 0x140
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 800fed4:	604a      	str	r2, [r1, #4]
 800fed6:	6802      	ldr	r2, [r0, #0]
 800fed8:	fb85 4202 	smull	r4, r2, r5, r2
 800fedc:	6a04      	ldr	r4, [r0, #32]
 800fede:	46a4      	mov	ip, r4
 800fee0:	f8d3 4128 	ldr.w	r4, [r3, #296]	; 0x128
 800fee4:	fb84 ec0c 	smull	lr, ip, r4, ip
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800fee8:	4462      	add	r2, ip
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800feea:	f8d3 a144 	ldr.w	sl, [r3, #324]	; 0x144
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 800feee:	608a      	str	r2, [r1, #8]
 800fef0:	6802      	ldr	r2, [r0, #0]
 800fef2:	4694      	mov	ip, r2
 800fef4:	fb8a 2c0c 	smull	r2, ip, sl, ip
 800fef8:	6a02      	ldr	r2, [r0, #32]
 800fefa:	f8d3 412c 	ldr.w	r4, [r3, #300]	; 0x12c
 800fefe:	fb84 e202 	smull	lr, r2, r4, r2
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800ff02:	4462      	add	r2, ip
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800ff04:	f8d3 c148 	ldr.w	ip, [r3, #328]	; 0x148
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 800ff08:	60ca      	str	r2, [r1, #12]
 800ff0a:	6842      	ldr	r2, [r0, #4]
 800ff0c:	fb8c e202 	smull	lr, r2, ip, r2
 800ff10:	f8d0 e01c 	ldr.w	lr, [r0, #28]
 800ff14:	f8d3 4130 	ldr.w	r4, [r3, #304]	; 0x130
 800ff18:	fb84 8e0e 	smull	r8, lr, r4, lr
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800ff1c:	4472      	add	r2, lr
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 800ff1e:	f8d3 e14c 	ldr.w	lr, [r3, #332]	; 0x14c
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 800ff22:	610a      	str	r2, [r1, #16]
 800ff24:	6882      	ldr	r2, [r0, #8]
 800ff26:	fb8e 8202 	smull	r8, r2, lr, r2
 800ff2a:	f8d3 8134 	ldr.w	r8, [r3, #308]	; 0x134
 800ff2e:	6983      	ldr	r3, [r0, #24]
 800ff30:	fb88 9303 	smull	r9, r3, r8, r3
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 800ff34:	441a      	add	r2, r3
 800ff36:	614a      	str	r2, [r1, #20]
 800ff38:	6943      	ldr	r3, [r0, #20]
 800ff3a:	fb87 2303 	smull	r2, r3, r7, r3
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 800ff3e:	618b      	str	r3, [r1, #24]
 800ff40:	6903      	ldr	r3, [r0, #16]
 800ff42:	fb86 2303 	smull	r2, r3, r6, r3
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 800ff46:	61cb      	str	r3, [r1, #28]
 800ff48:	68c3      	ldr	r3, [r0, #12]
 800ff4a:	fb85 2303 	smull	r2, r3, r5, r3
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 800ff4e:	620b      	str	r3, [r1, #32]
 800ff50:	68c3      	ldr	r3, [r0, #12]
 800ff52:	fb8a 2303 	smull	r2, r3, sl, r3
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 800ff56:	624b      	str	r3, [r1, #36]	; 0x24
 800ff58:	6903      	ldr	r3, [r0, #16]
 800ff5a:	fb8c 2303 	smull	r2, r3, ip, r3
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 800ff5e:	628b      	str	r3, [r1, #40]	; 0x28
 800ff60:	6942      	ldr	r2, [r0, #20]
 800ff62:	fb8e 3202 	smull	r3, r2, lr, r2
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800ff66:	2300      	movs	r3, #0
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 800ff68:	62ca      	str	r2, [r1, #44]	; 0x2c
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 800ff6a:	e9c1 3310 	strd	r3, r3, [r1, #64]	; 0x40
 800ff6e:	e9c1 330e 	strd	r3, r3, [r1, #56]	; 0x38
 800ff72:	e9c1 330c 	strd	r3, r3, [r1, #48]	; 0x30
}
 800ff76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ff7a:	bf00      	nop
 800ff7c:	08019c80 	.word	0x08019c80

0800ff80 <xmp3_IMDCT>:
 *              updated hi->nonZeroBound index for this channel
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 800ff80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ff84:	b0e3      	sub	sp, #396	; 0x18c
 800ff86:	9138      	str	r1, [sp, #224]	; 0xe0
 800ff88:	9235      	str	r2, [sp, #212]	; 0xd4
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 800ff8a:	2800      	cmp	r0, #0
 800ff8c:	f002 807a 	beq.w	8012084 <xmp3_IMDCT+0x2104>
 800ff90:	6803      	ldr	r3, [r0, #0]
 800ff92:	2b00      	cmp	r3, #0
 800ff94:	f002 8076 	beq.w	8012084 <xmp3_IMDCT+0x2104>
 800ff98:	6844      	ldr	r4, [r0, #4]
 800ff9a:	9437      	str	r4, [sp, #220]	; 0xdc
 800ff9c:	2c00      	cmp	r4, #0
 800ff9e:	f002 8071 	beq.w	8012084 <xmp3_IMDCT+0x2104>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 800ffa2:	68c5      	ldr	r5, [r0, #12]
 800ffa4:	9513      	str	r5, [sp, #76]	; 0x4c
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 800ffa6:	2d00      	cmp	r5, #0
 800ffa8:	f002 806c 	beq.w	8012084 <xmp3_IMDCT+0x2104>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 800ffac:	6940      	ldr	r0, [r0, #20]
 800ffae:	9014      	str	r0, [sp, #80]	; 0x50
 800ffb0:	2800      	cmp	r0, #0
 800ffb2:	f002 8067 	beq.w	8012084 <xmp3_IMDCT+0x2104>
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffb6:	4616      	mov	r6, r2
 800ffb8:	781a      	ldrb	r2, [r3, #0]
 800ffba:	460f      	mov	r7, r1
 800ffbc:	48bd      	ldr	r0, [pc, #756]	; (80102b4 <xmp3_IMDCT+0x334>)
 800ffbe:	2a00      	cmp	r2, #0
 800ffc0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
	if (si->sis[gr][ch].blockType != 2) {
 800ffc2:	eb01 03c1 	add.w	r3, r1, r1, lsl #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffc6:	bf0c      	ite	eq
 800ffc8:	2108      	moveq	r1, #8
 800ffca:	2106      	movne	r1, #6
	if (si->sis[gr][ch].blockType != 2) {
 800ffcc:	011b      	lsls	r3, r3, #4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffce:	f932 2011 	ldrsh.w	r2, [r2, r1, lsl #1]
	if (si->sis[gr][ch].blockType != 2) {
 800ffd2:	eb06 01c6 	add.w	r1, r6, r6, lsl #3
 800ffd6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800ffda:	4423      	add	r3, r4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffdc:	17d4      	asrs	r4, r2, #31
 800ffde:	fb80 c202 	smull	ip, r2, r0, r2
 800ffe2:	ebc4 02a2 	rsb	r2, r4, r2, asr #2
	if (si->sis[gr][ch].blockType != 2) {
 800ffe6:	00f4      	lsls	r4, r6, #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffe8:	b212      	sxth	r2, r2
	if (si->sis[gr][ch].blockType != 2) {
 800ffea:	9436      	str	r4, [sp, #216]	; 0xd8
 800ffec:	00fc      	lsls	r4, r7, #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 800ffee:	922c      	str	r2, [sp, #176]	; 0xb0
	if (si->sis[gr][ch].blockType != 2) {
 800fff0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800fff2:	9439      	str	r4, [sp, #228]	; 0xe4
 800fff4:	2a02      	cmp	r2, #2
 800fff6:	f002 801e 	beq.w	8012036 <xmp3_IMDCT+0x20b6>
		/* all long transforms */
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 800fffa:	f506 6390 	add.w	r3, r6, #1152	; 0x480
 800fffe:	f240 2226 	movw	r2, #550	; 0x226
 8010002:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8010006:	4293      	cmp	r3, r2
 8010008:	f340 8323 	ble.w	8010652 <xmp3_IMDCT+0x6d2>
		/* all short transforms */
		bc.nBlocksLong = 0;
		nBfly = 0;
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 801000c:	020b      	lsls	r3, r1, #8
 801000e:	f240 2236 	movw	r2, #566	; 0x236
 8010012:	9316      	str	r3, [sp, #88]	; 0x58
 8010014:	eb05 2301 	add.w	r3, r5, r1, lsl #8
 8010018:	9215      	str	r2, [sp, #84]	; 0x54
 801001a:	9311      	str	r3, [sp, #68]	; 0x44
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 801001c:	2320      	movs	r3, #32
 801001e:	9332      	str	r3, [sp, #200]	; 0xc8
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8010020:	231f      	movs	r3, #31
 8010022:	9911      	ldr	r1, [sp, #68]	; 0x44
 8010024:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 8010028:	4aa3      	ldr	r2, [pc, #652]	; (80102b8 <xmp3_IMDCT+0x338>)
 801002a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801002e:	930f      	str	r3, [sp, #60]	; 0x3c
 8010030:	460b      	mov	r3, r1
 8010032:	6811      	ldr	r1, [r2, #0]
 8010034:	9101      	str	r1, [sp, #4]
 8010036:	6851      	ldr	r1, [r2, #4]
 8010038:	9102      	str	r1, [sp, #8]
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801003a:	6891      	ldr	r1, [r2, #8]
 801003c:	9103      	str	r1, [sp, #12]
 801003e:	68d1      	ldr	r1, [r2, #12]
 8010040:	9108      	str	r1, [sp, #32]
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 8010042:	6911      	ldr	r1, [r2, #16]
 8010044:	9109      	str	r1, [sp, #36]	; 0x24
 8010046:	6951      	ldr	r1, [r2, #20]
 8010048:	910b      	str	r1, [sp, #44]	; 0x2c
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 801004a:	6991      	ldr	r1, [r2, #24]
 801004c:	910c      	str	r1, [sp, #48]	; 0x30
 801004e:	69d1      	ldr	r1, [r2, #28]
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8010050:	e9d2 ce08 	ldrd	ip, lr, [r2, #32]
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 8010054:	910e      	str	r1, [sp, #56]	; 0x38
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 8010056:	e9d2 890a 	ldrd	r8, r9, [r2, #40]	; 0x28
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801005a:	e9d2 170e 	ldrd	r1, r7, [r2, #56]	; 0x38
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801005e:	e9d2 ab0c 	ldrd	sl, fp, [r2, #48]	; 0x30
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 8010062:	9110      	str	r1, [sp, #64]	; 0x40
 8010064:	9712      	str	r7, [sp, #72]	; 0x48
 8010066:	9f01      	ldr	r7, [sp, #4]
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 8010068:	e9d3 4211 	ldrd	r4, r2, [r3, #68]	; 0x44
 801006c:	4625      	mov	r5, r4
 801006e:	fb87 0505 	smull	r0, r5, r7, r5
 8010072:	4610      	mov	r0, r2
 8010074:	9902      	ldr	r1, [sp, #8]
 8010076:	fb81 6000 	smull	r6, r0, r1, r0
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801007a:	1a28      	subs	r0, r5, r0
 801007c:	0040      	lsls	r0, r0, #1
 801007e:	6458      	str	r0, [r3, #68]	; 0x44
 8010080:	fb87 0202 	smull	r0, r2, r7, r2
 8010084:	fb81 0404 	smull	r0, r4, r1, r4
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010088:	4422      	add	r2, r4
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801008a:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 801008c:	9903      	ldr	r1, [sp, #12]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801008e:	0052      	lsls	r2, r2, #1
 8010090:	4625      	mov	r5, r4
 8010092:	649a      	str	r2, [r3, #72]	; 0x48
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 8010094:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010096:	fb81 0505 	smull	r0, r5, r1, r5
 801009a:	4610      	mov	r0, r2
 801009c:	9f08      	ldr	r7, [sp, #32]
 801009e:	fb87 6000 	smull	r6, r0, r7, r0
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80100a2:	1a28      	subs	r0, r5, r0
 80100a4:	0040      	lsls	r0, r0, #1
 80100a6:	6418      	str	r0, [r3, #64]	; 0x40
 80100a8:	fb81 0202 	smull	r0, r2, r1, r2
 80100ac:	fb87 0404 	smull	r0, r4, r7, r4
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80100b0:	4422      	add	r2, r4
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 80100b2:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80100b4:	9909      	ldr	r1, [sp, #36]	; 0x24
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80100b6:	0052      	lsls	r2, r2, #1
 80100b8:	4625      	mov	r5, r4
 80100ba:	64da      	str	r2, [r3, #76]	; 0x4c
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 80100bc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80100be:	fb81 0505 	smull	r0, r5, r1, r5
 80100c2:	4610      	mov	r0, r2
 80100c4:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80100c6:	fb87 6000 	smull	r6, r0, r7, r0
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80100ca:	1a28      	subs	r0, r5, r0
 80100cc:	0040      	lsls	r0, r0, #1
 80100ce:	63d8      	str	r0, [r3, #60]	; 0x3c
 80100d0:	fb81 0202 	smull	r0, r2, r1, r2
 80100d4:	fb87 0404 	smull	r0, r4, r7, r4
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80100d8:	4422      	add	r2, r4
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 80100da:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 80100dc:	990c      	ldr	r1, [sp, #48]	; 0x30
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 80100de:	0052      	lsls	r2, r2, #1
 80100e0:	4625      	mov	r5, r4
 80100e2:	651a      	str	r2, [r3, #80]	; 0x50
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 80100e4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80100e6:	fb81 0505 	smull	r0, r5, r1, r5
 80100ea:	4610      	mov	r0, r2
 80100ec:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 80100ee:	fb87 6000 	smull	r6, r0, r7, r0
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 80100f2:	1a28      	subs	r0, r5, r0
 80100f4:	0040      	lsls	r0, r0, #1
 80100f6:	6398      	str	r0, [r3, #56]	; 0x38
 80100f8:	fb81 0202 	smull	r0, r2, r1, r2
 80100fc:	fb87 0404 	smull	r0, r4, r7, r4
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010100:	4422      	add	r2, r4
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 8010102:	6b5c      	ldr	r4, [r3, #52]	; 0x34
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010104:	0052      	lsls	r2, r2, #1
 8010106:	4625      	mov	r5, r4
 8010108:	655a      	str	r2, [r3, #84]	; 0x54
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 801010a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 801010c:	fb8c 0505 	smull	r0, r5, ip, r5
 8010110:	4610      	mov	r0, r2
 8010112:	fb8e 6000 	smull	r6, r0, lr, r0
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010116:	1a28      	subs	r0, r5, r0
 8010118:	0040      	lsls	r0, r0, #1
 801011a:	6358      	str	r0, [r3, #52]	; 0x34
 801011c:	fb8c 0202 	smull	r0, r2, ip, r2
 8010120:	fb8e 0404 	smull	r0, r4, lr, r4
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010124:	4422      	add	r2, r4
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 8010126:	6b1c      	ldr	r4, [r3, #48]	; 0x30
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010128:	0052      	lsls	r2, r2, #1
 801012a:	4625      	mov	r5, r4
 801012c:	659a      	str	r2, [r3, #88]	; 0x58
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 801012e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8010130:	fb88 0505 	smull	r0, r5, r8, r5
 8010134:	4610      	mov	r0, r2
 8010136:	fb89 6000 	smull	r6, r0, r9, r0
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801013a:	1a28      	subs	r0, r5, r0
 801013c:	0040      	lsls	r0, r0, #1
 801013e:	6318      	str	r0, [r3, #48]	; 0x30
 8010140:	fb88 0202 	smull	r0, r2, r8, r2
 8010144:	fb89 0404 	smull	r0, r4, r9, r4
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010148:	4422      	add	r2, r4
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801014a:	6adc      	ldr	r4, [r3, #44]	; 0x2c
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801014c:	0052      	lsls	r2, r2, #1
 801014e:	4625      	mov	r5, r4
 8010150:	65da      	str	r2, [r3, #92]	; 0x5c
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 8010152:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8010154:	fb8a 0505 	smull	r0, r5, sl, r5
 8010158:	4610      	mov	r0, r2
 801015a:	fb8b 6000 	smull	r6, r0, fp, r0
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801015e:	1a28      	subs	r0, r5, r0
 8010160:	0040      	lsls	r0, r0, #1
 8010162:	62d8      	str	r0, [r3, #44]	; 0x2c
 8010164:	fb8a 0202 	smull	r0, r2, sl, r2
 8010168:	fb8b 0404 	smull	r0, r4, fp, r4
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801016c:	4422      	add	r2, r4
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801016e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8010170:	9f10      	ldr	r7, [sp, #64]	; 0x40
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010172:	0052      	lsls	r2, r2, #1
 8010174:	4625      	mov	r5, r4
 8010176:	661a      	str	r2, [r3, #96]	; 0x60
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 8010178:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 801017a:	fb87 0505 	smull	r0, r5, r7, r5
 801017e:	4610      	mov	r0, r2
 8010180:	9912      	ldr	r1, [sp, #72]	; 0x48
 8010182:	fb81 6000 	smull	r6, r0, r1, r0
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 8010186:	1a28      	subs	r0, r5, r0
 8010188:	0040      	lsls	r0, r0, #1
 801018a:	6298      	str	r0, [r3, #40]	; 0x28
 801018c:	fb87 0202 	smull	r0, r2, r7, r2
 8010190:	fb81 0404 	smull	r0, r4, r1, r4
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010194:	4422      	add	r2, r4
	for (k = nBfly; k > 0; k--) {
 8010196:	3348      	adds	r3, #72	; 0x48
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 8010198:	0052      	lsls	r2, r2, #1
 801019a:	61da      	str	r2, [r3, #28]
	for (k = nBfly; k > 0; k--) {
 801019c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801019e:	4293      	cmp	r3, r2
 80101a0:	f47f af61 	bne.w	8010066 <xmp3_IMDCT+0xe6>
	/* for readability, use a struct instead of passing a million parameters to HybridTransform() */
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
	bc.prevType = mi->prevType[ch];
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80101a4:	e9dd 2338 	ldrd	r2, r3, [sp, #224]	; 0xe0
 80101a8:	4413      	add	r3, r2
 80101aa:	e9dd 1235 	ldrd	r1, r2, [sp, #212]	; 0xd4
 80101ae:	011b      	lsls	r3, r3, #4
 80101b0:	440a      	add	r2, r1
 80101b2:	460e      	mov	r6, r1
 80101b4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80101b8:	9a37      	ldr	r2, [sp, #220]	; 0xdc
 80101ba:	4413      	add	r3, r2
 80101bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80101be:	9a13      	ldr	r2, [sp, #76]	; 0x4c
	bc.gbIn = hi->gb[ch];

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 80101c0:	9f14      	ldr	r7, [sp, #80]	; 0x50
 80101c2:	eb02 0186 	add.w	r1, r2, r6, lsl #2
 80101c6:	9d16      	ldr	r5, [sp, #88]	; 0x58
 80101c8:	eb07 0286 	add.w	r2, r7, r6, lsl #2
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 80101cc:	4839      	ldr	r0, [pc, #228]	; (80102b4 <xmp3_IMDCT+0x334>)
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 80101ce:	443d      	add	r5, r7
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80101d0:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 80101d4:	f502 5480 	add.w	r4, r2, #4096	; 0x1000
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 80101d8:	9534      	str	r5, [sp, #208]	; 0xd0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80101da:	f8d1 2200 	ldr.w	r2, [r1, #512]	; 0x200
 80101de:	9d15      	ldr	r5, [sp, #84]	; 0x54
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 80101e0:	943c      	str	r4, [sp, #240]	; 0xf0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80101e2:	4295      	cmp	r5, r2
 80101e4:	bfb8      	it	lt
 80101e6:	4615      	movlt	r5, r2
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80101e8:	2b00      	cmp	r3, #0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 80101ea:	462a      	mov	r2, r5
 80101ec:	f8c1 5200 	str.w	r5, [r1, #512]	; 0x200
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80101f0:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 80101f2:	bf08      	it	eq
 80101f4:	2500      	moveq	r5, #0
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 80101f6:	3211      	adds	r2, #17
	bc.gbIn = hi->gb[ch];
 80101f8:	f8d1 1208 	ldr.w	r1, [r1, #520]	; 0x208
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 80101fc:	952c      	str	r5, [sp, #176]	; 0xb0
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 80101fe:	fb80 5002 	smull	r5, r0, r0, r2
 8010202:	17d2      	asrs	r2, r2, #31
	bc.gbIn = hi->gb[ch];
 8010204:	9112      	str	r1, [sp, #72]	; 0x48
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 8010206:	ebc2 02a0 	rsb	r2, r2, r0, asr #2
 801020a:	922a      	str	r2, [sp, #168]	; 0xa8
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801020c:	9a36      	ldr	r2, [sp, #216]	; 0xd8
 801020e:	1991      	adds	r1, r2, r6
 8010210:	eb07 12c1 	add.w	r2, r7, r1, lsl #7
 8010214:	f502 5790 	add.w	r7, r2, #4608	; 0x1200
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 8010218:	f8d4 2b00 	ldr.w	r2, [r4, #2816]	; 0xb00
 801021c:	922b      	str	r2, [sp, #172]	; 0xac
	bc.prevType = mi->prevType[ch];
 801021e:	f8d4 2b08 	ldr.w	r2, [r4, #2824]	; 0xb08
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8010222:	9733      	str	r7, [sp, #204]	; 0xcc
	bc.prevType = mi->prevType[ch];
 8010224:	9218      	str	r2, [sp, #96]	; 0x60
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 8010226:	f8d4 2b10 	ldr.w	r2, [r4, #2832]	; 0xb10
	for(i = 0; i < bc->nBlocksLong; i++) {
 801022a:	9c32      	ldr	r4, [sp, #200]	; 0xc8
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 801022c:	922d      	str	r2, [sp, #180]	; 0xb4
	for(i = 0; i < bc->nBlocksLong; i++) {
 801022e:	2c00      	cmp	r4, #0
 8010230:	f341 8720 	ble.w	8012074 <xmp3_IMDCT+0x20f4>
 8010234:	9812      	ldr	r0, [sp, #72]	; 0x48
		currWinIdx = sis->blockType;
 8010236:	e9dd 5238 	ldrd	r5, r2, [sp, #224]	; 0xe0
 801023a:	2806      	cmp	r0, #6
 801023c:	442a      	add	r2, r5
 801023e:	9d34      	ldr	r5, [sp, #208]	; 0xd0
 8010240:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8010244:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 8010248:	9937      	ldr	r1, [sp, #220]	; 0xdc
 801024a:	440a      	add	r2, r1
		es = 7 - gb;
 801024c:	f1c0 0107 	rsb	r1, r0, #7
		currWinIdx = sis->blockType;
 8010250:	9223      	str	r2, [sp, #140]	; 0x8c
 8010252:	eb05 0284 	add.w	r2, r5, r4, lsl #2
		es = 7 - gb;
 8010256:	912e      	str	r1, [sp, #184]	; 0xb8
 8010258:	f5a2 6290 	sub.w	r2, r2, #1152	; 0x480
 801025c:	9227      	str	r2, [sp, #156]	; 0x9c
	mOut = 0;
 801025e:	f04f 0200 	mov.w	r2, #0
 8010262:	bfc8      	it	gt
 8010264:	4611      	movgt	r1, r2
 8010266:	9202      	str	r2, [sp, #8]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010268:	920c      	str	r2, [sp, #48]	; 0x30
 801026a:	ee07 1a90 	vmov	s15, r1
 801026e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8010270:	f101 0648 	add.w	r6, r1, #72	; 0x48
 8010274:	f107 0124 	add.w	r1, r7, #36	; 0x24
 8010278:	910b      	str	r1, [sp, #44]	; 0x2c
 801027a:	f5a5 6190 	sub.w	r1, r5, #1152	; 0x480
 801027e:	9103      	str	r1, [sp, #12]
 8010280:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 8010282:	992c      	ldr	r1, [sp, #176]	; 0xb0
 8010284:	3a24      	subs	r2, #36	; 0x24
 8010286:	980c      	ldr	r0, [sp, #48]	; 0x30
 8010288:	9214      	str	r2, [sp, #80]	; 0x50
 801028a:	4281      	cmp	r1, r0
		currWinIdx = sis->blockType;
 801028c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801028e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8010290:	9213      	str	r2, [sp, #76]	; 0x4c
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 8010292:	dd03      	ble.n	801029c <xmp3_IMDCT+0x31c>
			currWinIdx = 0;
 8010294:	2b00      	cmp	r3, #0
 8010296:	bf18      	it	ne
 8010298:	2200      	movne	r2, #0
 801029a:	9213      	str	r2, [sp, #76]	; 0x4c
		if (i < bc->prevWinSwitch)
 801029c:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801029e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80102a0:	4293      	cmp	r3, r2
 80102a2:	f300 82aa 	bgt.w	80107fa <xmp3_IMDCT+0x87a>
 80102a6:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80102a8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
	bc.prevType = mi->prevType[ch];
 80102aa:	9324      	str	r3, [sp, #144]	; 0x90
 80102ac:	ea43 0b02 	orr.w	fp, r3, r2
 80102b0:	e004      	b.n	80102bc <xmp3_IMDCT+0x33c>
 80102b2:	bf00      	nop
 80102b4:	38e38e39 	.word	0x38e38e39
 80102b8:	08019c40 	.word	0x08019c40
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 80102bc:	9b03      	ldr	r3, [sp, #12]
 80102be:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 80102c2:	931d      	str	r3, [sp, #116]	; 0x74
 80102c4:	9301      	str	r3, [sp, #4]
	if (gb < 7) {
 80102c6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80102c8:	2b06      	cmp	r3, #6
 80102ca:	f340 81f3 	ble.w	80106b4 <xmp3_IMDCT+0x734>
			acc1 = (*xCurr--) - acc1;
 80102ce:	f856 1c04 	ldr.w	r1, [r6, #-4]
			acc1 = (*xCurr--) - acc1;
 80102d2:	f856 3c08 	ldr.w	r3, [r6, #-8]
 80102d6:	f856 2c10 	ldr.w	r2, [r6, #-16]
 80102da:	eba3 0901 	sub.w	r9, r3, r1
			acc1 = (*xCurr--) - acc1;
 80102de:	f856 3c0c 	ldr.w	r3, [r6, #-12]
			acc1 = (*xCurr--) - acc1;
 80102e2:	f856 5c18 	ldr.w	r5, [r6, #-24]
			acc1 = (*xCurr--) - acc1;
 80102e6:	eba3 0309 	sub.w	r3, r3, r9
 80102ea:	911e      	str	r1, [sp, #120]	; 0x78
			acc1 = (*xCurr--) - acc1;
 80102ec:	eba2 0e03 	sub.w	lr, r2, r3
			acc2 = acc1 - acc2;
 80102f0:	1a5a      	subs	r2, r3, r1
			acc1 = (*xCurr--) - acc1;
 80102f2:	f856 3c14 	ldr.w	r3, [r6, #-20]
			acc2 = acc1 - acc2;
 80102f6:	920e      	str	r2, [sp, #56]	; 0x38
			acc1 = (*xCurr--) - acc1;
 80102f8:	eba3 030e 	sub.w	r3, r3, lr
			acc1 = (*xCurr--) - acc1;
 80102fc:	1ae9      	subs	r1, r5, r3
			acc2 = acc1 - acc2;
 80102fe:	1a98      	subs	r0, r3, r2
			acc1 = (*xCurr--) - acc1;
 8010300:	f856 3c1c 	ldr.w	r3, [r6, #-28]
			acc1 = (*xCurr--) - acc1;
 8010304:	f856 2c20 	ldr.w	r2, [r6, #-32]
			acc1 = (*xCurr--) - acc1;
 8010308:	1a5b      	subs	r3, r3, r1
			acc1 = (*xCurr--) - acc1;
 801030a:	9117      	str	r1, [sp, #92]	; 0x5c
			acc2 = acc1 - acc2;
 801030c:	9016      	str	r0, [sp, #88]	; 0x58
 801030e:	1a19      	subs	r1, r3, r0
			acc1 = (*xCurr--) - acc1;
 8010310:	eba2 0a03 	sub.w	sl, r2, r3
			acc1 = (*xCurr--) - acc1;
 8010314:	f856 3c24 	ldr.w	r3, [r6, #-36]
			acc1 = (*xCurr--) - acc1;
 8010318:	f856 2c28 	ldr.w	r2, [r6, #-40]
			acc1 = (*xCurr--) - acc1;
 801031c:	eba3 050a 	sub.w	r5, r3, sl
 8010320:	f856 3c2c 	ldr.w	r3, [r6, #-44]
			acc2 = acc1 - acc2;
 8010324:	910f      	str	r1, [sp, #60]	; 0x3c
			acc1 = (*xCurr--) - acc1;
 8010326:	eba2 0805 	sub.w	r8, r2, r5
			acc2 = acc1 - acc2;
 801032a:	1a6a      	subs	r2, r5, r1
			acc1 = (*xCurr--) - acc1;
 801032c:	f856 5c30 	ldr.w	r5, [r6, #-48]
			acc1 = (*xCurr--) - acc1;
 8010330:	eba3 0308 	sub.w	r3, r3, r8
			acc2 = acc1 - acc2;
 8010334:	921f      	str	r2, [sp, #124]	; 0x7c
 8010336:	1a99      	subs	r1, r3, r2
			acc1 = (*xCurr--) - acc1;
 8010338:	1aed      	subs	r5, r5, r3
			acc1 = (*xCurr--) - acc1;
 801033a:	f856 3c34 	ldr.w	r3, [r6, #-52]
			acc2 = acc1 - acc2;
 801033e:	911a      	str	r1, [sp, #104]	; 0x68
			acc1 = (*xCurr--) - acc1;
 8010340:	1b5a      	subs	r2, r3, r5
			acc1 = (*xCurr--) - acc1;
 8010342:	f856 3c38 	ldr.w	r3, [r6, #-56]
			acc2 = acc1 - acc2;
 8010346:	1a50      	subs	r0, r2, r1
			acc1 = (*xCurr--) - acc1;
 8010348:	1a9b      	subs	r3, r3, r2
			acc1 = (*xCurr--) - acc1;
 801034a:	f856 2c3c 	ldr.w	r2, [r6, #-60]
			acc1 = (*xCurr--) - acc1;
 801034e:	f856 1c40 	ldr.w	r1, [r6, #-64]
			acc1 = (*xCurr--) - acc1;
 8010352:	1ad7      	subs	r7, r2, r3
 8010354:	f856 2c44 	ldr.w	r2, [r6, #-68]
			acc2 = acc1 - acc2;
 8010358:	9008      	str	r0, [sp, #32]
			acc1 = (*xCurr--) - acc1;
 801035a:	eba1 0c07 	sub.w	ip, r1, r7
			acc2 = acc1 - acc2;
 801035e:	1a38      	subs	r0, r7, r0
			acc1 = (*xCurr--) - acc1;
 8010360:	f856 1c48 	ldr.w	r1, [r6, #-72]
			acc1 = (*xCurr--) - acc1;
 8010364:	eba2 020c 	sub.w	r2, r2, ip
			acc2 = acc1 - acc2;
 8010368:	9009      	str	r0, [sp, #36]	; 0x24
			acc1 = (*xCurr--) - acc1;
 801036a:	1a89      	subs	r1, r1, r2
			acc2 = acc1 - acc2;
 801036c:	1a12      	subs	r2, r2, r0
	xBuf[9] >>= 1;
 801036e:	1050      	asrs	r0, r2, #1
	a4 = x2 - x4;
 8010370:	eba3 0208 	sub.w	r2, r3, r8
 8010374:	9510      	str	r5, [sp, #64]	; 0x40
	xBuf[0] >>= 1;
 8010376:	104d      	asrs	r5, r1, #1
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8010378:	eba2 0709 	sub.w	r7, r2, r9
	a1 = x0 - x6;
 801037c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
	xBuf[9] >>= 1;
 801037e:	9015      	str	r0, [sp, #84]	; 0x54
	a5 = x2 + x4;
 8010380:	eb08 0003 	add.w	r0, r8, r3
	a1 = x0 - x6;
 8010384:	ebc2 0161 	rsb	r1, r2, r1, asr #1
	xBuf[0] >>= 1;
 8010388:	9519      	str	r5, [sp, #100]	; 0x64
 801038a:	4cc4      	ldr	r4, [pc, #784]	; (801069c <xmp3_IMDCT+0x71c>)
	a1 = x0 - x6;
 801038c:	911b      	str	r1, [sp, #108]	; 0x6c
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801038e:	ebaa 010e 	sub.w	r1, sl, lr
 8010392:	9d10      	ldr	r5, [sp, #64]	; 0x40
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8010394:	971c      	str	r7, [sp, #112]	; 0x70
 8010396:	fb84 2505 	smull	r2, r5, r4, r5
	a2 = x1 - x5;
 801039a:	ebac 070a 	sub.w	r7, ip, sl
 801039e:	9510      	str	r5, [sp, #64]	; 0x40
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80103a0:	eba7 070e 	sub.w	r7, r7, lr
 80103a4:	463d      	mov	r5, r7
 80103a6:	fb84 2505 	smull	r2, r5, r4, r5
 80103aa:	4fbd      	ldr	r7, [pc, #756]	; (80106a0 <xmp3_IMDCT+0x720>)
 80103ac:	9520      	str	r5, [sp, #128]	; 0x80
 80103ae:	4605      	mov	r5, r0
 80103b0:	fb87 2505 	smull	r2, r5, r7, r5
	a6 = x2 + x8;
 80103b4:	444b      	add	r3, r9
 80103b6:	4fbb      	ldr	r7, [pc, #748]	; (80106a4 <xmp3_IMDCT+0x724>)
 80103b8:	9521      	str	r5, [sp, #132]	; 0x84
 80103ba:	461a      	mov	r2, r3
 80103bc:	463b      	mov	r3, r7
 80103be:	4615      	mov	r5, r2
 80103c0:	fb87 2505 	smull	r2, r5, r7, r5
 80103c4:	4fb6      	ldr	r7, [pc, #728]	; (80106a0 <xmp3_IMDCT+0x720>)
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 80103c6:	eba9 0808 	sub.w	r8, r9, r8
 80103ca:	9522      	str	r5, [sp, #136]	; 0x88
 80103cc:	fb87 2808 	smull	r2, r8, r7, r8
 80103d0:	fb83 2000 	smull	r2, r0, r3, r0
 80103d4:	f103 5770 	add.w	r7, r3, #1006632960	; 0x3c000000
 80103d8:	4689      	mov	r9, r1
 80103da:	f507 274c 	add.w	r7, r7, #835584	; 0xcc000
 80103de:	f207 27cb 	addw	r7, r7, #715	; 0x2cb
 80103e2:	fb87 2909 	smull	r2, r9, r7, r9
 80103e6:	4bb0      	ldr	r3, [pc, #704]	; (80106a8 <xmp3_IMDCT+0x728>)
	a7 = x1 + x7;
 80103e8:	eb0c 020e 	add.w	r2, ip, lr
 80103ec:	fb83 e202 	smull	lr, r2, r3, r2
	a3 = x1 + x5;
 80103f0:	44d4      	add	ip, sl
 80103f2:	fb87 ec0c 	smull	lr, ip, r7, ip
 80103f6:	fb83 e101 	smull	lr, r1, r3, r1
	a12 = x[0] +  (x[6] >> 1);
 80103fa:	9b17      	ldr	r3, [sp, #92]	; 0x5c
	a19 = ( m9 << 1) + (m10 << 1);
 80103fc:	0052      	lsls	r2, r2, #1
	a12 = x[0] +  (x[6] >> 1);
 80103fe:	9d19      	ldr	r5, [sp, #100]	; 0x64
	a20 = (m11 << 1) - (m12 << 1);
 8010400:	0049      	lsls	r1, r1, #1
	a19 = ( m9 << 1) + (m10 << 1);
 8010402:	eb02 0749 	add.w	r7, r2, r9, lsl #1
	a13 = a12  +  (  m1 << 1);
 8010406:	9a10      	ldr	r2, [sp, #64]	; 0x40
	a12 = x[0] +  (x[6] >> 1);
 8010408:	eb05 0e63 	add.w	lr, r5, r3, asr #1
	a16 = ( m5 << 1) + (m6 << 1);
 801040c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801040e:	9d21      	ldr	r5, [sp, #132]	; 0x84
	a20 = (m11 << 1) - (m12 << 1);
 8010410:	ebc1 014c 	rsb	r1, r1, ip, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010414:	005b      	lsls	r3, r3, #1
	a19 = ( m9 << 1) + (m10 << 1);
 8010416:	9717      	str	r7, [sp, #92]	; 0x5c
	a13 = a12  +  (  m1 << 1);
 8010418:	eb0e 0c42 	add.w	ip, lr, r2, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 801041c:	eb03 0345 	add.w	r3, r3, r5, lsl #1
	a17 = ( m7 << 1) - (m8 << 1);
 8010420:	0040      	lsls	r0, r0, #1
	a14 = a12  -  (  m1 << 1);
 8010422:	ebae 0542 	sub.w	r5, lr, r2, lsl #1
	a17 = ( m7 << 1) - (m8 << 1);
 8010426:	ebc0 0048 	rsb	r0, r0, r8, lsl #1
 801042a:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
	a15 = a1   +  ( a11 >> 1);
 801042e:	e9dd 271b 	ldrd	r2, r7, [sp, #108]	; 0x6c
	a18 = a16 + a17;
 8010432:	eb03 0e00 	add.w	lr, r3, r0
	x4 = a1 - a11;			x[4] = x4;
 8010436:	eba2 0a07 	sub.w	sl, r2, r7
	a15 = a1   +  ( a11 >> 1);
 801043a:	eb02 0967 	add.w	r9, r2, r7, asr #1
	a21 = a20 - a19;
 801043e:	9f17      	ldr	r7, [sp, #92]	; 0x5c
	x4 = a1 - a11;			x[4] = x4;
 8010440:	f8cd a108 	str.w	sl, [sp, #264]	; 0x108
	a22 = a13 + a16;
 8010444:	eb0c 0a03 	add.w	sl, ip, r3
	a23 = a14 + a16;
 8010448:	442b      	add	r3, r5
	a21 = a20 - a19;
 801044a:	1bca      	subs	r2, r1, r7
	x0 = a22 + a19;			x[0] = x0;
 801044c:	44ba      	add	sl, r7
	x8 = a23 - a19;			x[8] = x8;
 801044e:	1bdb      	subs	r3, r3, r7
	x0 = a22 + a19;			x[0] = x0;
 8010450:	f8cd a0f8 	str.w	sl, [sp, #248]	; 0xf8
	x8 = a23 - a19;			x[8] = x8;
 8010454:	9346      	str	r3, [sp, #280]	; 0x118
	a24 = a14 + a17;
 8010456:	182b      	adds	r3, r5, r0
	a26 = a14 - a18;
 8010458:	eba5 050e 	sub.w	r5, r5, lr
	a27 = a13 - a18;
 801045c:	ebac 0e0e 	sub.w	lr, ip, lr
	x2 = a24 + a20;			x[2] = x2;
 8010460:	440b      	add	r3, r1
	a25 = a13 + a17;
 8010462:	4460      	add	r0, ip
	x3 = a26 - a21;			x[3] = x3;
 8010464:	1aad      	subs	r5, r5, r2
	x2 = a24 + a20;			x[2] = x2;
 8010466:	9340      	str	r3, [sp, #256]	; 0x100
	x5 = a27 + a21;			x[5] = x5;
 8010468:	eb0e 0302 	add.w	r3, lr, r2
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801046c:	9a20      	ldr	r2, [sp, #128]	; 0x80
	x6 = a25 - a20;			x[6] = x6;
 801046e:	1a40      	subs	r0, r0, r1
	x3 = a26 - a21;			x[3] = x3;
 8010470:	9541      	str	r5, [sp, #260]	; 0x104
	x7 = a15 - (m3 << 1);	x[7] = x7;
 8010472:	eba9 0742 	sub.w	r7, r9, r2, lsl #1
	a4 = x2 - x4;
 8010476:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
	x5 = a27 + a21;			x[5] = x5;
 8010478:	9343      	str	r3, [sp, #268]	; 0x10c
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801047a:	eb09 0342 	add.w	r3, r9, r2, lsl #1
	a4 = x2 - x4;
 801047e:	9a08      	ldr	r2, [sp, #32]
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8010480:	991e      	ldr	r1, [sp, #120]	; 0x78
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8010482:	933f      	str	r3, [sp, #252]	; 0xfc
	a4 = x2 - x4;
 8010484:	1b53      	subs	r3, r2, r5
	x6 = a25 - a20;			x[6] = x6;
 8010486:	9044      	str	r0, [sp, #272]	; 0x110
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 8010488:	1a5b      	subs	r3, r3, r1
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801048a:	9745      	str	r7, [sp, #276]	; 0x114
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801048c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 801048e:	9319      	str	r3, [sp, #100]	; 0x64
	a1 = x0 - x6;
 8010490:	e9dd 0315 	ldrd	r0, r3, [sp, #84]	; 0x54
 8010494:	1ac0      	subs	r0, r0, r3
 8010496:	9017      	str	r0, [sp, #92]	; 0x5c
	a5 = x2 + x4;
 8010498:	1950      	adds	r0, r2, r5
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801049a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801049c:	1abb      	subs	r3, r7, r2
 801049e:	9310      	str	r3, [sp, #64]	; 0x40
 80104a0:	fb84 3808 	smull	r3, r8, r4, r8
	a2 = x1 - x5;
 80104a4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80104a6:	eba2 0e07 	sub.w	lr, r2, r7
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 80104aa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80104ac:	ebae 0e02 	sub.w	lr, lr, r2
 80104b0:	fb84 3e0e 	smull	r3, lr, r4, lr
 80104b4:	4c7a      	ldr	r4, [pc, #488]	; (80106a0 <xmp3_IMDCT+0x720>)
 80104b6:	4681      	mov	r9, r0
 80104b8:	fb84 3909 	smull	r3, r9, r4, r9
	a6 = x2 + x8;
 80104bc:	9a08      	ldr	r2, [sp, #32]
 80104be:	4f79      	ldr	r7, [pc, #484]	; (80106a4 <xmp3_IMDCT+0x724>)
 80104c0:	1853      	adds	r3, r2, r1
 80104c2:	fb87 2303 	smull	r2, r3, r7, r3
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 80104c6:	1b4d      	subs	r5, r1, r5
 80104c8:	fb84 2505 	smull	r2, r5, r4, r5
 80104cc:	fb87 2000 	smull	r2, r0, r7, r0
 80104d0:	f1a4 647c 	sub.w	r4, r4, #264241152	; 0xfc00000
 80104d4:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
 80104d8:	f5a4 24dc 	sub.w	r4, r4, #450560	; 0x6e000
 80104dc:	f5a4 74a1 	sub.w	r4, r4, #322	; 0x142
 80104e0:	fb84 2a0a 	smull	r2, sl, r4, sl
	a7 = x1 + x7;
 80104e4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80104e6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80104e8:	188a      	adds	r2, r1, r2
 80104ea:	496f      	ldr	r1, [pc, #444]	; (80106a8 <xmp3_IMDCT+0x728>)
 80104ec:	fb81 7202 	smull	r7, r2, r1, r2
	a3 = x1 + x5;
 80104f0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80104f2:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 80104f4:	9208      	str	r2, [sp, #32]
 80104f6:	19cf      	adds	r7, r1, r7
 80104f8:	fb84 c707 	smull	ip, r7, r4, r7
 80104fc:	4c6a      	ldr	r4, [pc, #424]	; (80106a8 <xmp3_IMDCT+0x728>)
 80104fe:	9910      	ldr	r1, [sp, #64]	; 0x40
 8010500:	fb84 c101 	smull	ip, r1, r4, r1
	a12 = x[0] +  (x[6] >> 1);
 8010504:	e9dd 4215 	ldrd	r4, r2, [sp, #84]	; 0x54
	a16 = ( m5 << 1) + (m6 << 1);
 8010508:	005b      	lsls	r3, r3, #1
	a12 = x[0] +  (x[6] >> 1);
 801050a:	eb04 0c62 	add.w	ip, r4, r2, asr #1
	a19 = ( m9 << 1) + (m10 << 1);
 801050e:	9a08      	ldr	r2, [sp, #32]
	a17 = ( m7 << 1) - (m8 << 1);
 8010510:	0040      	lsls	r0, r0, #1
	a15 = a1   +  ( a11 >> 1);
 8010512:	9c19      	ldr	r4, [sp, #100]	; 0x64
	a19 = ( m9 << 1) + (m10 << 1);
 8010514:	0052      	lsls	r2, r2, #1
	a16 = ( m5 << 1) + (m6 << 1);
 8010516:	eb03 0349 	add.w	r3, r3, r9, lsl #1
	a17 = ( m7 << 1) - (m8 << 1);
 801051a:	ebc0 0045 	rsb	r0, r0, r5, lsl #1
	a15 = a1   +  ( a11 >> 1);
 801051e:	9d17      	ldr	r5, [sp, #92]	; 0x5c
	a19 = ( m9 << 1) + (m10 << 1);
 8010520:	eb02 0a4a 	add.w	sl, r2, sl, lsl #1
	a20 = (m11 << 1) - (m12 << 1);
 8010524:	0049      	lsls	r1, r1, #1
	x4 = a1 - a11;			x[4] = x4;
 8010526:	eba5 0904 	sub.w	r9, r5, r4
	a13 = a12  +  (  m1 << 1);
 801052a:	eb0c 0248 	add.w	r2, ip, r8, lsl #1
	a14 = a12  -  (  m1 << 1);
 801052e:	ebac 0c48 	sub.w	ip, ip, r8, lsl #1
	x4 = a1 - a11;			x[4] = x4;
 8010532:	f8cd 912c 	str.w	r9, [sp, #300]	; 0x12c
	a20 = (m11 << 1) - (m12 << 1);
 8010536:	ebc1 0747 	rsb	r7, r1, r7, lsl #1
	a22 = a13 + a16;
 801053a:	eb02 0803 	add.w	r8, r2, r3
	a18 = a16 + a17;
 801053e:	1819      	adds	r1, r3, r0
	a23 = a14 + a16;
 8010540:	4463      	add	r3, ip
	a21 = a20 - a19;
 8010542:	eba7 090a 	sub.w	r9, r7, sl
	x0 = a22 + a19;			x[0] = x0;
 8010546:	44d0      	add	r8, sl
	x8 = a23 - a19;			x[8] = x8;
 8010548:	eba3 030a 	sub.w	r3, r3, sl
	a18 = a16 + a17;
 801054c:	9108      	str	r1, [sp, #32]
	a15 = a1   +  ( a11 >> 1);
 801054e:	eb05 0164 	add.w	r1, r5, r4, asr #1
	x0 = a22 + a19;			x[0] = x0;
 8010552:	f8cd 811c 	str.w	r8, [sp, #284]	; 0x11c
	x8 = a23 - a19;			x[8] = x8;
 8010556:	934f      	str	r3, [sp, #316]	; 0x13c
	a24 = a14 + a17;
 8010558:	eb0c 0300 	add.w	r3, ip, r0
	a15 = a1   +  ( a11 >> 1);
 801055c:	9109      	str	r1, [sp, #36]	; 0x24
	a25 = a13 + a17;
 801055e:	4410      	add	r0, r2
	a26 = a14 - a18;
 8010560:	9908      	ldr	r1, [sp, #32]
	x2 = a24 + a20;			x[2] = x2;
 8010562:	443b      	add	r3, r7
	x6 = a25 - a20;			x[6] = x6;
 8010564:	1bc0      	subs	r0, r0, r7
	a26 = a14 - a18;
 8010566:	ebac 0c01 	sub.w	ip, ip, r1
	x2 = a24 + a20;			x[2] = x2;
 801056a:	9349      	str	r3, [sp, #292]	; 0x124
	a27 = a13 - a18;
 801056c:	1a51      	subs	r1, r2, r1
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801056e:	9a09      	ldr	r2, [sp, #36]	; 0x24
	x3 = a26 - a21;			x[3] = x3;
 8010570:	ebac 0309 	sub.w	r3, ip, r9
	x6 = a25 - a20;			x[6] = x6;
 8010574:	904d      	str	r0, [sp, #308]	; 0x134
	x5 = a27 + a21;			x[5] = x5;
 8010576:	4449      	add	r1, r9
	x7 = a15 - (m3 << 1);	x[7] = x7;
 8010578:	eba2 054e 	sub.w	r5, r2, lr, lsl #1
	x3 = a26 - a21;			x[3] = x3;
 801057c:	934a      	str	r3, [sp, #296]	; 0x128
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801057e:	eb02 034e 	add.w	r3, r2, lr, lsl #1
	x5 = a27 + a21;			x[5] = x5;
 8010582:	914c      	str	r1, [sp, #304]	; 0x130
	x1 = a15 + (m3 << 1);	x[1] = x1;
 8010584:	9348      	str	r3, [sp, #288]	; 0x120
	x7 = a15 - (m3 << 1);	x[7] = x7;
 8010586:	954e      	str	r5, [sp, #312]	; 0x138
	if (btPrev == 0 && btCurr == 0) {
 8010588:	f1bb 0f00 	cmp.w	fp, #0
 801058c:	f040 813a 	bne.w	8010804 <xmp3_IMDCT+0x884>
	cp = c18 + 8;
 8010590:	9608      	str	r6, [sp, #32]
	if (btPrev == 0 && btCurr == 0) {
 8010592:	46dc      	mov	ip, fp
 8010594:	4d45      	ldr	r5, [pc, #276]	; (80106ac <xmp3_IMDCT+0x72c>)
	xp = xBuf + 8;
 8010596:	af46      	add	r7, sp, #280	; 0x118
	if (btPrev == 0 && btCurr == 0) {
 8010598:	f8dd e050 	ldr.w	lr, [sp, #80]	; 0x50
	cp = c18 + 8;
 801059c:	f8df 8110 	ldr.w	r8, [pc, #272]	; 80106b0 <xmp3_IMDCT+0x730>
 80105a0:	f8dd 9098 	ldr.w	r9, [sp, #152]	; 0x98
 80105a4:	9e25      	ldr	r6, [sp, #148]	; 0x94
 80105a6:	9c1d      	ldr	r4, [sp, #116]	; 0x74
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 80105a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105aa:	f858 1904 	ldr.w	r1, [r8], #-4
 80105ae:	f857 2904 	ldr.w	r2, [r7], #-4
 80105b2:	fb81 0303 	smull	r0, r3, r1, r3
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 80105b6:	eb03 01a2 	add.w	r1, r3, r2, asr #2
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 80105ba:	f8de 0000 	ldr.w	r0, [lr]
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 80105be:	eba3 02a2 	sub.w	r2, r3, r2, asr #2
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 80105c2:	f84e 1b04 	str.w	r1, [lr], #4
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 80105c6:	4241      	negs	r1, r0
 80105c8:	f855 3c08 	ldr.w	r3, [r5, #-8]
			t = s - d;
 80105cc:	1a89      	subs	r1, r1, r2
 80105ce:	fb81 a303 	smull	sl, r3, r1, r3
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 80105d2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80105d6:	f855 2c04 	ldr.w	r2, [r5, #-4]
 80105da:	fb81 a202 	smull	sl, r2, r1, r2
    return y;
 80105de:	ebc0 0282 	rsb	r2, r0, r2, lsl #2
			y[(i)*NBANDS]    = 	yLo;
 80105e2:	9901      	ldr	r1, [sp, #4]
 80105e4:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
			y[(17-i)*NBANDS] =  yHi;
 80105e8:	f8c4 2880 	str.w	r2, [r4, #2176]	; 0x880
	__asm__ volatile (
 80105ec:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 80105f0:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
 80105f4:	ea82 79e2 	eor.w	r9, r2, r2, asr #31
 80105f8:	eba9 79e2 	sub.w	r9, r9, r2, asr #31
			mOut |= FASTABS(yHi);
 80105fc:	ea46 0309 	orr.w	r3, r6, r9
		for (i = 0; i < 9; i++) {
 8010600:	3c80      	subs	r4, #128	; 0x80
 8010602:	3508      	adds	r5, #8
 8010604:	f10c 0c20 	add.w	ip, ip, #32
			mOut |= FASTABS(yHi);
 8010608:	ea4b 0b03 	orr.w	fp, fp, r3
		for (i = 0; i < 9; i++) {
 801060c:	9b03      	ldr	r3, [sp, #12]
 801060e:	42a3      	cmp	r3, r4
 8010610:	d1ca      	bne.n	80105a8 <xmp3_IMDCT+0x628>
 8010612:	4608      	mov	r0, r1
 8010614:	e9cd 6925 	strd	r6, r9, [sp, #148]	; 0x94
 8010618:	9e08      	ldr	r6, [sp, #32]
	for(i = 0; i < bc->nBlocksLong; i++) {
 801061a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801061c:	3648      	adds	r6, #72	; 0x48
 801061e:	9c03      	ldr	r4, [sp, #12]
 8010620:	3324      	adds	r3, #36	; 0x24
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010622:	9914      	ldr	r1, [sp, #80]	; 0x50
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010624:	3404      	adds	r4, #4
 8010626:	930b      	str	r3, [sp, #44]	; 0x2c
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010628:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	for(i = 0; i < bc->nBlocksLong; i++) {
 801062a:	9403      	str	r4, [sp, #12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801062c:	461a      	mov	r2, r3
	for(i = 0; i < bc->nBlocksLong; i++) {
 801062e:	3301      	adds	r3, #1
 8010630:	930c      	str	r3, [sp, #48]	; 0x30
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8010632:	ee17 3a90 	vmov	r3, s15
 8010636:	f7ff f9c1 	bl	800f9bc <FreqInvertRescale>
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 801063a:	9b02      	ldr	r3, [sp, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801063c:	ea40 000b 	orr.w	r0, r0, fp
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 8010640:	4303      	orrs	r3, r0
 8010642:	9302      	str	r3, [sp, #8]
	for(i = 0; i < bc->nBlocksLong; i++) {
 8010644:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 8010646:	429c      	cmp	r4, r3
 8010648:	f000 81b2 	beq.w	80109b0 <xmp3_IMDCT+0xa30>
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 801064c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 801064e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010650:	e616      	b.n	8010280 <xmp3_IMDCT+0x300>
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 8010652:	3307      	adds	r3, #7
 8010654:	4631      	mov	r1, r6
 8010656:	fb80 2003 	smull	r2, r0, r0, r3
 801065a:	17db      	asrs	r3, r3, #31
 801065c:	ebc3 03a0 	rsb	r3, r3, r0, asr #2
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8010660:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
 8010664:	0052      	lsls	r2, r2, #1
 8010666:	3208      	adds	r2, #8
 8010668:	9215      	str	r2, [sp, #84]	; 0x54
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 801066a:	1c5a      	adds	r2, r3, #1
 801066c:	9232      	str	r2, [sp, #200]	; 0xc8
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 801066e:	9a36      	ldr	r2, [sp, #216]	; 0xd8
	for (k = nBfly; k > 0; k--) {
 8010670:	2b00      	cmp	r3, #0
 8010672:	440a      	add	r2, r1
 8010674:	ea4f 2102 	mov.w	r1, r2, lsl #8
 8010678:	9116      	str	r1, [sp, #88]	; 0x58
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 801067a:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801067c:	eb01 2102 	add.w	r1, r1, r2, lsl #8
 8010680:	9111      	str	r1, [sp, #68]	; 0x44
	for (k = nBfly; k > 0; k--) {
 8010682:	f73f acce 	bgt.w	8010022 <xmp3_IMDCT+0xa2>
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 8010686:	e9dd 1338 	ldrd	r1, r3, [sp, #224]	; 0xe0
 801068a:	9e35      	ldr	r6, [sp, #212]	; 0xd4
 801068c:	440b      	add	r3, r1
 801068e:	011b      	lsls	r3, r3, #4
 8010690:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8010694:	9a37      	ldr	r2, [sp, #220]	; 0xdc
 8010696:	4413      	add	r3, r2
 8010698:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801069a:	e590      	b.n	80101be <xmp3_IMDCT+0x23e>
 801069c:	6ed9eba1 	.word	0x6ed9eba1
 80106a0:	620dbe8b 	.word	0x620dbe8b
 80106a4:	163a1a7e 	.word	0x163a1a7e
 80106a8:	7e0e2e32 	.word	0x7e0e2e32
 80106ac:	08019a98 	.word	0x08019a98
 80106b0:	08019a8c 	.word	0x08019a8c
			xPrev[i] >>= es;
 80106b4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80106b6:	982e      	ldr	r0, [sp, #184]	; 0xb8
 80106b8:	f851 3c04 	ldr.w	r3, [r1, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106bc:	f856 5c04 	ldr.w	r5, [r6, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106c0:	f856 2c08 	ldr.w	r2, [r6, #-8]
			xPrev[i] >>= es;
 80106c4:	4103      	asrs	r3, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 80106c6:	fa45 f400 	asr.w	r4, r5, r0
			xPrev[i] >>= es;
 80106ca:	460d      	mov	r5, r1
 80106cc:	f841 3c04 	str.w	r3, [r1, #-4]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106d0:	fa42 f800 	asr.w	r8, r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 80106d4:	f856 3c0c 	ldr.w	r3, [r6, #-12]
			xPrev[i] >>= es;
 80106d8:	f851 2c08 	ldr.w	r2, [r1, #-8]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106dc:	eba8 0904 	sub.w	r9, r8, r4
 80106e0:	f856 1c10 	ldr.w	r1, [r6, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106e4:	4103      	asrs	r3, r0
			xPrev[i] >>= es;
 80106e6:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 80106e8:	941e      	str	r4, [sp, #120]	; 0x78
 80106ea:	eba3 0309 	sub.w	r3, r3, r9
			xPrev[i] >>= es;
 80106ee:	f845 2c08 	str.w	r2, [r5, #-8]
			acc1 = ((*xCurr--) >> es) - acc1;
 80106f2:	fa41 f200 	asr.w	r2, r1, r0
			acc2 = acc1 - acc2;
 80106f6:	1b1c      	subs	r4, r3, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 80106f8:	f856 1c18 	ldr.w	r1, [r6, #-24]
 80106fc:	eba2 0e03 	sub.w	lr, r2, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 8010700:	f856 3c14 	ldr.w	r3, [r6, #-20]
			xPrev[i] >>= es;
 8010704:	f855 2c0c 	ldr.w	r2, [r5, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010708:	4101      	asrs	r1, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 801070a:	4103      	asrs	r3, r0
			acc2 = acc1 - acc2;
 801070c:	940e      	str	r4, [sp, #56]	; 0x38
			xPrev[i] >>= es;
 801070e:	4102      	asrs	r2, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 8010710:	eba3 030e 	sub.w	r3, r3, lr
			xPrev[i] >>= es;
 8010714:	f845 2c0c 	str.w	r2, [r5, #-12]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010718:	4602      	mov	r2, r0
			acc2 = acc1 - acc2;
 801071a:	1b1c      	subs	r4, r3, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 801071c:	1ac8      	subs	r0, r1, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 801071e:	f856 3c1c 	ldr.w	r3, [r6, #-28]
 8010722:	4611      	mov	r1, r2
			acc1 = ((*xCurr--) >> es) - acc1;
 8010724:	9017      	str	r0, [sp, #92]	; 0x5c
			acc1 = ((*xCurr--) >> es) - acc1;
 8010726:	4113      	asrs	r3, r2
			xPrev[i] >>= es;
 8010728:	f855 2c10 	ldr.w	r2, [r5, #-16]
			acc2 = acc1 - acc2;
 801072c:	9416      	str	r4, [sp, #88]	; 0x58
			acc1 = ((*xCurr--) >> es) - acc1;
 801072e:	1a1f      	subs	r7, r3, r0
			xPrev[i] >>= es;
 8010730:	410a      	asrs	r2, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010732:	f856 3c20 	ldr.w	r3, [r6, #-32]
			xPrev[i] >>= es;
 8010736:	4628      	mov	r0, r5
 8010738:	f845 2c10 	str.w	r2, [r5, #-16]
			acc1 = ((*xCurr--) >> es) - acc1;
 801073c:	460a      	mov	r2, r1
 801073e:	fa43 fc01 	asr.w	ip, r3, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 8010742:	f856 3c24 	ldr.w	r3, [r6, #-36]
			acc2 = acc1 - acc2;
 8010746:	1b39      	subs	r1, r7, r4
			acc1 = ((*xCurr--) >> es) - acc1;
 8010748:	ebac 0a07 	sub.w	sl, ip, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 801074c:	4113      	asrs	r3, r2
 801074e:	4617      	mov	r7, r2
			xPrev[i] >>= es;
 8010750:	f850 2c14 	ldr.w	r2, [r0, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010754:	eba3 050a 	sub.w	r5, r3, sl
			acc1 = ((*xCurr--) >> es) - acc1;
 8010758:	f856 3c28 	ldr.w	r3, [r6, #-40]
			xPrev[i] >>= es;
 801075c:	413a      	asrs	r2, r7
			acc2 = acc1 - acc2;
 801075e:	910f      	str	r1, [sp, #60]	; 0x3c
			acc1 = ((*xCurr--) >> es) - acc1;
 8010760:	fa43 f807 	asr.w	r8, r3, r7
			acc2 = acc1 - acc2;
 8010764:	1a69      	subs	r1, r5, r1
			xPrev[i] >>= es;
 8010766:	f840 2c14 	str.w	r2, [r0, #-20]
			acc1 = ((*xCurr--) >> es) - acc1;
 801076a:	f856 3c2c 	ldr.w	r3, [r6, #-44]
			acc1 = ((*xCurr--) >> es) - acc1;
 801076e:	eba8 0805 	sub.w	r8, r8, r5
			xPrev[i] >>= es;
 8010772:	f850 2c18 	ldr.w	r2, [r0, #-24]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010776:	413b      	asrs	r3, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 8010778:	f856 5c30 	ldr.w	r5, [r6, #-48]
			xPrev[i] >>= es;
 801077c:	413a      	asrs	r2, r7
			acc2 = acc1 - acc2;
 801077e:	911f      	str	r1, [sp, #124]	; 0x7c
			acc1 = ((*xCurr--) >> es) - acc1;
 8010780:	eba3 0308 	sub.w	r3, r3, r8
			acc1 = ((*xCurr--) >> es) - acc1;
 8010784:	413d      	asrs	r5, r7
			xPrev[i] >>= es;
 8010786:	f840 2c18 	str.w	r2, [r0, #-24]
			acc2 = acc1 - acc2;
 801078a:	1a5c      	subs	r4, r3, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 801078c:	1aed      	subs	r5, r5, r3
			acc2 = acc1 - acc2;
 801078e:	941a      	str	r4, [sp, #104]	; 0x68
			acc1 = ((*xCurr--) >> es) - acc1;
 8010790:	f856 3c34 	ldr.w	r3, [r6, #-52]
			xPrev[i] >>= es;
 8010794:	f850 2c1c 	ldr.w	r2, [r0, #-28]
			acc1 = ((*xCurr--) >> es) - acc1;
 8010798:	413b      	asrs	r3, r7
			xPrev[i] >>= es;
 801079a:	413a      	asrs	r2, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 801079c:	1b59      	subs	r1, r3, r5
			acc1 = ((*xCurr--) >> es) - acc1;
 801079e:	f856 3c38 	ldr.w	r3, [r6, #-56]
			xPrev[i] >>= es;
 80107a2:	f840 2c1c 	str.w	r2, [r0, #-28]
			acc1 = ((*xCurr--) >> es) - acc1;
 80107a6:	4638      	mov	r0, r7
 80107a8:	f856 2c3c 	ldr.w	r2, [r6, #-60]
			acc1 = ((*xCurr--) >> es) - acc1;
 80107ac:	413b      	asrs	r3, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 80107ae:	413a      	asrs	r2, r7
			acc1 = ((*xCurr--) >> es) - acc1;
 80107b0:	1a5b      	subs	r3, r3, r1
			acc2 = acc1 - acc2;
 80107b2:	1b09      	subs	r1, r1, r4
			xPrev[i] >>= es;
 80107b4:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
			acc1 = ((*xCurr--) >> es) - acc1;
 80107b6:	1ad7      	subs	r7, r2, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 80107b8:	f856 2c40 	ldr.w	r2, [r6, #-64]
			acc2 = acc1 - acc2;
 80107bc:	9108      	str	r1, [sp, #32]
			xPrev[i] >>= es;
 80107be:	f854 1c20 	ldr.w	r1, [r4, #-32]
			acc1 = ((*xCurr--) >> es) - acc1;
 80107c2:	fa42 fc00 	asr.w	ip, r2, r0
			acc2 = acc1 - acc2;
 80107c6:	9a08      	ldr	r2, [sp, #32]
			xPrev[i] >>= es;
 80107c8:	4101      	asrs	r1, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 80107ca:	ebac 0c07 	sub.w	ip, ip, r7
			xPrev[i] >>= es;
 80107ce:	f844 1c20 	str.w	r1, [r4, #-32]
			acc1 = ((*xCurr--) >> es) - acc1;
 80107d2:	4601      	mov	r1, r0
			acc2 = acc1 - acc2;
 80107d4:	1ab8      	subs	r0, r7, r2
			acc1 = ((*xCurr--) >> es) - acc1;
 80107d6:	f856 2c44 	ldr.w	r2, [r6, #-68]
 80107da:	460f      	mov	r7, r1
 80107dc:	410a      	asrs	r2, r1
			acc1 = ((*xCurr--) >> es) - acc1;
 80107de:	f856 1c48 	ldr.w	r1, [r6, #-72]
			acc2 = acc1 - acc2;
 80107e2:	9009      	str	r0, [sp, #36]	; 0x24
			acc1 = ((*xCurr--) >> es) - acc1;
 80107e4:	eba2 020c 	sub.w	r2, r2, ip
			acc1 = ((*xCurr--) >> es) - acc1;
 80107e8:	4139      	asrs	r1, r7
 80107ea:	1a89      	subs	r1, r1, r2
			acc2 = acc1 - acc2;
 80107ec:	1a12      	subs	r2, r2, r0
			xPrev[i] >>= es;
 80107ee:	f854 0c24 	ldr.w	r0, [r4, #-36]
 80107f2:	4138      	asrs	r0, r7
 80107f4:	f844 0c24 	str.w	r0, [r4, #-36]
		for (i = 8; i >= 0; i--) {	
 80107f8:	e5b9      	b.n	801036e <xmp3_IMDCT+0x3ee>
			 prevWinIdx = 0;
 80107fa:	2300      	movs	r3, #0
 80107fc:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
 8010800:	9324      	str	r3, [sp, #144]	; 0x90
 8010802:	e55b      	b.n	80102bc <xmp3_IMDCT+0x33c>
	if (btPrev == 2) {
 8010804:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8010806:	2b02      	cmp	r3, #2
 8010808:	f000 80c6 	beq.w	8010998 <xmp3_IMDCT+0xa18>
		wpLo = imdctWin[btPrev] + 18;
 801080c:	f8df c198 	ldr.w	ip, [pc, #408]	; 80109a8 <xmp3_IMDCT+0xa28>
 8010810:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010814:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
		wpLo = imdctWin[btPrev] + 18;
 8010816:	eb0c 1303 	add.w	r3, ip, r3, lsl #4
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801081a:	f854 0c24 	ldr.w	r0, [r4, #-36]
 801081e:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010822:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8010824:	4605      	mov	r5, r0
 8010826:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801082a:	9550      	str	r5, [sp, #320]	; 0x140
 801082c:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010830:	9061      	str	r0, [sp, #388]	; 0x184
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010832:	f854 0c20 	ldr.w	r0, [r4, #-32]
 8010836:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 801083a:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 801083c:	4605      	mov	r5, r0
 801083e:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010842:	9551      	str	r5, [sp, #324]	; 0x144
 8010844:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010848:	9060      	str	r0, [sp, #384]	; 0x180
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801084a:	f854 0c1c 	ldr.w	r0, [r4, #-28]
 801084e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8010852:	6d19      	ldr	r1, [r3, #80]	; 0x50
 8010854:	4605      	mov	r5, r0
 8010856:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801085a:	9552      	str	r5, [sp, #328]	; 0x148
 801085c:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010860:	905f      	str	r0, [sp, #380]	; 0x17c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010862:	f854 0c18 	ldr.w	r0, [r4, #-24]
 8010866:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 801086a:	6d59      	ldr	r1, [r3, #84]	; 0x54
 801086c:	4605      	mov	r5, r0
 801086e:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010872:	9553      	str	r5, [sp, #332]	; 0x14c
 8010874:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010878:	905e      	str	r0, [sp, #376]	; 0x178
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801087a:	f854 0c14 	ldr.w	r0, [r4, #-20]
 801087e:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8010880:	6d99      	ldr	r1, [r3, #88]	; 0x58
 8010882:	4605      	mov	r5, r0
 8010884:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010888:	9554      	str	r5, [sp, #336]	; 0x150
 801088a:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 801088e:	905d      	str	r0, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010890:	f854 0c10 	ldr.w	r0, [r4, #-16]
 8010894:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8010896:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8010898:	4605      	mov	r5, r0
 801089a:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801089e:	9555      	str	r5, [sp, #340]	; 0x154
 80108a0:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 80108a4:	905c      	str	r0, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80108a6:	f854 0c0c 	ldr.w	r0, [r4, #-12]
 80108aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80108ac:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80108ae:	4605      	mov	r5, r0
 80108b0:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80108b4:	9556      	str	r5, [sp, #344]	; 0x158
 80108b6:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 80108ba:	905b      	str	r0, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80108bc:	f854 0c08 	ldr.w	r0, [r4, #-8]
 80108c0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80108c2:	6e59      	ldr	r1, [r3, #100]	; 0x64
 80108c4:	4605      	mov	r5, r0
 80108c6:	fb81 7505 	smull	r7, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80108ca:	9557      	str	r5, [sp, #348]	; 0x15c
 80108cc:	fb82 1000 	smull	r1, r0, r2, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 80108d0:	905a      	str	r0, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80108d2:	f854 2c04 	ldr.w	r2, [r4, #-4]
 80108d6:	e9d3 011a 	ldrd	r0, r1, [r3, #104]	; 0x68
 80108da:	4613      	mov	r3, r2
 80108dc:	fb80 5303 	smull	r5, r3, r0, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 80108e0:	9358      	str	r3, [sp, #352]	; 0x160
 80108e2:	fb81 3202 	smull	r3, r2, r1, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 80108e6:	9259      	str	r2, [sp, #356]	; 0x164
		wp = imdctWin[btCurr];
 80108e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80108ea:	2000      	movs	r0, #0
 80108ec:	f8dd e050 	ldr.w	lr, [sp, #80]	; 0x50
 80108f0:	f50d 7a9e 	add.w	sl, sp, #316	; 0x13c
 80108f4:	eb03 05c3 	add.w	r5, r3, r3, lsl #3
	cp = c18 + 8;
 80108f8:	960e      	str	r6, [sp, #56]	; 0x38
 80108fa:	f8cd e020 	str.w	lr, [sp, #32]
 80108fe:	f50d 79c4 	add.w	r9, sp, #392	; 0x188
		wp = imdctWin[btCurr];
 8010902:	eb0c 1505 	add.w	r5, ip, r5, lsl #4
	cp = c18 + 8;
 8010906:	f8df c0a4 	ldr.w	ip, [pc, #164]	; 80109ac <xmp3_IMDCT+0xa2c>
	mOut = 0;
 801090a:	4683      	mov	fp, r0
	xp = xBuf + 8;
 801090c:	af46      	add	r7, sp, #280	; 0x118
 801090e:	f1a5 0804 	sub.w	r8, r5, #4
	cp = c18 + 8;
 8010912:	46e6      	mov	lr, ip
 8010914:	3548      	adds	r5, #72	; 0x48
 8010916:	f8dd c0a4 	ldr.w	ip, [sp, #164]	; 0xa4
 801091a:	9e28      	ldr	r6, [sp, #160]	; 0xa0
 801091c:	9c1d      	ldr	r4, [sp, #116]	; 0x74
 801091e:	9509      	str	r5, [sp, #36]	; 0x24
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 8010920:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010922:	f85e 2904 	ldr.w	r2, [lr], #-4
 8010926:	f857 1904 	ldr.w	r1, [r7], #-4
 801092a:	fb82 5303 	smull	r5, r3, r2, r3
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 801092e:	eb03 02a1 	add.w	r2, r3, r1, asr #2
			d = xe - xo;
 8010932:	ebc3 01a1 	rsb	r1, r3, r1, asr #2
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 8010936:	9b08      	ldr	r3, [sp, #32]
 8010938:	f843 2b04 	str.w	r2, [r3], #4
 801093c:	f858 2f04 	ldr.w	r2, [r8, #4]!
 8010940:	9308      	str	r3, [sp, #32]
 8010942:	fb81 3202 	smull	r3, r2, r1, r2
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 8010946:	f85a 3f04 	ldr.w	r3, [sl, #4]!
 801094a:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801094c:	441a      	add	r2, r3
 801094e:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8010952:	0092      	lsls	r2, r2, #2
 8010954:	9509      	str	r5, [sp, #36]	; 0x24
 8010956:	fb81 5303 	smull	r5, r3, r1, r3
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 801095a:	f859 1d04 	ldr.w	r1, [r9, #-4]!
 801095e:	440b      	add	r3, r1
			y[(i)*NBANDS]    = yLo;
 8010960:	9901      	ldr	r1, [sp, #4]
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 8010962:	009b      	lsls	r3, r3, #2
			y[(i)*NBANDS]    = yLo;
 8010964:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
			y[(17-i)*NBANDS] = yHi;
 8010968:	f8c4 3880 	str.w	r3, [r4, #2176]	; 0x880
	__asm__ volatile (
 801096c:	ea82 76e2 	eor.w	r6, r2, r2, asr #31
 8010970:	eba6 76e2 	sub.w	r6, r6, r2, asr #31
 8010974:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
 8010978:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
		for (i = 0; i < 9; i++) {
 801097c:	3020      	adds	r0, #32
			mOut |= FASTABS(yHi);
 801097e:	ea46 030c 	orr.w	r3, r6, ip
		for (i = 0; i < 9; i++) {
 8010982:	3c80      	subs	r4, #128	; 0x80
 8010984:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
			mOut |= FASTABS(yHi);
 8010988:	ea4b 0b03 	orr.w	fp, fp, r3
		for (i = 0; i < 9; i++) {
 801098c:	d1c8      	bne.n	8010920 <xmp3_IMDCT+0x9a0>
 801098e:	4608      	mov	r0, r1
 8010990:	e9cd 6c28 	strd	r6, ip, [sp, #160]	; 0xa0
 8010994:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8010996:	e640      	b.n	801061a <xmp3_IMDCT+0x69a>
 8010998:	a950      	add	r1, sp, #320	; 0x140
 801099a:	9814      	ldr	r0, [sp, #80]	; 0x50
 801099c:	f7ff fa7e 	bl	800fe9c <WinPrevious.part.0>
 80109a0:	f8df c004 	ldr.w	ip, [pc, #4]	; 80109a8 <xmp3_IMDCT+0xa28>
 80109a4:	e7a0      	b.n	80108e8 <xmp3_IMDCT+0x968>
 80109a6:	bf00      	nop
 80109a8:	08019c80 	.word	0x08019c80
 80109ac:	08019a8c 	.word	0x08019a8c
		xCurr += 18;
 80109b0:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 80109b2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80109b4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 80109b8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 80109bc:	9211      	str	r2, [sp, #68]	; 0x44
		xPrev += 9;
 80109be:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 80109c0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80109c4:	9333      	str	r3, [sp, #204]	; 0xcc
	for (   ; i < bc->nBlocksTotal; i++) {
 80109c6:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 80109c8:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 80109ca:	429a      	cmp	r2, r3
 80109cc:	f341 834f 	ble.w	801206e <xmp3_IMDCT+0x20ee>
 80109d0:	9912      	ldr	r1, [sp, #72]	; 0x48
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80109d2:	f8df 8514 	ldr.w	r8, [pc, #1300]	; 8010ee8 <xmp3_IMDCT+0xf68>
 80109d6:	2906      	cmp	r1, #6
		es = 7 - gb;
 80109d8:	f1c1 0107 	rsb	r1, r1, #7
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80109dc:	f8d8 0120 	ldr.w	r0, [r8, #288]	; 0x120
		es = 7 - gb;
 80109e0:	912e      	str	r1, [sp, #184]	; 0xb8
 80109e2:	bfc8      	it	gt
 80109e4:	2100      	movgt	r1, #0
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80109e6:	9021      	str	r0, [sp, #132]	; 0x84
 80109e8:	ee07 1a10 	vmov	s14, r1
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80109ec:	f8d8 1138 	ldr.w	r1, [r8, #312]	; 0x138
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 80109f0:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80109f4:	9123      	str	r1, [sp, #140]	; 0x8c
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 80109f6:	f8d8 1144 	ldr.w	r1, [r8, #324]	; 0x144
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 80109fa:	9022      	str	r0, [sp, #136]	; 0x88
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 80109fc:	9119      	str	r1, [sp, #100]	; 0x64
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80109fe:	f8d8 1124 	ldr.w	r1, [r8, #292]	; 0x124
 8010a02:	911a      	str	r1, [sp, #104]	; 0x68
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010a04:	f8d8 1130 	ldr.w	r1, [r8, #304]	; 0x130
 8010a08:	911b      	str	r1, [sp, #108]	; 0x6c
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010a0a:	f8d8 113c 	ldr.w	r1, [r8, #316]	; 0x13c
 8010a0e:	9120      	str	r1, [sp, #128]	; 0x80
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010a10:	f8d8 1148 	ldr.w	r1, [r8, #328]	; 0x148
 8010a14:	911c      	str	r1, [sp, #112]	; 0x70
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010a16:	f8d8 1128 	ldr.w	r1, [r8, #296]	; 0x128
 8010a1a:	911d      	str	r1, [sp, #116]	; 0x74
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010a1c:	f8d8 1134 	ldr.w	r1, [r8, #308]	; 0x134
 8010a20:	9103      	str	r1, [sp, #12]
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010a22:	f8d8 1140 	ldr.w	r1, [r8, #320]	; 0x140
 8010a26:	911e      	str	r1, [sp, #120]	; 0x78
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010a28:	f8d8 114c 	ldr.w	r1, [r8, #332]	; 0x14c
 8010a2c:	911f      	str	r1, [sp, #124]	; 0x7c
 8010a2e:	992d      	ldr	r1, [sp, #180]	; 0xb4
 8010a30:	4299      	cmp	r1, r3
 8010a32:	f341 82fb 	ble.w	801202c <xmp3_IMDCT+0x20ac>
 8010a36:	428a      	cmp	r2, r1
 8010a38:	9811      	ldr	r0, [sp, #68]	; 0x44
 8010a3a:	9301      	str	r3, [sp, #4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010a3c:	46c1      	mov	r9, r8
 8010a3e:	bfa8      	it	ge
 8010a40:	460a      	movge	r2, r1
 8010a42:	f100 0a48 	add.w	sl, r0, #72	; 0x48
 8010a46:	9230      	str	r2, [sp, #192]	; 0xc0
 8010a48:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 8010a4a:	f102 0c24 	add.w	ip, r2, #36	; 0x24
 8010a4e:	9a34      	ldr	r2, [sp, #208]	; 0xd0
 8010a50:	eb02 0283 	add.w	r2, r2, r3, lsl #2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010a54:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
 8010a58:	46e6      	mov	lr, ip
 8010a5a:	932f      	str	r3, [sp, #188]	; 0xbc
 8010a5c:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
 8010a60:	4690      	mov	r8, r2
 8010a62:	9331      	str	r3, [sp, #196]	; 0xc4
 8010a64:	f1ae 0324 	sub.w	r3, lr, #36	; 0x24
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8010a68:	ee07 8a90 	vmov	s15, r8
 8010a6c:	ee06 3a90 	vmov	s13, r3
	if (gb < 7) {
 8010a70:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8010a72:	2b06      	cmp	r3, #6
 8010a74:	f300 8088 	bgt.w	8010b88 <xmp3_IMDCT+0xc08>
			xCurr[i+0] >>= es;
 8010a78:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8010a7a:	f85a 3c48 	ldr.w	r3, [sl, #-72]
 8010a7e:	4113      	asrs	r3, r2
 8010a80:	f84a 3c48 	str.w	r3, [sl, #-72]
			xCurr[i+1] >>= es;
 8010a84:	f85a 3c44 	ldr.w	r3, [sl, #-68]
 8010a88:	4113      	asrs	r3, r2
 8010a8a:	f84a 3c44 	str.w	r3, [sl, #-68]
			*xPrev++ >>= es;
 8010a8e:	f85e 3c24 	ldr.w	r3, [lr, #-36]
 8010a92:	4113      	asrs	r3, r2
 8010a94:	f84e 3c24 	str.w	r3, [lr, #-36]
			xCurr[i+0] >>= es;
 8010a98:	f85a 3c40 	ldr.w	r3, [sl, #-64]
 8010a9c:	4113      	asrs	r3, r2
 8010a9e:	f84a 3c40 	str.w	r3, [sl, #-64]
			xCurr[i+1] >>= es;
 8010aa2:	f85a 3c3c 	ldr.w	r3, [sl, #-60]
 8010aa6:	4113      	asrs	r3, r2
 8010aa8:	f84a 3c3c 	str.w	r3, [sl, #-60]
			*xPrev++ >>= es;
 8010aac:	f85e 3c20 	ldr.w	r3, [lr, #-32]
 8010ab0:	4113      	asrs	r3, r2
 8010ab2:	f84e 3c20 	str.w	r3, [lr, #-32]
			xCurr[i+0] >>= es;
 8010ab6:	f85a 3c38 	ldr.w	r3, [sl, #-56]
 8010aba:	4113      	asrs	r3, r2
 8010abc:	f84a 3c38 	str.w	r3, [sl, #-56]
			xCurr[i+1] >>= es;
 8010ac0:	f85a 3c34 	ldr.w	r3, [sl, #-52]
 8010ac4:	4113      	asrs	r3, r2
 8010ac6:	f84a 3c34 	str.w	r3, [sl, #-52]
			*xPrev++ >>= es;
 8010aca:	f85e 3c1c 	ldr.w	r3, [lr, #-28]
 8010ace:	4113      	asrs	r3, r2
 8010ad0:	f84e 3c1c 	str.w	r3, [lr, #-28]
			xCurr[i+0] >>= es;
 8010ad4:	f85a 3c30 	ldr.w	r3, [sl, #-48]
 8010ad8:	4113      	asrs	r3, r2
 8010ada:	f84a 3c30 	str.w	r3, [sl, #-48]
			xCurr[i+1] >>= es;
 8010ade:	f85a 3c2c 	ldr.w	r3, [sl, #-44]
 8010ae2:	4113      	asrs	r3, r2
 8010ae4:	f84a 3c2c 	str.w	r3, [sl, #-44]
			*xPrev++ >>= es;
 8010ae8:	f85e 3c18 	ldr.w	r3, [lr, #-24]
 8010aec:	4113      	asrs	r3, r2
 8010aee:	f84e 3c18 	str.w	r3, [lr, #-24]
			xCurr[i+0] >>= es;
 8010af2:	f85a 3c28 	ldr.w	r3, [sl, #-40]
 8010af6:	4113      	asrs	r3, r2
 8010af8:	f84a 3c28 	str.w	r3, [sl, #-40]
			xCurr[i+1] >>= es;
 8010afc:	f85a 3c24 	ldr.w	r3, [sl, #-36]
 8010b00:	4113      	asrs	r3, r2
 8010b02:	f84a 3c24 	str.w	r3, [sl, #-36]
			*xPrev++ >>= es;
 8010b06:	f85e 3c14 	ldr.w	r3, [lr, #-20]
 8010b0a:	4113      	asrs	r3, r2
 8010b0c:	f84e 3c14 	str.w	r3, [lr, #-20]
			xCurr[i+0] >>= es;
 8010b10:	f85a 3c20 	ldr.w	r3, [sl, #-32]
 8010b14:	4113      	asrs	r3, r2
 8010b16:	f84a 3c20 	str.w	r3, [sl, #-32]
			xCurr[i+1] >>= es;
 8010b1a:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
 8010b1e:	4113      	asrs	r3, r2
 8010b20:	f84a 3c1c 	str.w	r3, [sl, #-28]
			*xPrev++ >>= es;
 8010b24:	f85e 3c10 	ldr.w	r3, [lr, #-16]
 8010b28:	4113      	asrs	r3, r2
 8010b2a:	f84e 3c10 	str.w	r3, [lr, #-16]
			xCurr[i+0] >>= es;
 8010b2e:	f85a 3c18 	ldr.w	r3, [sl, #-24]
 8010b32:	4113      	asrs	r3, r2
 8010b34:	f84a 3c18 	str.w	r3, [sl, #-24]
			xCurr[i+1] >>= es;
 8010b38:	f85a 3c14 	ldr.w	r3, [sl, #-20]
 8010b3c:	4113      	asrs	r3, r2
 8010b3e:	f84a 3c14 	str.w	r3, [sl, #-20]
			*xPrev++ >>= es;
 8010b42:	f85e 3c0c 	ldr.w	r3, [lr, #-12]
 8010b46:	4113      	asrs	r3, r2
 8010b48:	f84e 3c0c 	str.w	r3, [lr, #-12]
			xCurr[i+0] >>= es;
 8010b4c:	f85a 3c10 	ldr.w	r3, [sl, #-16]
 8010b50:	4113      	asrs	r3, r2
 8010b52:	f84a 3c10 	str.w	r3, [sl, #-16]
			xCurr[i+1] >>= es;
 8010b56:	f85a 3c0c 	ldr.w	r3, [sl, #-12]
 8010b5a:	4113      	asrs	r3, r2
 8010b5c:	f84a 3c0c 	str.w	r3, [sl, #-12]
			*xPrev++ >>= es;
 8010b60:	f85e 3c08 	ldr.w	r3, [lr, #-8]
 8010b64:	4113      	asrs	r3, r2
 8010b66:	f84e 3c08 	str.w	r3, [lr, #-8]
			xCurr[i+0] >>= es;
 8010b6a:	f85a 3c08 	ldr.w	r3, [sl, #-8]
 8010b6e:	4113      	asrs	r3, r2
 8010b70:	f84a 3c08 	str.w	r3, [sl, #-8]
			xCurr[i+1] >>= es;
 8010b74:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 8010b78:	4113      	asrs	r3, r2
 8010b7a:	f84a 3c04 	str.w	r3, [sl, #-4]
			*xPrev++ >>= es;
 8010b7e:	f85e 3c04 	ldr.w	r3, [lr, #-4]
 8010b82:	4113      	asrs	r3, r2
 8010b84:	f84e 3c04 	str.w	r3, [lr, #-4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010b88:	f85a 0c0c 	ldr.w	r0, [sl, #-12]
 8010b8c:	f85a 6c18 	ldr.w	r6, [sl, #-24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010b90:	f85a 3c24 	ldr.w	r3, [sl, #-36]
	x4 -= x5;
 8010b94:	1a35      	subs	r5, r6, r0
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010b96:	f85a 2c30 	ldr.w	r2, [sl, #-48]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010b9a:	f85a 4c48 	ldr.w	r4, [sl, #-72]
	x3 -= x4;
 8010b9e:	1b5b      	subs	r3, r3, r5
 8010ba0:	4fcd      	ldr	r7, [pc, #820]	; (8010ed8 <xmp3_IMDCT+0xf58>)
	x2 -= x3;
 8010ba2:	eba2 0c03 	sub.w	ip, r2, r3
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010ba6:	f85a 2c3c 	ldr.w	r2, [sl, #-60]
	x3 -= x5;
 8010baa:	1a1b      	subs	r3, r3, r0
	x1 -= x2;
 8010bac:	eba2 020c 	sub.w	r2, r2, ip
	x0 -= x1;
 8010bb0:	1aa6      	subs	r6, r4, r2
	x1 -= x3;
 8010bb2:	1ad2      	subs	r2, r2, r3
	x0 >>= 1;
 8010bb4:	1076      	asrs	r6, r6, #1
	x1 >>= 1;
 8010bb6:	1052      	asrs	r2, r2, #1
 8010bb8:	fb87 4c0c 	smull	r4, ip, r7, ip
	a1 = x0 + (x4 >> 1);
 8010bbc:	eb06 0765 	add.w	r7, r6, r5, asr #1
	a2 = x0 - x4;
 8010bc0:	1b76      	subs	r6, r6, r5
	x0 = a1 + a0;
 8010bc2:	eb07 014c 	add.w	r1, r7, ip, lsl #1
	a2 = x0 - x4;
 8010bc6:	9608      	str	r6, [sp, #32]
	x4 = a1 - a0;
 8010bc8:	eba7 0c4c 	sub.w	ip, r7, ip, lsl #1
 8010bcc:	4fc2      	ldr	r7, [pc, #776]	; (8010ed8 <xmp3_IMDCT+0xf58>)
	x0 = a1 + a0;
 8010bce:	9109      	str	r1, [sp, #36]	; 0x24
 8010bd0:	fb87 4303 	smull	r4, r3, r7, r3
	a1 = x1 + (x5 >> 1);
 8010bd4:	eb02 0560 	add.w	r5, r2, r0, asr #1
 8010bd8:	49c0      	ldr	r1, [pc, #768]	; (8010edc <xmp3_IMDCT+0xf5c>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8010bda:	005c      	lsls	r4, r3, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010bdc:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 8010be0:	fb81 7303 	smull	r7, r3, r1, r3
 8010be4:	49be      	ldr	r1, [pc, #760]	; (8010ee0 <xmp3_IMDCT+0xf60>)
	a2 = x1 - x5;
 8010be6:	1a10      	subs	r0, r2, r0
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010be8:	009b      	lsls	r3, r3, #2
 8010bea:	fb81 2000 	smull	r2, r0, r1, r0
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010bee:	0082      	lsls	r2, r0, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010bf0:	1b2d      	subs	r5, r5, r4
 8010bf2:	48bc      	ldr	r0, [pc, #752]	; (8010ee4 <xmp3_IMDCT+0xf64>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010bf4:	920b      	str	r2, [sp, #44]	; 0x2c
 8010bf6:	fb80 2505 	smull	r2, r5, r0, r5
	*out = x0 + x1;	out++;
 8010bfa:	9e09      	ldr	r6, [sp, #36]	; 0x24
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010bfc:	f85a 1c08 	ldr.w	r1, [sl, #-8]
	*out = x0 + x1;	out++;
 8010c00:	441e      	add	r6, r3
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010c02:	f85a 2c14 	ldr.w	r2, [sl, #-20]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010c06:	f85a 4c2c 	ldr.w	r4, [sl, #-44]
	*out = x0 + x1;	out++;
 8010c0a:	9613      	str	r6, [sp, #76]	; 0x4c
	x4 -= x5;
 8010c0c:	1a50      	subs	r0, r2, r1
	*out = x0 - x1;
 8010c0e:	9e09      	ldr	r6, [sp, #36]	; 0x24
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010c10:	f85a 2c20 	ldr.w	r2, [sl, #-32]
	*out = x0 - x1;
 8010c14:	1af3      	subs	r3, r6, r3
	*out = x2 + x3;	out++;
 8010c16:	9e08      	ldr	r6, [sp, #32]
	x3 -= x4;
 8010c18:	1a12      	subs	r2, r2, r0
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010c1a:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
	*out = x0 - x1;
 8010c1e:	9317      	str	r3, [sp, #92]	; 0x5c
	*out = x2 + x3;	out++;
 8010c20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	x2 -= x3;
 8010c22:	1aa7      	subs	r7, r4, r2
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010c24:	f85a 4c38 	ldr.w	r4, [sl, #-56]
	x3 -= x5;
 8010c28:	1a52      	subs	r2, r2, r1
	*out = x2 + x3;	out++;
 8010c2a:	441e      	add	r6, r3
	x1 -= x2;
 8010c2c:	eba4 0b07 	sub.w	fp, r4, r7
 8010c30:	463c      	mov	r4, r7
	*out = x2 + x3;	out++;
 8010c32:	9614      	str	r6, [sp, #80]	; 0x50
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010c34:	f85a 7c44 	ldr.w	r7, [sl, #-68]
	*out = x2 - x3;	out++;
 8010c38:	9e08      	ldr	r6, [sp, #32]
	x0 -= x1;
 8010c3a:	eba7 070b 	sub.w	r7, r7, fp
	x1 -= x3;
 8010c3e:	ebab 0b02 	sub.w	fp, fp, r2
	*out = x2 - x3;	out++;
 8010c42:	1af6      	subs	r6, r6, r3
	*out = x4 + x5;	out++;
 8010c44:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
	*out = x4 - x5;	out++;
 8010c48:	ebac 0c85 	sub.w	ip, ip, r5, lsl #2
 8010c4c:	4da2      	ldr	r5, [pc, #648]	; (8010ed8 <xmp3_IMDCT+0xf58>)
	x0 >>= 1;
 8010c4e:	107f      	asrs	r7, r7, #1
	*out = x4 + x5;	out++;
 8010c50:	9315      	str	r3, [sp, #84]	; 0x54
	x1 >>= 1;
 8010c52:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	*out = x4 - x5;	out++;
 8010c56:	f8cd c058 	str.w	ip, [sp, #88]	; 0x58
 8010c5a:	fb85 3404 	smull	r3, r4, r5, r4
	a1 = x0 + (x4 >> 1);
 8010c5e:	eb07 0360 	add.w	r3, r7, r0, asr #1
	a2 = x0 - x4;
 8010c62:	1a38      	subs	r0, r7, r0
	x0 = a1 + a0;
 8010c64:	eb03 0c44 	add.w	ip, r3, r4, lsl #1
	a2 = x0 - x4;
 8010c68:	9008      	str	r0, [sp, #32]
	x0 = a1 + a0;
 8010c6a:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
	x4 = a1 - a0;
 8010c6e:	eba3 0c44 	sub.w	ip, r3, r4, lsl #1
 8010c72:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
 8010c76:	fb85 3202 	smull	r3, r2, r5, r2
	a1 = x1 + (x5 >> 1);
 8010c7a:	eb0b 0461 	add.w	r4, fp, r1, asr #1
 8010c7e:	4d97      	ldr	r5, [pc, #604]	; (8010edc <xmp3_IMDCT+0xf5c>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8010c80:	0053      	lsls	r3, r2, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010c82:	eb04 0242 	add.w	r2, r4, r2, lsl #1
 8010c86:	fb85 0202 	smull	r0, r2, r5, r2
 8010c8a:	0092      	lsls	r2, r2, #2
	a2 = x1 - x5;
 8010c8c:	ebab 0b01 	sub.w	fp, fp, r1
 8010c90:	4893      	ldr	r0, [pc, #588]	; (8010ee0 <xmp3_IMDCT+0xf60>)
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010c92:	920c      	str	r2, [sp, #48]	; 0x30
 8010c94:	fb80 2b0b 	smull	r2, fp, r0, fp
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010c98:	ea4f 0c8b 	mov.w	ip, fp, lsl #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010c9c:	1ae4      	subs	r4, r4, r3
 8010c9e:	4a91      	ldr	r2, [pc, #580]	; (8010ee4 <xmp3_IMDCT+0xf64>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010ca0:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
 8010ca4:	fb82 3404 	smull	r3, r4, r2, r4
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010ca8:	f85a 5c04 	ldr.w	r5, [sl, #-4]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010cac:	00a1      	lsls	r1, r4, #2
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 8010cae:	f85a 3c10 	ldr.w	r3, [sl, #-16]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010cb2:	f85a 2c28 	ldr.w	r2, [sl, #-40]
	x4 -= x5;
 8010cb6:	1b5f      	subs	r7, r3, r5
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 8010cb8:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010cbc:	9129      	str	r1, [sp, #164]	; 0xa4
	x3 -= x4;
 8010cbe:	1bdb      	subs	r3, r3, r7
	*out = x4 - x5;	out++;
 8010cc0:	990b      	ldr	r1, [sp, #44]	; 0x2c
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010cc2:	f85a cc40 	ldr.w	ip, [sl, #-64]
	x2 -= x3;
 8010cc6:	1ad2      	subs	r2, r2, r3
	x3 -= x5;
 8010cc8:	1b58      	subs	r0, r3, r5
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8010cca:	f85a 3c34 	ldr.w	r3, [sl, #-52]
	*out = x4 - x5;	out++;
 8010cce:	eba1 0a84 	sub.w	sl, r1, r4, lsl #2
	*out = x2 - x3;	out++;
 8010cd2:	990e      	ldr	r1, [sp, #56]	; 0x38
 8010cd4:	9c08      	ldr	r4, [sp, #32]
	x1 -= x2;
 8010cd6:	1a9b      	subs	r3, r3, r2
	*out = x2 - x3;	out++;
 8010cd8:	1a64      	subs	r4, r4, r1
	*out = x0 - x1;
 8010cda:	990c      	ldr	r1, [sp, #48]	; 0x30
	x0 -= x1;
 8010cdc:	ebac 0c03 	sub.w	ip, ip, r3
	x1 -= x3;
 8010ce0:	1a1b      	subs	r3, r3, r0
	*out = x2 - x3;	out++;
 8010ce2:	940f      	str	r4, [sp, #60]	; 0x3c
	*out = x0 - x1;
 8010ce4:	9c09      	ldr	r4, [sp, #36]	; 0x24
	x0 >>= 1;
 8010ce6:	ea4f 0c6c 	mov.w	ip, ip, asr #1
	x1 >>= 1;
 8010cea:	105b      	asrs	r3, r3, #1
	*out = x0 - x1;
 8010cec:	1a64      	subs	r4, r4, r1
 8010cee:	497a      	ldr	r1, [pc, #488]	; (8010ed8 <xmp3_IMDCT+0xf58>)
 8010cf0:	9410      	str	r4, [sp, #64]	; 0x40
 8010cf2:	fb81 4202 	smull	r4, r2, r1, r2
	a1 = x0 + (x4 >> 1);
 8010cf6:	eb0c 0467 	add.w	r4, ip, r7, asr #1
	a2 = x0 - x4;
 8010cfa:	ebac 0c07 	sub.w	ip, ip, r7
 8010cfe:	f8cd c090 	str.w	ip, [sp, #144]	; 0x90
	x0 = a1 + a0;
 8010d02:	eb04 0c42 	add.w	ip, r4, r2, lsl #1
	x4 = a1 - a0;
 8010d06:	eba4 0242 	sub.w	r2, r4, r2, lsl #1
 8010d0a:	9225      	str	r2, [sp, #148]	; 0x94
 8010d0c:	fb81 2000 	smull	r2, r0, r1, r0
	a1 = x1 + (x5 >> 1);
 8010d10:	eb03 0265 	add.w	r2, r3, r5, asr #1
 8010d14:	4971      	ldr	r1, [pc, #452]	; (8010edc <xmp3_IMDCT+0xf5c>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8010d16:	0044      	lsls	r4, r0, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010d18:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 8010d1c:	fb81 7000 	smull	r7, r0, r1, r0
	a2 = x1 - x5;
 8010d20:	1b5b      	subs	r3, r3, r5
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8010d22:	0085      	lsls	r5, r0, #2
 8010d24:	496e      	ldr	r1, [pc, #440]	; (8010ee0 <xmp3_IMDCT+0xf60>)
 8010d26:	9526      	str	r5, [sp, #152]	; 0x98
 8010d28:	fb81 0303 	smull	r0, r3, r1, r3
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010d2c:	009b      	lsls	r3, r3, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010d2e:	1b12      	subs	r2, r2, r4
 8010d30:	486c      	ldr	r0, [pc, #432]	; (8010ee4 <xmp3_IMDCT+0xf64>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8010d32:	9327      	str	r3, [sp, #156]	; 0x9c
 8010d34:	fb80 3202 	smull	r3, r2, r0, r2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010d38:	0090      	lsls	r0, r2, #2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010d3a:	f85e 2c24 	ldr.w	r2, [lr, #-36]
 8010d3e:	46f3      	mov	fp, lr
 8010d40:	9f31      	ldr	r7, [sp, #196]	; 0xc4
 8010d42:	4613      	mov	r3, r2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8010d44:	9028      	str	r0, [sp, #160]	; 0xa0
 8010d46:	fb87 0303 	smull	r0, r3, r7, r3
 8010d4a:	9f2f      	ldr	r7, [sp, #188]	; 0xbc
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010d4c:	9350      	str	r3, [sp, #320]	; 0x140
 8010d4e:	fb87 0202 	smull	r0, r2, r7, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010d52:	9261      	str	r2, [sp, #388]	; 0x184
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010d54:	f85e 4c20 	ldr.w	r4, [lr, #-32]
 8010d58:	f8d9 2088 	ldr.w	r2, [r9, #136]	; 0x88
 8010d5c:	f8d9 004c 	ldr.w	r0, [r9, #76]	; 0x4c
 8010d60:	4625      	mov	r5, r4
 8010d62:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010d66:	9551      	str	r5, [sp, #324]	; 0x144
 8010d68:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010d6c:	9460      	str	r4, [sp, #384]	; 0x180
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010d6e:	f85e 4c1c 	ldr.w	r4, [lr, #-28]
 8010d72:	f8d9 2084 	ldr.w	r2, [r9, #132]	; 0x84
 8010d76:	f8d9 0050 	ldr.w	r0, [r9, #80]	; 0x50
 8010d7a:	4625      	mov	r5, r4
 8010d7c:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010d80:	9552      	str	r5, [sp, #328]	; 0x148
 8010d82:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010d86:	945f      	str	r4, [sp, #380]	; 0x17c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010d88:	f85e 4c18 	ldr.w	r4, [lr, #-24]
 8010d8c:	f8d9 2080 	ldr.w	r2, [r9, #128]	; 0x80
 8010d90:	f8d9 0054 	ldr.w	r0, [r9, #84]	; 0x54
 8010d94:	4625      	mov	r5, r4
 8010d96:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010d9a:	9553      	str	r5, [sp, #332]	; 0x14c
 8010d9c:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010da0:	945e      	str	r4, [sp, #376]	; 0x178
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010da2:	f85e 4c14 	ldr.w	r4, [lr, #-20]
 8010da6:	f8d9 207c 	ldr.w	r2, [r9, #124]	; 0x7c
 8010daa:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8010dae:	4625      	mov	r5, r4
 8010db0:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010db4:	9554      	str	r5, [sp, #336]	; 0x150
 8010db6:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010dba:	945d      	str	r4, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010dbc:	f85e 4c10 	ldr.w	r4, [lr, #-16]
 8010dc0:	f8d9 2078 	ldr.w	r2, [r9, #120]	; 0x78
 8010dc4:	f8d9 005c 	ldr.w	r0, [r9, #92]	; 0x5c
 8010dc8:	4625      	mov	r5, r4
 8010dca:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010dce:	9555      	str	r5, [sp, #340]	; 0x154
 8010dd0:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010dd4:	945c      	str	r4, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010dd6:	f85e 4c0c 	ldr.w	r4, [lr, #-12]
 8010dda:	f8d9 2074 	ldr.w	r2, [r9, #116]	; 0x74
 8010dde:	f8d9 0060 	ldr.w	r0, [r9, #96]	; 0x60
 8010de2:	4625      	mov	r5, r4
 8010de4:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010de8:	9556      	str	r5, [sp, #344]	; 0x158
 8010dea:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010dee:	945b      	str	r4, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010df0:	f85e 4c08 	ldr.w	r4, [lr, #-8]
 8010df4:	f8d9 2070 	ldr.w	r2, [r9, #112]	; 0x70
 8010df8:	f8d9 0064 	ldr.w	r0, [r9, #100]	; 0x64
 8010dfc:	4625      	mov	r5, r4
 8010dfe:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010e02:	9557      	str	r5, [sp, #348]	; 0x15c
 8010e04:	fb82 0404 	smull	r0, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010e08:	945a      	str	r4, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8010e0a:	f85e 4c04 	ldr.w	r4, [lr, #-4]
 8010e0e:	e9d9 021a 	ldrd	r0, r2, [r9, #104]	; 0x68
 8010e12:	4625      	mov	r5, r4
 8010e14:	fb80 7505 	smull	r7, r5, r0, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8010e18:	9558      	str	r5, [sp, #352]	; 0x160
 8010e1a:	fb82 0404 	smull	r0, r4, r2, r4
		yLo = (xPrevWin[ 0+i] << 2);
 8010e1e:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8010e20:	9804      	ldr	r0, [sp, #16]
			*xpwHi-- = MULSHIFT32(wHi, x);
 8010e22:	9459      	str	r4, [sp, #356]	; 0x164
 8010e24:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010e28:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8010e2c:	f848 3b04 	str.w	r3, [r8], #4
		yLo = (xPrevWin[ 3+i] << 2);
 8010e30:	9b53      	ldr	r3, [sp, #332]	; 0x14c
 8010e32:	9a05      	ldr	r2, [sp, #20]
 8010e34:	009b      	lsls	r3, r3, #2
 8010e36:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8010e3a:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8010e3e:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010e40:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8010e42:	9816      	ldr	r0, [sp, #88]	; 0x58
 8010e44:	f8c8 317c 	str.w	r3, [r8, #380]	; 0x17c
 8010e48:	fb84 3000 	smull	r3, r0, r4, r0
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010e4c:	9b56      	ldr	r3, [sp, #344]	; 0x158
 8010e4e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	__asm__ volatile (
 8010e52:	9806      	ldr	r0, [sp, #24]
 8010e54:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010e58:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8010e5c:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010e5e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8010e60:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8010e62:	f8c8 32fc 	str.w	r3, [r8, #764]	; 0x2fc
 8010e66:	fb81 3000 	smull	r3, r0, r1, r0
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010e6a:	9b59      	ldr	r3, [sp, #356]	; 0x164
 8010e6c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	__asm__ volatile (
 8010e70:	9807      	ldr	r0, [sp, #28]
 8010e72:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010e76:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8010e7a:	f8c8 347c 	str.w	r3, [r8, #1148]	; 0x47c
 8010e7e:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010e80:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8010e82:	9f23      	ldr	r7, [sp, #140]	; 0x8c
 8010e84:	fb87 0303 	smull	r0, r3, r7, r3
 8010e88:	4650      	mov	r0, sl
 8010e8a:	4627      	mov	r7, r4
 8010e8c:	fb87 4000 	smull	r4, r0, r7, r0
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010e90:	4418      	add	r0, r3
 8010e92:	9b5c      	ldr	r3, [sp, #368]	; 0x170
 8010e94:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	__asm__ volatile (
 8010e98:	980a      	ldr	r0, [sp, #40]	; 0x28
 8010e9a:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010e9e:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8010ea2:	f8c8 35fc 	str.w	r3, [r8, #1532]	; 0x5fc
 8010ea6:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010ea8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010eaa:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8010eac:	fb87 0303 	smull	r0, r3, r7, r3
 8010eb0:	9810      	ldr	r0, [sp, #64]	; 0x40
 8010eb2:	fb81 4000 	smull	r4, r0, r1, r0
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010eb6:	4418      	add	r0, r3
	__asm__ volatile (
 8010eb8:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8010eba:	9b5f      	ldr	r3, [sp, #380]	; 0x17c
 8010ebc:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8010ec0:	4628      	mov	r0, r5
 8010ec2:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010ec6:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8010eca:	f8c8 377c 	str.w	r3, [r8, #1916]	; 0x77c
 8010ece:	4302      	orrs	r2, r0
		yLo = (xPrevWin[ 0+i] << 2);
 8010ed0:	9b51      	ldr	r3, [sp, #324]	; 0x144
 8010ed2:	9804      	ldr	r0, [sp, #16]
 8010ed4:	009b      	lsls	r3, r3, #2
 8010ed6:	e009      	b.n	8010eec <xmp3_IMDCT+0xf6c>
 8010ed8:	6ed9eba1 	.word	0x6ed9eba1
 8010edc:	7ba3751d 	.word	0x7ba3751d
 8010ee0:	5a82799a 	.word	0x5a82799a
 8010ee4:	2120fb83 	.word	0x2120fb83
 8010ee8:	08019c80 	.word	0x08019c80
 8010eec:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010ef0:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8010ef4:	f8c8 307c 	str.w	r3, [r8, #124]	; 0x7c
 8010ef8:	4302      	orrs	r2, r0
		yLo = (xPrevWin[ 3+i] << 2);
 8010efa:	9b54      	ldr	r3, [sp, #336]	; 0x150
 8010efc:	9805      	ldr	r0, [sp, #20]
 8010efe:	009b      	lsls	r3, r3, #2
 8010f00:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010f04:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8010f08:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010f0a:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8010f0c:	4630      	mov	r0, r6
 8010f0e:	f8c8 31fc 	str.w	r3, [r8, #508]	; 0x1fc
 8010f12:	fb87 3000 	smull	r3, r0, r7, r0
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010f16:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 8010f18:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	__asm__ volatile (
 8010f1c:	9806      	ldr	r0, [sp, #24]
 8010f1e:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010f22:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8010f26:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010f28:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8010f2a:	f8c8 337c 	str.w	r3, [r8, #892]	; 0x37c
 8010f2e:	fb81 3606 	smull	r3, r6, r1, r6
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010f32:	9b5a      	ldr	r3, [sp, #360]	; 0x168
	__asm__ volatile (
 8010f34:	9807      	ldr	r0, [sp, #28]
 8010f36:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8010f3a:	ea86 70e6 	eor.w	r0, r6, r6, asr #31
 8010f3e:	eba0 70e6 	sub.w	r0, r0, r6, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8010f42:	f8c8 64fc 	str.w	r6, [r8, #1276]	; 0x4fc
 8010f46:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010f48:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8010f4a:	9e20      	ldr	r6, [sp, #128]	; 0x80
 8010f4c:	fb86 0303 	smull	r0, r3, r6, r3
 8010f50:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010f52:	fb87 4000 	smull	r4, r0, r7, r0
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8010f56:	4418      	add	r0, r3
 8010f58:	9b5d      	ldr	r3, [sp, #372]	; 0x174
 8010f5a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
	__asm__ volatile (
 8010f5e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8010f60:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010f64:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8010f68:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010f6a:	9c14      	ldr	r4, [sp, #80]	; 0x50
 8010f6c:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8010f6e:	f8c8 367c 	str.w	r3, [r8, #1660]	; 0x67c
 8010f72:	fb86 3404 	smull	r3, r4, r6, r4
 8010f76:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8010f78:	fb81 3000 	smull	r3, r0, r1, r0
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8010f7c:	1823      	adds	r3, r4, r0
 8010f7e:	9860      	ldr	r0, [sp, #384]	; 0x180
	__asm__ volatile (
 8010f80:	4629      	mov	r1, r5
 8010f82:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 8010f86:	4628      	mov	r0, r5
 8010f88:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8010f8c:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8010f90:	f8c8 37fc 	str.w	r3, [r8, #2044]	; 0x7fc
 8010f94:	4310      	orrs	r0, r2
		yLo = (xPrevWin[ 0+i] << 2);
 8010f96:	9b52      	ldr	r3, [sp, #328]	; 0x148
 8010f98:	9a04      	ldr	r2, [sp, #16]
 8010f9a:	009b      	lsls	r3, r3, #2
 8010f9c:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8010fa0:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8010fa4:	f8c8 30fc 	str.w	r3, [r8, #252]	; 0xfc
 8010fa8:	4310      	orrs	r0, r2
		yLo = (xPrevWin[ 3+i] << 2);
 8010faa:	9b55      	ldr	r3, [sp, #340]	; 0x154
 8010fac:	9204      	str	r2, [sp, #16]
 8010fae:	009b      	lsls	r3, r3, #2
 8010fb0:	9a05      	ldr	r2, [sp, #20]
 8010fb2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8010fb6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 8010fba:	f8c8 327c 	str.w	r3, [r8, #636]	; 0x27c
 8010fbe:	4310      	orrs	r0, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010fc0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8010fc2:	9e1d      	ldr	r6, [sp, #116]	; 0x74
	__asm__ volatile (
 8010fc4:	9205      	str	r2, [sp, #20]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010fc6:	fb86 2303 	smull	r2, r3, r6, r3
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 8010fca:	9a58      	ldr	r2, [sp, #352]	; 0x160
 8010fcc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	__asm__ volatile (
 8010fd0:	9a06      	ldr	r2, [sp, #24]
 8010fd2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8010fd6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 8010fda:	4310      	orrs	r0, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010fdc:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8010fde:	9f03      	ldr	r7, [sp, #12]
	__asm__ volatile (
 8010fe0:	9206      	str	r2, [sp, #24]
 8010fe2:	f8c8 33fc 	str.w	r3, [r8, #1020]	; 0x3fc
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010fe6:	fb87 3505 	smull	r3, r5, r7, r5
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8010fea:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
	__asm__ volatile (
 8010fec:	9a07      	ldr	r2, [sp, #28]
 8010fee:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8010ff2:	ea85 72e5 	eor.w	r2, r5, r5, asr #31
 8010ff6:	eba2 72e5 	sub.w	r2, r2, r5, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8010ffa:	4310      	orrs	r0, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8010ffc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8010ffe:	9c1e      	ldr	r4, [sp, #120]	; 0x78
	__asm__ volatile (
 8011000:	9207      	str	r2, [sp, #28]
 8011002:	f8c8 557c 	str.w	r5, [r8, #1404]	; 0x57c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011006:	fb84 2303 	smull	r2, r3, r4, r3
 801100a:	9c10      	ldr	r4, [sp, #64]	; 0x40
 801100c:	fb86 2404 	smull	r2, r4, r6, r4
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8011010:	9a5e      	ldr	r2, [sp, #376]	; 0x178
 8011012:	4423      	add	r3, r4
 8011014:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	__asm__ volatile (
 8011018:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801101a:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801101e:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8011022:	920a      	str	r2, [sp, #40]	; 0x28
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8011024:	4302      	orrs	r2, r0
 8011026:	f8c8 36fc 	str.w	r3, [r8, #1788]	; 0x6fc
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801102a:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 801102c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801102e:	fb84 0303 	smull	r0, r3, r4, r3
 8011032:	4654      	mov	r4, sl
 8011034:	fb87 0404 	smull	r0, r4, r7, r4
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011038:	441c      	add	r4, r3
 801103a:	9b61      	ldr	r3, [sp, #388]	; 0x184
	__asm__ volatile (
 801103c:	460d      	mov	r5, r1
 801103e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8011042:	ea83 75e3 	eor.w	r5, r3, r3, asr #31
 8011046:	eba5 75e3 	sub.w	r5, r5, r3, asr #31
	*out = x0 + x1;	out++;
 801104a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801104c:	9809      	ldr	r0, [sp, #36]	; 0x24
	*out = x2 + x3;	out++;
 801104e:	9908      	ldr	r1, [sp, #32]
	*out = x0 + x1;	out++;
 8011050:	4430      	add	r0, r6
	*out = x2 + x3;	out++;
 8011052:	9e0e      	ldr	r6, [sp, #56]	; 0x38
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011054:	f8c8 387c 	str.w	r3, [r8, #2172]	; 0x87c
	*out = x2 + x3;	out++;
 8011058:	198f      	adds	r7, r1, r6
	*out = x4 + x5;	out++;
 801105a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801105c:	9e29      	ldr	r6, [sp, #164]	; 0xa4
		*xPrev++ = xBuf[i] >> 2;
 801105e:	1080      	asrs	r0, r0, #2
 8011060:	950d      	str	r5, [sp, #52]	; 0x34
 8011062:	10bf      	asrs	r7, r7, #2
	*out = x4 + x5;	out++;
 8011064:	198c      	adds	r4, r1, r6
		*xPrev++ = xBuf[i] >> 2;
 8011066:	f84e 0c24 	str.w	r0, [lr, #-36]
 801106a:	f84e 7c20 	str.w	r7, [lr, #-32]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801106e:	ee16 1a90 	vmov	r1, s13
		*xPrev++ = xBuf[i] >> 2;
 8011072:	10a4      	asrs	r4, r4, #2
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011074:	ee17 0a90 	vmov	r0, s15
		*xPrev++ = xBuf[i] >> 2;
 8011078:	f84e 4c1c 	str.w	r4, [lr, #-28]
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801107c:	ea42 0405 	orr.w	r4, r2, r5
	*out = x0 + x1;	out++;
 8011080:	9d26      	ldr	r5, [sp, #152]	; 0x98
 8011082:	eb0c 0305 	add.w	r3, ip, r5
	*out = x0 - x1;
 8011086:	ebac 0c05 	sub.w	ip, ip, r5
	*out = x2 + x3;	out++;
 801108a:	9d27      	ldr	r5, [sp, #156]	; 0x9c
		*xPrev++ = xBuf[i] >> 2;
 801108c:	109b      	asrs	r3, r3, #2
 801108e:	f84e 3c18 	str.w	r3, [lr, #-24]
 8011092:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8011096:	f84e 3c04 	str.w	r3, [lr, #-4]
	*out = x2 + x3;	out++;
 801109a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801109c:	195a      	adds	r2, r3, r5
	*out = x2 - x3;	out++;
 801109e:	1b5b      	subs	r3, r3, r5
	*out = x4 + x5;	out++;
 80110a0:	9d28      	ldr	r5, [sp, #160]	; 0xa0
		*xPrev++ = xBuf[i] >> 2;
 80110a2:	1092      	asrs	r2, r2, #2
 80110a4:	109b      	asrs	r3, r3, #2
 80110a6:	f84e 2c14 	str.w	r2, [lr, #-20]
	*out = x4 + x5;	out++;
 80110aa:	9a25      	ldr	r2, [sp, #148]	; 0x94
		*xPrev++ = xBuf[i] >> 2;
 80110ac:	f84e 3c08 	str.w	r3, [lr, #-8]
	*out = x4 + x5;	out++;
 80110b0:	1953      	adds	r3, r2, r5
	*out = x4 - x5;	out++;
 80110b2:	1b52      	subs	r2, r2, r5
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80110b4:	9d01      	ldr	r5, [sp, #4]
		*xPrev++ = xBuf[i] >> 2;
 80110b6:	1092      	asrs	r2, r2, #2
 80110b8:	109b      	asrs	r3, r3, #2
 80110ba:	f84e 2c0c 	str.w	r2, [lr, #-12]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80110be:	462a      	mov	r2, r5
	for (   ; i < bc->nBlocksTotal; i++) {
 80110c0:	3501      	adds	r5, #1
		*xPrev++ = xBuf[i] >> 2;
 80110c2:	f84e 3c10 	str.w	r3, [lr, #-16]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80110c6:	ee17 3a10 	vmov	r3, s14
	for (   ; i < bc->nBlocksTotal; i++) {
 80110ca:	9501      	str	r5, [sp, #4]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80110cc:	f7fe fc76 	bl	800f9bc <FreqInvertRescale>
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80110d0:	9b02      	ldr	r3, [sp, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 80110d2:	4320      	orrs	r0, r4
	for (   ; i < bc->nBlocksTotal; i++) {
 80110d4:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80110d6:	f10b 0e24 	add.w	lr, fp, #36	; 0x24
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80110da:	4303      	orrs	r3, r0
	for (   ; i < bc->nBlocksTotal; i++) {
 80110dc:	f107 0a48 	add.w	sl, r7, #72	; 0x48
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80110e0:	9302      	str	r3, [sp, #8]
	for (   ; i < bc->nBlocksTotal; i++) {
 80110e2:	9b30      	ldr	r3, [sp, #192]	; 0xc0
 80110e4:	429d      	cmp	r5, r3
 80110e6:	f6ff acbd 	blt.w	8010a64 <xmp3_IMDCT+0xae4>
 80110ea:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 80110ec:	46c8      	mov	r8, r9
 80110ee:	9a01      	ldr	r2, [sp, #4]
 80110f0:	4293      	cmp	r3, r2
 80110f2:	f340 836f 	ble.w	80117d4 <xmp3_IMDCT+0x1854>
 80110f6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80110f8:	f10b 0b24 	add.w	fp, fp, #36	; 0x24
 80110fc:	9a01      	ldr	r2, [sp, #4]
 80110fe:	f103 0a48 	add.w	sl, r3, #72	; 0x48
		wpLo = imdctWin[btPrev] + 18;
 8011102:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8011104:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 8011108:	eb08 1903 	add.w	r9, r8, r3, lsl #4
 801110c:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 801110e:	eb03 0882 	add.w	r8, r3, r2, lsl #2
 8011112:	4647      	mov	r7, r8
 8011114:	46c8      	mov	r8, r9
 8011116:	46d9      	mov	r9, fp
 8011118:	e1c4      	b.n	80114a4 <xmp3_IMDCT+0x1524>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801111a:	f859 4c24 	ldr.w	r4, [r9, #-36]
 801111e:	f8d8 208c 	ldr.w	r2, [r8, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011122:	f8d8 1048 	ldr.w	r1, [r8, #72]	; 0x48
 8011126:	4623      	mov	r3, r4
 8011128:	fb81 5303 	smull	r5, r3, r1, r3
			*xpwLo++ = MULSHIFT32(wLo, x);
 801112c:	9350      	str	r3, [sp, #320]	; 0x140
 801112e:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011132:	9461      	str	r4, [sp, #388]	; 0x184
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011134:	f859 4c20 	ldr.w	r4, [r9, #-32]
 8011138:	f8d8 2088 	ldr.w	r2, [r8, #136]	; 0x88
 801113c:	f8d8 104c 	ldr.w	r1, [r8, #76]	; 0x4c
 8011140:	4625      	mov	r5, r4
 8011142:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011146:	9551      	str	r5, [sp, #324]	; 0x144
 8011148:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801114c:	9460      	str	r4, [sp, #384]	; 0x180
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801114e:	f859 4c1c 	ldr.w	r4, [r9, #-28]
 8011152:	f8d8 2084 	ldr.w	r2, [r8, #132]	; 0x84
 8011156:	f8d8 1050 	ldr.w	r1, [r8, #80]	; 0x50
 801115a:	4625      	mov	r5, r4
 801115c:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011160:	9552      	str	r5, [sp, #328]	; 0x148
 8011162:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011166:	945f      	str	r4, [sp, #380]	; 0x17c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011168:	f859 4c18 	ldr.w	r4, [r9, #-24]
 801116c:	f8d8 2080 	ldr.w	r2, [r8, #128]	; 0x80
 8011170:	f8d8 1054 	ldr.w	r1, [r8, #84]	; 0x54
 8011174:	4625      	mov	r5, r4
 8011176:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 801117a:	9553      	str	r5, [sp, #332]	; 0x14c
 801117c:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011180:	945e      	str	r4, [sp, #376]	; 0x178
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011182:	f859 4c14 	ldr.w	r4, [r9, #-20]
 8011186:	f8d8 207c 	ldr.w	r2, [r8, #124]	; 0x7c
 801118a:	f8d8 1058 	ldr.w	r1, [r8, #88]	; 0x58
 801118e:	4625      	mov	r5, r4
 8011190:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011194:	9554      	str	r5, [sp, #336]	; 0x150
 8011196:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 801119a:	945d      	str	r4, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801119c:	f859 4c10 	ldr.w	r4, [r9, #-16]
 80111a0:	f8d8 2078 	ldr.w	r2, [r8, #120]	; 0x78
 80111a4:	f8d8 105c 	ldr.w	r1, [r8, #92]	; 0x5c
 80111a8:	4625      	mov	r5, r4
 80111aa:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111ae:	9555      	str	r5, [sp, #340]	; 0x154
 80111b0:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111b4:	945c      	str	r4, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111b6:	f859 4c0c 	ldr.w	r4, [r9, #-12]
 80111ba:	f8d8 2074 	ldr.w	r2, [r8, #116]	; 0x74
 80111be:	f8d8 1060 	ldr.w	r1, [r8, #96]	; 0x60
 80111c2:	4625      	mov	r5, r4
 80111c4:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111c8:	9556      	str	r5, [sp, #344]	; 0x158
 80111ca:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111ce:	945b      	str	r4, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111d0:	f859 4c08 	ldr.w	r4, [r9, #-8]
 80111d4:	f8d8 2070 	ldr.w	r2, [r8, #112]	; 0x70
 80111d8:	f8d8 1064 	ldr.w	r1, [r8, #100]	; 0x64
 80111dc:	4625      	mov	r5, r4
 80111de:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111e2:	9557      	str	r5, [sp, #348]	; 0x15c
 80111e4:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111e8:	945a      	str	r4, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80111ea:	f859 4c04 	ldr.w	r4, [r9, #-4]
 80111ee:	e9d8 121a 	ldrd	r1, r2, [r8, #104]	; 0x68
 80111f2:	4625      	mov	r5, r4
 80111f4:	fb81 6505 	smull	r6, r5, r1, r5
			*xpwLo++ = MULSHIFT32(wLo, x);
 80111f8:	9558      	str	r5, [sp, #352]	; 0x160
 80111fa:	fb82 1404 	smull	r1, r4, r2, r4
			*xpwHi-- = MULSHIFT32(wHi, x);
 80111fe:	9459      	str	r4, [sp, #356]	; 0x164
		yLo = (xPrevWin[ 0+i] << 2);
 8011200:	009b      	lsls	r3, r3, #2
	__asm__ volatile (
 8011202:	9a04      	ldr	r2, [sp, #16]
 8011204:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8011208:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 801120c:	f847 3b04 	str.w	r3, [r7], #4
		yLo = (xPrevWin[ 3+i] << 2);
 8011210:	9b53      	ldr	r3, [sp, #332]	; 0x14c
 8011212:	9905      	ldr	r1, [sp, #20]
 8011214:	009b      	lsls	r3, r3, #2
 8011216:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 801121a:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 801121e:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011220:	9c21      	ldr	r4, [sp, #132]	; 0x84
 8011222:	990c      	ldr	r1, [sp, #48]	; 0x30
 8011224:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8011228:	fb84 3101 	smull	r3, r1, r4, r1
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801122c:	9b56      	ldr	r3, [sp, #344]	; 0x158
	__asm__ volatile (
 801122e:	9806      	ldr	r0, [sp, #24]
 8011230:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8011234:	4601      	mov	r1, r0
 8011236:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 801123a:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 801123e:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011240:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8011242:	990e      	ldr	r1, [sp, #56]	; 0x38
 8011244:	f8c7 32fc 	str.w	r3, [r7, #764]	; 0x2fc
 8011248:	fb85 3101 	smull	r3, r1, r5, r1
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 801124c:	9b59      	ldr	r3, [sp, #356]	; 0x164
 801124e:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	__asm__ volatile (
 8011252:	9907      	ldr	r1, [sp, #28]
 8011254:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 8011258:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 801125c:	f8c7 347c 	str.w	r3, [r7, #1148]	; 0x47c
 8011260:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011262:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011264:	9e23      	ldr	r6, [sp, #140]	; 0x8c
 8011266:	fb86 1303 	smull	r1, r3, r6, r3
 801126a:	990f      	ldr	r1, [sp, #60]	; 0x3c
 801126c:	4626      	mov	r6, r4
 801126e:	fb86 4101 	smull	r4, r1, r6, r1
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 8011272:	440b      	add	r3, r1
	__asm__ volatile (
 8011274:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 8011278:	995c      	ldr	r1, [sp, #368]	; 0x170
 801127a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 801127e:	4663      	mov	r3, ip
 8011280:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 8011284:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 8011288:	431a      	orrs	r2, r3
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801128a:	9c19      	ldr	r4, [sp, #100]	; 0x64
 801128c:	9b08      	ldr	r3, [sp, #32]
 801128e:	f8c7 15fc 	str.w	r1, [r7, #1532]	; 0x5fc
 8011292:	fb84 1303 	smull	r1, r3, r4, r3
 8011296:	9910      	ldr	r1, [sp, #64]	; 0x40
 8011298:	fb85 4101 	smull	r4, r1, r5, r1
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 801129c:	4419      	add	r1, r3
	__asm__ volatile (
 801129e:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
 80112a2:	9b5f      	ldr	r3, [sp, #380]	; 0x17c
 80112a4:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80112a8:	4671      	mov	r1, lr
 80112aa:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80112ae:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 80112b2:	f8c7 377c 	str.w	r3, [r7, #1916]	; 0x77c
 80112b6:	430a      	orrs	r2, r1
		yLo = (xPrevWin[ 0+i] << 2);
 80112b8:	9b51      	ldr	r3, [sp, #324]	; 0x144
 80112ba:	9904      	ldr	r1, [sp, #16]
 80112bc:	009b      	lsls	r3, r3, #2
 80112be:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80112c2:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 80112c6:	67fb      	str	r3, [r7, #124]	; 0x7c
 80112c8:	430a      	orrs	r2, r1
		yLo = (xPrevWin[ 3+i] << 2);
 80112ca:	9b54      	ldr	r3, [sp, #336]	; 0x150
 80112cc:	9905      	ldr	r1, [sp, #20]
 80112ce:	009b      	lsls	r3, r3, #2
 80112d0:	ea83 71e3 	eor.w	r1, r3, r3, asr #31
 80112d4:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80112d8:	9c17      	ldr	r4, [sp, #92]	; 0x5c
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 80112da:	4311      	orrs	r1, r2
 80112dc:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 80112de:	4622      	mov	r2, r4
 80112e0:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
 80112e4:	fb85 3202 	smull	r3, r2, r5, r2
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 80112e8:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 80112ea:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	__asm__ volatile (
 80112ee:	4602      	mov	r2, r0
 80112f0:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80112f4:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80112f8:	430a      	orrs	r2, r1
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80112fa:	981b      	ldr	r0, [sp, #108]	; 0x6c
 80112fc:	f8c7 337c 	str.w	r3, [r7, #892]	; 0x37c
 8011300:	fb80 3404 	smull	r3, r4, r0, r4
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 8011304:	9b5a      	ldr	r3, [sp, #360]	; 0x168
	__asm__ volatile (
 8011306:	9907      	ldr	r1, [sp, #28]
 8011308:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 801130c:	ea84 71e4 	eor.w	r1, r4, r4, asr #31
 8011310:	eba1 71e4 	sub.w	r1, r1, r4, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 8011314:	4311      	orrs	r1, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011316:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011318:	9e20      	ldr	r6, [sp, #128]	; 0x80
 801131a:	f8c7 44fc 	str.w	r4, [r7, #1276]	; 0x4fc
 801131e:	fb86 2303 	smull	r2, r3, r6, r3
 8011322:	9e27      	ldr	r6, [sp, #156]	; 0x9c
 8011324:	4632      	mov	r2, r6
 8011326:	fb85 4202 	smull	r4, r2, r5, r2
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 801132a:	4413      	add	r3, r2
 801132c:	9a5d      	ldr	r2, [sp, #372]	; 0x174
 801132e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
	__asm__ volatile (
 8011332:	4663      	mov	r3, ip
 8011334:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 8011338:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 801133c:	f8c7 267c 	str.w	r2, [r7, #1660]	; 0x67c
 8011340:	4319      	orrs	r1, r3
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011342:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011344:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 8011346:	fb84 3202 	smull	r3, r2, r4, r2
 801134a:	fb80 3606 	smull	r3, r6, r0, r6
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 801134e:	4416      	add	r6, r2
 8011350:	9b60      	ldr	r3, [sp, #384]	; 0x180
	__asm__ volatile (
 8011352:	4672      	mov	r2, lr
 8011354:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8011358:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801135c:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 8011360:	f8c7 37fc 	str.w	r3, [r7, #2044]	; 0x7fc
 8011364:	4311      	orrs	r1, r2
		yLo = (xPrevWin[ 0+i] << 2);
 8011366:	9b52      	ldr	r3, [sp, #328]	; 0x148
 8011368:	9804      	ldr	r0, [sp, #16]
 801136a:	009b      	lsls	r3, r3, #2
 801136c:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8011370:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 8011374:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8011378:	ea41 0200 	orr.w	r2, r1, r0
		yLo = (xPrevWin[ 3+i] << 2);
 801137c:	9b55      	ldr	r3, [sp, #340]	; 0x154
 801137e:	9004      	str	r0, [sp, #16]
 8011380:	009b      	lsls	r3, r3, #2
 8011382:	9805      	ldr	r0, [sp, #20]
 8011384:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8011388:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 801138c:	ea42 0100 	orr.w	r1, r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011390:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8011392:	9a0e      	ldr	r2, [sp, #56]	; 0x38
	__asm__ volatile (
 8011394:	9005      	str	r0, [sp, #20]
 8011396:	f8c7 327c 	str.w	r3, [r7, #636]	; 0x27c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801139a:	fb86 3202 	smull	r3, r2, r6, r2
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801139e:	9b58      	ldr	r3, [sp, #352]	; 0x160
	__asm__ volatile (
 80113a0:	9806      	ldr	r0, [sp, #24]
 80113a2:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80113a6:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
 80113aa:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 80113ae:	f8c7 23fc 	str.w	r2, [r7, #1020]	; 0x3fc
 80113b2:	ea41 0200 	orr.w	r2, r1, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113b6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80113b8:	9c03      	ldr	r4, [sp, #12]
	__asm__ volatile (
 80113ba:	9006      	str	r0, [sp, #24]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113bc:	fb84 3505 	smull	r3, r5, r4, r5
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 80113c0:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
	__asm__ volatile (
 80113c2:	9807      	ldr	r0, [sp, #28]
 80113c4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 80113c8:	ea85 70e5 	eor.w	r0, r5, r5, asr #31
 80113cc:	eba0 70e5 	sub.w	r0, r0, r5, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 80113d0:	f8c7 557c 	str.w	r5, [r7, #1404]	; 0x57c
 80113d4:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113d6:	9b08      	ldr	r3, [sp, #32]
 80113d8:	9d1e      	ldr	r5, [sp, #120]	; 0x78
	__asm__ volatile (
 80113da:	9007      	str	r0, [sp, #28]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113dc:	fb85 1303 	smull	r1, r3, r5, r3
 80113e0:	9910      	ldr	r1, [sp, #64]	; 0x40
 80113e2:	fb86 4101 	smull	r4, r1, r6, r1
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 80113e6:	4419      	add	r1, r3
 80113e8:	9b5e      	ldr	r3, [sp, #376]	; 0x178
	__asm__ volatile (
 80113ea:	4660      	mov	r0, ip
 80113ec:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80113f0:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 80113f4:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 80113f8:	f8c7 36fc 	str.w	r3, [r7, #1788]	; 0x6fc
 80113fc:	4302      	orrs	r2, r0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80113fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011400:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
	__asm__ volatile (
 8011402:	900a      	str	r0, [sp, #40]	; 0x28
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011404:	fb85 1303 	smull	r1, r3, r5, r3
 8011408:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
 801140c:	9803      	ldr	r0, [sp, #12]
 801140e:	fb80 1c0c 	smull	r1, ip, r0, ip
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 8011412:	449c      	add	ip, r3
 8011414:	9961      	ldr	r1, [sp, #388]	; 0x184
	__asm__ volatile (
 8011416:	4674      	mov	r4, lr
 8011418:	eb0c 0181 	add.w	r1, ip, r1, lsl #2
 801141c:	ea81 74e1 	eor.w	r4, r1, r1, asr #31
 8011420:	eba4 74e1 	sub.w	r4, r4, r1, asr #31
		*xPrev++ = xBuf[i] >> 2;
 8011424:	9b24      	ldr	r3, [sp, #144]	; 0x90
		*xPrev++ = xBuf[i] >> 2;
 8011426:	ea4f 05ab 	mov.w	r5, fp, asr #2
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801142a:	f8c7 187c 	str.w	r1, [r7, #2172]	; 0x87c
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801142e:	ee16 0a90 	vmov	r0, s13
		*xPrev++ = xBuf[i] >> 2;
 8011432:	109b      	asrs	r3, r3, #2
		*xPrev++ = xBuf[i] >> 2;
 8011434:	f849 5c08 	str.w	r5, [r9, #-8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011438:	9d01      	ldr	r5, [sp, #4]
	for (   ; i < bc->nBlocksTotal; i++) {
 801143a:	f10a 0a48 	add.w	sl, sl, #72	; 0x48
		*xPrev++ = xBuf[i] >> 2;
 801143e:	f849 3c24 	str.w	r3, [r9, #-36]
	for (   ; i < bc->nBlocksTotal; i++) {
 8011442:	f109 0924 	add.w	r9, r9, #36	; 0x24
		*xPrev++ = xBuf[i] >> 2;
 8011446:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8011448:	940d      	str	r4, [sp, #52]	; 0x34
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801144a:	4314      	orrs	r4, r2
		*xPrev++ = xBuf[i] >> 2;
 801144c:	109b      	asrs	r3, r3, #2
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801144e:	462a      	mov	r2, r5
	for (   ; i < bc->nBlocksTotal; i++) {
 8011450:	3501      	adds	r5, #1
		*xPrev++ = xBuf[i] >> 2;
 8011452:	f849 3c44 	str.w	r3, [r9, #-68]
 8011456:	9b26      	ldr	r3, [sp, #152]	; 0x98
	for (   ; i < bc->nBlocksTotal; i++) {
 8011458:	9501      	str	r5, [sp, #4]
		*xPrev++ = xBuf[i] >> 2;
 801145a:	109b      	asrs	r3, r3, #2
 801145c:	f849 3c40 	str.w	r3, [r9, #-64]
		*xPrev++ = xBuf[i] >> 2;
 8011460:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8011462:	109b      	asrs	r3, r3, #2
 8011464:	f849 3c3c 	str.w	r3, [r9, #-60]
 8011468:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801146a:	109b      	asrs	r3, r3, #2
 801146c:	f849 3c38 	str.w	r3, [r9, #-56]
 8011470:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8011472:	109b      	asrs	r3, r3, #2
 8011474:	f849 3c34 	str.w	r3, [r9, #-52]
 8011478:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801147a:	1099      	asrs	r1, r3, #2
 801147c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801147e:	109b      	asrs	r3, r3, #2
 8011480:	f849 1c30 	str.w	r1, [r9, #-48]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011484:	ee17 1a90 	vmov	r1, s15
		*xPrev++ = xBuf[i] >> 2;
 8011488:	f849 3c28 	str.w	r3, [r9, #-40]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801148c:	ee17 3a10 	vmov	r3, s14
 8011490:	f7fe fa94 	bl	800f9bc <FreqInvertRescale>
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8011494:	9b02      	ldr	r3, [sp, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 8011496:	4320      	orrs	r0, r4
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 8011498:	4303      	orrs	r3, r0
 801149a:	9302      	str	r3, [sp, #8]
	for (   ; i < bc->nBlocksTotal; i++) {
 801149c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801149e:	42ab      	cmp	r3, r5
 80114a0:	f340 8198 	ble.w	80117d4 <xmp3_IMDCT+0x1854>
 80114a4:	f1a9 0324 	sub.w	r3, r9, #36	; 0x24
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 80114a8:	ee06 7a90 	vmov	s13, r7
 80114ac:	ee07 3a90 	vmov	s15, r3
	if (gb < 7) {
 80114b0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80114b2:	2b06      	cmp	r3, #6
 80114b4:	f300 8088 	bgt.w	80115c8 <xmp3_IMDCT+0x1648>
			xCurr[i+0] >>= es;
 80114b8:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 80114ba:	f85a 3c48 	ldr.w	r3, [sl, #-72]
 80114be:	4113      	asrs	r3, r2
 80114c0:	f84a 3c48 	str.w	r3, [sl, #-72]
			xCurr[i+1] >>= es;
 80114c4:	f85a 3c44 	ldr.w	r3, [sl, #-68]
 80114c8:	4113      	asrs	r3, r2
 80114ca:	f84a 3c44 	str.w	r3, [sl, #-68]
			*xPrev++ >>= es;
 80114ce:	f859 3c24 	ldr.w	r3, [r9, #-36]
 80114d2:	4113      	asrs	r3, r2
 80114d4:	f849 3c24 	str.w	r3, [r9, #-36]
			xCurr[i+0] >>= es;
 80114d8:	f85a 3c40 	ldr.w	r3, [sl, #-64]
 80114dc:	4113      	asrs	r3, r2
 80114de:	f84a 3c40 	str.w	r3, [sl, #-64]
			xCurr[i+1] >>= es;
 80114e2:	f85a 3c3c 	ldr.w	r3, [sl, #-60]
 80114e6:	4113      	asrs	r3, r2
 80114e8:	f84a 3c3c 	str.w	r3, [sl, #-60]
			*xPrev++ >>= es;
 80114ec:	f859 3c20 	ldr.w	r3, [r9, #-32]
 80114f0:	4113      	asrs	r3, r2
 80114f2:	f849 3c20 	str.w	r3, [r9, #-32]
			xCurr[i+0] >>= es;
 80114f6:	f85a 3c38 	ldr.w	r3, [sl, #-56]
 80114fa:	4113      	asrs	r3, r2
 80114fc:	f84a 3c38 	str.w	r3, [sl, #-56]
			xCurr[i+1] >>= es;
 8011500:	f85a 3c34 	ldr.w	r3, [sl, #-52]
 8011504:	4113      	asrs	r3, r2
 8011506:	f84a 3c34 	str.w	r3, [sl, #-52]
			*xPrev++ >>= es;
 801150a:	f859 3c1c 	ldr.w	r3, [r9, #-28]
 801150e:	4113      	asrs	r3, r2
 8011510:	f849 3c1c 	str.w	r3, [r9, #-28]
			xCurr[i+0] >>= es;
 8011514:	f85a 3c30 	ldr.w	r3, [sl, #-48]
 8011518:	4113      	asrs	r3, r2
 801151a:	f84a 3c30 	str.w	r3, [sl, #-48]
			xCurr[i+1] >>= es;
 801151e:	f85a 3c2c 	ldr.w	r3, [sl, #-44]
 8011522:	4113      	asrs	r3, r2
 8011524:	f84a 3c2c 	str.w	r3, [sl, #-44]
			*xPrev++ >>= es;
 8011528:	f859 3c18 	ldr.w	r3, [r9, #-24]
 801152c:	4113      	asrs	r3, r2
 801152e:	f849 3c18 	str.w	r3, [r9, #-24]
			xCurr[i+0] >>= es;
 8011532:	f85a 3c28 	ldr.w	r3, [sl, #-40]
 8011536:	4113      	asrs	r3, r2
 8011538:	f84a 3c28 	str.w	r3, [sl, #-40]
			xCurr[i+1] >>= es;
 801153c:	f85a 3c24 	ldr.w	r3, [sl, #-36]
 8011540:	4113      	asrs	r3, r2
 8011542:	f84a 3c24 	str.w	r3, [sl, #-36]
			*xPrev++ >>= es;
 8011546:	f859 3c14 	ldr.w	r3, [r9, #-20]
 801154a:	4113      	asrs	r3, r2
 801154c:	f849 3c14 	str.w	r3, [r9, #-20]
			xCurr[i+0] >>= es;
 8011550:	f85a 3c20 	ldr.w	r3, [sl, #-32]
 8011554:	4113      	asrs	r3, r2
 8011556:	f84a 3c20 	str.w	r3, [sl, #-32]
			xCurr[i+1] >>= es;
 801155a:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
 801155e:	4113      	asrs	r3, r2
 8011560:	f84a 3c1c 	str.w	r3, [sl, #-28]
			*xPrev++ >>= es;
 8011564:	f859 3c10 	ldr.w	r3, [r9, #-16]
 8011568:	4113      	asrs	r3, r2
 801156a:	f849 3c10 	str.w	r3, [r9, #-16]
			xCurr[i+0] >>= es;
 801156e:	f85a 3c18 	ldr.w	r3, [sl, #-24]
 8011572:	4113      	asrs	r3, r2
 8011574:	f84a 3c18 	str.w	r3, [sl, #-24]
			xCurr[i+1] >>= es;
 8011578:	f85a 3c14 	ldr.w	r3, [sl, #-20]
 801157c:	4113      	asrs	r3, r2
 801157e:	f84a 3c14 	str.w	r3, [sl, #-20]
			*xPrev++ >>= es;
 8011582:	f859 3c0c 	ldr.w	r3, [r9, #-12]
 8011586:	4113      	asrs	r3, r2
 8011588:	f849 3c0c 	str.w	r3, [r9, #-12]
			xCurr[i+0] >>= es;
 801158c:	f85a 3c10 	ldr.w	r3, [sl, #-16]
 8011590:	4113      	asrs	r3, r2
 8011592:	f84a 3c10 	str.w	r3, [sl, #-16]
			xCurr[i+1] >>= es;
 8011596:	f85a 3c0c 	ldr.w	r3, [sl, #-12]
 801159a:	4113      	asrs	r3, r2
 801159c:	f84a 3c0c 	str.w	r3, [sl, #-12]
			*xPrev++ >>= es;
 80115a0:	f859 3c08 	ldr.w	r3, [r9, #-8]
 80115a4:	4113      	asrs	r3, r2
 80115a6:	f849 3c08 	str.w	r3, [r9, #-8]
			xCurr[i+0] >>= es;
 80115aa:	f85a 3c08 	ldr.w	r3, [sl, #-8]
 80115ae:	4113      	asrs	r3, r2
 80115b0:	f84a 3c08 	str.w	r3, [sl, #-8]
			xCurr[i+1] >>= es;
 80115b4:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 80115b8:	4113      	asrs	r3, r2
 80115ba:	f84a 3c04 	str.w	r3, [sl, #-4]
			*xPrev++ >>= es;
 80115be:	f859 3c04 	ldr.w	r3, [r9, #-4]
 80115c2:	4113      	asrs	r3, r2
 80115c4:	f849 3c04 	str.w	r3, [r9, #-4]
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 80115c8:	f85a 1c0c 	ldr.w	r1, [sl, #-12]
 80115cc:	f85a 3c18 	ldr.w	r3, [sl, #-24]
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 80115d0:	f85a 2c24 	ldr.w	r2, [sl, #-36]
	x4 -= x5;
 80115d4:	1a5d      	subs	r5, r3, r1
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 80115d6:	f85a 3c30 	ldr.w	r3, [sl, #-48]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 80115da:	f85a 4c48 	ldr.w	r4, [sl, #-72]
	x3 -= x4;
 80115de:	1b52      	subs	r2, r2, r5
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80115e0:	4e78      	ldr	r6, [pc, #480]	; (80117c4 <xmp3_IMDCT+0x1844>)
	x2 -= x3;
 80115e2:	eba3 0c02 	sub.w	ip, r3, r2
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 80115e6:	f85a 3c3c 	ldr.w	r3, [sl, #-60]
	x3 -= x5;
 80115ea:	1a52      	subs	r2, r2, r1
	x1 -= x2;
 80115ec:	eba3 030c 	sub.w	r3, r3, ip
	x0 -= x1;
 80115f0:	1ae4      	subs	r4, r4, r3
	x1 -= x3;
 80115f2:	1a9b      	subs	r3, r3, r2
	x0 >>= 1;
 80115f4:	ea4f 0e64 	mov.w	lr, r4, asr #1
	x1 >>= 1;
 80115f8:	105b      	asrs	r3, r3, #1
 80115fa:	fb86 4c0c 	smull	r4, ip, r6, ip
	a1 = x0 + (x4 >> 1);
 80115fe:	eb0e 0665 	add.w	r6, lr, r5, asr #1
	a2 = x0 - x4;
 8011602:	ebae 0005 	sub.w	r0, lr, r5
	x0 = a1 + a0;
 8011606:	eb06 054c 	add.w	r5, r6, ip, lsl #1
	a2 = x0 - x4;
 801160a:	9009      	str	r0, [sp, #36]	; 0x24
	x4 = a1 - a0;
 801160c:	eba6 0c4c 	sub.w	ip, r6, ip, lsl #1
 8011610:	4e6c      	ldr	r6, [pc, #432]	; (80117c4 <xmp3_IMDCT+0x1844>)
	x0 = a1 + a0;
 8011612:	9508      	str	r5, [sp, #32]
 8011614:	fb86 4202 	smull	r4, r2, r6, r2
	a1 = x1 + (x5 >> 1);
 8011618:	eb03 0561 	add.w	r5, r3, r1, asr #1
 801161c:	486a      	ldr	r0, [pc, #424]	; (80117c8 <xmp3_IMDCT+0x1848>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 801161e:	0056      	lsls	r6, r2, #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011620:	eb05 0242 	add.w	r2, r5, r2, lsl #1
 8011624:	fb80 4202 	smull	r4, r2, r0, r2
 8011628:	4c68      	ldr	r4, [pc, #416]	; (80117cc <xmp3_IMDCT+0x184c>)
	a2 = x1 - x5;
 801162a:	1a5b      	subs	r3, r3, r1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801162c:	0092      	lsls	r2, r2, #2
 801162e:	fb84 1303 	smull	r1, r3, r4, r3
 8011632:	4967      	ldr	r1, [pc, #412]	; (80117d0 <xmp3_IMDCT+0x1850>)
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011634:	1bad      	subs	r5, r5, r6
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011636:	009c      	lsls	r4, r3, #2
 8011638:	fb81 3505 	smull	r3, r5, r1, r5
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 801163c:	f85a 3c14 	ldr.w	r3, [sl, #-20]
	x4 -= x5;
 8011640:	f85a 1c08 	ldr.w	r1, [sl, #-8]
	*out = x0 + x1;	out++;
 8011644:	9808      	ldr	r0, [sp, #32]
	x4 -= x5;
 8011646:	eba3 0e01 	sub.w	lr, r3, r1
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801164a:	f85a 3c20 	ldr.w	r3, [sl, #-32]
 801164e:	f85a 1c2c 	ldr.w	r1, [sl, #-44]
	x3 -= x4;
 8011652:	eba3 030e 	sub.w	r3, r3, lr
	x2 -= x3;
 8011656:	1ace      	subs	r6, r1, r3
	x3 -= x5;
 8011658:	f85a 1c08 	ldr.w	r1, [sl, #-8]
 801165c:	1a5b      	subs	r3, r3, r1
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801165e:	f85a 1c38 	ldr.w	r1, [sl, #-56]
	x1 -= x2;
 8011662:	eba1 0b06 	sub.w	fp, r1, r6
 8011666:	4631      	mov	r1, r6
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011668:	f85a 6c44 	ldr.w	r6, [sl, #-68]
	x1 -= x3;
 801166c:	930f      	str	r3, [sp, #60]	; 0x3c
	x0 -= x1;
 801166e:	eba6 060b 	sub.w	r6, r6, fp
	x1 -= x3;
 8011672:	ebab 0b03 	sub.w	fp, fp, r3
	*out = x0 + x1;	out++;
 8011676:	1813      	adds	r3, r2, r0
	x0 >>= 1;
 8011678:	1076      	asrs	r6, r6, #1
	*out = x0 + x1;	out++;
 801167a:	9308      	str	r3, [sp, #32]
	*out = x0 - x1;
 801167c:	1a83      	subs	r3, r0, r2
	*out = x2 + x3;	out++;
 801167e:	9a09      	ldr	r2, [sp, #36]	; 0x24
	x1 >>= 1;
 8011680:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	*out = x0 - x1;
 8011684:	930e      	str	r3, [sp, #56]	; 0x38
	*out = x2 + x3;	out++;
 8011686:	1913      	adds	r3, r2, r4
 8011688:	9309      	str	r3, [sp, #36]	; 0x24
	*out = x2 - x3;	out++;
 801168a:	1b13      	subs	r3, r2, r4
 801168c:	4c4d      	ldr	r4, [pc, #308]	; (80117c4 <xmp3_IMDCT+0x1844>)
 801168e:	9317      	str	r3, [sp, #92]	; 0x5c
	*out = x4 + x5;	out++;
 8011690:	eb0c 0385 	add.w	r3, ip, r5, lsl #2
 8011694:	930b      	str	r3, [sp, #44]	; 0x2c
	*out = x4 - x5;	out++;
 8011696:	ebac 0385 	sub.w	r3, ip, r5, lsl #2
 801169a:	930c      	str	r3, [sp, #48]	; 0x30
 801169c:	fb84 2101 	smull	r2, r1, r4, r1
	a1 = x0 + (x4 >> 1);
 80116a0:	eb06 0c6e 	add.w	ip, r6, lr, asr #1
 80116a4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	a2 = x0 - x4;
 80116a6:	eba6 060e 	sub.w	r6, r6, lr
	x0 = a1 + a0;
 80116aa:	eb0c 0541 	add.w	r5, ip, r1, lsl #1
	x4 = a1 - a0;
 80116ae:	ebac 0c41 	sub.w	ip, ip, r1, lsl #1
	x0 = a1 + a0;
 80116b2:	950f      	str	r5, [sp, #60]	; 0x3c
 80116b4:	fb84 2303 	smull	r2, r3, r4, r3
	a1 = x1 + (x5 >> 1);
 80116b8:	f85a 2c08 	ldr.w	r2, [sl, #-8]
	a0 = MULSHIFT32(c3_0, x3) << 1;
 80116bc:	005d      	lsls	r5, r3, #1
 80116be:	4842      	ldr	r0, [pc, #264]	; (80117c8 <xmp3_IMDCT+0x1848>)
	a1 = x1 + (x5 >> 1);
 80116c0:	eb0b 0262 	add.w	r2, fp, r2, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80116c4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80116c8:	fb80 1303 	smull	r1, r3, r0, r3
	a2 = x1 - x5;
 80116cc:	f85a 1c08 	ldr.w	r1, [sl, #-8]
 80116d0:	4c3e      	ldr	r4, [pc, #248]	; (80117cc <xmp3_IMDCT+0x184c>)
 80116d2:	ebab 0b01 	sub.w	fp, fp, r1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 80116d6:	0099      	lsls	r1, r3, #2
 80116d8:	fb84 3b0b 	smull	r3, fp, r4, fp
	x3 = MULSHIFT32(c6[1], a2) << 2;
 80116dc:	ea4f 038b 	mov.w	r3, fp, lsl #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 80116e0:	eba2 0e05 	sub.w	lr, r2, r5
 80116e4:	4a3a      	ldr	r2, [pc, #232]	; (80117d0 <xmp3_IMDCT+0x1850>)
	x3 = MULSHIFT32(c6[1], a2) << 2;
 80116e6:	9313      	str	r3, [sp, #76]	; 0x4c
 80116e8:	fb82 3e0e 	smull	r3, lr, r2, lr
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 80116ec:	f85a 2c10 	ldr.w	r2, [sl, #-16]
	x4 -= x5;
 80116f0:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 80116f4:	1ad4      	subs	r4, r2, r3
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 80116f6:	f85a 3c1c 	ldr.w	r3, [sl, #-28]
 80116fa:	f85a 2c28 	ldr.w	r2, [sl, #-40]
	x3 -= x4;
 80116fe:	1b1b      	subs	r3, r3, r4
	x2 -= x3;
 8011700:	1ad5      	subs	r5, r2, r3
	x3 -= x5;
 8011702:	f85a 2c04 	ldr.w	r2, [sl, #-4]
 8011706:	1a9b      	subs	r3, r3, r2
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011708:	f85a 2c34 	ldr.w	r2, [sl, #-52]
	x1 -= x2;
 801170c:	eba2 0b05 	sub.w	fp, r2, r5
 8011710:	462a      	mov	r2, r5
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 8011712:	f85a 5c40 	ldr.w	r5, [sl, #-64]
	x0 -= x1;
 8011716:	eba5 050b 	sub.w	r5, r5, fp
	x1 -= x3;
 801171a:	ebab 0b03 	sub.w	fp, fp, r3
	x0 >>= 1;
 801171e:	1068      	asrs	r0, r5, #1
	x1 >>= 1;
 8011720:	ea4f 0b6b 	mov.w	fp, fp, asr #1
	x0 >>= 1;
 8011724:	9011      	str	r0, [sp, #68]	; 0x44
	*out = x0 + x1;	out++;
 8011726:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8011728:	1845      	adds	r5, r0, r1
 801172a:	9524      	str	r5, [sp, #144]	; 0x90
	*out = x0 - x1;
 801172c:	1a45      	subs	r5, r0, r1
	*out = x2 + x3;	out++;
 801172e:	9913      	ldr	r1, [sp, #76]	; 0x4c
	*out = x0 - x1;
 8011730:	9510      	str	r5, [sp, #64]	; 0x40
	*out = x2 + x3;	out++;
 8011732:	1875      	adds	r5, r6, r1
	*out = x2 - x3;	out++;
 8011734:	1a71      	subs	r1, r6, r1
 8011736:	4e23      	ldr	r6, [pc, #140]	; (80117c4 <xmp3_IMDCT+0x1844>)
 8011738:	9127      	str	r1, [sp, #156]	; 0x9c
	*out = x4 + x5;	out++;
 801173a:	eb0c 018e 	add.w	r1, ip, lr, lsl #2
	*out = x2 + x3;	out++;
 801173e:	9525      	str	r5, [sp, #148]	; 0x94
	*out = x4 + x5;	out++;
 8011740:	9126      	str	r1, [sp, #152]	; 0x98
	*out = x4 - x5;	out++;
 8011742:	ebac 018e 	sub.w	r1, ip, lr, lsl #2
 8011746:	910f      	str	r1, [sp, #60]	; 0x3c
 8011748:	fb86 1202 	smull	r1, r2, r6, r2
	a1 = x0 + (x4 >> 1);
 801174c:	9811      	ldr	r0, [sp, #68]	; 0x44
 801174e:	eb00 0164 	add.w	r1, r0, r4, asr #1
	a2 = x0 - x4;
 8011752:	1b05      	subs	r5, r0, r4
	x0 = a1 + a0;
 8011754:	eb01 0442 	add.w	r4, r1, r2, lsl #1
	x4 = a1 - a0;
 8011758:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
 801175c:	fb86 1303 	smull	r1, r3, r6, r3
	a1 = x1 + (x5 >> 1);
 8011760:	f85a 1c04 	ldr.w	r1, [sl, #-4]
	a0 = MULSHIFT32(c3_0, x3) << 1;
 8011764:	005e      	lsls	r6, r3, #1
 8011766:	4818      	ldr	r0, [pc, #96]	; (80117c8 <xmp3_IMDCT+0x1848>)
	a1 = x1 + (x5 >> 1);
 8011768:	eb0b 0161 	add.w	r1, fp, r1, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801176c:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8011770:	fb80 c303 	smull	ip, r3, r0, r3
	a2 = x1 - x5;
 8011774:	f85a 0c04 	ldr.w	r0, [sl, #-4]
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 8011778:	009b      	lsls	r3, r3, #2
	a2 = x1 - x5;
 801177a:	ebab 0b00 	sub.w	fp, fp, r0
 801177e:	4813      	ldr	r0, [pc, #76]	; (80117cc <xmp3_IMDCT+0x184c>)
 8011780:	fb80 cb0b 	smull	ip, fp, r0, fp
 8011784:	4812      	ldr	r0, [pc, #72]	; (80117d0 <xmp3_IMDCT+0x1850>)
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 8011786:	1b89      	subs	r1, r1, r6
	x3 = MULSHIFT32(c6[1], a2) << 2;
 8011788:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 801178c:	fb80 6101 	smull	r6, r1, r0, r1
	*out = x0 + x1;	out++;
 8011790:	1918      	adds	r0, r3, r4
	*out = x0 - x1;
 8011792:	1ae3      	subs	r3, r4, r3
 8011794:	9316      	str	r3, [sp, #88]	; 0x58
	*out = x2 + x3;	out++;
 8011796:	eb0b 0305 	add.w	r3, fp, r5
	*out = x0 + x1;	out++;
 801179a:	9011      	str	r0, [sp, #68]	; 0x44
	*out = x2 - x3;	out++;
 801179c:	eba5 0b0b 	sub.w	fp, r5, fp
	*out = x2 + x3;	out++;
 80117a0:	9313      	str	r3, [sp, #76]	; 0x4c
	*out = x4 + x5;	out++;
 80117a2:	eb02 0381 	add.w	r3, r2, r1, lsl #2
 80117a6:	9314      	str	r3, [sp, #80]	; 0x50
	*out = x4 - x5;	out++;
 80117a8:	eba2 0381 	sub.w	r3, r2, r1, lsl #2
 80117ac:	9315      	str	r3, [sp, #84]	; 0x54
	if (btPrev == 2) {
 80117ae:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80117b0:	2b02      	cmp	r3, #2
 80117b2:	f47f acb2 	bne.w	801111a <xmp3_IMDCT+0x119a>
 80117b6:	a950      	add	r1, sp, #320	; 0x140
 80117b8:	ee17 0a90 	vmov	r0, s15
 80117bc:	f7fe fb6e 	bl	800fe9c <WinPrevious.part.0>
		yLo = (xPrevWin[ 0+i] << 2);
 80117c0:	9b50      	ldr	r3, [sp, #320]	; 0x140
 80117c2:	e51d      	b.n	8011200 <xmp3_IMDCT+0x1280>
 80117c4:	6ed9eba1 	.word	0x6ed9eba1
 80117c8:	7ba3751d 	.word	0x7ba3751d
 80117cc:	5a82799a 	.word	0x5a82799a
 80117d0:	2120fb83 	.word	0x2120fb83
		xPrev += 9;
 80117d4:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 80117d6:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 80117d8:	1a9b      	subs	r3, r3, r2
 80117da:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 80117dc:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 80117e0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80117e4:	9333      	str	r3, [sp, #204]	; 0xcc
	for (   ; i < bc->nBlocksPrev; i++) {
 80117e6:	e9dd 122a 	ldrd	r1, r2, [sp, #168]	; 0xa8
 80117ea:	428a      	cmp	r2, r1
 80117ec:	f340 83df 	ble.w	8011fae <xmp3_IMDCT+0x202e>
 80117f0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 80117f2:	428b      	cmp	r3, r1
 80117f4:	f340 8416 	ble.w	8012024 <xmp3_IMDCT+0x20a4>
 80117f8:	4293      	cmp	r3, r2
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80117fa:	f8df 8890 	ldr.w	r8, [pc, #2192]	; 801208c <xmp3_IMDCT+0x210c>
 80117fe:	bfa8      	it	ge
 8011800:	4613      	movge	r3, r2
 8011802:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 8011804:	9332      	str	r3, [sp, #200]	; 0xc8
 8011806:	3224      	adds	r2, #36	; 0x24
 8011808:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 801180a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801180e:	f1a3 0e04 	sub.w	lr, r3, #4
 8011812:	f8d8 3048 	ldr.w	r3, [r8, #72]	; 0x48
 8011816:	931e      	str	r3, [sp, #120]	; 0x78
 8011818:	f8d8 308c 	ldr.w	r3, [r8, #140]	; 0x8c
 801181c:	931f      	str	r3, [sp, #124]	; 0x7c
 801181e:	f8d8 304c 	ldr.w	r3, [r8, #76]	; 0x4c
 8011822:	9320      	str	r3, [sp, #128]	; 0x80
 8011824:	f8d8 3088 	ldr.w	r3, [r8, #136]	; 0x88
 8011828:	9321      	str	r3, [sp, #132]	; 0x84
 801182a:	f8d8 3050 	ldr.w	r3, [r8, #80]	; 0x50
 801182e:	9322      	str	r3, [sp, #136]	; 0x88
 8011830:	f8d8 3084 	ldr.w	r3, [r8, #132]	; 0x84
 8011834:	9323      	str	r3, [sp, #140]	; 0x8c
 8011836:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 801183a:	9324      	str	r3, [sp, #144]	; 0x90
 801183c:	f8d8 3080 	ldr.w	r3, [r8, #128]	; 0x80
 8011840:	9325      	str	r3, [sp, #148]	; 0x94
 8011842:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 8011846:	9326      	str	r3, [sp, #152]	; 0x98
 8011848:	f8d8 307c 	ldr.w	r3, [r8, #124]	; 0x7c
 801184c:	9327      	str	r3, [sp, #156]	; 0x9c
 801184e:	f8d8 305c 	ldr.w	r3, [r8, #92]	; 0x5c
 8011852:	9328      	str	r3, [sp, #160]	; 0xa0
 8011854:	f8d8 3078 	ldr.w	r3, [r8, #120]	; 0x78
 8011858:	9329      	str	r3, [sp, #164]	; 0xa4
 801185a:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
 801185e:	932a      	str	r3, [sp, #168]	; 0xa8
 8011860:	f8d8 3074 	ldr.w	r3, [r8, #116]	; 0x74
 8011864:	932d      	str	r3, [sp, #180]	; 0xb4
 8011866:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
 801186a:	932e      	str	r3, [sp, #184]	; 0xb8
 801186c:	f8d8 3070 	ldr.w	r3, [r8, #112]	; 0x70
			xPrev[j] = 0;
 8011870:	f8cd 80f4 	str.w	r8, [sp, #244]	; 0xf4
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011874:	932f      	str	r3, [sp, #188]	; 0xbc
 8011876:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 801187a:	9101      	str	r1, [sp, #4]
 801187c:	9330      	str	r3, [sp, #192]	; 0xc0
 801187e:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
			xPrev[j] = 0;
 8011882:	4688      	mov	r8, r1
 8011884:	e9dd 463a 	ldrd	r4, r6, [sp, #232]	; 0xe8
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011888:	9331      	str	r3, [sp, #196]	; 0xc4
 801188a:	f852 3c24 	ldr.w	r3, [r2, #-36]
 801188e:	4611      	mov	r1, r2
 8011890:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 8011892:	4618      	mov	r0, r3
 8011894:	fb85 2000 	smull	r2, r0, r5, r0
 8011898:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
			*xpwLo++ = MULSHIFT32(wLo, x);
 801189a:	9050      	str	r0, [sp, #320]	; 0x140
 801189c:	fb85 2303 	smull	r2, r3, r5, r3
			*xpwHi-- = MULSHIFT32(wHi, x);
 80118a0:	9361      	str	r3, [sp, #388]	; 0x184
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80118a2:	f851 2c20 	ldr.w	r2, [r1, #-32]
 80118a6:	9d20      	ldr	r5, [sp, #128]	; 0x80
 80118a8:	4613      	mov	r3, r2
 80118aa:	fb85 7303 	smull	r7, r3, r5, r3
 80118ae:	9d21      	ldr	r5, [sp, #132]	; 0x84
			*xpwLo++ = MULSHIFT32(wLo, x);
 80118b0:	9351      	str	r3, [sp, #324]	; 0x144
 80118b2:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 80118b6:	9260      	str	r2, [sp, #384]	; 0x180
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80118b8:	f851 2c1c 	ldr.w	r2, [r1, #-28]
 80118bc:	9d22      	ldr	r5, [sp, #136]	; 0x88
 80118be:	4617      	mov	r7, r2
 80118c0:	fb85 c707 	smull	ip, r7, r5, r7
 80118c4:	9d23      	ldr	r5, [sp, #140]	; 0x8c
			*xpwLo++ = MULSHIFT32(wLo, x);
 80118c6:	9752      	str	r7, [sp, #328]	; 0x148
 80118c8:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 80118cc:	925f      	str	r2, [sp, #380]	; 0x17c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80118ce:	f851 2c18 	ldr.w	r2, [r1, #-24]
 80118d2:	9d24      	ldr	r5, [sp, #144]	; 0x90
 80118d4:	4617      	mov	r7, r2
 80118d6:	fb85 c707 	smull	ip, r7, r5, r7
 80118da:	9d25      	ldr	r5, [sp, #148]	; 0x94
			*xpwLo++ = MULSHIFT32(wLo, x);
 80118dc:	9753      	str	r7, [sp, #332]	; 0x14c
 80118de:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 80118e2:	925e      	str	r2, [sp, #376]	; 0x178
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80118e4:	f851 2c14 	ldr.w	r2, [r1, #-20]
 80118e8:	9d26      	ldr	r5, [sp, #152]	; 0x98
 80118ea:	4617      	mov	r7, r2
 80118ec:	fb85 c707 	smull	ip, r7, r5, r7
 80118f0:	9d27      	ldr	r5, [sp, #156]	; 0x9c
			*xpwLo++ = MULSHIFT32(wLo, x);
 80118f2:	9754      	str	r7, [sp, #336]	; 0x150
 80118f4:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 80118f8:	925d      	str	r2, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 80118fa:	f851 2c10 	ldr.w	r2, [r1, #-16]
 80118fe:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 8011900:	4617      	mov	r7, r2
 8011902:	fb85 c707 	smull	ip, r7, r5, r7
 8011906:	9d29      	ldr	r5, [sp, #164]	; 0xa4
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011908:	9755      	str	r7, [sp, #340]	; 0x154
 801190a:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 801190e:	925c      	str	r2, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011910:	f851 2c0c 	ldr.w	r2, [r1, #-12]
 8011914:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 8011916:	4617      	mov	r7, r2
 8011918:	fb85 c707 	smull	ip, r7, r5, r7
 801191c:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
			*xpwLo++ = MULSHIFT32(wLo, x);
 801191e:	9756      	str	r7, [sp, #344]	; 0x158
 8011920:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011924:	925b      	str	r2, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011926:	f851 2c08 	ldr.w	r2, [r1, #-8]
 801192a:	9d2e      	ldr	r5, [sp, #184]	; 0xb8
 801192c:	4617      	mov	r7, r2
 801192e:	fb85 c707 	smull	ip, r7, r5, r7
 8011932:	9d2f      	ldr	r5, [sp, #188]	; 0xbc
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011934:	9757      	str	r7, [sp, #348]	; 0x15c
 8011936:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 801193a:	925a      	str	r2, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801193c:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8011940:	9d30      	ldr	r5, [sp, #192]	; 0xc0
 8011942:	4617      	mov	r7, r2
 8011944:	fb85 c707 	smull	ip, r7, r5, r7
 8011948:	9d31      	ldr	r5, [sp, #196]	; 0xc4
			*xpwLo++ = MULSHIFT32(wLo, x);
 801194a:	9758      	str	r7, [sp, #352]	; 0x160
 801194c:	fb85 7202 	smull	r7, r2, r5, r2
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011950:	9259      	str	r2, [sp, #356]	; 0x164
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011952:	0082      	lsls	r2, r0, #2
	__asm__ volatile (
 8011954:	4620      	mov	r0, r4
			y[2*j+0][i] = xp;
 8011956:	f84e 2f04 	str.w	r2, [lr, #4]!
 801195a:	9203      	str	r2, [sp, #12]
 801195c:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
 8011960:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
 8011964:	9010      	str	r0, [sp, #64]	; 0x40
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011966:	f348 0000 	sbfx	r0, r8, #0, #1
 801196a:	f008 0201 	and.w	r2, r8, #1
 801196e:	4637      	mov	r7, r6
 8011970:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011974:	4413      	add	r3, r2
			y[2*j+1][i] = xp;
 8011976:	f8ce 3080 	str.w	r3, [lr, #128]	; 0x80
 801197a:	9304      	str	r3, [sp, #16]
 801197c:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
 8011980:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
			xPrev[j] = 0;
 8011984:	2300      	movs	r3, #0
 8011986:	9711      	str	r7, [sp, #68]	; 0x44
 8011988:	f841 3c24 	str.w	r3, [r1, #-36]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801198c:	9b52      	ldr	r3, [sp, #328]	; 0x148
 801198e:	009f      	lsls	r7, r3, #2
 8011990:	4623      	mov	r3, r4
 8011992:	463d      	mov	r5, r7
			y[2*j+0][i] = xp;
 8011994:	f8ce 7100 	str.w	r7, [lr, #256]	; 0x100
 8011998:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 801199c:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 80119a0:	9312      	str	r3, [sp, #72]	; 0x48
			xp = xPrevWin[2*j+1] << 2;
 80119a2:	9b53      	ldr	r3, [sp, #332]	; 0x14c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 80119a4:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 80119a8:	18d7      	adds	r7, r2, r3
 80119aa:	4633      	mov	r3, r6
			y[2*j+1][i] = xp;
 80119ac:	f8ce 7180 	str.w	r7, [lr, #384]	; 0x180
 80119b0:	9705      	str	r7, [sp, #20]
 80119b2:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 80119b6:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 80119ba:	9313      	str	r3, [sp, #76]	; 0x4c
			xPrev[j] = 0;
 80119bc:	2300      	movs	r3, #0
 80119be:	4627      	mov	r7, r4
 80119c0:	f841 3c20 	str.w	r3, [r1, #-32]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 80119c4:	9b54      	ldr	r3, [sp, #336]	; 0x150
 80119c6:	009b      	lsls	r3, r3, #2
			y[2*j+0][i] = xp;
 80119c8:	f8ce 3200 	str.w	r3, [lr, #512]	; 0x200
 80119cc:	9306      	str	r3, [sp, #24]
 80119ce:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
 80119d2:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
			xp = xPrevWin[2*j+1] << 2;
 80119d6:	9b55      	ldr	r3, [sp, #340]	; 0x154
 80119d8:	9714      	str	r7, [sp, #80]	; 0x50
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 80119da:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 80119de:	18d7      	adds	r7, r2, r3
 80119e0:	4633      	mov	r3, r6
			y[2*j+1][i] = xp;
 80119e2:	f8ce 7280 	str.w	r7, [lr, #640]	; 0x280
 80119e6:	9707      	str	r7, [sp, #28]
 80119e8:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 80119ec:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 80119f0:	9315      	str	r3, [sp, #84]	; 0x54
			xPrev[j] = 0;
 80119f2:	2300      	movs	r3, #0
 80119f4:	f841 3c1c 	str.w	r3, [r1, #-28]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 80119f8:	9b56      	ldr	r3, [sp, #344]	; 0x158
 80119fa:	009f      	lsls	r7, r3, #2
 80119fc:	4623      	mov	r3, r4
			y[2*j+0][i] = xp;
 80119fe:	f8ce 7300 	str.w	r7, [lr, #768]	; 0x300
 8011a02:	9708      	str	r7, [sp, #32]
 8011a04:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011a08:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 8011a0c:	9316      	str	r3, [sp, #88]	; 0x58
 8011a0e:	4637      	mov	r7, r6
			xp = xPrevWin[2*j+1] << 2;
 8011a10:	9b57      	ldr	r3, [sp, #348]	; 0x15c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011a12:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011a16:	18d3      	adds	r3, r2, r3
			y[2*j+1][i] = xp;
 8011a18:	f8ce 3380 	str.w	r3, [lr, #896]	; 0x380
 8011a1c:	9309      	str	r3, [sp, #36]	; 0x24
 8011a1e:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
 8011a22:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
			xPrev[j] = 0;
 8011a26:	2300      	movs	r3, #0
 8011a28:	9717      	str	r7, [sp, #92]	; 0x5c
 8011a2a:	f841 3c18 	str.w	r3, [r1, #-24]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011a2e:	9b58      	ldr	r3, [sp, #352]	; 0x160
 8011a30:	009f      	lsls	r7, r3, #2
 8011a32:	4623      	mov	r3, r4
			y[2*j+0][i] = xp;
 8011a34:	f8ce 7400 	str.w	r7, [lr, #1024]	; 0x400
 8011a38:	970a      	str	r7, [sp, #40]	; 0x28
 8011a3a:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011a3e:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 8011a42:	9319      	str	r3, [sp, #100]	; 0x64
 8011a44:	4637      	mov	r7, r6
			xp = xPrevWin[2*j+1] << 2;
 8011a46:	9b59      	ldr	r3, [sp, #356]	; 0x164
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011a48:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011a4c:	18d3      	adds	r3, r2, r3
			y[2*j+1][i] = xp;
 8011a4e:	f8ce 3480 	str.w	r3, [lr, #1152]	; 0x480
 8011a52:	930b      	str	r3, [sp, #44]	; 0x2c
 8011a54:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
 8011a58:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
			xPrev[j] = 0;
 8011a5c:	2300      	movs	r3, #0
 8011a5e:	971a      	str	r7, [sp, #104]	; 0x68
 8011a60:	f841 3c14 	str.w	r3, [r1, #-20]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011a64:	9b5a      	ldr	r3, [sp, #360]	; 0x168
 8011a66:	009f      	lsls	r7, r3, #2
 8011a68:	4623      	mov	r3, r4
			y[2*j+0][i] = xp;
 8011a6a:	f8ce 7500 	str.w	r7, [lr, #1280]	; 0x500
 8011a6e:	970c      	str	r7, [sp, #48]	; 0x30
 8011a70:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011a74:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 8011a78:	931b      	str	r3, [sp, #108]	; 0x6c
 8011a7a:	4637      	mov	r7, r6
			xp = xPrevWin[2*j+1] << 2;
 8011a7c:	9b5b      	ldr	r3, [sp, #364]	; 0x16c
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011a7e:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011a82:	18d3      	adds	r3, r2, r3
			y[2*j+1][i] = xp;
 8011a84:	f8ce 3580 	str.w	r3, [lr, #1408]	; 0x580
 8011a88:	930d      	str	r3, [sp, #52]	; 0x34
 8011a8a:	ea83 77e3 	eor.w	r7, r3, r3, asr #31
 8011a8e:	eba7 77e3 	sub.w	r7, r7, r3, asr #31
			xPrev[j] = 0;
 8011a92:	2300      	movs	r3, #0
 8011a94:	971c      	str	r7, [sp, #112]	; 0x70
 8011a96:	f841 3c10 	str.w	r3, [r1, #-16]
 8011a9a:	4623      	mov	r3, r4
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011a9c:	9f5c      	ldr	r7, [sp, #368]	; 0x170
 8011a9e:	00bf      	lsls	r7, r7, #2
			y[2*j+0][i] = xp;
 8011aa0:	f8ce 7600 	str.w	r7, [lr, #1536]	; 0x600
 8011aa4:	970e      	str	r7, [sp, #56]	; 0x38
 8011aa6:	ea87 73e7 	eor.w	r3, r7, r7, asr #31
 8011aaa:	eba3 73e7 	sub.w	r3, r3, r7, asr #31
 8011aae:	931d      	str	r3, [sp, #116]	; 0x74
 8011ab0:	46b2      	mov	sl, r6
			xp = xPrevWin[2*j+1] << 2;
 8011ab2:	9b5d      	ldr	r3, [sp, #372]	; 0x174
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011ab4:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011ab8:	18d3      	adds	r3, r2, r3
			y[2*j+1][i] = xp;
 8011aba:	f8ce 3680 	str.w	r3, [lr, #1664]	; 0x680
 8011abe:	930f      	str	r3, [sp, #60]	; 0x3c
 8011ac0:	ea83 7ae3 	eor.w	sl, r3, r3, asr #31
 8011ac4:	ebaa 7ae3 	sub.w	sl, sl, r3, asr #31
			xPrev[j] = 0;
 8011ac8:	2300      	movs	r3, #0
 8011aca:	46a1      	mov	r9, r4
 8011acc:	f841 3c0c 	str.w	r3, [r1, #-12]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011ad0:	9f5e      	ldr	r7, [sp, #376]	; 0x178
 8011ad2:	00bf      	lsls	r7, r7, #2
			y[2*j+0][i] = xp;
 8011ad4:	f8ce 7700 	str.w	r7, [lr, #1792]	; 0x700
 8011ad8:	ea87 79e7 	eor.w	r9, r7, r7, asr #31
 8011adc:	eba9 79e7 	sub.w	r9, r9, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011ae0:	9b5f      	ldr	r3, [sp, #380]	; 0x17c
 8011ae2:	46b4      	mov	ip, r6
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011ae4:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011ae8:	eb02 0b03 	add.w	fp, r2, r3
			y[2*j+1][i] = xp;
 8011aec:	f8ce b780 	str.w	fp, [lr, #1920]	; 0x780
 8011af0:	ea8b 7ceb 	eor.w	ip, fp, fp, asr #31
 8011af4:	ebac 7ceb 	sub.w	ip, ip, fp, asr #31
			nonZero |= xp;
 8011af8:	9b06      	ldr	r3, [sp, #24]
 8011afa:	432b      	orrs	r3, r5
 8011afc:	9d08      	ldr	r5, [sp, #32]
 8011afe:	432b      	orrs	r3, r5
 8011b00:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8011b02:	432b      	orrs	r3, r5
 8011b04:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8011b06:	432b      	orrs	r3, r5
 8011b08:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8011b0a:	432b      	orrs	r3, r5
			xPrev[j] = 0;
 8011b0c:	2500      	movs	r5, #0
 8011b0e:	f841 5c08 	str.w	r5, [r1, #-8]
			nonZero |= xp;
 8011b12:	433b      	orrs	r3, r7
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011b14:	9f60      	ldr	r7, [sp, #384]	; 0x180
			nonZero |= xp;
 8011b16:	9d03      	ldr	r5, [sp, #12]
 8011b18:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011b1c:	00bf      	lsls	r7, r7, #2
			nonZero |= xp;
 8011b1e:	432b      	orrs	r3, r5
 8011b20:	9d04      	ldr	r5, [sp, #16]
			y[2*j+0][i] = xp;
 8011b22:	f8ce 7800 	str.w	r7, [lr, #2048]	; 0x800
			nonZero |= xp;
 8011b26:	432b      	orrs	r3, r5
 8011b28:	9d05      	ldr	r5, [sp, #20]
 8011b2a:	432b      	orrs	r3, r5
 8011b2c:	9d07      	ldr	r5, [sp, #28]
 8011b2e:	432b      	orrs	r3, r5
 8011b30:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8011b32:	432b      	orrs	r3, r5
 8011b34:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8011b36:	432b      	orrs	r3, r5
 8011b38:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8011b3a:	432b      	orrs	r3, r5
 8011b3c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8011b3e:	432b      	orrs	r3, r5
 8011b40:	ea43 0b0b 	orr.w	fp, r3, fp
 8011b44:	ea87 74e7 	eor.w	r4, r7, r7, asr #31
 8011b48:	eba4 74e7 	sub.w	r4, r4, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011b4c:	9b61      	ldr	r3, [sp, #388]	; 0x184
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011b4e:	ea80 0383 	eor.w	r3, r0, r3, lsl #2
 8011b52:	4413      	add	r3, r2
			y[2*j+1][i] = xp;
 8011b54:	f8ce 3880 	str.w	r3, [lr, #2176]	; 0x880
 8011b58:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
 8011b5c:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
			xPrev[j] = 0;
 8011b60:	2200      	movs	r2, #0
		if (nonZero)
 8011b62:	ea5b 0503 	orrs.w	r5, fp, r3
			mOut |= FASTABS(xp);
 8011b66:	e9dd 0710 	ldrd	r0, r7, [sp, #64]	; 0x40
			xPrev[j] = 0;
 8011b6a:	f841 2c04 	str.w	r2, [r1, #-4]
			mOut |= FASTABS(xp);
 8011b6e:	ea40 0307 	orr.w	r3, r0, r7
 8011b72:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8011b74:	9f14      	ldr	r7, [sp, #80]	; 0x50
 8011b76:	ea43 0302 	orr.w	r3, r3, r2
 8011b7a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8011b7c:	ea43 0302 	orr.w	r3, r3, r2
 8011b80:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011b82:	ea43 0307 	orr.w	r3, r3, r7
 8011b86:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8011b88:	ea43 0302 	orr.w	r3, r3, r2
 8011b8c:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8011b8e:	ea43 0302 	orr.w	r3, r3, r2
 8011b92:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8011b94:	ea43 0307 	orr.w	r3, r3, r7
 8011b98:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8011b9a:	ea43 0302 	orr.w	r3, r3, r2
 8011b9e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8011ba0:	ea43 0307 	orr.w	r3, r3, r7
 8011ba4:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8011ba6:	ea43 0302 	orr.w	r3, r3, r2
 8011baa:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8011bac:	ea43 0307 	orr.w	r3, r3, r7
 8011bb0:	ea43 0302 	orr.w	r3, r3, r2
		if (nonZero)
 8011bb4:	9a01      	ldr	r2, [sp, #4]
 8011bb6:	bf18      	it	ne
 8011bb8:	4642      	movne	r2, r8
	for (   ; i < bc->nBlocksPrev; i++) {
 8011bba:	f108 0801 	add.w	r8, r8, #1
			mOut |= FASTABS(xp);
 8011bbe:	ea43 030a 	orr.w	r3, r3, sl
		if (nonZero)
 8011bc2:	9201      	str	r2, [sp, #4]
			mOut |= FASTABS(xp);
 8011bc4:	ea43 0309 	orr.w	r3, r3, r9
 8011bc8:	9a02      	ldr	r2, [sp, #8]
 8011bca:	ea43 030c 	orr.w	r3, r3, ip
 8011bce:	4323      	orrs	r3, r4
 8011bd0:	4333      	orrs	r3, r6
 8011bd2:	431a      	orrs	r2, r3
	for (   ; i < bc->nBlocksPrev; i++) {
 8011bd4:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8011bd6:	4598      	cmp	r8, r3
			mOut |= FASTABS(xp);
 8011bd8:	9202      	str	r2, [sp, #8]
	for (   ; i < bc->nBlocksPrev; i++) {
 8011bda:	f101 0224 	add.w	r2, r1, #36	; 0x24
 8011bde:	f6ff ae54 	blt.w	801188a <xmp3_IMDCT+0x190a>
 8011be2:	f8cd 80a8 	str.w	r8, [sp, #168]	; 0xa8
 8011be6:	9133      	str	r1, [sp, #204]	; 0xcc
 8011be8:	f8dd 80f4 	ldr.w	r8, [sp, #244]	; 0xf4
 8011bec:	e9dd 232a 	ldrd	r2, r3, [sp, #168]	; 0xa8
 8011bf0:	e9cd 463a 	strd	r4, r6, [sp, #232]	; 0xe8
 8011bf4:	4293      	cmp	r3, r2
 8011bf6:	f340 81dd 	ble.w	8011fb4 <xmp3_IMDCT+0x2034>
 8011bfa:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 8011bfc:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8011bfe:	f103 0924 	add.w	r9, r3, #36	; 0x24
 8011c02:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 8011c04:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8011c08:	f1a3 0a04 	sub.w	sl, r3, #4
		wpLo = imdctWin[btPrev] + 18;
 8011c0c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8011c0e:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
			xPrev[j] = 0;
 8011c12:	e9dd 453a 	ldrd	r4, r5, [sp, #232]	; 0xe8
		wpLo = imdctWin[btPrev] + 18;
 8011c16:	eb08 1b03 	add.w	fp, r8, r3, lsl #4
			xPrev[j] = 0;
 8011c1a:	4690      	mov	r8, r2
 8011c1c:	e14d      	b.n	8011eba <xmp3_IMDCT+0x1f3a>
 8011c1e:	a950      	add	r1, sp, #320	; 0x140
 8011c20:	f7fe f93c 	bl	800fe9c <WinPrevious.part.0>
			xp = xPrevWin[2*j+1] << 2;
 8011c24:	e9dd 0250 	ldrd	r0, r2, [sp, #320]	; 0x140
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011c28:	0083      	lsls	r3, r0, #2
 8011c2a:	4620      	mov	r0, r4
			y[2*j+0][i] = xp;
 8011c2c:	f84a 3f04 	str.w	r3, [sl, #4]!
 8011c30:	9311      	str	r3, [sp, #68]	; 0x44
 8011c32:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 8011c36:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011c3a:	f348 0300 	sbfx	r3, r8, #0, #1
 8011c3e:	9012      	str	r0, [sp, #72]	; 0x48
 8011c40:	462e      	mov	r6, r5
 8011c42:	ea83 0182 	eor.w	r1, r3, r2, lsl #2
 8011c46:	f008 0201 	and.w	r2, r8, #1
 8011c4a:	1850      	adds	r0, r2, r1
			y[2*j+1][i] = xp;
 8011c4c:	f8ca 0080 	str.w	r0, [sl, #128]	; 0x80
 8011c50:	9010      	str	r0, [sp, #64]	; 0x40
 8011c52:	ea80 76e0 	eor.w	r6, r0, r0, asr #31
 8011c56:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
			xPrev[j] = 0;
 8011c5a:	2700      	movs	r7, #0
 8011c5c:	9613      	str	r6, [sp, #76]	; 0x4c
 8011c5e:	f849 7c24 	str.w	r7, [r9, #-36]
 8011c62:	4627      	mov	r7, r4
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011c64:	9952      	ldr	r1, [sp, #328]	; 0x148
 8011c66:	008e      	lsls	r6, r1, #2
			y[2*j+0][i] = xp;
 8011c68:	f8ca 6100 	str.w	r6, [sl, #256]	; 0x100
 8011c6c:	960f      	str	r6, [sp, #60]	; 0x3c
 8011c6e:	ea86 77e6 	eor.w	r7, r6, r6, asr #31
 8011c72:	eba7 77e6 	sub.w	r7, r7, r6, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011c76:	9953      	ldr	r1, [sp, #332]	; 0x14c
 8011c78:	9714      	str	r7, [sp, #80]	; 0x50
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011c7a:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011c7e:	188f      	adds	r7, r1, r2
 8011c80:	4629      	mov	r1, r5
			y[2*j+1][i] = xp;
 8011c82:	f8ca 7180 	str.w	r7, [sl, #384]	; 0x180
 8011c86:	970e      	str	r7, [sp, #56]	; 0x38
 8011c88:	ea87 71e7 	eor.w	r1, r7, r7, asr #31
 8011c8c:	eba1 71e7 	sub.w	r1, r1, r7, asr #31
			xPrev[j] = 0;
 8011c90:	f04f 0c00 	mov.w	ip, #0
 8011c94:	9115      	str	r1, [sp, #84]	; 0x54
 8011c96:	4626      	mov	r6, r4
 8011c98:	f849 cc20 	str.w	ip, [r9, #-32]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011c9c:	9954      	ldr	r1, [sp, #336]	; 0x150
 8011c9e:	0089      	lsls	r1, r1, #2
			y[2*j+0][i] = xp;
 8011ca0:	f8ca 1200 	str.w	r1, [sl, #512]	; 0x200
 8011ca4:	910d      	str	r1, [sp, #52]	; 0x34
 8011ca6:	ea81 76e1 	eor.w	r6, r1, r1, asr #31
 8011caa:	eba6 76e1 	sub.w	r6, r6, r1, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011cae:	9955      	ldr	r1, [sp, #340]	; 0x154
 8011cb0:	9616      	str	r6, [sp, #88]	; 0x58
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011cb2:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011cb6:	188e      	adds	r6, r1, r2
 8011cb8:	4629      	mov	r1, r5
			y[2*j+1][i] = xp;
 8011cba:	f8ca 6280 	str.w	r6, [sl, #640]	; 0x280
 8011cbe:	960c      	str	r6, [sp, #48]	; 0x30
 8011cc0:	ea86 71e6 	eor.w	r1, r6, r6, asr #31
 8011cc4:	eba1 71e6 	sub.w	r1, r1, r6, asr #31
			xPrev[j] = 0;
 8011cc8:	f04f 0c00 	mov.w	ip, #0
 8011ccc:	9117      	str	r1, [sp, #92]	; 0x5c
 8011cce:	4620      	mov	r0, r4
 8011cd0:	f849 cc1c 	str.w	ip, [r9, #-28]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011cd4:	9956      	ldr	r1, [sp, #344]	; 0x158
 8011cd6:	0089      	lsls	r1, r1, #2
			y[2*j+0][i] = xp;
 8011cd8:	f8ca 1300 	str.w	r1, [sl, #768]	; 0x300
 8011cdc:	910b      	str	r1, [sp, #44]	; 0x2c
 8011cde:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 8011ce2:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011ce6:	9957      	ldr	r1, [sp, #348]	; 0x15c
 8011ce8:	462e      	mov	r6, r5
 8011cea:	9019      	str	r0, [sp, #100]	; 0x64
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011cec:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011cf0:	1888      	adds	r0, r1, r2
			y[2*j+1][i] = xp;
 8011cf2:	f8ca 0380 	str.w	r0, [sl, #896]	; 0x380
 8011cf6:	900a      	str	r0, [sp, #40]	; 0x28
 8011cf8:	ea80 76e0 	eor.w	r6, r0, r0, asr #31
 8011cfc:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
			xPrev[j] = 0;
 8011d00:	f04f 0c00 	mov.w	ip, #0
 8011d04:	961a      	str	r6, [sp, #104]	; 0x68
 8011d06:	f849 cc18 	str.w	ip, [r9, #-24]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d0a:	9958      	ldr	r1, [sp, #352]	; 0x160
 8011d0c:	008e      	lsls	r6, r1, #2
 8011d0e:	4621      	mov	r1, r4
			y[2*j+0][i] = xp;
 8011d10:	f8ca 6400 	str.w	r6, [sl, #1024]	; 0x400
 8011d14:	9609      	str	r6, [sp, #36]	; 0x24
 8011d16:	ea86 71e6 	eor.w	r1, r6, r6, asr #31
 8011d1a:	eba1 71e6 	sub.w	r1, r1, r6, asr #31
 8011d1e:	911b      	str	r1, [sp, #108]	; 0x6c
 8011d20:	4628      	mov	r0, r5
			xp = xPrevWin[2*j+1] << 2;
 8011d22:	9959      	ldr	r1, [sp, #356]	; 0x164
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d24:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011d28:	4411      	add	r1, r2
			y[2*j+1][i] = xp;
 8011d2a:	f8ca 1480 	str.w	r1, [sl, #1152]	; 0x480
 8011d2e:	9108      	str	r1, [sp, #32]
 8011d30:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 8011d34:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
			xPrev[j] = 0;
 8011d38:	f04f 0c00 	mov.w	ip, #0
 8011d3c:	901c      	str	r0, [sp, #112]	; 0x70
 8011d3e:	4620      	mov	r0, r4
 8011d40:	f849 cc14 	str.w	ip, [r9, #-20]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d44:	9f5a      	ldr	r7, [sp, #360]	; 0x168
 8011d46:	00bf      	lsls	r7, r7, #2
			y[2*j+0][i] = xp;
 8011d48:	f8ca 7500 	str.w	r7, [sl, #1280]	; 0x500
 8011d4c:	ea87 70e7 	eor.w	r0, r7, r7, asr #31
 8011d50:	eba0 70e7 	sub.w	r0, r0, r7, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011d54:	995b      	ldr	r1, [sp, #364]	; 0x16c
 8011d56:	462e      	mov	r6, r5
 8011d58:	901d      	str	r0, [sp, #116]	; 0x74
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d5a:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011d5e:	1888      	adds	r0, r1, r2
			y[2*j+1][i] = xp;
 8011d60:	f8ca 0580 	str.w	r0, [sl, #1408]	; 0x580
 8011d64:	9007      	str	r0, [sp, #28]
 8011d66:	ea80 76e0 	eor.w	r6, r0, r0, asr #31
 8011d6a:	eba6 76e0 	sub.w	r6, r6, r0, asr #31
			xPrev[j] = 0;
 8011d6e:	f04f 0c00 	mov.w	ip, #0
 8011d72:	961e      	str	r6, [sp, #120]	; 0x78
 8011d74:	f849 cc10 	str.w	ip, [r9, #-16]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011d78:	995c      	ldr	r1, [sp, #368]	; 0x170
 8011d7a:	008e      	lsls	r6, r1, #2
 8011d7c:	4621      	mov	r1, r4
			y[2*j+0][i] = xp;
 8011d7e:	f8ca 6600 	str.w	r6, [sl, #1536]	; 0x600
 8011d82:	9606      	str	r6, [sp, #24]
 8011d84:	ea86 71e6 	eor.w	r1, r6, r6, asr #31
 8011d88:	eba1 71e6 	sub.w	r1, r1, r6, asr #31
 8011d8c:	911f      	str	r1, [sp, #124]	; 0x7c
 8011d8e:	4628      	mov	r0, r5
			xp = xPrevWin[2*j+1] << 2;
 8011d90:	995d      	ldr	r1, [sp, #372]	; 0x174
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011d92:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011d96:	4411      	add	r1, r2
			y[2*j+1][i] = xp;
 8011d98:	f8ca 1680 	str.w	r1, [sl, #1664]	; 0x680
 8011d9c:	9105      	str	r1, [sp, #20]
 8011d9e:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 8011da2:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
			xPrev[j] = 0;
 8011da6:	f04f 0c00 	mov.w	ip, #0
 8011daa:	9020      	str	r0, [sp, #128]	; 0x80
 8011dac:	46a6      	mov	lr, r4
 8011dae:	f849 cc0c 	str.w	ip, [r9, #-12]
 8011db2:	4666      	mov	r6, ip
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011db4:	985e      	ldr	r0, [sp, #376]	; 0x178
 8011db6:	0080      	lsls	r0, r0, #2
			y[2*j+0][i] = xp;
 8011db8:	f8ca 0700 	str.w	r0, [sl, #1792]	; 0x700
 8011dbc:	9004      	str	r0, [sp, #16]
 8011dbe:	ea80 7ee0 	eor.w	lr, r0, r0, asr #31
 8011dc2:	ebae 7ee0 	sub.w	lr, lr, r0, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011dc6:	995f      	ldr	r1, [sp, #380]	; 0x17c
 8011dc8:	46ac      	mov	ip, r5
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011dca:	ea83 0181 	eor.w	r1, r3, r1, lsl #2
 8011dce:	4411      	add	r1, r2
 8011dd0:	9103      	str	r1, [sp, #12]
			y[2*j+1][i] = xp;
 8011dd2:	f8ca 1780 	str.w	r1, [sl, #1920]	; 0x780
 8011dd6:	ea81 7ce1 	eor.w	ip, r1, r1, asr #31
 8011dda:	ebac 7ce1 	sub.w	ip, ip, r1, asr #31
			xPrev[j] = 0;
 8011dde:	f849 6c08 	str.w	r6, [r9, #-8]
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 8011de2:	9860      	ldr	r0, [sp, #384]	; 0x180
 8011de4:	0080      	lsls	r0, r0, #2
			y[2*j+0][i] = xp;
 8011de6:	f8ca 0800 	str.w	r0, [sl, #2048]	; 0x800
 8011dea:	ea80 74e0 	eor.w	r4, r0, r0, asr #31
 8011dee:	eba4 74e0 	sub.w	r4, r4, r0, asr #31
			xp = xPrevWin[2*j+1] << 2;
 8011df2:	9e61      	ldr	r6, [sp, #388]	; 0x184
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 8011df4:	ea83 0686 	eor.w	r6, r3, r6, lsl #2
 8011df8:	4416      	add	r6, r2
			y[2*j+1][i] = xp;
 8011dfa:	f8ca 6880 	str.w	r6, [sl, #2176]	; 0x880
 8011dfe:	ea86 75e6 	eor.w	r5, r6, r6, asr #31
 8011e02:	eba5 75e6 	sub.w	r5, r5, r6, asr #31
			nonZero |= xp;
 8011e06:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	for (   ; i < bc->nBlocksPrev; i++) {
 8011e08:	f109 0924 	add.w	r9, r9, #36	; 0x24
			nonZero |= xp;
 8011e0c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011e0e:	4313      	orrs	r3, r2
 8011e10:	930d      	str	r3, [sp, #52]	; 0x34
			mOut |= FASTABS(xp);
 8011e12:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8011e16:	ea43 0102 	orr.w	r1, r3, r2
			nonZero |= xp;
 8011e1a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8011e1c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011e1e:	4313      	orrs	r3, r2
			mOut |= FASTABS(xp);
 8011e20:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011e22:	4311      	orrs	r1, r2
			nonZero |= xp;
 8011e24:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011e26:	4313      	orrs	r3, r2
			mOut |= FASTABS(xp);
 8011e28:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8011e2a:	4311      	orrs	r1, r2
			nonZero |= xp;
 8011e2c:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e2e:	9f16      	ldr	r7, [sp, #88]	; 0x58
 8011e30:	460a      	mov	r2, r1
			nonZero |= xp;
 8011e32:	9903      	ldr	r1, [sp, #12]
			mOut |= FASTABS(xp);
 8011e34:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e36:	9f06      	ldr	r7, [sp, #24]
 8011e38:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e3a:	9f17      	ldr	r7, [sp, #92]	; 0x5c
 8011e3c:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e3e:	9f04      	ldr	r7, [sp, #16]
 8011e40:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e42:	9f19      	ldr	r7, [sp, #100]	; 0x64
			nonZero |= xp;
 8011e44:	4303      	orrs	r3, r0
			mOut |= FASTABS(xp);
 8011e46:	433a      	orrs	r2, r7
 8011e48:	981a      	ldr	r0, [sp, #104]	; 0x68
			nonZero |= xp;
 8011e4a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			mOut |= FASTABS(xp);
 8011e4c:	4302      	orrs	r2, r0
		if (nonZero)
 8011e4e:	9810      	ldr	r0, [sp, #64]	; 0x40
			nonZero |= xp;
 8011e50:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e52:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8011e54:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e56:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 8011e58:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e5a:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8011e5c:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e5e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8011e60:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e62:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 8011e64:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e66:	9f08      	ldr	r7, [sp, #32]
 8011e68:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e6a:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8011e6c:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e6e:	9f07      	ldr	r7, [sp, #28]
 8011e70:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e72:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
 8011e74:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e76:	9f05      	ldr	r7, [sp, #20]
 8011e78:	433b      	orrs	r3, r7
			mOut |= FASTABS(xp);
 8011e7a:	9f20      	ldr	r7, [sp, #128]	; 0x80
			nonZero |= xp;
 8011e7c:	430b      	orrs	r3, r1
			mOut |= FASTABS(xp);
 8011e7e:	433a      	orrs	r2, r7
			nonZero |= xp;
 8011e80:	9911      	ldr	r1, [sp, #68]	; 0x44
			mOut |= FASTABS(xp);
 8011e82:	ea42 020e 	orr.w	r2, r2, lr
			nonZero |= xp;
 8011e86:	4333      	orrs	r3, r6
			mOut |= FASTABS(xp);
 8011e88:	ea42 020c 	orr.w	r2, r2, ip
			nonZero |= xp;
 8011e8c:	430b      	orrs	r3, r1
		if (nonZero)
 8011e8e:	4303      	orrs	r3, r0
			mOut |= FASTABS(xp);
 8011e90:	ea42 0304 	orr.w	r3, r2, r4
			xPrev[j] = 0;
 8011e94:	f04f 0200 	mov.w	r2, #0
			mOut |= FASTABS(xp);
 8011e98:	ea43 0305 	orr.w	r3, r3, r5
			xPrev[j] = 0;
 8011e9c:	f849 2c28 	str.w	r2, [r9, #-40]
			mOut |= FASTABS(xp);
 8011ea0:	9a02      	ldr	r2, [sp, #8]
 8011ea2:	ea42 0203 	orr.w	r2, r2, r3
		if (nonZero)
 8011ea6:	9b01      	ldr	r3, [sp, #4]
 8011ea8:	bf18      	it	ne
 8011eaa:	4643      	movne	r3, r8
	for (   ; i < bc->nBlocksPrev; i++) {
 8011eac:	f108 0801 	add.w	r8, r8, #1
			mOut |= FASTABS(xp);
 8011eb0:	9202      	str	r2, [sp, #8]
		if (nonZero)
 8011eb2:	9301      	str	r3, [sp, #4]
	for (   ; i < bc->nBlocksPrev; i++) {
 8011eb4:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8011eb6:	4543      	cmp	r3, r8
 8011eb8:	dd7c      	ble.n	8011fb4 <xmp3_IMDCT+0x2034>
	if (btPrev == 2) {
 8011eba:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8011ebc:	f1a9 0024 	sub.w	r0, r9, #36	; 0x24
 8011ec0:	2b02      	cmp	r3, #2
 8011ec2:	f43f aeac 	beq.w	8011c1e <xmp3_IMDCT+0x1c9e>
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011ec6:	f859 1c24 	ldr.w	r1, [r9, #-36]
 8011eca:	f8db 308c 	ldr.w	r3, [fp, #140]	; 0x8c
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8011ece:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
 8011ed2:	4608      	mov	r0, r1
 8011ed4:	fb82 6000 	smull	r6, r0, r2, r0
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011ed8:	9050      	str	r0, [sp, #320]	; 0x140
 8011eda:	fb83 2101 	smull	r2, r1, r3, r1
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011ede:	9161      	str	r1, [sp, #388]	; 0x184
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011ee0:	f859 6c20 	ldr.w	r6, [r9, #-32]
 8011ee4:	f8db 3088 	ldr.w	r3, [fp, #136]	; 0x88
 8011ee8:	f8db 104c 	ldr.w	r1, [fp, #76]	; 0x4c
 8011eec:	4632      	mov	r2, r6
 8011eee:	fb81 7202 	smull	r7, r2, r1, r2
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011ef2:	9251      	str	r2, [sp, #324]	; 0x144
 8011ef4:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011ef8:	9660      	str	r6, [sp, #384]	; 0x180
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011efa:	f859 6c1c 	ldr.w	r6, [r9, #-28]
 8011efe:	f8db 3084 	ldr.w	r3, [fp, #132]	; 0x84
 8011f02:	f8db 1050 	ldr.w	r1, [fp, #80]	; 0x50
 8011f06:	4637      	mov	r7, r6
 8011f08:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f0c:	9752      	str	r7, [sp, #328]	; 0x148
 8011f0e:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f12:	965f      	str	r6, [sp, #380]	; 0x17c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f14:	f859 6c18 	ldr.w	r6, [r9, #-24]
 8011f18:	f8db 3080 	ldr.w	r3, [fp, #128]	; 0x80
 8011f1c:	f8db 1054 	ldr.w	r1, [fp, #84]	; 0x54
 8011f20:	4637      	mov	r7, r6
 8011f22:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f26:	9753      	str	r7, [sp, #332]	; 0x14c
 8011f28:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f2c:	965e      	str	r6, [sp, #376]	; 0x178
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f2e:	f859 6c14 	ldr.w	r6, [r9, #-20]
 8011f32:	f8db 307c 	ldr.w	r3, [fp, #124]	; 0x7c
 8011f36:	f8db 1058 	ldr.w	r1, [fp, #88]	; 0x58
 8011f3a:	4637      	mov	r7, r6
 8011f3c:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f40:	9754      	str	r7, [sp, #336]	; 0x150
 8011f42:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f46:	965d      	str	r6, [sp, #372]	; 0x174
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f48:	f859 6c10 	ldr.w	r6, [r9, #-16]
 8011f4c:	f8db 3078 	ldr.w	r3, [fp, #120]	; 0x78
 8011f50:	f8db 105c 	ldr.w	r1, [fp, #92]	; 0x5c
 8011f54:	4637      	mov	r7, r6
 8011f56:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f5a:	9755      	str	r7, [sp, #340]	; 0x154
 8011f5c:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f60:	965c      	str	r6, [sp, #368]	; 0x170
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f62:	f859 6c0c 	ldr.w	r6, [r9, #-12]
 8011f66:	f8db 3074 	ldr.w	r3, [fp, #116]	; 0x74
 8011f6a:	f8db 1060 	ldr.w	r1, [fp, #96]	; 0x60
 8011f6e:	4637      	mov	r7, r6
 8011f70:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f74:	9756      	str	r7, [sp, #344]	; 0x158
 8011f76:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f7a:	965b      	str	r6, [sp, #364]	; 0x16c
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f7c:	f859 6c08 	ldr.w	r6, [r9, #-8]
 8011f80:	f8db 3070 	ldr.w	r3, [fp, #112]	; 0x70
 8011f84:	f8db 1064 	ldr.w	r1, [fp, #100]	; 0x64
 8011f88:	4637      	mov	r7, r6
 8011f8a:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011f8e:	9757      	str	r7, [sp, #348]	; 0x15c
 8011f90:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011f94:	965a      	str	r6, [sp, #360]	; 0x168
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 8011f96:	f859 6c04 	ldr.w	r6, [r9, #-4]
 8011f9a:	e9db 131a 	ldrd	r1, r3, [fp, #104]	; 0x68
 8011f9e:	4637      	mov	r7, r6
 8011fa0:	fb81 c707 	smull	ip, r7, r1, r7
			*xpwLo++ = MULSHIFT32(wLo, x);
 8011fa4:	9758      	str	r7, [sp, #352]	; 0x160
 8011fa6:	fb83 1606 	smull	r1, r6, r3, r6
			*xpwHi-- = MULSHIFT32(wHi, x);
 8011faa:	9659      	str	r6, [sp, #356]	; 0x164
		for (i = 9; i > 0; i--) {
 8011fac:	e63c      	b.n	8011c28 <xmp3_IMDCT+0x1ca8>
 8011fae:	460b      	mov	r3, r1
	for (   ; i < bc->nBlocksPrev; i++) {
 8011fb0:	912b      	str	r1, [sp, #172]	; 0xac
 8011fb2:	9101      	str	r1, [sp, #4]
	for (   ; i < 32; i++) {
 8011fb4:	2b1f      	cmp	r3, #31
 8011fb6:	dc0f      	bgt.n	8011fd8 <xmp3_IMDCT+0x2058>
 8011fb8:	4618      	mov	r0, r3
 8011fba:	9b34      	ldr	r3, [sp, #208]	; 0xd0
			y[j][i] = 0;
 8011fbc:	2100      	movs	r1, #0
 8011fbe:	eb03 0280 	add.w	r2, r3, r0, lsl #2
	for (   ; i < bc->nBlocksPrev; i++) {
 8011fc2:	2300      	movs	r3, #0
			y[j][i] = 0;
 8011fc4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (j = 0; j < 18; j++) 
 8011fc8:	3320      	adds	r3, #32
 8011fca:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8011fce:	d1f9      	bne.n	8011fc4 <xmp3_IMDCT+0x2044>
	for (   ; i < 32; i++) {
 8011fd0:	3001      	adds	r0, #1
 8011fd2:	3204      	adds	r2, #4
 8011fd4:	2820      	cmp	r0, #32
 8011fd6:	d1f4      	bne.n	8011fc2 <xmp3_IMDCT+0x2042>
	if (!x)
 8011fd8:	9b02      	ldr	r3, [sp, #8]
 8011fda:	2b00      	cmp	r3, #0
 8011fdc:	d03a      	beq.n	8012054 <xmp3_IMDCT+0x20d4>
	while (!(x & 0x80000000)) {
 8011fde:	db4e      	blt.n	801207e <xmp3_IMDCT+0x20fe>
 8011fe0:	4619      	mov	r1, r3
	numZeros = 0;
 8011fe2:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 8011fe4:	0049      	lsls	r1, r1, #1
 8011fe6:	461a      	mov	r2, r3
		numZeros++;
 8011fe8:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 8011fec:	d5fa      	bpl.n	8011fe4 <xmp3_IMDCT+0x2064>
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8011fee:	9c3c      	ldr	r4, [sp, #240]	; 0xf0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8011ff0:	e9dd 1338 	ldrd	r1, r3, [sp, #224]	; 0xe0
 8011ff4:	440b      	add	r3, r1
 8011ff6:	e9dd 0135 	ldrd	r0, r1, [sp, #212]	; 0xd4
 8011ffa:	011b      	lsls	r3, r3, #4
 8011ffc:	4401      	add	r1, r0
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8011ffe:	9801      	ldr	r0, [sp, #4]
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 8012000:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8012004:	9937      	ldr	r1, [sp, #220]	; 0xdc
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 8012006:	f8c4 0b00 	str.w	r0, [r4, #2816]	; 0xb00
	mi->gb[ch] = bc.gbOut;

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 801200a:	2000      	movs	r0, #0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801200c:	4419      	add	r1, r3
 801200e:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 8012010:	992c      	ldr	r1, [sp, #176]	; 0xb0
	mi->gb[ch] = bc.gbOut;
 8012012:	f8c4 2b18 	str.w	r2, [r4, #2840]	; 0xb18
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 8012016:	f8c4 1b10 	str.w	r1, [r4, #2832]	; 0xb10
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801201a:	f8c4 3b08 	str.w	r3, [r4, #2824]	; 0xb08
}
 801201e:	b063      	add	sp, #396	; 0x18c
 8012020:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8012024:	f8df 8064 	ldr.w	r8, [pc, #100]	; 801208c <xmp3_IMDCT+0x210c>
	for (   ; i < bc->nBlocksPrev; i++) {
 8012028:	9101      	str	r1, [sp, #4]
 801202a:	e5e6      	b.n	8011bfa <xmp3_IMDCT+0x1c7a>
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 801202c:	f8dd b0cc 	ldr.w	fp, [sp, #204]	; 0xcc
 8012030:	9301      	str	r3, [sp, #4]
 8012032:	f7ff b860 	b.w	80110f6 <xmp3_IMDCT+0x1176>
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 8012036:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012038:	9332      	str	r3, [sp, #200]	; 0xc8
 801203a:	b16b      	cbz	r3, 8012058 <xmp3_IMDCT+0x20d8>
		nBfly = bc.nBlocksLong - 1;
 801203c:	982c      	ldr	r0, [sp, #176]	; 0xb0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801203e:	2112      	movs	r1, #18
 8012040:	2208      	movs	r2, #8
 8012042:	1e43      	subs	r3, r0, #1
		bc.nBlocksLong = blockCutoff;	
 8012044:	9032      	str	r0, [sp, #200]	; 0xc8
 8012046:	b21b      	sxth	r3, r3
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 8012048:	fb13 2201 	smlabb	r2, r3, r1, r2
 801204c:	4631      	mov	r1, r6
 801204e:	9215      	str	r2, [sp, #84]	; 0x54
		nBfly = bc.nBlocksLong - 1;
 8012050:	f7fe bb0d 	b.w	801066e <xmp3_IMDCT+0x6ee>
 8012054:	221f      	movs	r2, #31
 8012056:	e7ca      	b.n	8011fee <xmp3_IMDCT+0x206e>
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 8012058:	020b      	lsls	r3, r1, #8
 801205a:	2208      	movs	r2, #8
 801205c:	9316      	str	r3, [sp, #88]	; 0x58
 801205e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012060:	9215      	str	r2, [sp, #84]	; 0x54
 8012062:	eb03 2301 	add.w	r3, r3, r1, lsl #8
 8012066:	9311      	str	r3, [sp, #68]	; 0x44
 8012068:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801206a:	f7fe b8a8 	b.w	80101be <xmp3_IMDCT+0x23e>
	for (   ; i < bc->nBlocksTotal; i++) {
 801206e:	932a      	str	r3, [sp, #168]	; 0xa8
 8012070:	f7ff bbb9 	b.w	80117e6 <xmp3_IMDCT+0x1866>
	mOut = 0;
 8012074:	2300      	movs	r3, #0
 8012076:	9332      	str	r3, [sp, #200]	; 0xc8
	for(i = 0; i < bc->nBlocksLong; i++) {
 8012078:	9302      	str	r3, [sp, #8]
 801207a:	f7fe bca4 	b.w	80109c6 <xmp3_IMDCT+0xa46>
 801207e:	f04f 32ff 	mov.w	r2, #4294967295
 8012082:	e7b4      	b.n	8011fee <xmp3_IMDCT+0x206e>
		return -1;
 8012084:	f04f 30ff 	mov.w	r0, #4294967295
 8012088:	e7c9      	b.n	801201e <xmp3_IMDCT+0x209e>
 801208a:	bf00      	nop
 801208c:	08019c80 	.word	0x08019c80

08012090 <xmp3_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 8012090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012094:	ed2d 8b02 	vpush	{d8}
 8012098:	b097      	sub	sp, #92	; 0x5c
 801209a:	9203      	str	r2, [sp, #12]
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 801209c:	9006      	str	r0, [sp, #24]
 801209e:	2800      	cmp	r0, #0
 80120a0:	f000 83f8 	beq.w	8012894 <xmp3_UnpackScaleFactors+0x804>
 80120a4:	6805      	ldr	r5, [r0, #0]
 80120a6:	ee08 1a10 	vmov	s16, r1
 80120aa:	4601      	mov	r1, r0
 80120ac:	2d00      	cmp	r5, #0
 80120ae:	f000 83f1 	beq.w	8012894 <xmp3_UnpackScaleFactors+0x804>
 80120b2:	6840      	ldr	r0, [r0, #4]
 80120b4:	9000      	str	r0, [sp, #0]
 80120b6:	2800      	cmp	r0, #0
 80120b8:	f000 83ec 	beq.w	8012894 <xmp3_UnpackScaleFactors+0x804>
 80120bc:	f8d1 a008 	ldr.w	sl, [r1, #8]
 80120c0:	f1ba 0f00 	cmp.w	sl, #0
 80120c4:	f000 83e6 	beq.w	8012894 <xmp3_UnpackScaleFactors+0x804>
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));

	/* init GetBits reader */
	startBuf = buf;
	bsi = &bitStreamInfo;
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 80120c8:	6812      	ldr	r2, [r2, #0]
 80120ca:	ac0e      	add	r4, sp, #56	; 0x38
 80120cc:	4413      	add	r3, r2
 80120ce:	4620      	mov	r0, r4
 80120d0:	ee18 2a10 	vmov	r2, s16
 80120d4:	1dd9      	adds	r1, r3, #7
 80120d6:	bf48      	it	mi
 80120d8:	f103 010e 	addmi.w	r1, r3, #14
 80120dc:	10c9      	asrs	r1, r1, #3
 80120de:	f7fa fd33 	bl	800cb48 <xmp3_SetBitstreamPointer>
	if (*bitOffset)
 80120e2:	9b03      	ldr	r3, [sp, #12]
 80120e4:	6819      	ldr	r1, [r3, #0]
 80120e6:	2900      	cmp	r1, #0
 80120e8:	f040 8180 	bne.w	80123ec <xmp3_UnpackScaleFactors+0x35c>
		GetBits(bsi, *bitOffset);

	if (fh->ver == MPEG1) 
 80120ec:	782b      	ldrb	r3, [r5, #0]
 80120ee:	2b00      	cmp	r3, #0
 80120f0:	f000 80d7 	beq.w	80122a2 <xmp3_UnpackScaleFactors+0x212>
	sfCompress = sis->sfCompress;
 80120f4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80120f6:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80120f8:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);
 80120fc:	6a2a      	ldr	r2, [r5, #32]
	sfCompress = sis->sfCompress;
 80120fe:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
 8012102:	011b      	lsls	r3, r3, #4
 8012104:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8012108:	9900      	ldr	r1, [sp, #0]
 801210a:	440b      	add	r3, r1
 801210c:	6b58      	ldr	r0, [r3, #52]	; 0x34
 801210e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012110:	00db      	lsls	r3, r3, #3
 8012112:	9302      	str	r3, [sp, #8]
 8012114:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012116:	00db      	lsls	r3, r3, #3
 8012118:	9301      	str	r3, [sp, #4]
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 801211a:	f012 0301 	ands.w	r3, r2, #1
 801211e:	9305      	str	r3, [sp, #20]
 8012120:	d006      	beq.n	8012130 <xmp3_UnpackScaleFactors+0xa0>
 8012122:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012124:	1e5a      	subs	r2, r3, #1
 8012126:	bf18      	it	ne
 8012128:	2201      	movne	r2, #1
 801212a:	2a00      	cmp	r2, #0
 801212c:	f000 831b 	beq.w	8012766 <xmp3_UnpackScaleFactors+0x6d6>
		if (sfCompress < 400) {
 8012130:	f5b0 7fc8 	cmp.w	r0, #400	; 0x190
 8012134:	f280 8162 	bge.w	80123fc <xmp3_UnpackScaleFactors+0x36c>
			slen[0] = (sfCompress >> 4) / 5;
 8012138:	1103      	asrs	r3, r0, #4
 801213a:	4aae      	ldr	r2, [pc, #696]	; (80123f4 <xmp3_UnpackScaleFactors+0x364>)
 801213c:	2103      	movs	r1, #3
	intensityScale = 0;
 801213e:	f04f 0e00 	mov.w	lr, #0
			slen[0] = (sfCompress >> 4) / 5;
 8012142:	fb82 2803 	smull	r2, r8, r2, r3
 8012146:	17c2      	asrs	r2, r0, #31
 8012148:	4689      	mov	r9, r1
 801214a:	2706      	movs	r7, #6
 801214c:	ebc2 0868 	rsb	r8, r2, r8, asr #1
 8012150:	468c      	mov	ip, r1
	preFlag = 0;
 8012152:	46f3      	mov	fp, lr
 8012154:	9109      	str	r1, [sp, #36]	; 0x24
			slen[1]= (sfCompress >> 4) % 5;
 8012156:	eb08 0288 	add.w	r2, r8, r8, lsl #2
			slen[0] = (sfCompress >> 4) / 5;
 801215a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1]= (sfCompress >> 4) % 5;
 801215e:	1a9b      	subs	r3, r3, r2
 8012160:	2205      	movs	r2, #5
 8012162:	930b      	str	r3, [sp, #44]	; 0x2c
			slen[2]= (sfCompress & 0x0f) >> 2;
 8012164:	f3c0 0381 	ubfx	r3, r0, #2, #2
			slen[3]= (sfCompress & 0x03);
 8012168:	4008      	ands	r0, r1
 801216a:	4616      	mov	r6, r2
			slen[2]= (sfCompress & 0x0f) >> 2;
 801216c:	930c      	str	r3, [sp, #48]	; 0x30
			slen[3]= (sfCompress & 0x03);
 801216e:	900d      	str	r0, [sp, #52]	; 0x34
			sfcIdx = 0;
 8012170:	4610      	mov	r0, r2
 8012172:	e9cd 1107 	strd	r1, r1, [sp, #28]
	if (sis->blockType == 2) 
 8012176:	9d22      	ldr	r5, [sp, #136]	; 0x88
 8012178:	9b01      	ldr	r3, [sp, #4]
 801217a:	442b      	add	r3, r5
 801217c:	9d02      	ldr	r5, [sp, #8]
 801217e:	011b      	lsls	r3, r3, #4
 8012180:	9304      	str	r3, [sp, #16]
 8012182:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012184:	441d      	add	r5, r3
 8012186:	9b04      	ldr	r3, [sp, #16]
 8012188:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 801218c:	9d00      	ldr	r5, [sp, #0]
 801218e:	442b      	add	r3, r5
 8012190:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 8012192:	2d02      	cmp	r5, #2
 8012194:	f000 829d 	beq.w	80126d2 <xmp3_UnpackScaleFactors+0x642>
	if( (modeExt & 0x01) && (ch == 1) ) {
 8012198:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 801219a:	2b01      	cmp	r3, #1
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 801219c:	e9cd 7612 	strd	r7, r6, [sp, #72]	; 0x48
 80121a0:	e9cd 0214 	strd	r0, r2, [sp, #80]	; 0x50
	if( (modeExt & 0x01) && (ch == 1) ) {
 80121a4:	d103      	bne.n	80121ae <xmp3_UnpackScaleFactors+0x11e>
 80121a6:	9b05      	ldr	r3, [sp, #20]
 80121a8:	2b00      	cmp	r3, #0
 80121aa:	f040 8306 	bne.w	80127ba <xmp3_UnpackScaleFactors+0x72a>
 80121ae:	ae0a      	add	r6, sp, #40	; 0x28
 80121b0:	af12      	add	r7, sp, #72	; 0x48
	sis->preFlag = preFlag;
 80121b2:	9a22      	ldr	r2, [sp, #136]	; 0x88
	if(sis->blockType == 2) {
 80121b4:	2d02      	cmp	r5, #2
	sis->preFlag = preFlag;
 80121b6:	9b01      	ldr	r3, [sp, #4]
 80121b8:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80121ba:	4413      	add	r3, r2
 80121bc:	9a02      	ldr	r2, [sp, #8]
 80121be:	ea4f 1303 	mov.w	r3, r3, lsl #4
 80121c2:	440a      	add	r2, r1
 80121c4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80121c8:	9a00      	ldr	r2, [sp, #0]
 80121ca:	4413      	add	r3, r2
 80121cc:	f8c3 b064 	str.w	fp, [r3, #100]	; 0x64
	if(sis->blockType == 2) {
 80121d0:	f000 821f 	beq.w	8012612 <xmp3_UnpackScaleFactors+0x582>
 80121d4:	9b22      	ldr	r3, [sp, #136]	; 0x88
		sfb = 0;
 80121d6:	f04f 0800 	mov.w	r8, #0
 80121da:	46b9      	mov	r9, r7
 80121dc:	f8cd a01c 	str.w	sl, [sp, #28]
 80121e0:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80121e4:	009a      	lsls	r2, r3, #2
 80121e6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80121e8:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80121ec:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80121f0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80121f2:	0152      	lsls	r2, r2, #5
 80121f4:	9308      	str	r3, [sp, #32]
 80121f6:	4453      	add	r3, sl
 80121f8:	9204      	str	r2, [sp, #16]
 80121fa:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80121fc:	9309      	str	r3, [sp, #36]	; 0x24
 80121fe:	0152      	lsls	r2, r2, #5
 8012200:	9205      	str	r2, [sp, #20]
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 8012202:	f859 7b04 	ldr.w	r7, [r9], #4
			iipTest = (1 << slen[nrIdx]) - 1;
 8012206:	f856 ab04 	ldr.w	sl, [r6], #4
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 801220a:	2f00      	cmp	r7, #0
 801220c:	dd11      	ble.n	8012232 <xmp3_UnpackScaleFactors+0x1a2>
 801220e:	9b08      	ldr	r3, [sp, #32]
 8012210:	9a07      	ldr	r2, [sp, #28]
 8012212:	4443      	add	r3, r8
 8012214:	eb02 0b03 	add.w	fp, r2, r3
 8012218:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801221a:	eb08 0503 	add.w	r5, r8, r3
 801221e:	443d      	add	r5, r7
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 8012220:	4651      	mov	r1, sl
 8012222:	4620      	mov	r0, r4
 8012224:	f7fa fc96 	bl	800cb54 <xmp3_GetBits>
 8012228:	f80b 0b01 	strb.w	r0, [fp], #1
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 801222c:	45ab      	cmp	fp, r5
 801222e:	d1f7      	bne.n	8012220 <xmp3_UnpackScaleFactors+0x190>
 8012230:	44b8      	add	r8, r7
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 8012232:	42a6      	cmp	r6, r4
 8012234:	d1e5      	bne.n	8012202 <xmp3_UnpackScaleFactors+0x172>
		sfis->l[21] = sfis->l[22] = 0;
 8012236:	f8dd a01c 	ldr.w	sl, [sp, #28]
 801223a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801223c:	9b05      	ldr	r3, [sp, #20]
 801223e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012240:	1a9b      	subs	r3, r3, r2
 8012242:	9a04      	ldr	r2, [sp, #16]
 8012244:	009b      	lsls	r3, r3, #2
 8012246:	1a52      	subs	r2, r2, r1
 8012248:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 801224c:	2200      	movs	r2, #0
 801224e:	3315      	adds	r3, #21
 8012250:	f82a 2003 	strh.w	r2, [sl, r3]

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 8012254:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012256:	9a01      	ldr	r2, [sp, #4]
 8012258:	9802      	ldr	r0, [sp, #8]
 801225a:	441a      	add	r2, r3
 801225c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 801225e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8012260:	4418      	add	r0, r3
 8012262:	0112      	lsls	r2, r2, #4
 8012264:	eb03 0341 	add.w	r3, r3, r1, lsl #1

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8012268:	ee18 1a10 	vmov	r1, s16
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 801226c:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 8012270:	9800      	ldr	r0, [sp, #0]
 8012272:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8012276:	4410      	add	r0, r2
 8012278:	4602      	mov	r2, r0
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 801227a:	4620      	mov	r0, r4
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 801227c:	9c06      	ldr	r4, [sp, #24]
 801227e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8012280:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 8012284:	9c03      	ldr	r4, [sp, #12]
 8012286:	6822      	ldr	r2, [r4, #0]
 8012288:	f7fa fccc 	bl	800cc24 <xmp3_CalcBitsUsed>
	buf += (bitsUsed + *bitOffset) >> 3;
 801228c:	6823      	ldr	r3, [r4, #0]
 801228e:	4418      	add	r0, r3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8012290:	f000 0307 	and.w	r3, r0, #7
	buf += (bitsUsed + *bitOffset) >> 3;
 8012294:	10c0      	asrs	r0, r0, #3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 8012296:	6023      	str	r3, [r4, #0]

	return (buf - startBuf);
}
 8012298:	b017      	add	sp, #92	; 0x5c
 801229a:	ecbd 8b02 	vpop	{d8}
 801229e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 80122a2:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80122a4:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80122a6:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 80122aa:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80122ac:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 80122b0:	00c9      	lsls	r1, r1, #3
 80122b2:	011b      	lsls	r3, r3, #4
 80122b4:	9102      	str	r1, [sp, #8]
 80122b6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80122ba:	9922      	ldr	r1, [sp, #136]	; 0x88
 80122bc:	9a00      	ldr	r2, [sp, #0]
 80122be:	00c9      	lsls	r1, r1, #3
 80122c0:	4413      	add	r3, r2
 80122c2:	4a4d      	ldr	r2, [pc, #308]	; (80123f8 <xmp3_UnpackScaleFactors+0x368>)
 80122c4:	9101      	str	r1, [sp, #4]
 80122c6:	6b58      	ldr	r0, [r3, #52]	; 0x34
	if (sis->blockType == 2) {
 80122c8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 80122ca:	eb02 0540 	add.w	r5, r2, r0, lsl #1
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 80122ce:	f812 9010 	ldrb.w	r9, [r2, r0, lsl #1]
	if (sis->blockType == 2) {
 80122d2:	2902      	cmp	r1, #2
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 80122d4:	786e      	ldrb	r6, [r5, #1]
	if (sis->blockType == 2) {
 80122d6:	f000 8143 	beq.w	8012560 <xmp3_UnpackScaleFactors+0x4d0>
		if(gr == 0) {
 80122da:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80122dc:	2b00      	cmp	r3, #0
 80122de:	f000 8200 	beq.w	80126e2 <xmp3_UnpackScaleFactors+0x652>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 80122e2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80122e4:	9a00      	ldr	r2, [sp, #0]
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 80122e6:	011f      	lsls	r7, r3, #4
 80122e8:	3708      	adds	r7, #8
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80122ea:	59d3      	ldr	r3, [r2, r7]
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 80122ec:	4417      	add	r7, r2
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80122ee:	2b00      	cmp	r3, #0
 80122f0:	f000 80be 	beq.w	8012470 <xmp3_UnpackScaleFactors+0x3e0>
 80122f4:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80122f6:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
 80122fa:	015b      	lsls	r3, r3, #5
 80122fc:	0092      	lsls	r2, r2, #2
 80122fe:	9305      	str	r3, [sp, #20]
 8012300:	1e53      	subs	r3, r2, #1
 8012302:	2b02      	cmp	r3, #2
 8012304:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8012306:	f240 82d6 	bls.w	80128b6 <xmp3_UnpackScaleFactors+0x826>
 801230a:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 801230e:	eb0a 0102 	add.w	r1, sl, r2
 8012312:	f85a 0013 	ldr.w	r0, [sl, r3, lsl #1]
 8012316:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801231a:	f841 0013 	str.w	r0, [r1, r3, lsl #1]
 801231e:	eb0a 0343 	add.w	r3, sl, r3, lsl #1
 8012322:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012324:	4452      	add	r2, sl
 8012326:	0149      	lsls	r1, r1, #5
 8012328:	9104      	str	r1, [sp, #16]
 801232a:	7919      	ldrb	r1, [r3, #4]
 801232c:	7111      	strb	r1, [r2, #4]
 801232e:	795b      	ldrb	r3, [r3, #5]
 8012330:	7153      	strb	r3, [r2, #5]
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	2b00      	cmp	r3, #0
 8012336:	f000 80bb 	beq.w	80124b0 <xmp3_UnpackScaleFactors+0x420>
 801233a:	9b04      	ldr	r3, [sp, #16]
 801233c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801233e:	9922      	ldr	r1, [sp, #136]	; 0x88
 8012340:	1a9a      	subs	r2, r3, r2
 8012342:	9b05      	ldr	r3, [sp, #20]
 8012344:	0052      	lsls	r2, r2, #1
 8012346:	1a5b      	subs	r3, r3, r1
 8012348:	1e51      	subs	r1, r2, #1
 801234a:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801234e:	009b      	lsls	r3, r3, #2
 8012350:	1a89      	subs	r1, r1, r2
 8012352:	2902      	cmp	r1, #2
 8012354:	f240 82a1 	bls.w	801289a <xmp3_UnpackScaleFactors+0x80a>
 8012358:	1d91      	adds	r1, r2, #6
 801235a:	eb0a 0003 	add.w	r0, sl, r3
 801235e:	4413      	add	r3, r2
 8012360:	4452      	add	r2, sl
 8012362:	f85a 5001 	ldr.w	r5, [sl, r1]
 8012366:	4453      	add	r3, sl
 8012368:	5045      	str	r5, [r0, r1]
 801236a:	7a92      	ldrb	r2, [r2, #10]
 801236c:	729a      	strb	r2, [r3, #10]
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801236e:	68bb      	ldr	r3, [r7, #8]
 8012370:	2b00      	cmp	r3, #0
 8012372:	f000 80b9 	beq.w	80124e8 <xmp3_UnpackScaleFactors+0x458>
 8012376:	9b04      	ldr	r3, [sp, #16]
 8012378:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801237a:	9922      	ldr	r1, [sp, #136]	; 0x88
 801237c:	1a9a      	subs	r2, r3, r2
 801237e:	9b05      	ldr	r3, [sp, #20]
 8012380:	0052      	lsls	r2, r2, #1
 8012382:	1a59      	subs	r1, r3, r1
 8012384:	1e53      	subs	r3, r2, #1
 8012386:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 801238a:	0089      	lsls	r1, r1, #2
 801238c:	1a9b      	subs	r3, r3, r2
 801238e:	2b02      	cmp	r3, #2
 8012390:	f240 82d7 	bls.w	8012942 <xmp3_UnpackScaleFactors+0x8b2>
 8012394:	f102 030b 	add.w	r3, r2, #11
 8012398:	eb0a 0002 	add.w	r0, sl, r2
 801239c:	440a      	add	r2, r1
 801239e:	f85a 5003 	ldr.w	r5, [sl, r3]
 80123a2:	4453      	add	r3, sl
 80123a4:	4452      	add	r2, sl
 80123a6:	505d      	str	r5, [r3, r1]
 80123a8:	7bc3      	ldrb	r3, [r0, #15]
 80123aa:	73d3      	strb	r3, [r2, #15]
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80123ac:	68fb      	ldr	r3, [r7, #12]
 80123ae:	2b00      	cmp	r3, #0
 80123b0:	f000 81bc 	beq.w	801272c <xmp3_UnpackScaleFactors+0x69c>
 80123b4:	9b04      	ldr	r3, [sp, #16]
 80123b6:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80123b8:	9922      	ldr	r1, [sp, #136]	; 0x88
 80123ba:	1a9a      	subs	r2, r3, r2
 80123bc:	9b05      	ldr	r3, [sp, #20]
 80123be:	0052      	lsls	r2, r2, #1
 80123c0:	1a5b      	subs	r3, r3, r1
 80123c2:	1e51      	subs	r1, r2, #1
 80123c4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80123c8:	009b      	lsls	r3, r3, #2
 80123ca:	1a89      	subs	r1, r1, r2
 80123cc:	2902      	cmp	r1, #2
 80123ce:	f240 82aa 	bls.w	8012926 <xmp3_UnpackScaleFactors+0x896>
 80123d2:	f102 0110 	add.w	r1, r2, #16
 80123d6:	eb0a 0003 	add.w	r0, sl, r3
 80123da:	4413      	add	r3, r2
 80123dc:	4452      	add	r2, sl
 80123de:	f85a 5001 	ldr.w	r5, [sl, r1]
 80123e2:	4453      	add	r3, sl
 80123e4:	5045      	str	r5, [r0, r1]
 80123e6:	7d12      	ldrb	r2, [r2, #20]
 80123e8:	751a      	strb	r2, [r3, #20]
 80123ea:	e726      	b.n	801223a <xmp3_UnpackScaleFactors+0x1aa>
		GetBits(bsi, *bitOffset);
 80123ec:	4620      	mov	r0, r4
 80123ee:	f7fa fbb1 	bl	800cb54 <xmp3_GetBits>
 80123f2:	e67b      	b.n	80120ec <xmp3_UnpackScaleFactors+0x5c>
 80123f4:	66666667 	.word	0x66666667
 80123f8:	08019ad8 	.word	0x08019ad8
		} else if (sfCompress < 500) {
 80123fc:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 8012400:	f2c0 808b 	blt.w	801251a <xmp3_UnpackScaleFactors+0x48a>
			sfCompress -= 500;
 8012404:	f5a0 70fa 	sub.w	r0, r0, #500	; 0x1f4
			slen[0] = sfCompress / 3;
 8012408:	4bc6      	ldr	r3, [pc, #792]	; (8012724 <xmp3_UnpackScaleFactors+0x694>)
			if (sis->mixedBlock) {
 801240a:	9a22      	ldr	r2, [sp, #136]	; 0x88
			slen[0] = sfCompress / 3;
 801240c:	fba3 3800 	umull	r3, r8, r3, r0
			if (sis->mixedBlock) {
 8012410:	9b01      	ldr	r3, [sp, #4]
 8012412:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8012414:	4413      	add	r3, r2
 8012416:	9a02      	ldr	r2, [sp, #8]
			slen[0] = sfCompress / 3;
 8012418:	ea4f 0858 	mov.w	r8, r8, lsr #1
			if (sis->mixedBlock) {
 801241c:	440a      	add	r2, r1
 801241e:	011b      	lsls	r3, r3, #4
			slen[0] = sfCompress / 3;
 8012420:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			if (sis->mixedBlock) {
 8012424:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8012428:	9a00      	ldr	r2, [sp, #0]
 801242a:	4413      	add	r3, r2
			slen[2] = slen[3] = 0;
 801242c:	2200      	movs	r2, #0
			if (sis->mixedBlock) {
 801242e:	f8d3 c040 	ldr.w	ip, [r3, #64]	; 0x40
			slen[1] = sfCompress % 3;
 8012432:	eb08 0348 	add.w	r3, r8, r8, lsl #1
 8012436:	1ac0      	subs	r0, r0, r3
			slen[2] = slen[3] = 0;
 8012438:	2300      	movs	r3, #0
			slen[1] = sfCompress % 3;
 801243a:	900b      	str	r0, [sp, #44]	; 0x2c
			slen[2] = slen[3] = 0;
 801243c:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
			if (sis->mixedBlock) {
 8012440:	f1bc 0f00 	cmp.w	ip, #0
 8012444:	f000 81f1 	beq.w	801282a <xmp3_UnpackScaleFactors+0x79a>
				slen[1] = slen[0];
 8012448:	2100      	movs	r1, #0
 801244a:	f04f 0906 	mov.w	r9, #6
 801244e:	2303      	movs	r3, #3
 8012450:	260a      	movs	r6, #10
 8012452:	270b      	movs	r7, #11
 8012454:	460a      	mov	r2, r1
 8012456:	468c      	mov	ip, r1
	intensityScale = 0;
 8012458:	468e      	mov	lr, r1
			preFlag = 1;
 801245a:	f04f 0b01 	mov.w	fp, #1
				slen[1] = slen[0];
 801245e:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8012462:	f8cd 9020 	str.w	r9, [sp, #32]
 8012466:	9307      	str	r3, [sp, #28]
 8012468:	e9cd 800b 	strd	r8, r0, [sp, #44]	; 0x2c
 801246c:	4608      	mov	r0, r1
 801246e:	e682      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
 8012470:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8012472:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 8012474:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8012478:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
 801247c:	009b      	lsls	r3, r3, #2
 801247e:	0152      	lsls	r2, r2, #5
 8012480:	eb03 0845 	add.w	r8, r3, r5, lsl #1
 8012484:	9204      	str	r2, [sp, #16]
 8012486:	4645      	mov	r5, r8
 8012488:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801248a:	f108 38ff 	add.w	r8, r8, #4294967295
 801248e:	3505      	adds	r5, #5
 8012490:	0152      	lsls	r2, r2, #5
 8012492:	44d0      	add	r8, sl
 8012494:	4455      	add	r5, sl
 8012496:	9205      	str	r2, [sp, #20]
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 8012498:	4649      	mov	r1, r9
 801249a:	4620      	mov	r0, r4
 801249c:	f7fa fb5a 	bl	800cb54 <xmp3_GetBits>
 80124a0:	f808 0f01 	strb.w	r0, [r8, #1]!
 80124a4:	45a8      	cmp	r8, r5
 80124a6:	d1f7      	bne.n	8012498 <xmp3_UnpackScaleFactors+0x408>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80124a8:	687b      	ldr	r3, [r7, #4]
 80124aa:	2b00      	cmp	r3, #0
 80124ac:	f47f af45 	bne.w	801233a <xmp3_UnpackScaleFactors+0x2aa>
 80124b0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80124b2:	9b04      	ldr	r3, [sp, #16]
 80124b4:	9922      	ldr	r1, [sp, #136]	; 0x88
 80124b6:	1a9b      	subs	r3, r3, r2
 80124b8:	9a05      	ldr	r2, [sp, #20]
 80124ba:	005b      	lsls	r3, r3, #1
 80124bc:	1a55      	subs	r5, r2, r1
 80124be:	f103 0806 	add.w	r8, r3, #6
 80124c2:	330b      	adds	r3, #11
 80124c4:	eb08 0885 	add.w	r8, r8, r5, lsl #2
 80124c8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80124cc:	44d0      	add	r8, sl
 80124ce:	4455      	add	r5, sl
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80124d0:	4649      	mov	r1, r9
 80124d2:	4620      	mov	r0, r4
 80124d4:	f7fa fb3e 	bl	800cb54 <xmp3_GetBits>
 80124d8:	f808 0b01 	strb.w	r0, [r8], #1
 80124dc:	45a8      	cmp	r8, r5
 80124de:	d1f7      	bne.n	80124d0 <xmp3_UnpackScaleFactors+0x440>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80124e0:	68bb      	ldr	r3, [r7, #8]
 80124e2:	2b00      	cmp	r3, #0
 80124e4:	f47f af47 	bne.w	8012376 <xmp3_UnpackScaleFactors+0x2e6>
 80124e8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80124ea:	9b04      	ldr	r3, [sp, #16]
 80124ec:	9922      	ldr	r1, [sp, #136]	; 0x88
 80124ee:	1a9b      	subs	r3, r3, r2
 80124f0:	9a05      	ldr	r2, [sp, #20]
 80124f2:	005b      	lsls	r3, r3, #1
 80124f4:	1a55      	subs	r5, r2, r1
 80124f6:	f103 080b 	add.w	r8, r3, #11
 80124fa:	3310      	adds	r3, #16
 80124fc:	eb08 0885 	add.w	r8, r8, r5, lsl #2
 8012500:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8012504:	44d0      	add	r8, sl
 8012506:	4455      	add	r5, sl
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8012508:	4631      	mov	r1, r6
 801250a:	4620      	mov	r0, r4
 801250c:	f7fa fb22 	bl	800cb54 <xmp3_GetBits>
 8012510:	f808 0b01 	strb.w	r0, [r8], #1
 8012514:	45a8      	cmp	r8, r5
 8012516:	d1f7      	bne.n	8012508 <xmp3_UnpackScaleFactors+0x478>
 8012518:	e748      	b.n	80123ac <xmp3_UnpackScaleFactors+0x31c>
			slen[3]= 0;
 801251a:	2300      	movs	r3, #0
			sfCompress -= 400;
 801251c:	f5a0 70c8 	sub.w	r0, r0, #400	; 0x190
			slen[0] = (sfCompress >> 2) / 5;
 8012520:	4a81      	ldr	r2, [pc, #516]	; (8012728 <xmp3_UnpackScaleFactors+0x698>)
 8012522:	f04f 0903 	mov.w	r9, #3
	intensityScale = 0;
 8012526:	469e      	mov	lr, r3
			slen[3]= 0;
 8012528:	930d      	str	r3, [sp, #52]	; 0x34
			slen[0] = (sfCompress >> 2) / 5;
 801252a:	1083      	asrs	r3, r0, #2
 801252c:	2104      	movs	r1, #4
			slen[2]= (sfCompress & 0x03);
 801252e:	f000 0003 	and.w	r0, r0, #3
 8012532:	2605      	movs	r6, #5
			slen[0] = (sfCompress >> 2) / 5;
 8012534:	fba2 2803 	umull	r2, r8, r2, r3
 8012538:	2706      	movs	r7, #6
			slen[2]= (sfCompress & 0x03);
 801253a:	900c      	str	r0, [sp, #48]	; 0x30
 801253c:	f04f 0c02 	mov.w	ip, #2
			slen[0] = (sfCompress >> 2) / 5;
 8012540:	ea4f 0898 	mov.w	r8, r8, lsr #2
 8012544:	2007      	movs	r0, #7
	preFlag = 0;
 8012546:	46f3      	mov	fp, lr
 8012548:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
			slen[1]= (sfCompress >> 2) % 5;
 801254c:	eb08 0288 	add.w	r2, r8, r8, lsl #2
			slen[0] = (sfCompress >> 2) / 5;
 8012550:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1]= (sfCompress >> 2) % 5;
 8012554:	1a9b      	subs	r3, r3, r2
 8012556:	464a      	mov	r2, r9
 8012558:	930b      	str	r3, [sp, #44]	; 0x2c
			sfcIdx = 1;
 801255a:	e9cd 9107 	strd	r9, r1, [sp, #28]
 801255e:	e60a      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
		if (sis->mixedBlock) {          
 8012560:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012562:	2b00      	cmp	r3, #0
 8012564:	f040 8144 	bne.w	80127f0 <xmp3_UnpackScaleFactors+0x760>
 8012568:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801256a:	0152      	lsls	r2, r2, #5
 801256c:	9204      	str	r2, [sp, #16]
 801256e:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012570:	0152      	lsls	r2, r2, #5
 8012572:	9205      	str	r2, [sp, #20]
 8012574:	eb03 0843 	add.w	r8, r3, r3, lsl #1
 8012578:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801257a:	9b05      	ldr	r3, [sp, #20]
 801257c:	9923      	ldr	r1, [sp, #140]	; 0x8c
 801257e:	1a9b      	subs	r3, r3, r2
 8012580:	9a04      	ldr	r2, [sp, #16]
 8012582:	009b      	lsls	r3, r3, #2
 8012584:	1a57      	subs	r7, r2, r1
 8012586:	eb03 0547 	add.w	r5, r3, r7, lsl #1
 801258a:	462f      	mov	r7, r5
 801258c:	44a8      	add	r8, r5
 801258e:	3712      	adds	r7, #18
 8012590:	44d0      	add	r8, sl
 8012592:	4457      	add	r7, sl
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 8012594:	4649      	mov	r1, r9
 8012596:	4620      	mov	r0, r4
 8012598:	f7fa fadc 	bl	800cb54 <xmp3_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801259c:	4649      	mov	r1, r9
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 801259e:	f888 0017 	strb.w	r0, [r8, #23]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 80125a2:	4620      	mov	r0, r4
 80125a4:	f7fa fad6 	bl	800cb54 <xmp3_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 80125a8:	4649      	mov	r1, r9
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 80125aa:	f888 0018 	strb.w	r0, [r8, #24]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 80125ae:	4620      	mov	r0, r4
 80125b0:	f7fa fad0 	bl	800cb54 <xmp3_GetBits>
		for (      ; sfb < 6; sfb++) {
 80125b4:	f108 0803 	add.w	r8, r8, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 80125b8:	f888 0016 	strb.w	r0, [r8, #22]
		for (      ; sfb < 6; sfb++) {
 80125bc:	4547      	cmp	r7, r8
 80125be:	d1e9      	bne.n	8012594 <xmp3_UnpackScaleFactors+0x504>
 80125c0:	4455      	add	r5, sl
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 80125c2:	4631      	mov	r1, r6
 80125c4:	4620      	mov	r0, r4
 80125c6:	f7fa fac5 	bl	800cb54 <xmp3_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80125ca:	4631      	mov	r1, r6
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 80125cc:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80125d0:	4620      	mov	r0, r4
 80125d2:	f7fa fabf 	bl	800cb54 <xmp3_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80125d6:	4631      	mov	r1, r6
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 80125d8:	f885 002a 	strb.w	r0, [r5, #42]	; 0x2a
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80125dc:	4620      	mov	r0, r4
 80125de:	f7fa fab9 	bl	800cb54 <xmp3_GetBits>
		for (      ; sfb < 12; sfb++) {
 80125e2:	3503      	adds	r5, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 80125e4:	f885 0028 	strb.w	r0, [r5, #40]	; 0x28
		for (      ; sfb < 12; sfb++) {
 80125e8:	42bd      	cmp	r5, r7
 80125ea:	d1ea      	bne.n	80125c2 <xmp3_UnpackScaleFactors+0x532>
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 80125ec:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80125ee:	9b05      	ldr	r3, [sp, #20]
 80125f0:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80125f2:	1a9b      	subs	r3, r3, r2
 80125f4:	9a04      	ldr	r2, [sp, #16]
 80125f6:	009b      	lsls	r3, r3, #2
 80125f8:	1a52      	subs	r2, r2, r1
 80125fa:	2100      	movs	r1, #0
 80125fc:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 8012600:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8012604:	4453      	add	r3, sl
 8012606:	4452      	add	r2, sl
 8012608:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
 801260c:	f8a2 1007 	strh.w	r1, [r2, #7]
 8012610:	e620      	b.n	8012254 <xmp3_UnpackScaleFactors+0x1c4>
		if(sis->mixedBlock) {
 8012612:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012614:	2b00      	cmp	r3, #0
 8012616:	f000 80c9 	beq.w	80127ac <xmp3_UnpackScaleFactors+0x71c>
 801261a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801261c:	ebc1 1541 	rsb	r5, r1, r1, lsl #5
 8012620:	014a      	lsls	r2, r1, #5
 8012622:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8012626:	9204      	str	r2, [sp, #16]
 8012628:	009b      	lsls	r3, r3, #2
 801262a:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801262c:	eb03 0945 	add.w	r9, r3, r5, lsl #1
 8012630:	0152      	lsls	r2, r2, #5
 8012632:	464d      	mov	r5, r9
 8012634:	f109 39ff 	add.w	r9, r9, #4294967295
 8012638:	9205      	str	r2, [sp, #20]
 801263a:	3505      	adds	r5, #5
 801263c:	44d1      	add	r9, sl
 801263e:	4455      	add	r5, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 8012640:	4641      	mov	r1, r8
 8012642:	4620      	mov	r0, r4
 8012644:	f7fa fa86 	bl	800cb54 <xmp3_GetBits>
 8012648:	f809 0f01 	strb.w	r0, [r9, #1]!
			for (sfb=0; sfb < 6; sfb++) {
 801264c:	45a9      	cmp	r9, r5
 801264e:	d1f7      	bne.n	8012640 <xmp3_UnpackScaleFactors+0x5b0>
			sfb = 3;  /* start sfb for short */
 8012650:	f04f 0b03 	mov.w	fp, #3
			nrIdx = 1;
 8012654:	2301      	movs	r3, #1
 8012656:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8012658:	eb06 0883 	add.w	r8, r6, r3, lsl #2
 801265c:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8012660:	9b05      	ldr	r3, [sp, #20]
 8012662:	eba3 0902 	sub.w	r9, r3, r2
 8012666:	9b04      	ldr	r3, [sp, #16]
 8012668:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801266a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 801266e:	1a9b      	subs	r3, r3, r2
 8012670:	eb09 0343 	add.w	r3, r9, r3, lsl #1
 8012674:	9307      	str	r3, [sp, #28]
 8012676:	4453      	add	r3, sl
 8012678:	9308      	str	r3, [sp, #32]
 801267a:	465b      	mov	r3, fp
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 801267c:	f857 6b04 	ldr.w	r6, [r7], #4
			iipTest = (1 << slen[nrIdx]) - 1;
 8012680:	f858 bb04 	ldr.w	fp, [r8], #4
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 8012684:	2e00      	cmp	r6, #0
 8012686:	dd21      	ble.n	80126cc <xmp3_UnpackScaleFactors+0x63c>
 8012688:	441e      	add	r6, r3
 801268a:	9a07      	ldr	r2, [sp, #28]
 801268c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8012690:	eb06 0546 	add.w	r5, r6, r6, lsl #1
 8012694:	4413      	add	r3, r2
 8012696:	eb0a 0903 	add.w	r9, sl, r3
 801269a:	9b08      	ldr	r3, [sp, #32]
 801269c:	441d      	add	r5, r3
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 801269e:	4659      	mov	r1, fp
 80126a0:	4620      	mov	r0, r4
 80126a2:	f7fa fa57 	bl	800cb54 <xmp3_GetBits>
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 80126a6:	4659      	mov	r1, fp
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 80126a8:	f889 0017 	strb.w	r0, [r9, #23]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 80126ac:	4620      	mov	r0, r4
 80126ae:	f7fa fa51 	bl	800cb54 <xmp3_GetBits>
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80126b2:	4659      	mov	r1, fp
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 80126b4:	f889 0018 	strb.w	r0, [r9, #24]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80126b8:	4620      	mov	r0, r4
 80126ba:	f7fa fa4b 	bl	800cb54 <xmp3_GetBits>
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 80126be:	f109 0903 	add.w	r9, r9, #3
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 80126c2:	f889 0016 	strb.w	r0, [r9, #22]
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 80126c6:	45a9      	cmp	r9, r5
 80126c8:	d1e9      	bne.n	801269e <xmp3_UnpackScaleFactors+0x60e>
 80126ca:	4633      	mov	r3, r6
		for (    ; nrIdx <= 3; nrIdx++) {
 80126cc:	45a0      	cmp	r8, r4
 80126ce:	d1d5      	bne.n	801267c <xmp3_UnpackScaleFactors+0x5ec>
 80126d0:	e78c      	b.n	80125ec <xmp3_UnpackScaleFactors+0x55c>
		btIdx = (sis->mixedBlock ? 2 : 1);
 80126d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80126d4:	4662      	mov	r2, ip
 80126d6:	2b00      	cmp	r3, #0
 80126d8:	d141      	bne.n	801275e <xmp3_UnpackScaleFactors+0x6ce>
 80126da:	4608      	mov	r0, r1
 80126dc:	464e      	mov	r6, r9
 80126de:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80126e0:	e55a      	b.n	8012198 <xmp3_UnpackScaleFactors+0x108>
 80126e2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80126e4:	ebc3 1543 	rsb	r5, r3, r3, lsl #5
 80126e8:	006d      	lsls	r5, r5, #1
 80126ea:	f105 38ff 	add.w	r8, r5, #4294967295
 80126ee:	f105 070a 	add.w	r7, r5, #10
 80126f2:	44d0      	add	r8, sl
 80126f4:	4457      	add	r7, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 80126f6:	4649      	mov	r1, r9
 80126f8:	4620      	mov	r0, r4
 80126fa:	f7fa fa2b 	bl	800cb54 <xmp3_GetBits>
 80126fe:	f808 0f01 	strb.w	r0, [r8, #1]!
			for (sfb = 0;  sfb < 11; sfb++) 
 8012702:	45b8      	cmp	r8, r7
 8012704:	d1f7      	bne.n	80126f6 <xmp3_UnpackScaleFactors+0x666>
 8012706:	f105 070b 	add.w	r7, r5, #11
 801270a:	3515      	adds	r5, #21
 801270c:	4457      	add	r7, sl
 801270e:	4455      	add	r5, sl
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 8012710:	4631      	mov	r1, r6
 8012712:	4620      	mov	r0, r4
 8012714:	f7fa fa1e 	bl	800cb54 <xmp3_GetBits>
 8012718:	f807 0b01 	strb.w	r0, [r7], #1
			for (sfb = 11; sfb < 21; sfb++) 
 801271c:	42bd      	cmp	r5, r7
 801271e:	d1f7      	bne.n	8012710 <xmp3_UnpackScaleFactors+0x680>
 8012720:	e598      	b.n	8012254 <xmp3_UnpackScaleFactors+0x1c4>
 8012722:	bf00      	nop
 8012724:	aaaaaaab 	.word	0xaaaaaaab
 8012728:	cccccccd 	.word	0xcccccccd
 801272c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801272e:	9b04      	ldr	r3, [sp, #16]
 8012730:	9922      	ldr	r1, [sp, #136]	; 0x88
 8012732:	1a9b      	subs	r3, r3, r2
 8012734:	9a05      	ldr	r2, [sp, #20]
 8012736:	005b      	lsls	r3, r3, #1
 8012738:	1a55      	subs	r5, r2, r1
 801273a:	f103 0710 	add.w	r7, r3, #16
 801273e:	3315      	adds	r3, #21
 8012740:	eb07 0785 	add.w	r7, r7, r5, lsl #2
 8012744:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8012748:	4457      	add	r7, sl
 801274a:	4455      	add	r5, sl
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 801274c:	4631      	mov	r1, r6
 801274e:	4620      	mov	r0, r4
 8012750:	f7fa fa00 	bl	800cb54 <xmp3_GetBits>
 8012754:	f807 0b01 	strb.w	r0, [r7], #1
 8012758:	42bd      	cmp	r5, r7
 801275a:	d1f7      	bne.n	801274c <xmp3_UnpackScaleFactors+0x6bc>
 801275c:	e56d      	b.n	801223a <xmp3_UnpackScaleFactors+0x1aa>
 801275e:	e9dd 6007 	ldrd	r6, r0, [sp, #28]
 8012762:	2706      	movs	r7, #6
 8012764:	e518      	b.n	8012198 <xmp3_UnpackScaleFactors+0x108>
		if (sfCompress < 180) {
 8012766:	f5b0 7fb4 	cmp.w	r0, #360	; 0x168
		intensityScale = sfCompress & 0x01;
 801276a:	f000 0e01 	and.w	lr, r0, #1
		sfCompress >>= 1;
 801276e:	ea4f 0360 	mov.w	r3, r0, asr #1
		if (sfCompress < 180) {
 8012772:	db6b      	blt.n	801284c <xmp3_UnpackScaleFactors+0x7bc>
		} else if (sfCompress < 244) {
 8012774:	2bf3      	cmp	r3, #243	; 0xf3
 8012776:	f300 80b7 	bgt.w	80128e8 <xmp3_UnpackScaleFactors+0x858>
			sfCompress -= 180;
 801277a:	2103      	movs	r1, #3
 801277c:	3bb4      	subs	r3, #180	; 0xb4
	preFlag = 0;
 801277e:	4693      	mov	fp, r2
			slen[3] = 0;
 8012780:	920d      	str	r2, [sp, #52]	; 0x34
			slen[0] = (sfCompress & 0x3f) >> 4;
 8012782:	ea4f 1823 	mov.w	r8, r3, asr #4
			slen[1] = (sfCompress & 0x0f) >> 2;
 8012786:	f3c3 0281 	ubfx	r2, r3, #2, #2
			slen[2] = (sfCompress & 0x03);
 801278a:	400b      	ands	r3, r1
 801278c:	2006      	movs	r0, #6
			slen[1] = (sfCompress & 0x0f) >> 2;
 801278e:	920b      	str	r2, [sp, #44]	; 0x2c
 8012790:	4689      	mov	r9, r1
			slen[2] = (sfCompress & 0x03);
 8012792:	930c      	str	r3, [sp, #48]	; 0x30
 8012794:	2304      	movs	r3, #4
 8012796:	460a      	mov	r2, r1
 8012798:	4606      	mov	r6, r0
 801279a:	4607      	mov	r7, r0
 801279c:	f04f 0c02 	mov.w	ip, #2
			slen[0] = (sfCompress & 0x3f) >> 4;
 80127a0:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			sfcIdx = 4;
 80127a4:	9309      	str	r3, [sp, #36]	; 0x24
 80127a6:	e9cd 3107 	strd	r3, r1, [sp, #28]
 80127aa:	e4e4      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
 80127ac:	014a      	lsls	r2, r1, #5
			sfb = 0;
 80127ae:	469b      	mov	fp, r3
 80127b0:	9204      	str	r2, [sp, #16]
 80127b2:	9a22      	ldr	r2, [sp, #136]	; 0x88
 80127b4:	0152      	lsls	r2, r2, #5
 80127b6:	9205      	str	r2, [sp, #20]
 80127b8:	e74d      	b.n	8012656 <xmp3_UnpackScaleFactors+0x5c6>
			sfjs->slen[i] = slen[i];
 80127ba:	ae0a      	add	r6, sp, #40	; 0x28
			sfjs->nr[i] = nr[i];
 80127bc:	af12      	add	r7, sp, #72	; 0x48
		sfjs->intensityScale = intensityScale;
 80127be:	f8ca e0f8 	str.w	lr, [sl, #248]	; 0xf8
			sfjs->slen[i] = slen[i];
 80127c2:	46b6      	mov	lr, r6
			sfjs->nr[i] = nr[i];
 80127c4:	46bc      	mov	ip, r7
			sfjs->slen[i] = slen[i];
 80127c6:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80127ca:	f8ca 00fc 	str.w	r0, [sl, #252]	; 0xfc
 80127ce:	f8ca 1100 	str.w	r1, [sl, #256]	; 0x100
 80127d2:	f8ca 2104 	str.w	r2, [sl, #260]	; 0x104
 80127d6:	f8ca 3108 	str.w	r3, [sl, #264]	; 0x108
			sfjs->nr[i] = nr[i];
 80127da:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80127de:	f8ca 010c 	str.w	r0, [sl, #268]	; 0x10c
 80127e2:	f8ca 1110 	str.w	r1, [sl, #272]	; 0x110
 80127e6:	f8ca 2114 	str.w	r2, [sl, #276]	; 0x114
 80127ea:	f8ca 3118 	str.w	r3, [sl, #280]	; 0x118
		sfjs->intensityScale = intensityScale;
 80127ee:	e4e0      	b.n	80121b2 <xmp3_UnpackScaleFactors+0x122>
 80127f0:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80127f2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 80127f4:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 80127f8:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
 80127fc:	009b      	lsls	r3, r3, #2
 80127fe:	0152      	lsls	r2, r2, #5
 8012800:	eb03 0745 	add.w	r7, r3, r5, lsl #1
 8012804:	9204      	str	r2, [sp, #16]
 8012806:	463d      	mov	r5, r7
 8012808:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801280a:	3f01      	subs	r7, #1
 801280c:	3507      	adds	r5, #7
 801280e:	0152      	lsls	r2, r2, #5
 8012810:	4457      	add	r7, sl
 8012812:	4455      	add	r5, sl
 8012814:	9205      	str	r2, [sp, #20]
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 8012816:	4649      	mov	r1, r9
 8012818:	4620      	mov	r0, r4
 801281a:	f7fa f99b 	bl	800cb54 <xmp3_GetBits>
 801281e:	f807 0f01 	strb.w	r0, [r7, #1]!
			for (sfb = 0; sfb < 8; sfb++)
 8012822:	42bd      	cmp	r5, r7
 8012824:	d1f7      	bne.n	8012816 <xmp3_UnpackScaleFactors+0x786>
			sfb = 3;
 8012826:	2303      	movs	r3, #3
 8012828:	e6a4      	b.n	8012574 <xmp3_UnpackScaleFactors+0x4e4>
 801282a:	f04f 0906 	mov.w	r9, #6
 801282e:	2303      	movs	r3, #3
 8012830:	4661      	mov	r1, ip
 8012832:	4662      	mov	r2, ip
 8012834:	4660      	mov	r0, ip
	intensityScale = 0;
 8012836:	46e6      	mov	lr, ip
 8012838:	260a      	movs	r6, #10
 801283a:	270b      	movs	r7, #11
			preFlag = 1;
 801283c:	f04f 0b01 	mov.w	fp, #1
 8012840:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8012844:	f8cd 9020 	str.w	r9, [sp, #32]
 8012848:	9307      	str	r3, [sp, #28]
 801284a:	e494      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
			slen[0] = (sfCompress / 36);
 801284c:	4946      	ldr	r1, [pc, #280]	; (8012968 <xmp3_UnpackScaleFactors+0x8d8>)
 801284e:	17c0      	asrs	r0, r0, #31
 8012850:	4694      	mov	ip, r2
	preFlag = 0;
 8012852:	4693      	mov	fp, r2
			slen[0] = (sfCompress / 36);
 8012854:	fb81 1803 	smull	r1, r8, r1, r3
			slen[3] = 0;
 8012858:	920d      	str	r2, [sp, #52]	; 0x34
			slen[0] = (sfCompress / 36);
 801285a:	ebc0 08e8 	rsb	r8, r0, r8, asr #3
			slen[1] = (sfCompress % 36) / 6;
 801285e:	eb08 01c8 	add.w	r1, r8, r8, lsl #3
			slen[0] = (sfCompress / 36);
 8012862:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1] = (sfCompress % 36) / 6;
 8012866:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
 801286a:	4940      	ldr	r1, [pc, #256]	; (801296c <xmp3_UnpackScaleFactors+0x8dc>)
 801286c:	fb81 0103 	smull	r0, r1, r1, r3
 8012870:	2007      	movs	r0, #7
 8012872:	eba1 71e3 	sub.w	r1, r1, r3, asr #31
 8012876:	4606      	mov	r6, r0
 8012878:	4607      	mov	r7, r0
 801287a:	910b      	str	r1, [sp, #44]	; 0x2c
			slen[2] = (sfCompress % 36) % 6;
 801287c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8012880:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8012884:	2305      	movs	r3, #5
 8012886:	910c      	str	r1, [sp, #48]	; 0x30
			sfcIdx = 3;
 8012888:	2104      	movs	r1, #4
 801288a:	9307      	str	r3, [sp, #28]
 801288c:	4689      	mov	r9, r1
 801288e:	9109      	str	r1, [sp, #36]	; 0x24
 8012890:	9108      	str	r1, [sp, #32]
 8012892:	e470      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
		return -1;
 8012894:	f04f 30ff 	mov.w	r0, #4294967295
 8012898:	e4fe      	b.n	8012298 <xmp3_UnpackScaleFactors+0x208>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801289a:	4413      	add	r3, r2
 801289c:	4452      	add	r2, sl
 801289e:	4453      	add	r3, sl
 80128a0:	7991      	ldrb	r1, [r2, #6]
 80128a2:	7199      	strb	r1, [r3, #6]
 80128a4:	79d1      	ldrb	r1, [r2, #7]
 80128a6:	71d9      	strb	r1, [r3, #7]
 80128a8:	7a11      	ldrb	r1, [r2, #8]
 80128aa:	7219      	strb	r1, [r3, #8]
 80128ac:	7a51      	ldrb	r1, [r2, #9]
 80128ae:	7259      	strb	r1, [r3, #9]
 80128b0:	7a92      	ldrb	r2, [r2, #10]
 80128b2:	729a      	strb	r2, [r3, #10]
 80128b4:	e55b      	b.n	801236e <xmp3_UnpackScaleFactors+0x2de>
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 80128b6:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
 80128ba:	eb02 0341 	add.w	r3, r2, r1, lsl #1
 80128be:	f81a 2011 	ldrb.w	r2, [sl, r1, lsl #1]
 80128c2:	f80a 2003 	strb.w	r2, [sl, r3]
 80128c6:	eb0a 0241 	add.w	r2, sl, r1, lsl #1
 80128ca:	9923      	ldr	r1, [sp, #140]	; 0x8c
 80128cc:	4453      	add	r3, sl
 80128ce:	0149      	lsls	r1, r1, #5
 80128d0:	9104      	str	r1, [sp, #16]
 80128d2:	7851      	ldrb	r1, [r2, #1]
 80128d4:	7059      	strb	r1, [r3, #1]
 80128d6:	7891      	ldrb	r1, [r2, #2]
 80128d8:	7099      	strb	r1, [r3, #2]
 80128da:	78d1      	ldrb	r1, [r2, #3]
 80128dc:	70d9      	strb	r1, [r3, #3]
 80128de:	7911      	ldrb	r1, [r2, #4]
 80128e0:	7119      	strb	r1, [r3, #4]
 80128e2:	7952      	ldrb	r2, [r2, #5]
 80128e4:	715a      	strb	r2, [r3, #5]
 80128e6:	e524      	b.n	8012332 <xmp3_UnpackScaleFactors+0x2a2>
			sfCompress -= 244;
 80128e8:	3bf4      	subs	r3, #244	; 0xf4
			slen[0] = (sfCompress / 3);
 80128ea:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8012970 <xmp3_UnpackScaleFactors+0x8e0>
			slen[2] = slen[3] = 0;
 80128ee:	2608      	movs	r6, #8
 80128f0:	f04f 0904 	mov.w	r9, #4
			slen[0] = (sfCompress / 3);
 80128f4:	fba8 1803 	umull	r1, r8, r8, r3
			slen[2] = slen[3] = 0;
 80128f8:	4694      	mov	ip, r2
 80128fa:	4637      	mov	r7, r6
	preFlag = 0;
 80128fc:	4693      	mov	fp, r2
			slen[0] = (sfCompress / 3);
 80128fe:	ea4f 0858 	mov.w	r8, r8, lsr #1
			slen[1] = (sfCompress % 3);
 8012902:	eb08 0148 	add.w	r1, r8, r8, lsl #1
			slen[0] = (sfCompress / 3);
 8012906:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
			slen[1] = (sfCompress % 3);
 801290a:	1a5b      	subs	r3, r3, r1
			slen[2] = slen[3] = 0;
 801290c:	2103      	movs	r1, #3
			slen[1] = (sfCompress % 3);
 801290e:	930b      	str	r3, [sp, #44]	; 0x2c
			slen[2] = slen[3] = 0;
 8012910:	2305      	movs	r3, #5
 8012912:	9108      	str	r1, [sp, #32]
 8012914:	4618      	mov	r0, r3
 8012916:	9309      	str	r3, [sp, #36]	; 0x24
 8012918:	2306      	movs	r3, #6
 801291a:	ed9f 7b11 	vldr	d7, [pc, #68]	; 8012960 <xmp3_UnpackScaleFactors+0x8d0>
 801291e:	9307      	str	r3, [sp, #28]
 8012920:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
			sfcIdx = 5;
 8012924:	e427      	b.n	8012176 <xmp3_UnpackScaleFactors+0xe6>
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012926:	4413      	add	r3, r2
 8012928:	4452      	add	r2, sl
 801292a:	4453      	add	r3, sl
 801292c:	7c11      	ldrb	r1, [r2, #16]
 801292e:	7419      	strb	r1, [r3, #16]
 8012930:	7c51      	ldrb	r1, [r2, #17]
 8012932:	7459      	strb	r1, [r3, #17]
 8012934:	7c91      	ldrb	r1, [r2, #18]
 8012936:	7499      	strb	r1, [r3, #18]
 8012938:	7cd1      	ldrb	r1, [r2, #19]
 801293a:	74d9      	strb	r1, [r3, #19]
 801293c:	7d12      	ldrb	r2, [r2, #20]
 801293e:	751a      	strb	r2, [r3, #20]
 8012940:	e47b      	b.n	801223a <xmp3_UnpackScaleFactors+0x1aa>
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 8012942:	1853      	adds	r3, r2, r1
 8012944:	4452      	add	r2, sl
 8012946:	4453      	add	r3, sl
 8012948:	7ad1      	ldrb	r1, [r2, #11]
 801294a:	72d9      	strb	r1, [r3, #11]
 801294c:	7b11      	ldrb	r1, [r2, #12]
 801294e:	7319      	strb	r1, [r3, #12]
 8012950:	7b51      	ldrb	r1, [r2, #13]
 8012952:	7359      	strb	r1, [r3, #13]
 8012954:	7b91      	ldrb	r1, [r2, #14]
 8012956:	7399      	strb	r1, [r3, #14]
 8012958:	7bd2      	ldrb	r2, [r2, #15]
 801295a:	73da      	strb	r2, [r3, #15]
 801295c:	e526      	b.n	80123ac <xmp3_UnpackScaleFactors+0x31c>
 801295e:	bf00      	nop
	...
 8012968:	38e38e39 	.word	0x38e38e39
 801296c:	2aaaaaab 	.word	0x2aaaaaab
 8012970:	aaaaaaab 	.word	0xaaaaaaab

08012974 <xmp3_MidSideProc>:
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
	for(i = 0; i < nSamps; i++) {
 8012974:	2900      	cmp	r1, #0
{
 8012976:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	for(i = 0; i < nSamps; i++) {
 801297a:	dd2a      	ble.n	80129d2 <xmp3_MidSideProc+0x5e>
	mOutL = mOutR = 0;
 801297c:	2700      	movs	r7, #0
 801297e:	f1a0 0c04 	sub.w	ip, r0, #4
 8012982:	f600 00fc 	addw	r0, r0, #2300	; 0x8fc
 8012986:	46b8      	mov	r8, r7
	for(i = 0; i < nSamps; i++) {
 8012988:	46be      	mov	lr, r7
		xl = x[0][i];
 801298a:	f85c 3f04 	ldr.w	r3, [ip, #4]!
		xr = x[1][i];
 801298e:	f850 6f04 	ldr.w	r6, [r0, #4]!
		x[0][i] = xl + xr;
 8012992:	eb03 0906 	add.w	r9, r3, r6
		x[1][i] = xl - xr;
 8012996:	1b9b      	subs	r3, r3, r6
		x[0][i] = xl + xr;
 8012998:	f8cc 9000 	str.w	r9, [ip]
		x[1][i] = xl - xr;
 801299c:	6003      	str	r3, [r0, #0]
	__asm__ volatile (
 801299e:	f8dc 6000 	ldr.w	r6, [ip]
 80129a2:	ea86 75e6 	eor.w	r5, r6, r6, asr #31
 80129a6:	eba5 75e6 	sub.w	r5, r5, r6, asr #31
		mOutL |= FASTABS(x[0][i]);
 80129aa:	ea48 0805 	orr.w	r8, r8, r5
 80129ae:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 80129b2:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
	for(i = 0; i < nSamps; i++) {
 80129b6:	f10e 0e01 	add.w	lr, lr, #1
		mOutR |= FASTABS(x[1][i]);
 80129ba:	4327      	orrs	r7, r4
	for(i = 0; i < nSamps; i++) {
 80129bc:	4571      	cmp	r1, lr
 80129be:	d1e4      	bne.n	801298a <xmp3_MidSideProc+0x16>
	}
	mOut[0] |= mOutL;
	mOut[1] |= mOutR;
 80129c0:	e9d2 1300 	ldrd	r1, r3, [r2]
	mOut[0] |= mOutL;
 80129c4:	ea41 0108 	orr.w	r1, r1, r8
	mOut[1] |= mOutR;
 80129c8:	433b      	orrs	r3, r7
 80129ca:	e9c2 1300 	strd	r1, r3, [r2]
}
 80129ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	mOutL = mOutR = 0;
 80129d2:	2700      	movs	r7, #0
 80129d4:	46b8      	mov	r8, r7
 80129d6:	e7f3      	b.n	80129c0 <xmp3_MidSideProc+0x4c>

080129d8 <xmp3_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 80129d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80129dc:	b093      	sub	sp, #76	; 0x4c
 80129de:	469b      	mov	fp, r3
 80129e0:	f8dd 9070 	ldr.w	r9, [sp, #112]	; 0x70
 80129e4:	900f      	str	r0, [sp, #60]	; 0x3c
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 80129e6:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80129ea:	2b00      	cmp	r3, #0
 80129ec:	f040 8094 	bne.w	8012b18 <xmp3_IntensityProcMPEG1+0x140>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
		cbEndL =   cbi[0].cbEndL + 1;
 80129f0:	f8d9 3014 	ldr.w	r3, [r9, #20]
		cbStartL = cbi[1].cbEndL + 1;
 80129f4:	f8d9 702c 	ldr.w	r7, [r9, #44]	; 0x2c
		cbEndL =   cbi[0].cbEndL + 1;
 80129f8:	3301      	adds	r3, #1
		cbStartL = cbi[1].cbEndL + 1;
 80129fa:	3701      	adds	r7, #1
		cbEndL =   cbi[0].cbEndL + 1;
 80129fc:	9303      	str	r3, [sp, #12]
		cbStartS = cbEndS = 0;
		i = fh->sfBand->l[cbStartL];
 80129fe:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8012a00:	f933 a017 	ldrsh.w	sl, [r3, r7, lsl #1]
		cbStartL = cbEndL = 0;
		i = 3 * fh->sfBand->s[cbStartS];
	}

	sampsLeft = nSamps - i;		/* process to length of left */
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012a04:	9b1d      	ldr	r3, [sp, #116]	; 0x74
	sampsLeft = nSamps - i;		/* process to length of left */
 8012a06:	eba1 080a 	sub.w	r8, r1, sl
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012a0a:	4941      	ldr	r1, [pc, #260]	; (8012b10 <xmp3_IntensityProcMPEG1+0x138>)
 8012a0c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8012a10:	eb01 0383 	add.w	r3, r1, r3, lsl #2
	mOutL = mOutR = 0;

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8012a14:	9903      	ldr	r1, [sp, #12]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012a16:	9305      	str	r3, [sp, #20]
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8012a18:	428f      	cmp	r7, r1
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012a1a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8012a1c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8012a20:	f280 818b 	bge.w	8012d3a <xmp3_IntensityProcMPEG1+0x362>
 8012a24:	f1b8 0f00 	cmp.w	r8, #0
 8012a28:	f340 8187 	ble.w	8012d3a <xmp3_IntensityProcMPEG1+0x362>
 8012a2c:	6b52      	ldr	r2, [r2, #52]	; 0x34
	mOutL = mOutR = 0;
 8012a2e:	f04f 0900 	mov.w	r9, #0
 8012a32:	eb02 0247 	add.w	r2, r2, r7, lsl #1
 8012a36:	3f01      	subs	r7, #1
 8012a38:	46cc      	mov	ip, r9
 8012a3a:	9202      	str	r2, [sp, #8]
 8012a3c:	eb0b 0207 	add.w	r2, fp, r7
 8012a40:	9201      	str	r2, [sp, #4]
 8012a42:	f1cb 0201 	rsb	r2, fp, #1
 8012a46:	9204      	str	r2, [sp, #16]
		isf = sfis->l[cb];
		if (isf == 7) {
			fl = ISFIIP[midSideFlag][0];
			fr = ISFIIP[midSideFlag][1];
 8012a48:	4a32      	ldr	r2, [pc, #200]	; (8012b14 <xmp3_IntensityProcMPEG1+0x13c>)
 8012a4a:	18d3      	adds	r3, r2, r3
 8012a4c:	9306      	str	r3, [sp, #24]
		isf = sfis->l[cb];
 8012a4e:	9a01      	ldr	r2, [sp, #4]
 8012a50:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		if (isf == 7) {
 8012a54:	2b07      	cmp	r3, #7
		isf = sfis->l[cb];
 8012a56:	9201      	str	r2, [sp, #4]
		if (isf == 7) {
 8012a58:	d053      	beq.n	8012b02 <xmp3_IntensityProcMPEG1+0x12a>
		} else {
			fl = isfTab[isf];	
 8012a5a:	9a05      	ldr	r2, [sp, #20]
 8012a5c:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
			fr = isfTab[6] - isfTab[isf];
 8012a60:	6996      	ldr	r6, [r2, #24]
 8012a62:	1bf6      	subs	r6, r6, r7
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8012a64:	9902      	ldr	r1, [sp, #8]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8012a66:	f1b8 0f00 	cmp.w	r8, #0
 8012a6a:	460a      	mov	r2, r1
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8012a6c:	f9b1 e002 	ldrsh.w	lr, [r1, #2]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8012a70:	bfd4      	ite	le
 8012a72:	2300      	movle	r3, #0
 8012a74:	2301      	movgt	r3, #1
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8012a76:	f9b2 2000 	ldrsh.w	r2, [r2]
 8012a7a:	3102      	adds	r1, #2
 8012a7c:	ebae 0e02 	sub.w	lr, lr, r2
 8012a80:	9102      	str	r1, [sp, #8]
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8012a82:	f1be 0f00 	cmp.w	lr, #0
 8012a86:	dd2d      	ble.n	8012ae4 <xmp3_IntensityProcMPEG1+0x10c>
 8012a88:	b363      	cbz	r3, 8012ae4 <xmp3_IntensityProcMPEG1+0x10c>
 8012a8a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012a8c:	eb08 0b0a 	add.w	fp, r8, sl
 8012a90:	4641      	mov	r1, r8
 8012a92:	eb03 008a 	add.w	r0, r3, sl, lsl #2
 8012a96:	3804      	subs	r0, #4
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 8012a98:	f850 3f04 	ldr.w	r3, [r0, #4]!
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012a9c:	461a      	mov	r2, r3
 8012a9e:	fb86 a202 	smull	sl, r2, r6, r2
 8012aa2:	0092      	lsls	r2, r2, #2
 8012aa4:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
	__asm__ volatile (
 8012aa8:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
 8012aac:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
 8012ab0:	ea49 0905 	orr.w	r9, r9, r5
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012ab4:	fb87 2303 	smull	r2, r3, r7, r3
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 8012ab8:	009b      	lsls	r3, r3, #2
 8012aba:	6003      	str	r3, [r0, #0]
	__asm__ volatile (
 8012abc:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8012ac0:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
			sampsLeft--;
 8012ac4:	3901      	subs	r1, #1
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 8012ac6:	ea4c 0c04 	orr.w	ip, ip, r4
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8012aca:	2900      	cmp	r1, #0
 8012acc:	eba8 0201 	sub.w	r2, r8, r1
 8012ad0:	ebab 0a01 	sub.w	sl, fp, r1
 8012ad4:	bfd4      	ite	le
 8012ad6:	2300      	movle	r3, #0
 8012ad8:	2301      	movgt	r3, #1
 8012ada:	4572      	cmp	r2, lr
 8012adc:	da01      	bge.n	8012ae2 <xmp3_IntensityProcMPEG1+0x10a>
 8012ade:	2b00      	cmp	r3, #0
 8012ae0:	d1da      	bne.n	8012a98 <xmp3_IntensityProcMPEG1+0xc0>
			sampsLeft--;
 8012ae2:	4688      	mov	r8, r1
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8012ae4:	9901      	ldr	r1, [sp, #4]
 8012ae6:	9a04      	ldr	r2, [sp, #16]
 8012ae8:	440a      	add	r2, r1
 8012aea:	9903      	ldr	r1, [sp, #12]
 8012aec:	428a      	cmp	r2, r1
 8012aee:	da01      	bge.n	8012af4 <xmp3_IntensityProcMPEG1+0x11c>
 8012af0:	2b00      	cmp	r3, #0
 8012af2:	d1ac      	bne.n	8012a4e <xmp3_IntensityProcMPEG1+0x76>
 8012af4:	4667      	mov	r7, ip
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
			sampsLeft -= 3;
		}
	}
	mOut[0] = mOutL;
 8012af6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
	mOut[1] = mOutR;
 8012af8:	e9c3 7900 	strd	r7, r9, [r3]
	
	return;
}
 8012afc:	b013      	add	sp, #76	; 0x4c
 8012afe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fl = ISFIIP[midSideFlag][0];
 8012b02:	4b04      	ldr	r3, [pc, #16]	; (8012b14 <xmp3_IntensityProcMPEG1+0x13c>)
 8012b04:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8012b06:	f853 7032 	ldr.w	r7, [r3, r2, lsl #3]
			fr = ISFIIP[midSideFlag][1];
 8012b0a:	9b06      	ldr	r3, [sp, #24]
 8012b0c:	685e      	ldr	r6, [r3, #4]
 8012b0e:	e7a9      	b.n	8012a64 <xmp3_IntensityProcMPEG1+0x8c>
 8012b10:	08019b08 	.word	0x08019b08
 8012b14:	08019af8 	.word	0x08019af8
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 8012b18:	3b01      	subs	r3, #1
 8012b1a:	2b01      	cmp	r3, #1
 8012b1c:	f63f af72 	bhi.w	8012a04 <xmp3_IntensityProcMPEG1+0x2c>
		i = 3 * fh->sfBand->s[cbStartS];
 8012b20:	6b50      	ldr	r0, [r2, #52]	; 0x34
		cbStartS = cbi[1].cbEndSMax + 1;
 8012b22:	f8d9 2028 	ldr.w	r2, [r9, #40]	; 0x28
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b26:	9b1d      	ldr	r3, [sp, #116]	; 0x74
		i = 3 * fh->sfBand->s[cbStartS];
 8012b28:	eb00 0442 	add.w	r4, r0, r2, lsl #1
		cbEndS =   cbi[0].cbEndSMax + 1;
 8012b2c:	f8d9 5010 	ldr.w	r5, [r9, #16]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b30:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
		i = 3 * fh->sfBand->s[cbStartS];
 8012b34:	f9b4 a030 	ldrsh.w	sl, [r4, #48]	; 0x30
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b38:	4c82      	ldr	r4, [pc, #520]	; (8012d44 <xmp3_IntensityProcMPEG1+0x36c>)
		i = 3 * fh->sfBand->s[cbStartS];
 8012b3a:	eb0a 0a4a 	add.w	sl, sl, sl, lsl #1
		cbEndS =   cbi[0].cbEndSMax + 1;
 8012b3e:	9511      	str	r5, [sp, #68]	; 0x44
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b40:	eb04 0383 	add.w	r3, r4, r3, lsl #2
	sampsLeft = nSamps - i;		/* process to length of left */
 8012b44:	eba1 010a 	sub.w	r1, r1, sl
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b48:	930d      	str	r3, [sp, #52]	; 0x34
		cbStartS = cbi[1].cbEndSMax + 1;
 8012b4a:	1c53      	adds	r3, r2, #1
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8012b4c:	2902      	cmp	r1, #2
		cbStartS = cbi[1].cbEndSMax + 1;
 8012b4e:	930b      	str	r3, [sp, #44]	; 0x2c
	isfTab = (int *)ISFMpeg1[midSideFlag];
 8012b50:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8012b52:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8012b56:	f340 80f0 	ble.w	8012d3a <xmp3_IntensityProcMPEG1+0x362>
 8012b5a:	42aa      	cmp	r2, r5
 8012b5c:	f280 80ed 	bge.w	8012d3a <xmp3_IntensityProcMPEG1+0x362>
 8012b60:	3218      	adds	r2, #24
	mOutL = mOutR = 0;
 8012b62:	f04f 0900 	mov.w	r9, #0
 8012b66:	eb00 0242 	add.w	r2, r0, r2, lsl #1
 8012b6a:	464f      	mov	r7, r9
 8012b6c:	920c      	str	r2, [sp, #48]	; 0x30
 8012b6e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012b70:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8012b74:	445a      	add	r2, fp
 8012b76:	920a      	str	r2, [sp, #40]	; 0x28
				frs[w] = ISFIIP[midSideFlag][1];
 8012b78:	4a73      	ldr	r2, [pc, #460]	; (8012d48 <xmp3_IntensityProcMPEG1+0x370>)
 8012b7a:	18d3      	adds	r3, r2, r3
 8012b7c:	9310      	str	r3, [sp, #64]	; 0x40
			isf = sfis->s[cb][w];
 8012b7e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012b80:	7ddb      	ldrb	r3, [r3, #23]
			if (isf == 7) {
 8012b82:	2b07      	cmp	r3, #7
 8012b84:	e9dd 5b01 	ldrd	r5, fp, [sp, #4]
 8012b88:	f000 80b4 	beq.w	8012cf4 <xmp3_IntensityProcMPEG1+0x31c>
				fls[w] = isfTab[isf];
 8012b8c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012b8e:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 8012b92:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 8012b94:	9005      	str	r0, [sp, #20]
				frs[w] = isfTab[6] - isfTab[isf];
 8012b96:	1a1b      	subs	r3, r3, r0
 8012b98:	9306      	str	r3, [sp, #24]
			isf = sfis->s[cb][w];
 8012b9a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012b9c:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 8012b9e:	2b07      	cmp	r3, #7
 8012ba0:	f000 80b5 	beq.w	8012d0e <xmp3_IntensityProcMPEG1+0x336>
				fls[w] = isfTab[isf];
 8012ba4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012ba6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 8012baa:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 8012bac:	9003      	str	r0, [sp, #12]
				frs[w] = isfTab[6] - isfTab[isf];
 8012bae:	1a1b      	subs	r3, r3, r0
 8012bb0:	9307      	str	r3, [sp, #28]
			isf = sfis->s[cb][w];
 8012bb2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012bb4:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 8012bb6:	2b07      	cmp	r3, #7
 8012bb8:	f000 80b6 	beq.w	8012d28 <xmp3_IntensityProcMPEG1+0x350>
				fls[w] = isfTab[isf];
 8012bbc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8012bbe:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 8012bc2:	6993      	ldr	r3, [r2, #24]
				fls[w] = isfTab[isf];
 8012bc4:	9004      	str	r0, [sp, #16]
				frs[w] = isfTab[6] - isfTab[isf];
 8012bc6:	1a1b      	subs	r3, r3, r0
 8012bc8:	9308      	str	r3, [sp, #32]
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012bca:	9c0c      	ldr	r4, [sp, #48]	; 0x30
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012bcc:	2902      	cmp	r1, #2
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012bce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8012bd0:	4623      	mov	r3, r4
 8012bd2:	f9b4 0002 	ldrsh.w	r0, [r4, #2]
 8012bd6:	f102 0201 	add.w	r2, r2, #1
 8012bda:	f104 0402 	add.w	r4, r4, #2
 8012bde:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012be2:	920e      	str	r2, [sp, #56]	; 0x38
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012be4:	bfd8      	it	le
 8012be6:	2200      	movle	r2, #0
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012be8:	eba0 0303 	sub.w	r3, r0, r3
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012bec:	bfc8      	it	gt
 8012bee:	2201      	movgt	r2, #1
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012bf0:	940c      	str	r4, [sp, #48]	; 0x30
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012bf2:	2b00      	cmp	r3, #0
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012bf4:	9302      	str	r3, [sp, #8]
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012bf6:	dd6b      	ble.n	8012cd0 <xmp3_IntensityProcMPEG1+0x2f8>
 8012bf8:	2a00      	cmp	r2, #0
 8012bfa:	d069      	beq.n	8012cd0 <xmp3_IntensityProcMPEG1+0x2f8>
 8012bfc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012bfe:	eb01 020a 	add.w	r2, r1, sl
 8012c02:	2000      	movs	r0, #0
 8012c04:	465c      	mov	r4, fp
 8012c06:	eb03 038a 	add.w	r3, r3, sl, lsl #2
 8012c0a:	9209      	str	r2, [sp, #36]	; 0x24
 8012c0c:	9701      	str	r7, [sp, #4]
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 8012c0e:	681a      	ldr	r2, [r3, #0]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c10:	9f06      	ldr	r7, [sp, #24]
 8012c12:	4692      	mov	sl, r2
 8012c14:	fb87 ba0a 	smull	fp, sl, r7, sl
 8012c18:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8012c1c:	f8c3 a900 	str.w	sl, [r3, #2304]	; 0x900
	__asm__ volatile (
 8012c20:	ea8a 74ea 	eor.w	r4, sl, sl, asr #31
 8012c24:	eba4 74ea 	sub.w	r4, r4, sl, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c28:	9f05      	ldr	r7, [sp, #20]
 8012c2a:	fb87 a202 	smull	sl, r2, r7, r2
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 8012c2e:	0092      	lsls	r2, r2, #2
 8012c30:	601a      	str	r2, [r3, #0]
	__asm__ volatile (
 8012c32:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
 8012c36:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 8012c3a:	685a      	ldr	r2, [r3, #4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c3c:	9f07      	ldr	r7, [sp, #28]
 8012c3e:	4692      	mov	sl, r2
 8012c40:	fb87 ba0a 	smull	fp, sl, r7, sl
 8012c44:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8012c48:	f8c3 a904 	str.w	sl, [r3, #2308]	; 0x904
	__asm__ volatile (
 8012c4c:	ea8a 76ea 	eor.w	r6, sl, sl, asr #31
 8012c50:	eba6 76ea 	sub.w	r6, r6, sl, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c54:	9f03      	ldr	r7, [sp, #12]
 8012c56:	fb87 a202 	smull	sl, r2, r7, r2
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 8012c5a:	0092      	lsls	r2, r2, #2
 8012c5c:	605a      	str	r2, [r3, #4]
	__asm__ volatile (
 8012c5e:	ea82 78e2 	eor.w	r8, r2, r2, asr #31
 8012c62:	eba8 78e2 	sub.w	r8, r8, r2, asr #31
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 8012c66:	689a      	ldr	r2, [r3, #8]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c68:	9f08      	ldr	r7, [sp, #32]
 8012c6a:	4692      	mov	sl, r2
 8012c6c:	fb87 ba0a 	smull	fp, sl, r7, sl
 8012c70:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8012c74:	f8c3 a908 	str.w	sl, [r3, #2312]	; 0x908
	__asm__ volatile (
 8012c78:	ea8a 7eea 	eor.w	lr, sl, sl, asr #31
 8012c7c:	ebae 7eea 	sub.w	lr, lr, sl, asr #31
 8012c80:	ea46 0a04 	orr.w	sl, r6, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012c84:	9f04      	ldr	r7, [sp, #16]
 8012c86:	ea4a 0a0e 	orr.w	sl, sl, lr
 8012c8a:	ea49 090a 	orr.w	r9, r9, sl
 8012c8e:	fb87 a202 	smull	sl, r2, r7, r2
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8012c92:	0092      	lsls	r2, r2, #2
 8012c94:	609a      	str	r2, [r3, #8]
	__asm__ volatile (
 8012c96:	ea82 7ce2 	eor.w	ip, r2, r2, asr #31
 8012c9a:	ebac 7ce2 	sub.w	ip, ip, r2, asr #31
 8012c9e:	ea48 0205 	orr.w	r2, r8, r5
 8012ca2:	9f01      	ldr	r7, [sp, #4]
			sampsLeft -= 3;
 8012ca4:	3903      	subs	r1, #3
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012ca6:	3001      	adds	r0, #1
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8012ca8:	ea42 020c 	orr.w	r2, r2, ip
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012cac:	330c      	adds	r3, #12
 8012cae:	2902      	cmp	r1, #2
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8012cb0:	ea47 0702 	orr.w	r7, r7, r2
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012cb4:	bfd4      	ite	le
 8012cb6:	2200      	movle	r2, #0
 8012cb8:	2201      	movgt	r2, #1
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8012cba:	9701      	str	r7, [sp, #4]
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8012cbc:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8012cbe:	eba7 0a01 	sub.w	sl, r7, r1
 8012cc2:	9f02      	ldr	r7, [sp, #8]
 8012cc4:	4287      	cmp	r7, r0
 8012cc6:	dd01      	ble.n	8012ccc <xmp3_IntensityProcMPEG1+0x2f4>
 8012cc8:	2a00      	cmp	r2, #0
 8012cca:	d1a0      	bne.n	8012c0e <xmp3_IntensityProcMPEG1+0x236>
			sampsLeft -= 3;
 8012ccc:	9f01      	ldr	r7, [sp, #4]
 8012cce:	46a3      	mov	fp, r4
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8012cd0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012cd2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8012cd4:	3303      	adds	r3, #3
 8012cd6:	930a      	str	r3, [sp, #40]	; 0x28
 8012cd8:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012cda:	4283      	cmp	r3, r0
 8012cdc:	f77f af0b 	ble.w	8012af6 <xmp3_IntensityProcMPEG1+0x11e>
 8012ce0:	2a00      	cmp	r2, #0
 8012ce2:	f43f af08 	beq.w	8012af6 <xmp3_IntensityProcMPEG1+0x11e>
 8012ce6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012ce8:	930b      	str	r3, [sp, #44]	; 0x2c
			isf = sfis->s[cb][w];
 8012cea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012cec:	7ddb      	ldrb	r3, [r3, #23]
			if (isf == 7) {
 8012cee:	2b07      	cmp	r3, #7
 8012cf0:	f47f af4c 	bne.w	8012b8c <xmp3_IntensityProcMPEG1+0x1b4>
				fls[w] = ISFIIP[midSideFlag][0];
 8012cf4:	4b14      	ldr	r3, [pc, #80]	; (8012d48 <xmp3_IntensityProcMPEG1+0x370>)
 8012cf6:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8012cf8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8012cfc:	9305      	str	r3, [sp, #20]
				frs[w] = ISFIIP[midSideFlag][1];
 8012cfe:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012d00:	685b      	ldr	r3, [r3, #4]
 8012d02:	9306      	str	r3, [sp, #24]
			isf = sfis->s[cb][w];
 8012d04:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012d06:	7e1b      	ldrb	r3, [r3, #24]
			if (isf == 7) {
 8012d08:	2b07      	cmp	r3, #7
 8012d0a:	f47f af4b 	bne.w	8012ba4 <xmp3_IntensityProcMPEG1+0x1cc>
				fls[w] = ISFIIP[midSideFlag][0];
 8012d0e:	4b0e      	ldr	r3, [pc, #56]	; (8012d48 <xmp3_IntensityProcMPEG1+0x370>)
 8012d10:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8012d12:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8012d16:	9303      	str	r3, [sp, #12]
				frs[w] = ISFIIP[midSideFlag][1];
 8012d18:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012d1a:	685b      	ldr	r3, [r3, #4]
 8012d1c:	9307      	str	r3, [sp, #28]
			isf = sfis->s[cb][w];
 8012d1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8012d20:	7e5b      	ldrb	r3, [r3, #25]
			if (isf == 7) {
 8012d22:	2b07      	cmp	r3, #7
 8012d24:	f47f af4a 	bne.w	8012bbc <xmp3_IntensityProcMPEG1+0x1e4>
				fls[w] = ISFIIP[midSideFlag][0];
 8012d28:	4b07      	ldr	r3, [pc, #28]	; (8012d48 <xmp3_IntensityProcMPEG1+0x370>)
 8012d2a:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8012d2c:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8012d30:	9304      	str	r3, [sp, #16]
				frs[w] = ISFIIP[midSideFlag][1];
 8012d32:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012d34:	685b      	ldr	r3, [r3, #4]
 8012d36:	9308      	str	r3, [sp, #32]
 8012d38:	e747      	b.n	8012bca <xmp3_IntensityProcMPEG1+0x1f2>
	mOutL = mOutR = 0;
 8012d3a:	f04f 0900 	mov.w	r9, #0
 8012d3e:	464f      	mov	r7, r9
 8012d40:	e6d9      	b.n	8012af6 <xmp3_IntensityProcMPEG1+0x11e>
 8012d42:	bf00      	nop
 8012d44:	08019b08 	.word	0x08019b08
 8012d48:	08019af8 	.word	0x08019af8

08012d4c <xmp3_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 8012d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012d50:	b0a1      	sub	sp, #132	; 0x84
 8012d52:	468b      	mov	fp, r1
 8012d54:	469a      	mov	sl, r3
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
		tmp = (1 << sfjs->slen[r]) - 1;
 8012d56:	f04f 0801 	mov.w	r8, #1
{
 8012d5a:	9f2b      	ldr	r7, [sp, #172]	; 0xac
	for (k = r = 0; r < 4; r++) {
 8012d5c:	2300      	movs	r3, #0
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8012d5e:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
 8012d60:	f107 0914 	add.w	r9, r7, #20
 8012d64:	f857 1b04 	ldr.w	r1, [r7], #4
{
 8012d68:	9000      	str	r0, [sp, #0]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8012d6a:	eb06 0141 	add.w	r1, r6, r1, lsl #1
 8012d6e:	4891      	ldr	r0, [pc, #580]	; (8012fb4 <xmp3_IntensityProcMPEG2+0x268>)
 8012d70:	eb00 1181 	add.w	r1, r0, r1, lsl #6
 8012d74:	9103      	str	r1, [sp, #12]
		tmp = (1 << sfjs->slen[r]) - 1;
 8012d76:	f857 1b04 	ldr.w	r1, [r7], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8012d7a:	68f8      	ldr	r0, [r7, #12]
		tmp = (1 << sfjs->slen[r]) - 1;
 8012d7c:	fa08 f101 	lsl.w	r1, r8, r1
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8012d80:	2800      	cmp	r0, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 8012d82:	f101 31ff 	add.w	r1, r1, #4294967295
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8012d86:	dd0a      	ble.n	8012d9e <xmp3_IntensityProcMPEG2+0x52>
 8012d88:	4418      	add	r0, r3
 8012d8a:	ae09      	add	r6, sp, #36	; 0x24
 8012d8c:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8012d90:	eb06 0680 	add.w	r6, r6, r0, lsl #2
			il[k] = tmp;
 8012d94:	f843 1b04 	str.w	r1, [r3], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 8012d98:	42b3      	cmp	r3, r6
 8012d9a:	d1fb      	bne.n	8012d94 <xmp3_IntensityProcMPEG2+0x48>
 8012d9c:	4603      	mov	r3, r0
	for (k = r = 0; r < 4; r++) {
 8012d9e:	454f      	cmp	r7, r9
 8012da0:	d1e9      	bne.n	8012d76 <xmp3_IntensityProcMPEG2+0x2a>
	}

	if (cbi[1].cbType == 0) {
 8012da2:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8012da4:	6998      	ldr	r0, [r3, #24]
 8012da6:	2800      	cmp	r0, #0
 8012da8:	d17a      	bne.n	8012ea0 <xmp3_IntensityProcMPEG2+0x154>
		/* long blocks */
		il[21] = il[22] = 1;
 8012daa:	4619      	mov	r1, r3
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
		i = fh->sfBand->l[cbStartL];
 8012dac:	6b53      	ldr	r3, [r2, #52]	; 0x34
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 8012dae:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 8012db0:	6949      	ldr	r1, [r1, #20]
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 8012db2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 8012db4:	9104      	str	r1, [sp, #16]
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 8012db6:	f102 0e01 	add.w	lr, r2, #1

		for(cb = cbStartL; cb < cbEndL; cb++) {
			sfIdx = sfis->l[cb];
			if (sfIdx == il[cb]) {
				fl = ISFIIP[midSideFlag][0];
				fr = ISFIIP[midSideFlag][1];
 8012dba:	992c      	ldr	r1, [sp, #176]	; 0xb0
 8012dbc:	eb0a 020e 	add.w	r2, sl, lr
 8012dc0:	eb03 094e 	add.w	r9, r3, lr, lsl #1
 8012dc4:	9201      	str	r2, [sp, #4]
		il[21] = il[22] = 1;
 8012dc6:	2201      	movs	r2, #1
 8012dc8:	e9cd 221e 	strd	r2, r2, [sp, #120]	; 0x78
		i = fh->sfBand->l[cbStartL];
 8012dcc:	f933 201e 	ldrsh.w	r2, [r3, lr, lsl #1]
				fr = ISFIIP[midSideFlag][1];
 8012dd0:	4b79      	ldr	r3, [pc, #484]	; (8012fb8 <xmp3_IntensityProcMPEG2+0x26c>)
		sampsLeft = nSamps - i;
 8012dd2:	ebab 0802 	sub.w	r8, fp, r2
	mOutL = mOutR = 0;
 8012dd6:	4683      	mov	fp, r0
				fr = ISFIIP[midSideFlag][1];
 8012dd8:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8012ddc:	9305      	str	r3, [sp, #20]
		for(cb = cbStartL; cb < cbEndL; cb++) {
 8012dde:	9b04      	ldr	r3, [sp, #16]
 8012de0:	4573      	cmp	r3, lr
 8012de2:	db4b      	blt.n	8012e7c <xmp3_IntensityProcMPEG2+0x130>
			sfIdx = sfis->l[cb];
 8012de4:	9b01      	ldr	r3, [sp, #4]
 8012de6:	f813 1b01 	ldrb.w	r1, [r3], #1
 8012dea:	9301      	str	r3, [sp, #4]
			if (sfIdx == il[cb]) {
 8012dec:	ab09      	add	r3, sp, #36	; 0x24
 8012dee:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
 8012df2:	428b      	cmp	r3, r1
 8012df4:	d048      	beq.n	8012e88 <xmp3_IntensityProcMPEG2+0x13c>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 8012df6:	1c4b      	adds	r3, r1, #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012df8:	07c9      	lsls	r1, r1, #31
				isf = (sfis->l[cb] + 1) >> 1;
 8012dfa:	ea4f 0363 	mov.w	r3, r3, asr #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012dfe:	d54a      	bpl.n	8012e96 <xmp3_IntensityProcMPEG2+0x14a>
 8012e00:	9e03      	ldr	r6, [sp, #12]
 8012e02:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8012e06:	4633      	mov	r3, r6
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012e08:	681e      	ldr	r6, [r3, #0]
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 8012e0a:	464b      	mov	r3, r9
 8012e0c:	f9b9 c002 	ldrsh.w	ip, [r9, #2]
 8012e10:	f10e 0e01 	add.w	lr, lr, #1
 8012e14:	f109 0902 	add.w	r9, r9, #2
 8012e18:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012e1c:	ebac 0c03 	sub.w	ip, ip, r3
 8012e20:	45c4      	cmp	ip, r8
 8012e22:	bfa8      	it	ge
 8012e24:	46c4      	movge	ip, r8

			for(j = 0; j < n; j++, i++) {
 8012e26:	f1bc 0f00 	cmp.w	ip, #0
 8012e2a:	dd24      	ble.n	8012e76 <xmp3_IntensityProcMPEG2+0x12a>
 8012e2c:	eb0c 0302 	add.w	r3, ip, r2
 8012e30:	9f00      	ldr	r7, [sp, #0]
 8012e32:	eb07 0282 	add.w	r2, r7, r2, lsl #2
 8012e36:	9302      	str	r3, [sp, #8]
 8012e38:	eb07 0783 	add.w	r7, r7, r3, lsl #2
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8012e3c:	f852 3b04 	ldr.w	r3, [r2], #4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012e40:	fb86 a303 	smull	sl, r3, r6, r3
 8012e44:	009b      	lsls	r3, r3, #2
 8012e46:	f8c2 38fc 	str.w	r3, [r2, #2300]	; 0x8fc
	__asm__ volatile (
 8012e4a:	ea83 75e3 	eor.w	r5, r3, r3, asr #31
 8012e4e:	eba5 75e3 	sub.w	r5, r5, r3, asr #31
 8012e52:	ea4b 0b05 	orr.w	fp, fp, r5
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012e56:	f852 3c04 	ldr.w	r3, [r2, #-4]
 8012e5a:	fb81 a303 	smull	sl, r3, r1, r3
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8012e5e:	009b      	lsls	r3, r3, #2
 8012e60:	f842 3c04 	str.w	r3, [r2, #-4]
	__asm__ volatile (
 8012e64:	ea83 74e3 	eor.w	r4, r3, r3, asr #31
 8012e68:	eba4 74e3 	sub.w	r4, r4, r3, asr #31
			for(j = 0; j < n; j++, i++) {
 8012e6c:	4297      	cmp	r7, r2
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8012e6e:	ea40 0004 	orr.w	r0, r0, r4
			for(j = 0; j < n; j++, i++) {
 8012e72:	d1e3      	bne.n	8012e3c <xmp3_IntensityProcMPEG2+0xf0>
 8012e74:	9a02      	ldr	r2, [sp, #8]
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
			if (sampsLeft == 0)		
 8012e76:	ebb8 080c 	subs.w	r8, r8, ip
 8012e7a:	d1b0      	bne.n	8012dde <xmp3_IntensityProcMPEG2+0x92>
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
				}
			}
		}
	}
	mOut[0] = mOutL;
 8012e7c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOut[1] = mOutR;
 8012e7e:	e9c3 0b00 	strd	r0, fp, [r3]

	return;
}
 8012e82:	b021      	add	sp, #132	; 0x84
 8012e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fl = ISFIIP[midSideFlag][0];
 8012e88:	4b4b      	ldr	r3, [pc, #300]	; (8012fb8 <xmp3_IntensityProcMPEG2+0x26c>)
 8012e8a:	992c      	ldr	r1, [sp, #176]	; 0xb0
 8012e8c:	f853 1031 	ldr.w	r1, [r3, r1, lsl #3]
				fr = ISFIIP[midSideFlag][1];
 8012e90:	9b05      	ldr	r3, [sp, #20]
 8012e92:	685e      	ldr	r6, [r3, #4]
 8012e94:	e7b9      	b.n	8012e0a <xmp3_IntensityProcMPEG2+0xbe>
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012e96:	9903      	ldr	r1, [sp, #12]
 8012e98:	eb01 0383 	add.w	r3, r1, r3, lsl #2
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012e9c:	6809      	ldr	r1, [r1, #0]
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012e9e:	e7b3      	b.n	8012e08 <xmp3_IntensityProcMPEG2+0xbc>
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8012ea0:	6b53      	ldr	r3, [r2, #52]	; 0x34
	mOutL = mOutR = 0;
 8012ea2:	f04f 0b00 	mov.w	fp, #0
					fr = ISFIIP[midSideFlag][1];
 8012ea6:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8012ea8:	9307      	str	r3, [sp, #28]
	mOutL = mOutR = 0;
 8012eaa:	4658      	mov	r0, fp
 8012eac:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
		for(w = 0; w < 3; w++) {
 8012eae:	f8cd b010 	str.w	fp, [sp, #16]
 8012eb2:	3304      	adds	r3, #4
 8012eb4:	9306      	str	r3, [sp, #24]
 8012eb6:	f10a 0317 	add.w	r3, sl, #23
 8012eba:	9301      	str	r3, [sp, #4]
		il[12] = 1;
 8012ebc:	2301      	movs	r3, #1
 8012ebe:	9315      	str	r3, [sp, #84]	; 0x54
					fr = ISFIIP[midSideFlag][1];
 8012ec0:	4b3d      	ldr	r3, [pc, #244]	; (8012fb8 <xmp3_IntensityProcMPEG2+0x26c>)
 8012ec2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8012ec6:	9305      	str	r3, [sp, #20]
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8012ec8:	9a06      	ldr	r2, [sp, #24]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8012eca:	9d07      	ldr	r5, [sp, #28]
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8012ecc:	6993      	ldr	r3, [r2, #24]
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8012ece:	f852 4b04 	ldr.w	r4, [r2], #4
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8012ed2:	f103 0901 	add.w	r9, r3, #1
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8012ed6:	9206      	str	r2, [sp, #24]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8012ed8:	eb05 0243 	add.w	r2, r5, r3, lsl #1
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8012edc:	454c      	cmp	r4, r9
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8012ede:	9402      	str	r4, [sp, #8]
			i = 3 * fh->sfBand->s[cbStartS] + w;
 8012ee0:	8e11      	ldrh	r1, [r2, #48]	; 0x30
 8012ee2:	f04f 0203 	mov.w	r2, #3
 8012ee6:	4616      	mov	r6, r2
 8012ee8:	9a04      	ldr	r2, [sp, #16]
 8012eea:	fb11 2106 	smlabb	r1, r1, r6, r2
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8012eee:	db48      	blt.n	8012f82 <xmp3_IntensityProcMPEG2+0x236>
 8012ef0:	3318      	adds	r3, #24
 8012ef2:	eb05 0a43 	add.w	sl, r5, r3, lsl #1
				sfIdx = sfis->s[cb][w];
 8012ef6:	eb09 0349 	add.w	r3, r9, r9, lsl #1
 8012efa:	9a01      	ldr	r2, [sp, #4]
 8012efc:	5cd2      	ldrb	r2, [r2, r3]
				if (sfIdx == il[cb]) {
 8012efe:	ab09      	add	r3, sp, #36	; 0x24
 8012f00:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
 8012f04:	4293      	cmp	r3, r2
 8012f06:	d04a      	beq.n	8012f9e <xmp3_IntensityProcMPEG2+0x252>
					isf = (sfis->s[cb][w] + 1) >> 1;
 8012f08:	1c53      	adds	r3, r2, #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012f0a:	f012 0f01 	tst.w	r2, #1
 8012f0e:	9a03      	ldr	r2, [sp, #12]
					isf = (sfis->s[cb][w] + 1) >> 1;
 8012f10:	ea4f 0363 	mov.w	r3, r3, asr #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012f14:	d04a      	beq.n	8012fac <xmp3_IntensityProcMPEG2+0x260>
 8012f16:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 8012f1a:	4613      	mov	r3, r2
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012f1c:	681d      	ldr	r5, [r3, #0]
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8012f1e:	4653      	mov	r3, sl
 8012f20:	f9ba 6002 	ldrsh.w	r6, [sl, #2]
 8012f24:	f109 0901 	add.w	r9, r9, #1
 8012f28:	f10a 0a02 	add.w	sl, sl, #2
 8012f2c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012f30:	1af6      	subs	r6, r6, r3
				for(j = 0; j < n; j++, i+=3) {
 8012f32:	2e00      	cmp	r6, #0
 8012f34:	dd22      	ble.n	8012f7c <xmp3_IntensityProcMPEG2+0x230>
 8012f36:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8012f3a:	9b00      	ldr	r3, [sp, #0]
 8012f3c:	440e      	add	r6, r1
 8012f3e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8012f42:	eb03 0786 	add.w	r7, r3, r6, lsl #2
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 8012f46:	680b      	ldr	r3, [r1, #0]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012f48:	461a      	mov	r2, r3
 8012f4a:	fb85 8202 	smull	r8, r2, r5, r2
 8012f4e:	0092      	lsls	r2, r2, #2
 8012f50:	f8c1 2900 	str.w	r2, [r1, #2304]	; 0x900
	__asm__ volatile (
 8012f54:	ea82 7ee2 	eor.w	lr, r2, r2, asr #31
 8012f58:	ebae 7ee2 	sub.w	lr, lr, r2, asr #31
 8012f5c:	ea4b 0b0e 	orr.w	fp, fp, lr
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8012f60:	fb84 2303 	smull	r2, r3, r4, r3
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8012f64:	009b      	lsls	r3, r3, #2
 8012f66:	f841 3b0c 	str.w	r3, [r1], #12
	__asm__ volatile (
 8012f6a:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
 8012f6e:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
				for(j = 0; j < n; j++, i+=3) {
 8012f72:	42b9      	cmp	r1, r7
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 8012f74:	ea40 000c 	orr.w	r0, r0, ip
				for(j = 0; j < n; j++, i+=3) {
 8012f78:	d1e5      	bne.n	8012f46 <xmp3_IntensityProcMPEG2+0x1fa>
 8012f7a:	4631      	mov	r1, r6
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8012f7c:	9b02      	ldr	r3, [sp, #8]
 8012f7e:	454b      	cmp	r3, r9
 8012f80:	dab9      	bge.n	8012ef6 <xmp3_IntensityProcMPEG2+0x1aa>
		for(w = 0; w < 3; w++) {
 8012f82:	9b04      	ldr	r3, [sp, #16]
 8012f84:	9a01      	ldr	r2, [sp, #4]
 8012f86:	3301      	adds	r3, #1
 8012f88:	3201      	adds	r2, #1
 8012f8a:	2b03      	cmp	r3, #3
 8012f8c:	9304      	str	r3, [sp, #16]
 8012f8e:	9201      	str	r2, [sp, #4]
 8012f90:	d19a      	bne.n	8012ec8 <xmp3_IntensityProcMPEG2+0x17c>
	mOut[0] = mOutL;
 8012f92:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
	mOut[1] = mOutR;
 8012f94:	e9c3 0b00 	strd	r0, fp, [r3]
}
 8012f98:	b021      	add	sp, #132	; 0x84
 8012f9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					fl = ISFIIP[midSideFlag][0];
 8012f9e:	4b06      	ldr	r3, [pc, #24]	; (8012fb8 <xmp3_IntensityProcMPEG2+0x26c>)
 8012fa0:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 8012fa2:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
					fr = ISFIIP[midSideFlag][1];
 8012fa6:	9b05      	ldr	r3, [sp, #20]
 8012fa8:	685d      	ldr	r5, [r3, #4]
 8012faa:	e7b8      	b.n	8012f1e <xmp3_IntensityProcMPEG2+0x1d2>
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012fac:	eb02 0383 	add.w	r3, r2, r3, lsl #2
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8012fb0:	6814      	ldr	r4, [r2, #0]
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8012fb2:	e7b3      	b.n	8012f1c <xmp3_IntensityProcMPEG2+0x1d0>
 8012fb4:	08019b40 	.word	0x08019b40
 8012fb8:	08019af8 	.word	0x08019af8

08012fbc <xmp3_Subband>:
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8012fbc:	2800      	cmp	r0, #0
 8012fbe:	f000 8083 	beq.w	80130c8 <xmp3_Subband+0x10c>
 8012fc2:	68c3      	ldr	r3, [r0, #12]
 8012fc4:	2b00      	cmp	r3, #0
 8012fc6:	d07f      	beq.n	80130c8 <xmp3_Subband+0x10c>
{
 8012fc8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8012fcc:	6946      	ldr	r6, [r0, #20]
{
 8012fce:	b085      	sub	sp, #20
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8012fd0:	2e00      	cmp	r6, #0
 8012fd2:	d076      	beq.n	80130c2 <xmp3_Subband+0x106>
 8012fd4:	6987      	ldr	r7, [r0, #24]
 8012fd6:	2f00      	cmp	r7, #0
 8012fd8:	d073      	beq.n	80130c2 <xmp3_Subband+0x106>

	hi = (HuffmanInfo *)mp3DecInfo->HuffmanInfoPS;
	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);

	if (mp3DecInfo->nChans == 2) {
 8012fda:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	; 0x7bc
		/* stereo */
		for (b = 0; b < BLOCK_SIZE; b++) {
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8012fde:	f507 5400 	add.w	r4, r7, #8192	; 0x2000
 8012fe2:	460d      	mov	r5, r1
	if (mp3DecInfo->nChans == 2) {
 8012fe4:	2b02      	cmp	r3, #2
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8012fe6:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
	if (mp3DecInfo->nChans == 2) {
 8012fea:	d030      	beq.n	801304e <xmp3_Subband+0x92>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += (2 * NBANDS);
		}
	} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
 8012fec:	f04f 0900 	mov.w	r9, #0
 8012ff0:	f506 5880 	add.w	r8, r6, #4096	; 0x1000
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8012ff4:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 80130d0 <xmp3_Subband+0x114>
 8012ff8:	9603      	str	r6, [sp, #12]
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8012ffa:	f009 0b01 	and.w	fp, r9, #1
 8012ffe:	9b03      	ldr	r3, [sp, #12]
 8013000:	f8d8 6b18 	ldr.w	r6, [r8, #2840]	; 0xb18
 8013004:	4639      	mov	r1, r7
 8013006:	eb03 10c9 	add.w	r0, r3, r9, lsl #7
 801300a:	465b      	mov	r3, fp
 801300c:	9600      	str	r6, [sp, #0]
		for (b = 0; b < BLOCK_SIZE; b++) {
 801300e:	f109 0901 	add.w	r9, r9, #1
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013012:	f7fb f839 	bl	800e088 <xmp3_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013016:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 801301a:	eb0b 130b 	add.w	r3, fp, fp, lsl #4
 801301e:	4628      	mov	r0, r5
 8013020:	4652      	mov	r2, sl
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
			pcmBuf += NBANDS;
 8013022:	3540      	adds	r5, #64	; 0x40
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8013024:	eb01 1183 	add.w	r1, r1, r3, lsl #6
 8013028:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 801302c:	f7ed fb56 	bl	80006dc <xmp3_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013030:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013034:	f1b9 0f12 	cmp.w	r9, #18
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8013038:	eba2 020b 	sub.w	r2, r2, fp
 801303c:	f002 0207 	and.w	r2, r2, #7
 8013040:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013044:	d1d9      	bne.n	8012ffa <xmp3_Subband+0x3e>
		}
	}

	return 0;
 8013046:	2000      	movs	r0, #0
}
 8013048:	b005      	add	sp, #20
 801304a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801304e:	f506 6310 	add.w	r3, r6, #2304	; 0x900
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 8013052:	f107 0b80 	add.w	fp, r7, #128	; 0x80
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013056:	f04f 0900 	mov.w	r9, #0
 801305a:	f506 5880 	add.w	r8, r6, #4096	; 0x1000
 801305e:	9303      	str	r3, [sp, #12]
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8013060:	f8d8 1b18 	ldr.w	r1, [r8, #2840]	; 0xb18
 8013064:	f009 0301 	and.w	r3, r9, #1
 8013068:	4630      	mov	r0, r6
 801306a:	f109 0901 	add.w	r9, r9, #1
 801306e:	9100      	str	r1, [sp, #0]
 8013070:	4639      	mov	r1, r7
 8013072:	469a      	mov	sl, r3
 8013074:	f7fb f808 	bl	800e088 <xmp3_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 8013078:	f8d8 1b1c 	ldr.w	r1, [r8, #2844]	; 0xb1c
 801307c:	f506 6010 	add.w	r0, r6, #2304	; 0x900
 8013080:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
 8013084:	4653      	mov	r3, sl
 8013086:	9100      	str	r1, [sp, #0]
 8013088:	4659      	mov	r1, fp
 801308a:	f7fa fffd 	bl	800e088 <xmp3_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 801308e:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 8013092:	eb0a 120a 	add.w	r2, sl, sl, lsl #4
 8013096:	4628      	mov	r0, r5
		for (b = 0; b < BLOCK_SIZE; b++) {
 8013098:	3680      	adds	r6, #128	; 0x80
			pcmBuf += (2 * NBANDS);
 801309a:	3580      	adds	r5, #128	; 0x80
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 801309c:	eb01 1182 	add.w	r1, r1, r2, lsl #6
 80130a0:	4a0b      	ldr	r2, [pc, #44]	; (80130d0 <xmp3_Subband+0x114>)
 80130a2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 80130a6:	f7ed f8b3 	bl	8000210 <xmp3_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 80130aa:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 80130ae:	9b03      	ldr	r3, [sp, #12]
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 80130b0:	eba2 020a 	sub.w	r2, r2, sl
		for (b = 0; b < BLOCK_SIZE; b++) {
 80130b4:	42b3      	cmp	r3, r6
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 80130b6:	f002 0207 	and.w	r2, r2, #7
 80130ba:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 80130be:	d1cf      	bne.n	8013060 <xmp3_Subband+0xa4>
 80130c0:	e7c1      	b.n	8013046 <xmp3_Subband+0x8a>
		return -1;
 80130c2:	f04f 30ff 	mov.w	r0, #4294967295
 80130c6:	e7bf      	b.n	8013048 <xmp3_Subband+0x8c>
 80130c8:	f04f 30ff 	mov.w	r0, #4294967295
}
 80130cc:	4770      	bx	lr
 80130ce:	bf00      	nop
 80130d0:	08019ec0 	.word	0x08019ec0

080130d4 <__errno>:
 80130d4:	4b01      	ldr	r3, [pc, #4]	; (80130dc <__errno+0x8>)
 80130d6:	6818      	ldr	r0, [r3, #0]
 80130d8:	4770      	bx	lr
 80130da:	bf00      	nop
 80130dc:	20000694 	.word	0x20000694

080130e0 <__libc_init_array>:
 80130e0:	b570      	push	{r4, r5, r6, lr}
 80130e2:	4d0d      	ldr	r5, [pc, #52]	; (8013118 <__libc_init_array+0x38>)
 80130e4:	4c0d      	ldr	r4, [pc, #52]	; (801311c <__libc_init_array+0x3c>)
 80130e6:	1b64      	subs	r4, r4, r5
 80130e8:	10a4      	asrs	r4, r4, #2
 80130ea:	2600      	movs	r6, #0
 80130ec:	42a6      	cmp	r6, r4
 80130ee:	d109      	bne.n	8013104 <__libc_init_array+0x24>
 80130f0:	4d0b      	ldr	r5, [pc, #44]	; (8013120 <__libc_init_array+0x40>)
 80130f2:	4c0c      	ldr	r4, [pc, #48]	; (8013124 <__libc_init_array+0x44>)
 80130f4:	f003 fc22 	bl	801693c <_init>
 80130f8:	1b64      	subs	r4, r4, r5
 80130fa:	10a4      	asrs	r4, r4, #2
 80130fc:	2600      	movs	r6, #0
 80130fe:	42a6      	cmp	r6, r4
 8013100:	d105      	bne.n	801310e <__libc_init_array+0x2e>
 8013102:	bd70      	pop	{r4, r5, r6, pc}
 8013104:	f855 3b04 	ldr.w	r3, [r5], #4
 8013108:	4798      	blx	r3
 801310a:	3601      	adds	r6, #1
 801310c:	e7ee      	b.n	80130ec <__libc_init_array+0xc>
 801310e:	f855 3b04 	ldr.w	r3, [r5], #4
 8013112:	4798      	blx	r3
 8013114:	3601      	adds	r6, #1
 8013116:	e7f2      	b.n	80130fe <__libc_init_array+0x1e>
 8013118:	0801a6e4 	.word	0x0801a6e4
 801311c:	0801a6e4 	.word	0x0801a6e4
 8013120:	0801a6e4 	.word	0x0801a6e4
 8013124:	0801a6e8 	.word	0x0801a6e8

08013128 <memcpy>:
 8013128:	440a      	add	r2, r1
 801312a:	4291      	cmp	r1, r2
 801312c:	f100 33ff 	add.w	r3, r0, #4294967295
 8013130:	d100      	bne.n	8013134 <memcpy+0xc>
 8013132:	4770      	bx	lr
 8013134:	b510      	push	{r4, lr}
 8013136:	f811 4b01 	ldrb.w	r4, [r1], #1
 801313a:	f803 4f01 	strb.w	r4, [r3, #1]!
 801313e:	4291      	cmp	r1, r2
 8013140:	d1f9      	bne.n	8013136 <memcpy+0xe>
 8013142:	bd10      	pop	{r4, pc}

08013144 <memmove>:
 8013144:	4288      	cmp	r0, r1
 8013146:	b510      	push	{r4, lr}
 8013148:	eb01 0402 	add.w	r4, r1, r2
 801314c:	d902      	bls.n	8013154 <memmove+0x10>
 801314e:	4284      	cmp	r4, r0
 8013150:	4623      	mov	r3, r4
 8013152:	d807      	bhi.n	8013164 <memmove+0x20>
 8013154:	1e43      	subs	r3, r0, #1
 8013156:	42a1      	cmp	r1, r4
 8013158:	d008      	beq.n	801316c <memmove+0x28>
 801315a:	f811 2b01 	ldrb.w	r2, [r1], #1
 801315e:	f803 2f01 	strb.w	r2, [r3, #1]!
 8013162:	e7f8      	b.n	8013156 <memmove+0x12>
 8013164:	4402      	add	r2, r0
 8013166:	4601      	mov	r1, r0
 8013168:	428a      	cmp	r2, r1
 801316a:	d100      	bne.n	801316e <memmove+0x2a>
 801316c:	bd10      	pop	{r4, pc}
 801316e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8013172:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8013176:	e7f7      	b.n	8013168 <memmove+0x24>

08013178 <memset>:
 8013178:	4402      	add	r2, r0
 801317a:	4603      	mov	r3, r0
 801317c:	4293      	cmp	r3, r2
 801317e:	d100      	bne.n	8013182 <memset+0xa>
 8013180:	4770      	bx	lr
 8013182:	f803 1b01 	strb.w	r1, [r3], #1
 8013186:	e7f9      	b.n	801317c <memset+0x4>

08013188 <__cvt>:
 8013188:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 801318c:	ec55 4b10 	vmov	r4, r5, d0
 8013190:	2d00      	cmp	r5, #0
 8013192:	460e      	mov	r6, r1
 8013194:	4619      	mov	r1, r3
 8013196:	462b      	mov	r3, r5
 8013198:	bfbb      	ittet	lt
 801319a:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 801319e:	461d      	movlt	r5, r3
 80131a0:	2300      	movge	r3, #0
 80131a2:	232d      	movlt	r3, #45	; 0x2d
 80131a4:	700b      	strb	r3, [r1, #0]
 80131a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80131a8:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 80131ac:	4691      	mov	r9, r2
 80131ae:	f023 0820 	bic.w	r8, r3, #32
 80131b2:	bfbc      	itt	lt
 80131b4:	4622      	movlt	r2, r4
 80131b6:	4614      	movlt	r4, r2
 80131b8:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 80131bc:	d005      	beq.n	80131ca <__cvt+0x42>
 80131be:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
 80131c2:	d100      	bne.n	80131c6 <__cvt+0x3e>
 80131c4:	3601      	adds	r6, #1
 80131c6:	2102      	movs	r1, #2
 80131c8:	e000      	b.n	80131cc <__cvt+0x44>
 80131ca:	2103      	movs	r1, #3
 80131cc:	ab03      	add	r3, sp, #12
 80131ce:	9301      	str	r3, [sp, #4]
 80131d0:	ab02      	add	r3, sp, #8
 80131d2:	9300      	str	r3, [sp, #0]
 80131d4:	ec45 4b10 	vmov	d0, r4, r5
 80131d8:	4653      	mov	r3, sl
 80131da:	4632      	mov	r2, r6
 80131dc:	f000 fde4 	bl	8013da8 <_dtoa_r>
 80131e0:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 80131e4:	4607      	mov	r7, r0
 80131e6:	d102      	bne.n	80131ee <__cvt+0x66>
 80131e8:	f019 0f01 	tst.w	r9, #1
 80131ec:	d022      	beq.n	8013234 <__cvt+0xac>
 80131ee:	f1b8 0f46 	cmp.w	r8, #70	; 0x46
 80131f2:	eb07 0906 	add.w	r9, r7, r6
 80131f6:	d110      	bne.n	801321a <__cvt+0x92>
 80131f8:	783b      	ldrb	r3, [r7, #0]
 80131fa:	2b30      	cmp	r3, #48	; 0x30
 80131fc:	d10a      	bne.n	8013214 <__cvt+0x8c>
 80131fe:	2200      	movs	r2, #0
 8013200:	2300      	movs	r3, #0
 8013202:	4620      	mov	r0, r4
 8013204:	4629      	mov	r1, r5
 8013206:	f7ee f857 	bl	80012b8 <__aeabi_dcmpeq>
 801320a:	b918      	cbnz	r0, 8013214 <__cvt+0x8c>
 801320c:	f1c6 0601 	rsb	r6, r6, #1
 8013210:	f8ca 6000 	str.w	r6, [sl]
 8013214:	f8da 3000 	ldr.w	r3, [sl]
 8013218:	4499      	add	r9, r3
 801321a:	2200      	movs	r2, #0
 801321c:	2300      	movs	r3, #0
 801321e:	4620      	mov	r0, r4
 8013220:	4629      	mov	r1, r5
 8013222:	f7ee f849 	bl	80012b8 <__aeabi_dcmpeq>
 8013226:	b108      	cbz	r0, 801322c <__cvt+0xa4>
 8013228:	f8cd 900c 	str.w	r9, [sp, #12]
 801322c:	2230      	movs	r2, #48	; 0x30
 801322e:	9b03      	ldr	r3, [sp, #12]
 8013230:	454b      	cmp	r3, r9
 8013232:	d307      	bcc.n	8013244 <__cvt+0xbc>
 8013234:	9b03      	ldr	r3, [sp, #12]
 8013236:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8013238:	1bdb      	subs	r3, r3, r7
 801323a:	4638      	mov	r0, r7
 801323c:	6013      	str	r3, [r2, #0]
 801323e:	b004      	add	sp, #16
 8013240:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8013244:	1c59      	adds	r1, r3, #1
 8013246:	9103      	str	r1, [sp, #12]
 8013248:	701a      	strb	r2, [r3, #0]
 801324a:	e7f0      	b.n	801322e <__cvt+0xa6>

0801324c <__exponent>:
 801324c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801324e:	4603      	mov	r3, r0
 8013250:	2900      	cmp	r1, #0
 8013252:	bfb8      	it	lt
 8013254:	4249      	neglt	r1, r1
 8013256:	f803 2b02 	strb.w	r2, [r3], #2
 801325a:	bfb4      	ite	lt
 801325c:	222d      	movlt	r2, #45	; 0x2d
 801325e:	222b      	movge	r2, #43	; 0x2b
 8013260:	2909      	cmp	r1, #9
 8013262:	7042      	strb	r2, [r0, #1]
 8013264:	dd2a      	ble.n	80132bc <__exponent+0x70>
 8013266:	f10d 0407 	add.w	r4, sp, #7
 801326a:	46a4      	mov	ip, r4
 801326c:	270a      	movs	r7, #10
 801326e:	46a6      	mov	lr, r4
 8013270:	460a      	mov	r2, r1
 8013272:	fb91 f6f7 	sdiv	r6, r1, r7
 8013276:	fb07 1516 	mls	r5, r7, r6, r1
 801327a:	3530      	adds	r5, #48	; 0x30
 801327c:	2a63      	cmp	r2, #99	; 0x63
 801327e:	f104 34ff 	add.w	r4, r4, #4294967295
 8013282:	f80e 5c01 	strb.w	r5, [lr, #-1]
 8013286:	4631      	mov	r1, r6
 8013288:	dcf1      	bgt.n	801326e <__exponent+0x22>
 801328a:	3130      	adds	r1, #48	; 0x30
 801328c:	f1ae 0502 	sub.w	r5, lr, #2
 8013290:	f804 1c01 	strb.w	r1, [r4, #-1]
 8013294:	1c44      	adds	r4, r0, #1
 8013296:	4629      	mov	r1, r5
 8013298:	4561      	cmp	r1, ip
 801329a:	d30a      	bcc.n	80132b2 <__exponent+0x66>
 801329c:	f10d 0209 	add.w	r2, sp, #9
 80132a0:	eba2 020e 	sub.w	r2, r2, lr
 80132a4:	4565      	cmp	r5, ip
 80132a6:	bf88      	it	hi
 80132a8:	2200      	movhi	r2, #0
 80132aa:	4413      	add	r3, r2
 80132ac:	1a18      	subs	r0, r3, r0
 80132ae:	b003      	add	sp, #12
 80132b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80132b2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80132b6:	f804 2f01 	strb.w	r2, [r4, #1]!
 80132ba:	e7ed      	b.n	8013298 <__exponent+0x4c>
 80132bc:	2330      	movs	r3, #48	; 0x30
 80132be:	3130      	adds	r1, #48	; 0x30
 80132c0:	7083      	strb	r3, [r0, #2]
 80132c2:	70c1      	strb	r1, [r0, #3]
 80132c4:	1d03      	adds	r3, r0, #4
 80132c6:	e7f1      	b.n	80132ac <__exponent+0x60>

080132c8 <_printf_float>:
 80132c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80132cc:	ed2d 8b02 	vpush	{d8}
 80132d0:	b08d      	sub	sp, #52	; 0x34
 80132d2:	460c      	mov	r4, r1
 80132d4:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
 80132d8:	4616      	mov	r6, r2
 80132da:	461f      	mov	r7, r3
 80132dc:	4605      	mov	r5, r0
 80132de:	f001 fb51 	bl	8014984 <_localeconv_r>
 80132e2:	f8d0 a000 	ldr.w	sl, [r0]
 80132e6:	4650      	mov	r0, sl
 80132e8:	f7ed fb67 	bl	80009ba <strlen>
 80132ec:	2300      	movs	r3, #0
 80132ee:	930a      	str	r3, [sp, #40]	; 0x28
 80132f0:	6823      	ldr	r3, [r4, #0]
 80132f2:	9305      	str	r3, [sp, #20]
 80132f4:	f8d8 3000 	ldr.w	r3, [r8]
 80132f8:	f894 b018 	ldrb.w	fp, [r4, #24]
 80132fc:	3307      	adds	r3, #7
 80132fe:	f023 0307 	bic.w	r3, r3, #7
 8013302:	f103 0208 	add.w	r2, r3, #8
 8013306:	f8c8 2000 	str.w	r2, [r8]
 801330a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801330e:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
 8013312:	e9d4 8912 	ldrd	r8, r9, [r4, #72]	; 0x48
 8013316:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 801331a:	9307      	str	r3, [sp, #28]
 801331c:	f8cd 8018 	str.w	r8, [sp, #24]
 8013320:	ee08 0a10 	vmov	s16, r0
 8013324:	4b9f      	ldr	r3, [pc, #636]	; (80135a4 <_printf_float+0x2dc>)
 8013326:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801332a:	f04f 32ff 	mov.w	r2, #4294967295
 801332e:	f7ed fff5 	bl	800131c <__aeabi_dcmpun>
 8013332:	bb88      	cbnz	r0, 8013398 <_printf_float+0xd0>
 8013334:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8013338:	4b9a      	ldr	r3, [pc, #616]	; (80135a4 <_printf_float+0x2dc>)
 801333a:	f04f 32ff 	mov.w	r2, #4294967295
 801333e:	f7ed ffcf 	bl	80012e0 <__aeabi_dcmple>
 8013342:	bb48      	cbnz	r0, 8013398 <_printf_float+0xd0>
 8013344:	2200      	movs	r2, #0
 8013346:	2300      	movs	r3, #0
 8013348:	4640      	mov	r0, r8
 801334a:	4649      	mov	r1, r9
 801334c:	f7ed ffbe 	bl	80012cc <__aeabi_dcmplt>
 8013350:	b110      	cbz	r0, 8013358 <_printf_float+0x90>
 8013352:	232d      	movs	r3, #45	; 0x2d
 8013354:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8013358:	4b93      	ldr	r3, [pc, #588]	; (80135a8 <_printf_float+0x2e0>)
 801335a:	4894      	ldr	r0, [pc, #592]	; (80135ac <_printf_float+0x2e4>)
 801335c:	f1bb 0f47 	cmp.w	fp, #71	; 0x47
 8013360:	bf94      	ite	ls
 8013362:	4698      	movls	r8, r3
 8013364:	4680      	movhi	r8, r0
 8013366:	2303      	movs	r3, #3
 8013368:	6123      	str	r3, [r4, #16]
 801336a:	9b05      	ldr	r3, [sp, #20]
 801336c:	f023 0204 	bic.w	r2, r3, #4
 8013370:	6022      	str	r2, [r4, #0]
 8013372:	f04f 0900 	mov.w	r9, #0
 8013376:	9700      	str	r7, [sp, #0]
 8013378:	4633      	mov	r3, r6
 801337a:	aa0b      	add	r2, sp, #44	; 0x2c
 801337c:	4621      	mov	r1, r4
 801337e:	4628      	mov	r0, r5
 8013380:	f000 f9d8 	bl	8013734 <_printf_common>
 8013384:	3001      	adds	r0, #1
 8013386:	f040 8090 	bne.w	80134aa <_printf_float+0x1e2>
 801338a:	f04f 30ff 	mov.w	r0, #4294967295
 801338e:	b00d      	add	sp, #52	; 0x34
 8013390:	ecbd 8b02 	vpop	{d8}
 8013394:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013398:	4642      	mov	r2, r8
 801339a:	464b      	mov	r3, r9
 801339c:	4640      	mov	r0, r8
 801339e:	4649      	mov	r1, r9
 80133a0:	f7ed ffbc 	bl	800131c <__aeabi_dcmpun>
 80133a4:	b140      	cbz	r0, 80133b8 <_printf_float+0xf0>
 80133a6:	464b      	mov	r3, r9
 80133a8:	2b00      	cmp	r3, #0
 80133aa:	bfbc      	itt	lt
 80133ac:	232d      	movlt	r3, #45	; 0x2d
 80133ae:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
 80133b2:	487f      	ldr	r0, [pc, #508]	; (80135b0 <_printf_float+0x2e8>)
 80133b4:	4b7f      	ldr	r3, [pc, #508]	; (80135b4 <_printf_float+0x2ec>)
 80133b6:	e7d1      	b.n	801335c <_printf_float+0x94>
 80133b8:	6863      	ldr	r3, [r4, #4]
 80133ba:	f00b 02df 	and.w	r2, fp, #223	; 0xdf
 80133be:	9206      	str	r2, [sp, #24]
 80133c0:	1c5a      	adds	r2, r3, #1
 80133c2:	d13f      	bne.n	8013444 <_printf_float+0x17c>
 80133c4:	2306      	movs	r3, #6
 80133c6:	6063      	str	r3, [r4, #4]
 80133c8:	9b05      	ldr	r3, [sp, #20]
 80133ca:	6861      	ldr	r1, [r4, #4]
 80133cc:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 80133d0:	2300      	movs	r3, #0
 80133d2:	9303      	str	r3, [sp, #12]
 80133d4:	ab0a      	add	r3, sp, #40	; 0x28
 80133d6:	e9cd b301 	strd	fp, r3, [sp, #4]
 80133da:	ab09      	add	r3, sp, #36	; 0x24
 80133dc:	ec49 8b10 	vmov	d0, r8, r9
 80133e0:	9300      	str	r3, [sp, #0]
 80133e2:	6022      	str	r2, [r4, #0]
 80133e4:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 80133e8:	4628      	mov	r0, r5
 80133ea:	f7ff fecd 	bl	8013188 <__cvt>
 80133ee:	9b06      	ldr	r3, [sp, #24]
 80133f0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80133f2:	2b47      	cmp	r3, #71	; 0x47
 80133f4:	4680      	mov	r8, r0
 80133f6:	d108      	bne.n	801340a <_printf_float+0x142>
 80133f8:	1cc8      	adds	r0, r1, #3
 80133fa:	db02      	blt.n	8013402 <_printf_float+0x13a>
 80133fc:	6863      	ldr	r3, [r4, #4]
 80133fe:	4299      	cmp	r1, r3
 8013400:	dd41      	ble.n	8013486 <_printf_float+0x1be>
 8013402:	f1ab 0b02 	sub.w	fp, fp, #2
 8013406:	fa5f fb8b 	uxtb.w	fp, fp
 801340a:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 801340e:	d820      	bhi.n	8013452 <_printf_float+0x18a>
 8013410:	3901      	subs	r1, #1
 8013412:	465a      	mov	r2, fp
 8013414:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8013418:	9109      	str	r1, [sp, #36]	; 0x24
 801341a:	f7ff ff17 	bl	801324c <__exponent>
 801341e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8013420:	1813      	adds	r3, r2, r0
 8013422:	2a01      	cmp	r2, #1
 8013424:	4681      	mov	r9, r0
 8013426:	6123      	str	r3, [r4, #16]
 8013428:	dc02      	bgt.n	8013430 <_printf_float+0x168>
 801342a:	6822      	ldr	r2, [r4, #0]
 801342c:	07d2      	lsls	r2, r2, #31
 801342e:	d501      	bpl.n	8013434 <_printf_float+0x16c>
 8013430:	3301      	adds	r3, #1
 8013432:	6123      	str	r3, [r4, #16]
 8013434:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8013438:	2b00      	cmp	r3, #0
 801343a:	d09c      	beq.n	8013376 <_printf_float+0xae>
 801343c:	232d      	movs	r3, #45	; 0x2d
 801343e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8013442:	e798      	b.n	8013376 <_printf_float+0xae>
 8013444:	9a06      	ldr	r2, [sp, #24]
 8013446:	2a47      	cmp	r2, #71	; 0x47
 8013448:	d1be      	bne.n	80133c8 <_printf_float+0x100>
 801344a:	2b00      	cmp	r3, #0
 801344c:	d1bc      	bne.n	80133c8 <_printf_float+0x100>
 801344e:	2301      	movs	r3, #1
 8013450:	e7b9      	b.n	80133c6 <_printf_float+0xfe>
 8013452:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8013456:	d118      	bne.n	801348a <_printf_float+0x1c2>
 8013458:	2900      	cmp	r1, #0
 801345a:	6863      	ldr	r3, [r4, #4]
 801345c:	dd0b      	ble.n	8013476 <_printf_float+0x1ae>
 801345e:	6121      	str	r1, [r4, #16]
 8013460:	b913      	cbnz	r3, 8013468 <_printf_float+0x1a0>
 8013462:	6822      	ldr	r2, [r4, #0]
 8013464:	07d0      	lsls	r0, r2, #31
 8013466:	d502      	bpl.n	801346e <_printf_float+0x1a6>
 8013468:	3301      	adds	r3, #1
 801346a:	440b      	add	r3, r1
 801346c:	6123      	str	r3, [r4, #16]
 801346e:	65a1      	str	r1, [r4, #88]	; 0x58
 8013470:	f04f 0900 	mov.w	r9, #0
 8013474:	e7de      	b.n	8013434 <_printf_float+0x16c>
 8013476:	b913      	cbnz	r3, 801347e <_printf_float+0x1b6>
 8013478:	6822      	ldr	r2, [r4, #0]
 801347a:	07d2      	lsls	r2, r2, #31
 801347c:	d501      	bpl.n	8013482 <_printf_float+0x1ba>
 801347e:	3302      	adds	r3, #2
 8013480:	e7f4      	b.n	801346c <_printf_float+0x1a4>
 8013482:	2301      	movs	r3, #1
 8013484:	e7f2      	b.n	801346c <_printf_float+0x1a4>
 8013486:	f04f 0b67 	mov.w	fp, #103	; 0x67
 801348a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801348c:	4299      	cmp	r1, r3
 801348e:	db05      	blt.n	801349c <_printf_float+0x1d4>
 8013490:	6823      	ldr	r3, [r4, #0]
 8013492:	6121      	str	r1, [r4, #16]
 8013494:	07d8      	lsls	r0, r3, #31
 8013496:	d5ea      	bpl.n	801346e <_printf_float+0x1a6>
 8013498:	1c4b      	adds	r3, r1, #1
 801349a:	e7e7      	b.n	801346c <_printf_float+0x1a4>
 801349c:	2900      	cmp	r1, #0
 801349e:	bfd4      	ite	le
 80134a0:	f1c1 0202 	rsble	r2, r1, #2
 80134a4:	2201      	movgt	r2, #1
 80134a6:	4413      	add	r3, r2
 80134a8:	e7e0      	b.n	801346c <_printf_float+0x1a4>
 80134aa:	6823      	ldr	r3, [r4, #0]
 80134ac:	055a      	lsls	r2, r3, #21
 80134ae:	d407      	bmi.n	80134c0 <_printf_float+0x1f8>
 80134b0:	6923      	ldr	r3, [r4, #16]
 80134b2:	4642      	mov	r2, r8
 80134b4:	4631      	mov	r1, r6
 80134b6:	4628      	mov	r0, r5
 80134b8:	47b8      	blx	r7
 80134ba:	3001      	adds	r0, #1
 80134bc:	d12c      	bne.n	8013518 <_printf_float+0x250>
 80134be:	e764      	b.n	801338a <_printf_float+0xc2>
 80134c0:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 80134c4:	f240 80e0 	bls.w	8013688 <_printf_float+0x3c0>
 80134c8:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 80134cc:	2200      	movs	r2, #0
 80134ce:	2300      	movs	r3, #0
 80134d0:	f7ed fef2 	bl	80012b8 <__aeabi_dcmpeq>
 80134d4:	2800      	cmp	r0, #0
 80134d6:	d034      	beq.n	8013542 <_printf_float+0x27a>
 80134d8:	4a37      	ldr	r2, [pc, #220]	; (80135b8 <_printf_float+0x2f0>)
 80134da:	2301      	movs	r3, #1
 80134dc:	4631      	mov	r1, r6
 80134de:	4628      	mov	r0, r5
 80134e0:	47b8      	blx	r7
 80134e2:	3001      	adds	r0, #1
 80134e4:	f43f af51 	beq.w	801338a <_printf_float+0xc2>
 80134e8:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 80134ec:	429a      	cmp	r2, r3
 80134ee:	db02      	blt.n	80134f6 <_printf_float+0x22e>
 80134f0:	6823      	ldr	r3, [r4, #0]
 80134f2:	07d8      	lsls	r0, r3, #31
 80134f4:	d510      	bpl.n	8013518 <_printf_float+0x250>
 80134f6:	ee18 3a10 	vmov	r3, s16
 80134fa:	4652      	mov	r2, sl
 80134fc:	4631      	mov	r1, r6
 80134fe:	4628      	mov	r0, r5
 8013500:	47b8      	blx	r7
 8013502:	3001      	adds	r0, #1
 8013504:	f43f af41 	beq.w	801338a <_printf_float+0xc2>
 8013508:	f04f 0800 	mov.w	r8, #0
 801350c:	f104 091a 	add.w	r9, r4, #26
 8013510:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013512:	3b01      	subs	r3, #1
 8013514:	4543      	cmp	r3, r8
 8013516:	dc09      	bgt.n	801352c <_printf_float+0x264>
 8013518:	6823      	ldr	r3, [r4, #0]
 801351a:	079b      	lsls	r3, r3, #30
 801351c:	f100 8105 	bmi.w	801372a <_printf_float+0x462>
 8013520:	68e0      	ldr	r0, [r4, #12]
 8013522:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013524:	4298      	cmp	r0, r3
 8013526:	bfb8      	it	lt
 8013528:	4618      	movlt	r0, r3
 801352a:	e730      	b.n	801338e <_printf_float+0xc6>
 801352c:	2301      	movs	r3, #1
 801352e:	464a      	mov	r2, r9
 8013530:	4631      	mov	r1, r6
 8013532:	4628      	mov	r0, r5
 8013534:	47b8      	blx	r7
 8013536:	3001      	adds	r0, #1
 8013538:	f43f af27 	beq.w	801338a <_printf_float+0xc2>
 801353c:	f108 0801 	add.w	r8, r8, #1
 8013540:	e7e6      	b.n	8013510 <_printf_float+0x248>
 8013542:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013544:	2b00      	cmp	r3, #0
 8013546:	dc39      	bgt.n	80135bc <_printf_float+0x2f4>
 8013548:	4a1b      	ldr	r2, [pc, #108]	; (80135b8 <_printf_float+0x2f0>)
 801354a:	2301      	movs	r3, #1
 801354c:	4631      	mov	r1, r6
 801354e:	4628      	mov	r0, r5
 8013550:	47b8      	blx	r7
 8013552:	3001      	adds	r0, #1
 8013554:	f43f af19 	beq.w	801338a <_printf_float+0xc2>
 8013558:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801355c:	4313      	orrs	r3, r2
 801355e:	d102      	bne.n	8013566 <_printf_float+0x29e>
 8013560:	6823      	ldr	r3, [r4, #0]
 8013562:	07d9      	lsls	r1, r3, #31
 8013564:	d5d8      	bpl.n	8013518 <_printf_float+0x250>
 8013566:	ee18 3a10 	vmov	r3, s16
 801356a:	4652      	mov	r2, sl
 801356c:	4631      	mov	r1, r6
 801356e:	4628      	mov	r0, r5
 8013570:	47b8      	blx	r7
 8013572:	3001      	adds	r0, #1
 8013574:	f43f af09 	beq.w	801338a <_printf_float+0xc2>
 8013578:	f04f 0900 	mov.w	r9, #0
 801357c:	f104 0a1a 	add.w	sl, r4, #26
 8013580:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013582:	425b      	negs	r3, r3
 8013584:	454b      	cmp	r3, r9
 8013586:	dc01      	bgt.n	801358c <_printf_float+0x2c4>
 8013588:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801358a:	e792      	b.n	80134b2 <_printf_float+0x1ea>
 801358c:	2301      	movs	r3, #1
 801358e:	4652      	mov	r2, sl
 8013590:	4631      	mov	r1, r6
 8013592:	4628      	mov	r0, r5
 8013594:	47b8      	blx	r7
 8013596:	3001      	adds	r0, #1
 8013598:	f43f aef7 	beq.w	801338a <_printf_float+0xc2>
 801359c:	f109 0901 	add.w	r9, r9, #1
 80135a0:	e7ee      	b.n	8013580 <_printf_float+0x2b8>
 80135a2:	bf00      	nop
 80135a4:	7fefffff 	.word	0x7fefffff
 80135a8:	0801a2e4 	.word	0x0801a2e4
 80135ac:	0801a2e8 	.word	0x0801a2e8
 80135b0:	0801a2f0 	.word	0x0801a2f0
 80135b4:	0801a2ec 	.word	0x0801a2ec
 80135b8:	0801a519 	.word	0x0801a519
 80135bc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80135be:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80135c0:	429a      	cmp	r2, r3
 80135c2:	bfa8      	it	ge
 80135c4:	461a      	movge	r2, r3
 80135c6:	2a00      	cmp	r2, #0
 80135c8:	4691      	mov	r9, r2
 80135ca:	dc37      	bgt.n	801363c <_printf_float+0x374>
 80135cc:	f04f 0b00 	mov.w	fp, #0
 80135d0:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 80135d4:	f104 021a 	add.w	r2, r4, #26
 80135d8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80135da:	9305      	str	r3, [sp, #20]
 80135dc:	eba3 0309 	sub.w	r3, r3, r9
 80135e0:	455b      	cmp	r3, fp
 80135e2:	dc33      	bgt.n	801364c <_printf_float+0x384>
 80135e4:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 80135e8:	429a      	cmp	r2, r3
 80135ea:	db3b      	blt.n	8013664 <_printf_float+0x39c>
 80135ec:	6823      	ldr	r3, [r4, #0]
 80135ee:	07da      	lsls	r2, r3, #31
 80135f0:	d438      	bmi.n	8013664 <_printf_float+0x39c>
 80135f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80135f4:	9a05      	ldr	r2, [sp, #20]
 80135f6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80135f8:	1a9a      	subs	r2, r3, r2
 80135fa:	eba3 0901 	sub.w	r9, r3, r1
 80135fe:	4591      	cmp	r9, r2
 8013600:	bfa8      	it	ge
 8013602:	4691      	movge	r9, r2
 8013604:	f1b9 0f00 	cmp.w	r9, #0
 8013608:	dc35      	bgt.n	8013676 <_printf_float+0x3ae>
 801360a:	f04f 0800 	mov.w	r8, #0
 801360e:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 8013612:	f104 0a1a 	add.w	sl, r4, #26
 8013616:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
 801361a:	1a9b      	subs	r3, r3, r2
 801361c:	eba3 0309 	sub.w	r3, r3, r9
 8013620:	4543      	cmp	r3, r8
 8013622:	f77f af79 	ble.w	8013518 <_printf_float+0x250>
 8013626:	2301      	movs	r3, #1
 8013628:	4652      	mov	r2, sl
 801362a:	4631      	mov	r1, r6
 801362c:	4628      	mov	r0, r5
 801362e:	47b8      	blx	r7
 8013630:	3001      	adds	r0, #1
 8013632:	f43f aeaa 	beq.w	801338a <_printf_float+0xc2>
 8013636:	f108 0801 	add.w	r8, r8, #1
 801363a:	e7ec      	b.n	8013616 <_printf_float+0x34e>
 801363c:	4613      	mov	r3, r2
 801363e:	4631      	mov	r1, r6
 8013640:	4642      	mov	r2, r8
 8013642:	4628      	mov	r0, r5
 8013644:	47b8      	blx	r7
 8013646:	3001      	adds	r0, #1
 8013648:	d1c0      	bne.n	80135cc <_printf_float+0x304>
 801364a:	e69e      	b.n	801338a <_printf_float+0xc2>
 801364c:	2301      	movs	r3, #1
 801364e:	4631      	mov	r1, r6
 8013650:	4628      	mov	r0, r5
 8013652:	9205      	str	r2, [sp, #20]
 8013654:	47b8      	blx	r7
 8013656:	3001      	adds	r0, #1
 8013658:	f43f ae97 	beq.w	801338a <_printf_float+0xc2>
 801365c:	9a05      	ldr	r2, [sp, #20]
 801365e:	f10b 0b01 	add.w	fp, fp, #1
 8013662:	e7b9      	b.n	80135d8 <_printf_float+0x310>
 8013664:	ee18 3a10 	vmov	r3, s16
 8013668:	4652      	mov	r2, sl
 801366a:	4631      	mov	r1, r6
 801366c:	4628      	mov	r0, r5
 801366e:	47b8      	blx	r7
 8013670:	3001      	adds	r0, #1
 8013672:	d1be      	bne.n	80135f2 <_printf_float+0x32a>
 8013674:	e689      	b.n	801338a <_printf_float+0xc2>
 8013676:	9a05      	ldr	r2, [sp, #20]
 8013678:	464b      	mov	r3, r9
 801367a:	4442      	add	r2, r8
 801367c:	4631      	mov	r1, r6
 801367e:	4628      	mov	r0, r5
 8013680:	47b8      	blx	r7
 8013682:	3001      	adds	r0, #1
 8013684:	d1c1      	bne.n	801360a <_printf_float+0x342>
 8013686:	e680      	b.n	801338a <_printf_float+0xc2>
 8013688:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801368a:	2a01      	cmp	r2, #1
 801368c:	dc01      	bgt.n	8013692 <_printf_float+0x3ca>
 801368e:	07db      	lsls	r3, r3, #31
 8013690:	d538      	bpl.n	8013704 <_printf_float+0x43c>
 8013692:	2301      	movs	r3, #1
 8013694:	4642      	mov	r2, r8
 8013696:	4631      	mov	r1, r6
 8013698:	4628      	mov	r0, r5
 801369a:	47b8      	blx	r7
 801369c:	3001      	adds	r0, #1
 801369e:	f43f ae74 	beq.w	801338a <_printf_float+0xc2>
 80136a2:	ee18 3a10 	vmov	r3, s16
 80136a6:	4652      	mov	r2, sl
 80136a8:	4631      	mov	r1, r6
 80136aa:	4628      	mov	r0, r5
 80136ac:	47b8      	blx	r7
 80136ae:	3001      	adds	r0, #1
 80136b0:	f43f ae6b 	beq.w	801338a <_printf_float+0xc2>
 80136b4:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
 80136b8:	2200      	movs	r2, #0
 80136ba:	2300      	movs	r3, #0
 80136bc:	f7ed fdfc 	bl	80012b8 <__aeabi_dcmpeq>
 80136c0:	b9d8      	cbnz	r0, 80136fa <_printf_float+0x432>
 80136c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80136c4:	f108 0201 	add.w	r2, r8, #1
 80136c8:	3b01      	subs	r3, #1
 80136ca:	4631      	mov	r1, r6
 80136cc:	4628      	mov	r0, r5
 80136ce:	47b8      	blx	r7
 80136d0:	3001      	adds	r0, #1
 80136d2:	d10e      	bne.n	80136f2 <_printf_float+0x42a>
 80136d4:	e659      	b.n	801338a <_printf_float+0xc2>
 80136d6:	2301      	movs	r3, #1
 80136d8:	4652      	mov	r2, sl
 80136da:	4631      	mov	r1, r6
 80136dc:	4628      	mov	r0, r5
 80136de:	47b8      	blx	r7
 80136e0:	3001      	adds	r0, #1
 80136e2:	f43f ae52 	beq.w	801338a <_printf_float+0xc2>
 80136e6:	f108 0801 	add.w	r8, r8, #1
 80136ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80136ec:	3b01      	subs	r3, #1
 80136ee:	4543      	cmp	r3, r8
 80136f0:	dcf1      	bgt.n	80136d6 <_printf_float+0x40e>
 80136f2:	464b      	mov	r3, r9
 80136f4:	f104 0250 	add.w	r2, r4, #80	; 0x50
 80136f8:	e6dc      	b.n	80134b4 <_printf_float+0x1ec>
 80136fa:	f04f 0800 	mov.w	r8, #0
 80136fe:	f104 0a1a 	add.w	sl, r4, #26
 8013702:	e7f2      	b.n	80136ea <_printf_float+0x422>
 8013704:	2301      	movs	r3, #1
 8013706:	4642      	mov	r2, r8
 8013708:	e7df      	b.n	80136ca <_printf_float+0x402>
 801370a:	2301      	movs	r3, #1
 801370c:	464a      	mov	r2, r9
 801370e:	4631      	mov	r1, r6
 8013710:	4628      	mov	r0, r5
 8013712:	47b8      	blx	r7
 8013714:	3001      	adds	r0, #1
 8013716:	f43f ae38 	beq.w	801338a <_printf_float+0xc2>
 801371a:	f108 0801 	add.w	r8, r8, #1
 801371e:	68e3      	ldr	r3, [r4, #12]
 8013720:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8013722:	1a5b      	subs	r3, r3, r1
 8013724:	4543      	cmp	r3, r8
 8013726:	dcf0      	bgt.n	801370a <_printf_float+0x442>
 8013728:	e6fa      	b.n	8013520 <_printf_float+0x258>
 801372a:	f04f 0800 	mov.w	r8, #0
 801372e:	f104 0919 	add.w	r9, r4, #25
 8013732:	e7f4      	b.n	801371e <_printf_float+0x456>

08013734 <_printf_common>:
 8013734:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013738:	4616      	mov	r6, r2
 801373a:	4699      	mov	r9, r3
 801373c:	688a      	ldr	r2, [r1, #8]
 801373e:	690b      	ldr	r3, [r1, #16]
 8013740:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8013744:	4293      	cmp	r3, r2
 8013746:	bfb8      	it	lt
 8013748:	4613      	movlt	r3, r2
 801374a:	6033      	str	r3, [r6, #0]
 801374c:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8013750:	4607      	mov	r7, r0
 8013752:	460c      	mov	r4, r1
 8013754:	b10a      	cbz	r2, 801375a <_printf_common+0x26>
 8013756:	3301      	adds	r3, #1
 8013758:	6033      	str	r3, [r6, #0]
 801375a:	6823      	ldr	r3, [r4, #0]
 801375c:	0699      	lsls	r1, r3, #26
 801375e:	bf42      	ittt	mi
 8013760:	6833      	ldrmi	r3, [r6, #0]
 8013762:	3302      	addmi	r3, #2
 8013764:	6033      	strmi	r3, [r6, #0]
 8013766:	6825      	ldr	r5, [r4, #0]
 8013768:	f015 0506 	ands.w	r5, r5, #6
 801376c:	d106      	bne.n	801377c <_printf_common+0x48>
 801376e:	f104 0a19 	add.w	sl, r4, #25
 8013772:	68e3      	ldr	r3, [r4, #12]
 8013774:	6832      	ldr	r2, [r6, #0]
 8013776:	1a9b      	subs	r3, r3, r2
 8013778:	42ab      	cmp	r3, r5
 801377a:	dc26      	bgt.n	80137ca <_printf_common+0x96>
 801377c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8013780:	1e13      	subs	r3, r2, #0
 8013782:	6822      	ldr	r2, [r4, #0]
 8013784:	bf18      	it	ne
 8013786:	2301      	movne	r3, #1
 8013788:	0692      	lsls	r2, r2, #26
 801378a:	d42b      	bmi.n	80137e4 <_printf_common+0xb0>
 801378c:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8013790:	4649      	mov	r1, r9
 8013792:	4638      	mov	r0, r7
 8013794:	47c0      	blx	r8
 8013796:	3001      	adds	r0, #1
 8013798:	d01e      	beq.n	80137d8 <_printf_common+0xa4>
 801379a:	6823      	ldr	r3, [r4, #0]
 801379c:	68e5      	ldr	r5, [r4, #12]
 801379e:	6832      	ldr	r2, [r6, #0]
 80137a0:	f003 0306 	and.w	r3, r3, #6
 80137a4:	2b04      	cmp	r3, #4
 80137a6:	bf08      	it	eq
 80137a8:	1aad      	subeq	r5, r5, r2
 80137aa:	68a3      	ldr	r3, [r4, #8]
 80137ac:	6922      	ldr	r2, [r4, #16]
 80137ae:	bf0c      	ite	eq
 80137b0:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80137b4:	2500      	movne	r5, #0
 80137b6:	4293      	cmp	r3, r2
 80137b8:	bfc4      	itt	gt
 80137ba:	1a9b      	subgt	r3, r3, r2
 80137bc:	18ed      	addgt	r5, r5, r3
 80137be:	2600      	movs	r6, #0
 80137c0:	341a      	adds	r4, #26
 80137c2:	42b5      	cmp	r5, r6
 80137c4:	d11a      	bne.n	80137fc <_printf_common+0xc8>
 80137c6:	2000      	movs	r0, #0
 80137c8:	e008      	b.n	80137dc <_printf_common+0xa8>
 80137ca:	2301      	movs	r3, #1
 80137cc:	4652      	mov	r2, sl
 80137ce:	4649      	mov	r1, r9
 80137d0:	4638      	mov	r0, r7
 80137d2:	47c0      	blx	r8
 80137d4:	3001      	adds	r0, #1
 80137d6:	d103      	bne.n	80137e0 <_printf_common+0xac>
 80137d8:	f04f 30ff 	mov.w	r0, #4294967295
 80137dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80137e0:	3501      	adds	r5, #1
 80137e2:	e7c6      	b.n	8013772 <_printf_common+0x3e>
 80137e4:	18e1      	adds	r1, r4, r3
 80137e6:	1c5a      	adds	r2, r3, #1
 80137e8:	2030      	movs	r0, #48	; 0x30
 80137ea:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80137ee:	4422      	add	r2, r4
 80137f0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80137f4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80137f8:	3302      	adds	r3, #2
 80137fa:	e7c7      	b.n	801378c <_printf_common+0x58>
 80137fc:	2301      	movs	r3, #1
 80137fe:	4622      	mov	r2, r4
 8013800:	4649      	mov	r1, r9
 8013802:	4638      	mov	r0, r7
 8013804:	47c0      	blx	r8
 8013806:	3001      	adds	r0, #1
 8013808:	d0e6      	beq.n	80137d8 <_printf_common+0xa4>
 801380a:	3601      	adds	r6, #1
 801380c:	e7d9      	b.n	80137c2 <_printf_common+0x8e>
	...

08013810 <_printf_i>:
 8013810:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8013814:	7e0f      	ldrb	r7, [r1, #24]
 8013816:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8013818:	2f78      	cmp	r7, #120	; 0x78
 801381a:	4691      	mov	r9, r2
 801381c:	4680      	mov	r8, r0
 801381e:	460c      	mov	r4, r1
 8013820:	469a      	mov	sl, r3
 8013822:	f101 0243 	add.w	r2, r1, #67	; 0x43
 8013826:	d807      	bhi.n	8013838 <_printf_i+0x28>
 8013828:	2f62      	cmp	r7, #98	; 0x62
 801382a:	d80a      	bhi.n	8013842 <_printf_i+0x32>
 801382c:	2f00      	cmp	r7, #0
 801382e:	f000 80d8 	beq.w	80139e2 <_printf_i+0x1d2>
 8013832:	2f58      	cmp	r7, #88	; 0x58
 8013834:	f000 80a3 	beq.w	801397e <_printf_i+0x16e>
 8013838:	f104 0542 	add.w	r5, r4, #66	; 0x42
 801383c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 8013840:	e03a      	b.n	80138b8 <_printf_i+0xa8>
 8013842:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 8013846:	2b15      	cmp	r3, #21
 8013848:	d8f6      	bhi.n	8013838 <_printf_i+0x28>
 801384a:	a101      	add	r1, pc, #4	; (adr r1, 8013850 <_printf_i+0x40>)
 801384c:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8013850:	080138a9 	.word	0x080138a9
 8013854:	080138bd 	.word	0x080138bd
 8013858:	08013839 	.word	0x08013839
 801385c:	08013839 	.word	0x08013839
 8013860:	08013839 	.word	0x08013839
 8013864:	08013839 	.word	0x08013839
 8013868:	080138bd 	.word	0x080138bd
 801386c:	08013839 	.word	0x08013839
 8013870:	08013839 	.word	0x08013839
 8013874:	08013839 	.word	0x08013839
 8013878:	08013839 	.word	0x08013839
 801387c:	080139c9 	.word	0x080139c9
 8013880:	080138ed 	.word	0x080138ed
 8013884:	080139ab 	.word	0x080139ab
 8013888:	08013839 	.word	0x08013839
 801388c:	08013839 	.word	0x08013839
 8013890:	080139eb 	.word	0x080139eb
 8013894:	08013839 	.word	0x08013839
 8013898:	080138ed 	.word	0x080138ed
 801389c:	08013839 	.word	0x08013839
 80138a0:	08013839 	.word	0x08013839
 80138a4:	080139b3 	.word	0x080139b3
 80138a8:	682b      	ldr	r3, [r5, #0]
 80138aa:	1d1a      	adds	r2, r3, #4
 80138ac:	681b      	ldr	r3, [r3, #0]
 80138ae:	602a      	str	r2, [r5, #0]
 80138b0:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80138b4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80138b8:	2301      	movs	r3, #1
 80138ba:	e0a3      	b.n	8013a04 <_printf_i+0x1f4>
 80138bc:	6820      	ldr	r0, [r4, #0]
 80138be:	6829      	ldr	r1, [r5, #0]
 80138c0:	0606      	lsls	r6, r0, #24
 80138c2:	f101 0304 	add.w	r3, r1, #4
 80138c6:	d50a      	bpl.n	80138de <_printf_i+0xce>
 80138c8:	680e      	ldr	r6, [r1, #0]
 80138ca:	602b      	str	r3, [r5, #0]
 80138cc:	2e00      	cmp	r6, #0
 80138ce:	da03      	bge.n	80138d8 <_printf_i+0xc8>
 80138d0:	232d      	movs	r3, #45	; 0x2d
 80138d2:	4276      	negs	r6, r6
 80138d4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80138d8:	485e      	ldr	r0, [pc, #376]	; (8013a54 <_printf_i+0x244>)
 80138da:	230a      	movs	r3, #10
 80138dc:	e019      	b.n	8013912 <_printf_i+0x102>
 80138de:	680e      	ldr	r6, [r1, #0]
 80138e0:	602b      	str	r3, [r5, #0]
 80138e2:	f010 0f40 	tst.w	r0, #64	; 0x40
 80138e6:	bf18      	it	ne
 80138e8:	b236      	sxthne	r6, r6
 80138ea:	e7ef      	b.n	80138cc <_printf_i+0xbc>
 80138ec:	682b      	ldr	r3, [r5, #0]
 80138ee:	6820      	ldr	r0, [r4, #0]
 80138f0:	1d19      	adds	r1, r3, #4
 80138f2:	6029      	str	r1, [r5, #0]
 80138f4:	0601      	lsls	r1, r0, #24
 80138f6:	d501      	bpl.n	80138fc <_printf_i+0xec>
 80138f8:	681e      	ldr	r6, [r3, #0]
 80138fa:	e002      	b.n	8013902 <_printf_i+0xf2>
 80138fc:	0646      	lsls	r6, r0, #25
 80138fe:	d5fb      	bpl.n	80138f8 <_printf_i+0xe8>
 8013900:	881e      	ldrh	r6, [r3, #0]
 8013902:	4854      	ldr	r0, [pc, #336]	; (8013a54 <_printf_i+0x244>)
 8013904:	2f6f      	cmp	r7, #111	; 0x6f
 8013906:	bf0c      	ite	eq
 8013908:	2308      	moveq	r3, #8
 801390a:	230a      	movne	r3, #10
 801390c:	2100      	movs	r1, #0
 801390e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8013912:	6865      	ldr	r5, [r4, #4]
 8013914:	60a5      	str	r5, [r4, #8]
 8013916:	2d00      	cmp	r5, #0
 8013918:	bfa2      	ittt	ge
 801391a:	6821      	ldrge	r1, [r4, #0]
 801391c:	f021 0104 	bicge.w	r1, r1, #4
 8013920:	6021      	strge	r1, [r4, #0]
 8013922:	b90e      	cbnz	r6, 8013928 <_printf_i+0x118>
 8013924:	2d00      	cmp	r5, #0
 8013926:	d04d      	beq.n	80139c4 <_printf_i+0x1b4>
 8013928:	4615      	mov	r5, r2
 801392a:	fbb6 f1f3 	udiv	r1, r6, r3
 801392e:	fb03 6711 	mls	r7, r3, r1, r6
 8013932:	5dc7      	ldrb	r7, [r0, r7]
 8013934:	f805 7d01 	strb.w	r7, [r5, #-1]!
 8013938:	4637      	mov	r7, r6
 801393a:	42bb      	cmp	r3, r7
 801393c:	460e      	mov	r6, r1
 801393e:	d9f4      	bls.n	801392a <_printf_i+0x11a>
 8013940:	2b08      	cmp	r3, #8
 8013942:	d10b      	bne.n	801395c <_printf_i+0x14c>
 8013944:	6823      	ldr	r3, [r4, #0]
 8013946:	07de      	lsls	r6, r3, #31
 8013948:	d508      	bpl.n	801395c <_printf_i+0x14c>
 801394a:	6923      	ldr	r3, [r4, #16]
 801394c:	6861      	ldr	r1, [r4, #4]
 801394e:	4299      	cmp	r1, r3
 8013950:	bfde      	ittt	le
 8013952:	2330      	movle	r3, #48	; 0x30
 8013954:	f805 3c01 	strble.w	r3, [r5, #-1]
 8013958:	f105 35ff 	addle.w	r5, r5, #4294967295
 801395c:	1b52      	subs	r2, r2, r5
 801395e:	6122      	str	r2, [r4, #16]
 8013960:	f8cd a000 	str.w	sl, [sp]
 8013964:	464b      	mov	r3, r9
 8013966:	aa03      	add	r2, sp, #12
 8013968:	4621      	mov	r1, r4
 801396a:	4640      	mov	r0, r8
 801396c:	f7ff fee2 	bl	8013734 <_printf_common>
 8013970:	3001      	adds	r0, #1
 8013972:	d14c      	bne.n	8013a0e <_printf_i+0x1fe>
 8013974:	f04f 30ff 	mov.w	r0, #4294967295
 8013978:	b004      	add	sp, #16
 801397a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801397e:	4835      	ldr	r0, [pc, #212]	; (8013a54 <_printf_i+0x244>)
 8013980:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 8013984:	6829      	ldr	r1, [r5, #0]
 8013986:	6823      	ldr	r3, [r4, #0]
 8013988:	f851 6b04 	ldr.w	r6, [r1], #4
 801398c:	6029      	str	r1, [r5, #0]
 801398e:	061d      	lsls	r5, r3, #24
 8013990:	d514      	bpl.n	80139bc <_printf_i+0x1ac>
 8013992:	07df      	lsls	r7, r3, #31
 8013994:	bf44      	itt	mi
 8013996:	f043 0320 	orrmi.w	r3, r3, #32
 801399a:	6023      	strmi	r3, [r4, #0]
 801399c:	b91e      	cbnz	r6, 80139a6 <_printf_i+0x196>
 801399e:	6823      	ldr	r3, [r4, #0]
 80139a0:	f023 0320 	bic.w	r3, r3, #32
 80139a4:	6023      	str	r3, [r4, #0]
 80139a6:	2310      	movs	r3, #16
 80139a8:	e7b0      	b.n	801390c <_printf_i+0xfc>
 80139aa:	6823      	ldr	r3, [r4, #0]
 80139ac:	f043 0320 	orr.w	r3, r3, #32
 80139b0:	6023      	str	r3, [r4, #0]
 80139b2:	2378      	movs	r3, #120	; 0x78
 80139b4:	4828      	ldr	r0, [pc, #160]	; (8013a58 <_printf_i+0x248>)
 80139b6:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80139ba:	e7e3      	b.n	8013984 <_printf_i+0x174>
 80139bc:	0659      	lsls	r1, r3, #25
 80139be:	bf48      	it	mi
 80139c0:	b2b6      	uxthmi	r6, r6
 80139c2:	e7e6      	b.n	8013992 <_printf_i+0x182>
 80139c4:	4615      	mov	r5, r2
 80139c6:	e7bb      	b.n	8013940 <_printf_i+0x130>
 80139c8:	682b      	ldr	r3, [r5, #0]
 80139ca:	6826      	ldr	r6, [r4, #0]
 80139cc:	6961      	ldr	r1, [r4, #20]
 80139ce:	1d18      	adds	r0, r3, #4
 80139d0:	6028      	str	r0, [r5, #0]
 80139d2:	0635      	lsls	r5, r6, #24
 80139d4:	681b      	ldr	r3, [r3, #0]
 80139d6:	d501      	bpl.n	80139dc <_printf_i+0x1cc>
 80139d8:	6019      	str	r1, [r3, #0]
 80139da:	e002      	b.n	80139e2 <_printf_i+0x1d2>
 80139dc:	0670      	lsls	r0, r6, #25
 80139de:	d5fb      	bpl.n	80139d8 <_printf_i+0x1c8>
 80139e0:	8019      	strh	r1, [r3, #0]
 80139e2:	2300      	movs	r3, #0
 80139e4:	6123      	str	r3, [r4, #16]
 80139e6:	4615      	mov	r5, r2
 80139e8:	e7ba      	b.n	8013960 <_printf_i+0x150>
 80139ea:	682b      	ldr	r3, [r5, #0]
 80139ec:	1d1a      	adds	r2, r3, #4
 80139ee:	602a      	str	r2, [r5, #0]
 80139f0:	681d      	ldr	r5, [r3, #0]
 80139f2:	6862      	ldr	r2, [r4, #4]
 80139f4:	2100      	movs	r1, #0
 80139f6:	4628      	mov	r0, r5
 80139f8:	f7ec ffea 	bl	80009d0 <memchr>
 80139fc:	b108      	cbz	r0, 8013a02 <_printf_i+0x1f2>
 80139fe:	1b40      	subs	r0, r0, r5
 8013a00:	6060      	str	r0, [r4, #4]
 8013a02:	6863      	ldr	r3, [r4, #4]
 8013a04:	6123      	str	r3, [r4, #16]
 8013a06:	2300      	movs	r3, #0
 8013a08:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8013a0c:	e7a8      	b.n	8013960 <_printf_i+0x150>
 8013a0e:	6923      	ldr	r3, [r4, #16]
 8013a10:	462a      	mov	r2, r5
 8013a12:	4649      	mov	r1, r9
 8013a14:	4640      	mov	r0, r8
 8013a16:	47d0      	blx	sl
 8013a18:	3001      	adds	r0, #1
 8013a1a:	d0ab      	beq.n	8013974 <_printf_i+0x164>
 8013a1c:	6823      	ldr	r3, [r4, #0]
 8013a1e:	079b      	lsls	r3, r3, #30
 8013a20:	d413      	bmi.n	8013a4a <_printf_i+0x23a>
 8013a22:	68e0      	ldr	r0, [r4, #12]
 8013a24:	9b03      	ldr	r3, [sp, #12]
 8013a26:	4298      	cmp	r0, r3
 8013a28:	bfb8      	it	lt
 8013a2a:	4618      	movlt	r0, r3
 8013a2c:	e7a4      	b.n	8013978 <_printf_i+0x168>
 8013a2e:	2301      	movs	r3, #1
 8013a30:	4632      	mov	r2, r6
 8013a32:	4649      	mov	r1, r9
 8013a34:	4640      	mov	r0, r8
 8013a36:	47d0      	blx	sl
 8013a38:	3001      	adds	r0, #1
 8013a3a:	d09b      	beq.n	8013974 <_printf_i+0x164>
 8013a3c:	3501      	adds	r5, #1
 8013a3e:	68e3      	ldr	r3, [r4, #12]
 8013a40:	9903      	ldr	r1, [sp, #12]
 8013a42:	1a5b      	subs	r3, r3, r1
 8013a44:	42ab      	cmp	r3, r5
 8013a46:	dcf2      	bgt.n	8013a2e <_printf_i+0x21e>
 8013a48:	e7eb      	b.n	8013a22 <_printf_i+0x212>
 8013a4a:	2500      	movs	r5, #0
 8013a4c:	f104 0619 	add.w	r6, r4, #25
 8013a50:	e7f5      	b.n	8013a3e <_printf_i+0x22e>
 8013a52:	bf00      	nop
 8013a54:	0801a2f4 	.word	0x0801a2f4
 8013a58:	0801a305 	.word	0x0801a305

08013a5c <siprintf>:
 8013a5c:	b40e      	push	{r1, r2, r3}
 8013a5e:	b500      	push	{lr}
 8013a60:	b09c      	sub	sp, #112	; 0x70
 8013a62:	ab1d      	add	r3, sp, #116	; 0x74
 8013a64:	9002      	str	r0, [sp, #8]
 8013a66:	9006      	str	r0, [sp, #24]
 8013a68:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8013a6c:	4809      	ldr	r0, [pc, #36]	; (8013a94 <siprintf+0x38>)
 8013a6e:	9107      	str	r1, [sp, #28]
 8013a70:	9104      	str	r1, [sp, #16]
 8013a72:	4909      	ldr	r1, [pc, #36]	; (8013a98 <siprintf+0x3c>)
 8013a74:	f853 2b04 	ldr.w	r2, [r3], #4
 8013a78:	9105      	str	r1, [sp, #20]
 8013a7a:	6800      	ldr	r0, [r0, #0]
 8013a7c:	9301      	str	r3, [sp, #4]
 8013a7e:	a902      	add	r1, sp, #8
 8013a80:	f001 fc74 	bl	801536c <_svfiprintf_r>
 8013a84:	9b02      	ldr	r3, [sp, #8]
 8013a86:	2200      	movs	r2, #0
 8013a88:	701a      	strb	r2, [r3, #0]
 8013a8a:	b01c      	add	sp, #112	; 0x70
 8013a8c:	f85d eb04 	ldr.w	lr, [sp], #4
 8013a90:	b003      	add	sp, #12
 8013a92:	4770      	bx	lr
 8013a94:	20000694 	.word	0x20000694
 8013a98:	ffff0208 	.word	0xffff0208

08013a9c <siscanf>:
 8013a9c:	b40e      	push	{r1, r2, r3}
 8013a9e:	b510      	push	{r4, lr}
 8013aa0:	b09f      	sub	sp, #124	; 0x7c
 8013aa2:	ac21      	add	r4, sp, #132	; 0x84
 8013aa4:	f44f 7101 	mov.w	r1, #516	; 0x204
 8013aa8:	f854 2b04 	ldr.w	r2, [r4], #4
 8013aac:	9201      	str	r2, [sp, #4]
 8013aae:	f8ad 101c 	strh.w	r1, [sp, #28]
 8013ab2:	9004      	str	r0, [sp, #16]
 8013ab4:	9008      	str	r0, [sp, #32]
 8013ab6:	f7ec ff80 	bl	80009ba <strlen>
 8013aba:	4b0c      	ldr	r3, [pc, #48]	; (8013aec <siscanf+0x50>)
 8013abc:	9005      	str	r0, [sp, #20]
 8013abe:	9009      	str	r0, [sp, #36]	; 0x24
 8013ac0:	930d      	str	r3, [sp, #52]	; 0x34
 8013ac2:	480b      	ldr	r0, [pc, #44]	; (8013af0 <siscanf+0x54>)
 8013ac4:	9a01      	ldr	r2, [sp, #4]
 8013ac6:	6800      	ldr	r0, [r0, #0]
 8013ac8:	9403      	str	r4, [sp, #12]
 8013aca:	2300      	movs	r3, #0
 8013acc:	9311      	str	r3, [sp, #68]	; 0x44
 8013ace:	9316      	str	r3, [sp, #88]	; 0x58
 8013ad0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8013ad4:	f8ad 301e 	strh.w	r3, [sp, #30]
 8013ad8:	a904      	add	r1, sp, #16
 8013ada:	4623      	mov	r3, r4
 8013adc:	f001 fda0 	bl	8015620 <__ssvfiscanf_r>
 8013ae0:	b01f      	add	sp, #124	; 0x7c
 8013ae2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8013ae6:	b003      	add	sp, #12
 8013ae8:	4770      	bx	lr
 8013aea:	bf00      	nop
 8013aec:	08013b17 	.word	0x08013b17
 8013af0:	20000694 	.word	0x20000694

08013af4 <__sread>:
 8013af4:	b510      	push	{r4, lr}
 8013af6:	460c      	mov	r4, r1
 8013af8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013afc:	f002 f85a 	bl	8015bb4 <_read_r>
 8013b00:	2800      	cmp	r0, #0
 8013b02:	bfab      	itete	ge
 8013b04:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8013b06:	89a3      	ldrhlt	r3, [r4, #12]
 8013b08:	181b      	addge	r3, r3, r0
 8013b0a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8013b0e:	bfac      	ite	ge
 8013b10:	6563      	strge	r3, [r4, #84]	; 0x54
 8013b12:	81a3      	strhlt	r3, [r4, #12]
 8013b14:	bd10      	pop	{r4, pc}

08013b16 <__seofread>:
 8013b16:	2000      	movs	r0, #0
 8013b18:	4770      	bx	lr

08013b1a <__swrite>:
 8013b1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013b1e:	461f      	mov	r7, r3
 8013b20:	898b      	ldrh	r3, [r1, #12]
 8013b22:	05db      	lsls	r3, r3, #23
 8013b24:	4605      	mov	r5, r0
 8013b26:	460c      	mov	r4, r1
 8013b28:	4616      	mov	r6, r2
 8013b2a:	d505      	bpl.n	8013b38 <__swrite+0x1e>
 8013b2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013b30:	2302      	movs	r3, #2
 8013b32:	2200      	movs	r2, #0
 8013b34:	f000 ff2a 	bl	801498c <_lseek_r>
 8013b38:	89a3      	ldrh	r3, [r4, #12]
 8013b3a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8013b3e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8013b42:	81a3      	strh	r3, [r4, #12]
 8013b44:	4632      	mov	r2, r6
 8013b46:	463b      	mov	r3, r7
 8013b48:	4628      	mov	r0, r5
 8013b4a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8013b4e:	f000 b87b 	b.w	8013c48 <_write_r>

08013b52 <__sseek>:
 8013b52:	b510      	push	{r4, lr}
 8013b54:	460c      	mov	r4, r1
 8013b56:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013b5a:	f000 ff17 	bl	801498c <_lseek_r>
 8013b5e:	1c43      	adds	r3, r0, #1
 8013b60:	89a3      	ldrh	r3, [r4, #12]
 8013b62:	bf15      	itete	ne
 8013b64:	6560      	strne	r0, [r4, #84]	; 0x54
 8013b66:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8013b6a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8013b6e:	81a3      	strheq	r3, [r4, #12]
 8013b70:	bf18      	it	ne
 8013b72:	81a3      	strhne	r3, [r4, #12]
 8013b74:	bd10      	pop	{r4, pc}

08013b76 <__sclose>:
 8013b76:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8013b7a:	f000 b877 	b.w	8013c6c <_close_r>

08013b7e <strchr>:
 8013b7e:	b2c9      	uxtb	r1, r1
 8013b80:	4603      	mov	r3, r0
 8013b82:	f810 2b01 	ldrb.w	r2, [r0], #1
 8013b86:	b11a      	cbz	r2, 8013b90 <strchr+0x12>
 8013b88:	428a      	cmp	r2, r1
 8013b8a:	d1f9      	bne.n	8013b80 <strchr+0x2>
 8013b8c:	4618      	mov	r0, r3
 8013b8e:	4770      	bx	lr
 8013b90:	2900      	cmp	r1, #0
 8013b92:	bf18      	it	ne
 8013b94:	2300      	movne	r3, #0
 8013b96:	e7f9      	b.n	8013b8c <strchr+0xe>

08013b98 <strcpy>:
 8013b98:	4603      	mov	r3, r0
 8013b9a:	f811 2b01 	ldrb.w	r2, [r1], #1
 8013b9e:	f803 2b01 	strb.w	r2, [r3], #1
 8013ba2:	2a00      	cmp	r2, #0
 8013ba4:	d1f9      	bne.n	8013b9a <strcpy+0x2>
 8013ba6:	4770      	bx	lr

08013ba8 <strstr>:
 8013ba8:	780a      	ldrb	r2, [r1, #0]
 8013baa:	b570      	push	{r4, r5, r6, lr}
 8013bac:	b96a      	cbnz	r2, 8013bca <strstr+0x22>
 8013bae:	bd70      	pop	{r4, r5, r6, pc}
 8013bb0:	429a      	cmp	r2, r3
 8013bb2:	d109      	bne.n	8013bc8 <strstr+0x20>
 8013bb4:	460c      	mov	r4, r1
 8013bb6:	4605      	mov	r5, r0
 8013bb8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8013bbc:	2b00      	cmp	r3, #0
 8013bbe:	d0f6      	beq.n	8013bae <strstr+0x6>
 8013bc0:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 8013bc4:	429e      	cmp	r6, r3
 8013bc6:	d0f7      	beq.n	8013bb8 <strstr+0x10>
 8013bc8:	3001      	adds	r0, #1
 8013bca:	7803      	ldrb	r3, [r0, #0]
 8013bcc:	2b00      	cmp	r3, #0
 8013bce:	d1ef      	bne.n	8013bb0 <strstr+0x8>
 8013bd0:	4618      	mov	r0, r3
 8013bd2:	e7ec      	b.n	8013bae <strstr+0x6>

08013bd4 <_vsniprintf_r>:
 8013bd4:	b530      	push	{r4, r5, lr}
 8013bd6:	4614      	mov	r4, r2
 8013bd8:	2c00      	cmp	r4, #0
 8013bda:	b09b      	sub	sp, #108	; 0x6c
 8013bdc:	4605      	mov	r5, r0
 8013bde:	461a      	mov	r2, r3
 8013be0:	da05      	bge.n	8013bee <_vsniprintf_r+0x1a>
 8013be2:	238b      	movs	r3, #139	; 0x8b
 8013be4:	6003      	str	r3, [r0, #0]
 8013be6:	f04f 30ff 	mov.w	r0, #4294967295
 8013bea:	b01b      	add	sp, #108	; 0x6c
 8013bec:	bd30      	pop	{r4, r5, pc}
 8013bee:	f44f 7302 	mov.w	r3, #520	; 0x208
 8013bf2:	f8ad 300c 	strh.w	r3, [sp, #12]
 8013bf6:	bf14      	ite	ne
 8013bf8:	f104 33ff 	addne.w	r3, r4, #4294967295
 8013bfc:	4623      	moveq	r3, r4
 8013bfe:	9302      	str	r3, [sp, #8]
 8013c00:	9305      	str	r3, [sp, #20]
 8013c02:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8013c06:	9100      	str	r1, [sp, #0]
 8013c08:	9104      	str	r1, [sp, #16]
 8013c0a:	f8ad 300e 	strh.w	r3, [sp, #14]
 8013c0e:	4669      	mov	r1, sp
 8013c10:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8013c12:	f001 fbab 	bl	801536c <_svfiprintf_r>
 8013c16:	1c43      	adds	r3, r0, #1
 8013c18:	bfbc      	itt	lt
 8013c1a:	238b      	movlt	r3, #139	; 0x8b
 8013c1c:	602b      	strlt	r3, [r5, #0]
 8013c1e:	2c00      	cmp	r4, #0
 8013c20:	d0e3      	beq.n	8013bea <_vsniprintf_r+0x16>
 8013c22:	9b00      	ldr	r3, [sp, #0]
 8013c24:	2200      	movs	r2, #0
 8013c26:	701a      	strb	r2, [r3, #0]
 8013c28:	e7df      	b.n	8013bea <_vsniprintf_r+0x16>
	...

08013c2c <vsniprintf>:
 8013c2c:	b507      	push	{r0, r1, r2, lr}
 8013c2e:	9300      	str	r3, [sp, #0]
 8013c30:	4613      	mov	r3, r2
 8013c32:	460a      	mov	r2, r1
 8013c34:	4601      	mov	r1, r0
 8013c36:	4803      	ldr	r0, [pc, #12]	; (8013c44 <vsniprintf+0x18>)
 8013c38:	6800      	ldr	r0, [r0, #0]
 8013c3a:	f7ff ffcb 	bl	8013bd4 <_vsniprintf_r>
 8013c3e:	b003      	add	sp, #12
 8013c40:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c44:	20000694 	.word	0x20000694

08013c48 <_write_r>:
 8013c48:	b538      	push	{r3, r4, r5, lr}
 8013c4a:	4d07      	ldr	r5, [pc, #28]	; (8013c68 <_write_r+0x20>)
 8013c4c:	4604      	mov	r4, r0
 8013c4e:	4608      	mov	r0, r1
 8013c50:	4611      	mov	r1, r2
 8013c52:	2200      	movs	r2, #0
 8013c54:	602a      	str	r2, [r5, #0]
 8013c56:	461a      	mov	r2, r3
 8013c58:	f7ef f992 	bl	8002f80 <_write>
 8013c5c:	1c43      	adds	r3, r0, #1
 8013c5e:	d102      	bne.n	8013c66 <_write_r+0x1e>
 8013c60:	682b      	ldr	r3, [r5, #0]
 8013c62:	b103      	cbz	r3, 8013c66 <_write_r+0x1e>
 8013c64:	6023      	str	r3, [r4, #0]
 8013c66:	bd38      	pop	{r3, r4, r5, pc}
 8013c68:	2004ee60 	.word	0x2004ee60

08013c6c <_close_r>:
 8013c6c:	b538      	push	{r3, r4, r5, lr}
 8013c6e:	4d06      	ldr	r5, [pc, #24]	; (8013c88 <_close_r+0x1c>)
 8013c70:	2300      	movs	r3, #0
 8013c72:	4604      	mov	r4, r0
 8013c74:	4608      	mov	r0, r1
 8013c76:	602b      	str	r3, [r5, #0]
 8013c78:	f7ef f990 	bl	8002f9c <_close>
 8013c7c:	1c43      	adds	r3, r0, #1
 8013c7e:	d102      	bne.n	8013c86 <_close_r+0x1a>
 8013c80:	682b      	ldr	r3, [r5, #0]
 8013c82:	b103      	cbz	r3, 8013c86 <_close_r+0x1a>
 8013c84:	6023      	str	r3, [r4, #0]
 8013c86:	bd38      	pop	{r3, r4, r5, pc}
 8013c88:	2004ee60 	.word	0x2004ee60

08013c8c <quorem>:
 8013c8c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013c90:	6903      	ldr	r3, [r0, #16]
 8013c92:	690c      	ldr	r4, [r1, #16]
 8013c94:	42a3      	cmp	r3, r4
 8013c96:	4607      	mov	r7, r0
 8013c98:	f2c0 8081 	blt.w	8013d9e <quorem+0x112>
 8013c9c:	3c01      	subs	r4, #1
 8013c9e:	f101 0814 	add.w	r8, r1, #20
 8013ca2:	f100 0514 	add.w	r5, r0, #20
 8013ca6:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8013caa:	9301      	str	r3, [sp, #4]
 8013cac:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8013cb0:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8013cb4:	3301      	adds	r3, #1
 8013cb6:	429a      	cmp	r2, r3
 8013cb8:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 8013cbc:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 8013cc0:	fbb2 f6f3 	udiv	r6, r2, r3
 8013cc4:	d331      	bcc.n	8013d2a <quorem+0x9e>
 8013cc6:	f04f 0e00 	mov.w	lr, #0
 8013cca:	4640      	mov	r0, r8
 8013ccc:	46ac      	mov	ip, r5
 8013cce:	46f2      	mov	sl, lr
 8013cd0:	f850 2b04 	ldr.w	r2, [r0], #4
 8013cd4:	b293      	uxth	r3, r2
 8013cd6:	fb06 e303 	mla	r3, r6, r3, lr
 8013cda:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8013cde:	b29b      	uxth	r3, r3
 8013ce0:	ebaa 0303 	sub.w	r3, sl, r3
 8013ce4:	f8dc a000 	ldr.w	sl, [ip]
 8013ce8:	0c12      	lsrs	r2, r2, #16
 8013cea:	fa13 f38a 	uxtah	r3, r3, sl
 8013cee:	fb06 e202 	mla	r2, r6, r2, lr
 8013cf2:	9300      	str	r3, [sp, #0]
 8013cf4:	9b00      	ldr	r3, [sp, #0]
 8013cf6:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8013cfa:	b292      	uxth	r2, r2
 8013cfc:	ebc2 421a 	rsb	r2, r2, sl, lsr #16
 8013d00:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8013d04:	f8bd 3000 	ldrh.w	r3, [sp]
 8013d08:	4581      	cmp	r9, r0
 8013d0a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8013d0e:	f84c 3b04 	str.w	r3, [ip], #4
 8013d12:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8013d16:	d2db      	bcs.n	8013cd0 <quorem+0x44>
 8013d18:	f855 300b 	ldr.w	r3, [r5, fp]
 8013d1c:	b92b      	cbnz	r3, 8013d2a <quorem+0x9e>
 8013d1e:	9b01      	ldr	r3, [sp, #4]
 8013d20:	3b04      	subs	r3, #4
 8013d22:	429d      	cmp	r5, r3
 8013d24:	461a      	mov	r2, r3
 8013d26:	d32e      	bcc.n	8013d86 <quorem+0xfa>
 8013d28:	613c      	str	r4, [r7, #16]
 8013d2a:	4638      	mov	r0, r7
 8013d2c:	f001 f8ca 	bl	8014ec4 <__mcmp>
 8013d30:	2800      	cmp	r0, #0
 8013d32:	db24      	blt.n	8013d7e <quorem+0xf2>
 8013d34:	3601      	adds	r6, #1
 8013d36:	4628      	mov	r0, r5
 8013d38:	f04f 0c00 	mov.w	ip, #0
 8013d3c:	f858 2b04 	ldr.w	r2, [r8], #4
 8013d40:	f8d0 e000 	ldr.w	lr, [r0]
 8013d44:	b293      	uxth	r3, r2
 8013d46:	ebac 0303 	sub.w	r3, ip, r3
 8013d4a:	0c12      	lsrs	r2, r2, #16
 8013d4c:	fa13 f38e 	uxtah	r3, r3, lr
 8013d50:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 8013d54:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8013d58:	b29b      	uxth	r3, r3
 8013d5a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8013d5e:	45c1      	cmp	r9, r8
 8013d60:	f840 3b04 	str.w	r3, [r0], #4
 8013d64:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8013d68:	d2e8      	bcs.n	8013d3c <quorem+0xb0>
 8013d6a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8013d6e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8013d72:	b922      	cbnz	r2, 8013d7e <quorem+0xf2>
 8013d74:	3b04      	subs	r3, #4
 8013d76:	429d      	cmp	r5, r3
 8013d78:	461a      	mov	r2, r3
 8013d7a:	d30a      	bcc.n	8013d92 <quorem+0x106>
 8013d7c:	613c      	str	r4, [r7, #16]
 8013d7e:	4630      	mov	r0, r6
 8013d80:	b003      	add	sp, #12
 8013d82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013d86:	6812      	ldr	r2, [r2, #0]
 8013d88:	3b04      	subs	r3, #4
 8013d8a:	2a00      	cmp	r2, #0
 8013d8c:	d1cc      	bne.n	8013d28 <quorem+0x9c>
 8013d8e:	3c01      	subs	r4, #1
 8013d90:	e7c7      	b.n	8013d22 <quorem+0x96>
 8013d92:	6812      	ldr	r2, [r2, #0]
 8013d94:	3b04      	subs	r3, #4
 8013d96:	2a00      	cmp	r2, #0
 8013d98:	d1f0      	bne.n	8013d7c <quorem+0xf0>
 8013d9a:	3c01      	subs	r4, #1
 8013d9c:	e7eb      	b.n	8013d76 <quorem+0xea>
 8013d9e:	2000      	movs	r0, #0
 8013da0:	e7ee      	b.n	8013d80 <quorem+0xf4>
 8013da2:	0000      	movs	r0, r0
 8013da4:	0000      	movs	r0, r0
	...

08013da8 <_dtoa_r>:
 8013da8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013dac:	ed2d 8b04 	vpush	{d8-d9}
 8013db0:	ec57 6b10 	vmov	r6, r7, d0
 8013db4:	b093      	sub	sp, #76	; 0x4c
 8013db6:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8013db8:	f8dd 8080 	ldr.w	r8, [sp, #128]	; 0x80
 8013dbc:	9106      	str	r1, [sp, #24]
 8013dbe:	ee10 aa10 	vmov	sl, s0
 8013dc2:	4604      	mov	r4, r0
 8013dc4:	9209      	str	r2, [sp, #36]	; 0x24
 8013dc6:	930c      	str	r3, [sp, #48]	; 0x30
 8013dc8:	46bb      	mov	fp, r7
 8013dca:	b975      	cbnz	r5, 8013dea <_dtoa_r+0x42>
 8013dcc:	2010      	movs	r0, #16
 8013dce:	f000 fdef 	bl	80149b0 <malloc>
 8013dd2:	4602      	mov	r2, r0
 8013dd4:	6260      	str	r0, [r4, #36]	; 0x24
 8013dd6:	b920      	cbnz	r0, 8013de2 <_dtoa_r+0x3a>
 8013dd8:	4ba7      	ldr	r3, [pc, #668]	; (8014078 <_dtoa_r+0x2d0>)
 8013dda:	21ea      	movs	r1, #234	; 0xea
 8013ddc:	48a7      	ldr	r0, [pc, #668]	; (801407c <_dtoa_r+0x2d4>)
 8013dde:	f002 f875 	bl	8015ecc <__assert_func>
 8013de2:	e9c0 5501 	strd	r5, r5, [r0, #4]
 8013de6:	6005      	str	r5, [r0, #0]
 8013de8:	60c5      	str	r5, [r0, #12]
 8013dea:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8013dec:	6819      	ldr	r1, [r3, #0]
 8013dee:	b151      	cbz	r1, 8013e06 <_dtoa_r+0x5e>
 8013df0:	685a      	ldr	r2, [r3, #4]
 8013df2:	604a      	str	r2, [r1, #4]
 8013df4:	2301      	movs	r3, #1
 8013df6:	4093      	lsls	r3, r2
 8013df8:	608b      	str	r3, [r1, #8]
 8013dfa:	4620      	mov	r0, r4
 8013dfc:	f000 fe20 	bl	8014a40 <_Bfree>
 8013e00:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8013e02:	2200      	movs	r2, #0
 8013e04:	601a      	str	r2, [r3, #0]
 8013e06:	1e3b      	subs	r3, r7, #0
 8013e08:	bfaa      	itet	ge
 8013e0a:	2300      	movge	r3, #0
 8013e0c:	f023 4b00 	biclt.w	fp, r3, #2147483648	; 0x80000000
 8013e10:	f8c8 3000 	strge.w	r3, [r8]
 8013e14:	4b9a      	ldr	r3, [pc, #616]	; (8014080 <_dtoa_r+0x2d8>)
 8013e16:	bfbc      	itt	lt
 8013e18:	2201      	movlt	r2, #1
 8013e1a:	f8c8 2000 	strlt.w	r2, [r8]
 8013e1e:	ea33 030b 	bics.w	r3, r3, fp
 8013e22:	d11b      	bne.n	8013e5c <_dtoa_r+0xb4>
 8013e24:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013e26:	f242 730f 	movw	r3, #9999	; 0x270f
 8013e2a:	6013      	str	r3, [r2, #0]
 8013e2c:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8013e30:	4333      	orrs	r3, r6
 8013e32:	f000 8592 	beq.w	801495a <_dtoa_r+0xbb2>
 8013e36:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013e38:	b963      	cbnz	r3, 8013e54 <_dtoa_r+0xac>
 8013e3a:	4b92      	ldr	r3, [pc, #584]	; (8014084 <_dtoa_r+0x2dc>)
 8013e3c:	e022      	b.n	8013e84 <_dtoa_r+0xdc>
 8013e3e:	4b92      	ldr	r3, [pc, #584]	; (8014088 <_dtoa_r+0x2e0>)
 8013e40:	9301      	str	r3, [sp, #4]
 8013e42:	3308      	adds	r3, #8
 8013e44:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8013e46:	6013      	str	r3, [r2, #0]
 8013e48:	9801      	ldr	r0, [sp, #4]
 8013e4a:	b013      	add	sp, #76	; 0x4c
 8013e4c:	ecbd 8b04 	vpop	{d8-d9}
 8013e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013e54:	4b8b      	ldr	r3, [pc, #556]	; (8014084 <_dtoa_r+0x2dc>)
 8013e56:	9301      	str	r3, [sp, #4]
 8013e58:	3303      	adds	r3, #3
 8013e5a:	e7f3      	b.n	8013e44 <_dtoa_r+0x9c>
 8013e5c:	2200      	movs	r2, #0
 8013e5e:	2300      	movs	r3, #0
 8013e60:	4650      	mov	r0, sl
 8013e62:	4659      	mov	r1, fp
 8013e64:	f7ed fa28 	bl	80012b8 <__aeabi_dcmpeq>
 8013e68:	ec4b ab19 	vmov	d9, sl, fp
 8013e6c:	4680      	mov	r8, r0
 8013e6e:	b158      	cbz	r0, 8013e88 <_dtoa_r+0xe0>
 8013e70:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8013e72:	2301      	movs	r3, #1
 8013e74:	6013      	str	r3, [r2, #0]
 8013e76:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8013e78:	2b00      	cmp	r3, #0
 8013e7a:	f000 856b 	beq.w	8014954 <_dtoa_r+0xbac>
 8013e7e:	4883      	ldr	r0, [pc, #524]	; (801408c <_dtoa_r+0x2e4>)
 8013e80:	6018      	str	r0, [r3, #0]
 8013e82:	1e43      	subs	r3, r0, #1
 8013e84:	9301      	str	r3, [sp, #4]
 8013e86:	e7df      	b.n	8013e48 <_dtoa_r+0xa0>
 8013e88:	ec4b ab10 	vmov	d0, sl, fp
 8013e8c:	aa10      	add	r2, sp, #64	; 0x40
 8013e8e:	a911      	add	r1, sp, #68	; 0x44
 8013e90:	4620      	mov	r0, r4
 8013e92:	f001 f8bd 	bl	8015010 <__d2b>
 8013e96:	f3cb 550a 	ubfx	r5, fp, #20, #11
 8013e9a:	ee08 0a10 	vmov	s16, r0
 8013e9e:	2d00      	cmp	r5, #0
 8013ea0:	f000 8084 	beq.w	8013fac <_dtoa_r+0x204>
 8013ea4:	ee19 3a90 	vmov	r3, s19
 8013ea8:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8013eac:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 8013eb0:	4656      	mov	r6, sl
 8013eb2:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 8013eb6:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8013eba:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
 8013ebe:	4b74      	ldr	r3, [pc, #464]	; (8014090 <_dtoa_r+0x2e8>)
 8013ec0:	2200      	movs	r2, #0
 8013ec2:	4630      	mov	r0, r6
 8013ec4:	4639      	mov	r1, r7
 8013ec6:	f7ec fdd7 	bl	8000a78 <__aeabi_dsub>
 8013eca:	a365      	add	r3, pc, #404	; (adr r3, 8014060 <_dtoa_r+0x2b8>)
 8013ecc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013ed0:	f7ec ff8a 	bl	8000de8 <__aeabi_dmul>
 8013ed4:	a364      	add	r3, pc, #400	; (adr r3, 8014068 <_dtoa_r+0x2c0>)
 8013ed6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013eda:	f7ec fdcf 	bl	8000a7c <__adddf3>
 8013ede:	4606      	mov	r6, r0
 8013ee0:	4628      	mov	r0, r5
 8013ee2:	460f      	mov	r7, r1
 8013ee4:	f7ec ff16 	bl	8000d14 <__aeabi_i2d>
 8013ee8:	a361      	add	r3, pc, #388	; (adr r3, 8014070 <_dtoa_r+0x2c8>)
 8013eea:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013eee:	f7ec ff7b 	bl	8000de8 <__aeabi_dmul>
 8013ef2:	4602      	mov	r2, r0
 8013ef4:	460b      	mov	r3, r1
 8013ef6:	4630      	mov	r0, r6
 8013ef8:	4639      	mov	r1, r7
 8013efa:	f7ec fdbf 	bl	8000a7c <__adddf3>
 8013efe:	4606      	mov	r6, r0
 8013f00:	460f      	mov	r7, r1
 8013f02:	f7ed fa21 	bl	8001348 <__aeabi_d2iz>
 8013f06:	2200      	movs	r2, #0
 8013f08:	9000      	str	r0, [sp, #0]
 8013f0a:	2300      	movs	r3, #0
 8013f0c:	4630      	mov	r0, r6
 8013f0e:	4639      	mov	r1, r7
 8013f10:	f7ed f9dc 	bl	80012cc <__aeabi_dcmplt>
 8013f14:	b150      	cbz	r0, 8013f2c <_dtoa_r+0x184>
 8013f16:	9800      	ldr	r0, [sp, #0]
 8013f18:	f7ec fefc 	bl	8000d14 <__aeabi_i2d>
 8013f1c:	4632      	mov	r2, r6
 8013f1e:	463b      	mov	r3, r7
 8013f20:	f7ed f9ca 	bl	80012b8 <__aeabi_dcmpeq>
 8013f24:	b910      	cbnz	r0, 8013f2c <_dtoa_r+0x184>
 8013f26:	9b00      	ldr	r3, [sp, #0]
 8013f28:	3b01      	subs	r3, #1
 8013f2a:	9300      	str	r3, [sp, #0]
 8013f2c:	9b00      	ldr	r3, [sp, #0]
 8013f2e:	2b16      	cmp	r3, #22
 8013f30:	d85a      	bhi.n	8013fe8 <_dtoa_r+0x240>
 8013f32:	9a00      	ldr	r2, [sp, #0]
 8013f34:	4b57      	ldr	r3, [pc, #348]	; (8014094 <_dtoa_r+0x2ec>)
 8013f36:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8013f3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8013f3e:	ec51 0b19 	vmov	r0, r1, d9
 8013f42:	f7ed f9c3 	bl	80012cc <__aeabi_dcmplt>
 8013f46:	2800      	cmp	r0, #0
 8013f48:	d050      	beq.n	8013fec <_dtoa_r+0x244>
 8013f4a:	9b00      	ldr	r3, [sp, #0]
 8013f4c:	3b01      	subs	r3, #1
 8013f4e:	9300      	str	r3, [sp, #0]
 8013f50:	2300      	movs	r3, #0
 8013f52:	930b      	str	r3, [sp, #44]	; 0x2c
 8013f54:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8013f56:	1b5d      	subs	r5, r3, r5
 8013f58:	1e6b      	subs	r3, r5, #1
 8013f5a:	9305      	str	r3, [sp, #20]
 8013f5c:	bf45      	ittet	mi
 8013f5e:	f1c5 0301 	rsbmi	r3, r5, #1
 8013f62:	9304      	strmi	r3, [sp, #16]
 8013f64:	2300      	movpl	r3, #0
 8013f66:	2300      	movmi	r3, #0
 8013f68:	bf4c      	ite	mi
 8013f6a:	9305      	strmi	r3, [sp, #20]
 8013f6c:	9304      	strpl	r3, [sp, #16]
 8013f6e:	9b00      	ldr	r3, [sp, #0]
 8013f70:	2b00      	cmp	r3, #0
 8013f72:	db3d      	blt.n	8013ff0 <_dtoa_r+0x248>
 8013f74:	9b05      	ldr	r3, [sp, #20]
 8013f76:	9a00      	ldr	r2, [sp, #0]
 8013f78:	920a      	str	r2, [sp, #40]	; 0x28
 8013f7a:	4413      	add	r3, r2
 8013f7c:	9305      	str	r3, [sp, #20]
 8013f7e:	2300      	movs	r3, #0
 8013f80:	9307      	str	r3, [sp, #28]
 8013f82:	9b06      	ldr	r3, [sp, #24]
 8013f84:	2b09      	cmp	r3, #9
 8013f86:	f200 8089 	bhi.w	801409c <_dtoa_r+0x2f4>
 8013f8a:	2b05      	cmp	r3, #5
 8013f8c:	bfc4      	itt	gt
 8013f8e:	3b04      	subgt	r3, #4
 8013f90:	9306      	strgt	r3, [sp, #24]
 8013f92:	9b06      	ldr	r3, [sp, #24]
 8013f94:	f1a3 0302 	sub.w	r3, r3, #2
 8013f98:	bfcc      	ite	gt
 8013f9a:	2500      	movgt	r5, #0
 8013f9c:	2501      	movle	r5, #1
 8013f9e:	2b03      	cmp	r3, #3
 8013fa0:	f200 8087 	bhi.w	80140b2 <_dtoa_r+0x30a>
 8013fa4:	e8df f003 	tbb	[pc, r3]
 8013fa8:	59383a2d 	.word	0x59383a2d
 8013fac:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 8013fb0:	441d      	add	r5, r3
 8013fb2:	f205 4332 	addw	r3, r5, #1074	; 0x432
 8013fb6:	2b20      	cmp	r3, #32
 8013fb8:	bfc1      	itttt	gt
 8013fba:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 8013fbe:	f205 4012 	addwgt	r0, r5, #1042	; 0x412
 8013fc2:	fa0b f303 	lslgt.w	r3, fp, r3
 8013fc6:	fa26 f000 	lsrgt.w	r0, r6, r0
 8013fca:	bfda      	itte	le
 8013fcc:	f1c3 0320 	rsble	r3, r3, #32
 8013fd0:	fa06 f003 	lslle.w	r0, r6, r3
 8013fd4:	4318      	orrgt	r0, r3
 8013fd6:	f7ec fe8d 	bl	8000cf4 <__aeabi_ui2d>
 8013fda:	2301      	movs	r3, #1
 8013fdc:	4606      	mov	r6, r0
 8013fde:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 8013fe2:	3d01      	subs	r5, #1
 8013fe4:	930e      	str	r3, [sp, #56]	; 0x38
 8013fe6:	e76a      	b.n	8013ebe <_dtoa_r+0x116>
 8013fe8:	2301      	movs	r3, #1
 8013fea:	e7b2      	b.n	8013f52 <_dtoa_r+0x1aa>
 8013fec:	900b      	str	r0, [sp, #44]	; 0x2c
 8013fee:	e7b1      	b.n	8013f54 <_dtoa_r+0x1ac>
 8013ff0:	9b04      	ldr	r3, [sp, #16]
 8013ff2:	9a00      	ldr	r2, [sp, #0]
 8013ff4:	1a9b      	subs	r3, r3, r2
 8013ff6:	9304      	str	r3, [sp, #16]
 8013ff8:	4253      	negs	r3, r2
 8013ffa:	9307      	str	r3, [sp, #28]
 8013ffc:	2300      	movs	r3, #0
 8013ffe:	930a      	str	r3, [sp, #40]	; 0x28
 8014000:	e7bf      	b.n	8013f82 <_dtoa_r+0x1da>
 8014002:	2300      	movs	r3, #0
 8014004:	9308      	str	r3, [sp, #32]
 8014006:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014008:	2b00      	cmp	r3, #0
 801400a:	dc55      	bgt.n	80140b8 <_dtoa_r+0x310>
 801400c:	2301      	movs	r3, #1
 801400e:	e9cd 3302 	strd	r3, r3, [sp, #8]
 8014012:	461a      	mov	r2, r3
 8014014:	9209      	str	r2, [sp, #36]	; 0x24
 8014016:	e00c      	b.n	8014032 <_dtoa_r+0x28a>
 8014018:	2301      	movs	r3, #1
 801401a:	e7f3      	b.n	8014004 <_dtoa_r+0x25c>
 801401c:	2300      	movs	r3, #0
 801401e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8014020:	9308      	str	r3, [sp, #32]
 8014022:	9b00      	ldr	r3, [sp, #0]
 8014024:	4413      	add	r3, r2
 8014026:	9302      	str	r3, [sp, #8]
 8014028:	3301      	adds	r3, #1
 801402a:	2b01      	cmp	r3, #1
 801402c:	9303      	str	r3, [sp, #12]
 801402e:	bfb8      	it	lt
 8014030:	2301      	movlt	r3, #1
 8014032:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8014034:	2200      	movs	r2, #0
 8014036:	6042      	str	r2, [r0, #4]
 8014038:	2204      	movs	r2, #4
 801403a:	f102 0614 	add.w	r6, r2, #20
 801403e:	429e      	cmp	r6, r3
 8014040:	6841      	ldr	r1, [r0, #4]
 8014042:	d93d      	bls.n	80140c0 <_dtoa_r+0x318>
 8014044:	4620      	mov	r0, r4
 8014046:	f000 fcbb 	bl	80149c0 <_Balloc>
 801404a:	9001      	str	r0, [sp, #4]
 801404c:	2800      	cmp	r0, #0
 801404e:	d13b      	bne.n	80140c8 <_dtoa_r+0x320>
 8014050:	4b11      	ldr	r3, [pc, #68]	; (8014098 <_dtoa_r+0x2f0>)
 8014052:	4602      	mov	r2, r0
 8014054:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8014058:	e6c0      	b.n	8013ddc <_dtoa_r+0x34>
 801405a:	2301      	movs	r3, #1
 801405c:	e7df      	b.n	801401e <_dtoa_r+0x276>
 801405e:	bf00      	nop
 8014060:	636f4361 	.word	0x636f4361
 8014064:	3fd287a7 	.word	0x3fd287a7
 8014068:	8b60c8b3 	.word	0x8b60c8b3
 801406c:	3fc68a28 	.word	0x3fc68a28
 8014070:	509f79fb 	.word	0x509f79fb
 8014074:	3fd34413 	.word	0x3fd34413
 8014078:	0801a323 	.word	0x0801a323
 801407c:	0801a33a 	.word	0x0801a33a
 8014080:	7ff00000 	.word	0x7ff00000
 8014084:	0801a31f 	.word	0x0801a31f
 8014088:	0801a316 	.word	0x0801a316
 801408c:	0801a51a 	.word	0x0801a51a
 8014090:	3ff80000 	.word	0x3ff80000
 8014094:	0801a430 	.word	0x0801a430
 8014098:	0801a395 	.word	0x0801a395
 801409c:	2501      	movs	r5, #1
 801409e:	2300      	movs	r3, #0
 80140a0:	9306      	str	r3, [sp, #24]
 80140a2:	9508      	str	r5, [sp, #32]
 80140a4:	f04f 33ff 	mov.w	r3, #4294967295
 80140a8:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80140ac:	2200      	movs	r2, #0
 80140ae:	2312      	movs	r3, #18
 80140b0:	e7b0      	b.n	8014014 <_dtoa_r+0x26c>
 80140b2:	2301      	movs	r3, #1
 80140b4:	9308      	str	r3, [sp, #32]
 80140b6:	e7f5      	b.n	80140a4 <_dtoa_r+0x2fc>
 80140b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80140ba:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80140be:	e7b8      	b.n	8014032 <_dtoa_r+0x28a>
 80140c0:	3101      	adds	r1, #1
 80140c2:	6041      	str	r1, [r0, #4]
 80140c4:	0052      	lsls	r2, r2, #1
 80140c6:	e7b8      	b.n	801403a <_dtoa_r+0x292>
 80140c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80140ca:	9a01      	ldr	r2, [sp, #4]
 80140cc:	601a      	str	r2, [r3, #0]
 80140ce:	9b03      	ldr	r3, [sp, #12]
 80140d0:	2b0e      	cmp	r3, #14
 80140d2:	f200 809d 	bhi.w	8014210 <_dtoa_r+0x468>
 80140d6:	2d00      	cmp	r5, #0
 80140d8:	f000 809a 	beq.w	8014210 <_dtoa_r+0x468>
 80140dc:	9b00      	ldr	r3, [sp, #0]
 80140de:	2b00      	cmp	r3, #0
 80140e0:	dd32      	ble.n	8014148 <_dtoa_r+0x3a0>
 80140e2:	4ab7      	ldr	r2, [pc, #732]	; (80143c0 <_dtoa_r+0x618>)
 80140e4:	f003 030f 	and.w	r3, r3, #15
 80140e8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80140ec:	e9d3 8900 	ldrd	r8, r9, [r3]
 80140f0:	9b00      	ldr	r3, [sp, #0]
 80140f2:	05d8      	lsls	r0, r3, #23
 80140f4:	ea4f 1723 	mov.w	r7, r3, asr #4
 80140f8:	d516      	bpl.n	8014128 <_dtoa_r+0x380>
 80140fa:	4bb2      	ldr	r3, [pc, #712]	; (80143c4 <_dtoa_r+0x61c>)
 80140fc:	ec51 0b19 	vmov	r0, r1, d9
 8014100:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8014104:	f7ec ff9a 	bl	800103c <__aeabi_ddiv>
 8014108:	f007 070f 	and.w	r7, r7, #15
 801410c:	4682      	mov	sl, r0
 801410e:	468b      	mov	fp, r1
 8014110:	2503      	movs	r5, #3
 8014112:	4eac      	ldr	r6, [pc, #688]	; (80143c4 <_dtoa_r+0x61c>)
 8014114:	b957      	cbnz	r7, 801412c <_dtoa_r+0x384>
 8014116:	4642      	mov	r2, r8
 8014118:	464b      	mov	r3, r9
 801411a:	4650      	mov	r0, sl
 801411c:	4659      	mov	r1, fp
 801411e:	f7ec ff8d 	bl	800103c <__aeabi_ddiv>
 8014122:	4682      	mov	sl, r0
 8014124:	468b      	mov	fp, r1
 8014126:	e028      	b.n	801417a <_dtoa_r+0x3d2>
 8014128:	2502      	movs	r5, #2
 801412a:	e7f2      	b.n	8014112 <_dtoa_r+0x36a>
 801412c:	07f9      	lsls	r1, r7, #31
 801412e:	d508      	bpl.n	8014142 <_dtoa_r+0x39a>
 8014130:	4640      	mov	r0, r8
 8014132:	4649      	mov	r1, r9
 8014134:	e9d6 2300 	ldrd	r2, r3, [r6]
 8014138:	f7ec fe56 	bl	8000de8 <__aeabi_dmul>
 801413c:	3501      	adds	r5, #1
 801413e:	4680      	mov	r8, r0
 8014140:	4689      	mov	r9, r1
 8014142:	107f      	asrs	r7, r7, #1
 8014144:	3608      	adds	r6, #8
 8014146:	e7e5      	b.n	8014114 <_dtoa_r+0x36c>
 8014148:	f000 809b 	beq.w	8014282 <_dtoa_r+0x4da>
 801414c:	9b00      	ldr	r3, [sp, #0]
 801414e:	4f9d      	ldr	r7, [pc, #628]	; (80143c4 <_dtoa_r+0x61c>)
 8014150:	425e      	negs	r6, r3
 8014152:	4b9b      	ldr	r3, [pc, #620]	; (80143c0 <_dtoa_r+0x618>)
 8014154:	f006 020f 	and.w	r2, r6, #15
 8014158:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801415c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8014160:	ec51 0b19 	vmov	r0, r1, d9
 8014164:	f7ec fe40 	bl	8000de8 <__aeabi_dmul>
 8014168:	1136      	asrs	r6, r6, #4
 801416a:	4682      	mov	sl, r0
 801416c:	468b      	mov	fp, r1
 801416e:	2300      	movs	r3, #0
 8014170:	2502      	movs	r5, #2
 8014172:	2e00      	cmp	r6, #0
 8014174:	d17a      	bne.n	801426c <_dtoa_r+0x4c4>
 8014176:	2b00      	cmp	r3, #0
 8014178:	d1d3      	bne.n	8014122 <_dtoa_r+0x37a>
 801417a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801417c:	2b00      	cmp	r3, #0
 801417e:	f000 8082 	beq.w	8014286 <_dtoa_r+0x4de>
 8014182:	4b91      	ldr	r3, [pc, #580]	; (80143c8 <_dtoa_r+0x620>)
 8014184:	2200      	movs	r2, #0
 8014186:	4650      	mov	r0, sl
 8014188:	4659      	mov	r1, fp
 801418a:	f7ed f89f 	bl	80012cc <__aeabi_dcmplt>
 801418e:	2800      	cmp	r0, #0
 8014190:	d079      	beq.n	8014286 <_dtoa_r+0x4de>
 8014192:	9b03      	ldr	r3, [sp, #12]
 8014194:	2b00      	cmp	r3, #0
 8014196:	d076      	beq.n	8014286 <_dtoa_r+0x4de>
 8014198:	9b02      	ldr	r3, [sp, #8]
 801419a:	2b00      	cmp	r3, #0
 801419c:	dd36      	ble.n	801420c <_dtoa_r+0x464>
 801419e:	9b00      	ldr	r3, [sp, #0]
 80141a0:	4650      	mov	r0, sl
 80141a2:	4659      	mov	r1, fp
 80141a4:	1e5f      	subs	r7, r3, #1
 80141a6:	2200      	movs	r2, #0
 80141a8:	4b88      	ldr	r3, [pc, #544]	; (80143cc <_dtoa_r+0x624>)
 80141aa:	f7ec fe1d 	bl	8000de8 <__aeabi_dmul>
 80141ae:	9e02      	ldr	r6, [sp, #8]
 80141b0:	4682      	mov	sl, r0
 80141b2:	468b      	mov	fp, r1
 80141b4:	3501      	adds	r5, #1
 80141b6:	4628      	mov	r0, r5
 80141b8:	f7ec fdac 	bl	8000d14 <__aeabi_i2d>
 80141bc:	4652      	mov	r2, sl
 80141be:	465b      	mov	r3, fp
 80141c0:	f7ec fe12 	bl	8000de8 <__aeabi_dmul>
 80141c4:	4b82      	ldr	r3, [pc, #520]	; (80143d0 <_dtoa_r+0x628>)
 80141c6:	2200      	movs	r2, #0
 80141c8:	f7ec fc58 	bl	8000a7c <__adddf3>
 80141cc:	46d0      	mov	r8, sl
 80141ce:	46d9      	mov	r9, fp
 80141d0:	4682      	mov	sl, r0
 80141d2:	f1a1 7b50 	sub.w	fp, r1, #54525952	; 0x3400000
 80141d6:	2e00      	cmp	r6, #0
 80141d8:	d158      	bne.n	801428c <_dtoa_r+0x4e4>
 80141da:	4b7e      	ldr	r3, [pc, #504]	; (80143d4 <_dtoa_r+0x62c>)
 80141dc:	2200      	movs	r2, #0
 80141de:	4640      	mov	r0, r8
 80141e0:	4649      	mov	r1, r9
 80141e2:	f7ec fc49 	bl	8000a78 <__aeabi_dsub>
 80141e6:	4652      	mov	r2, sl
 80141e8:	465b      	mov	r3, fp
 80141ea:	4680      	mov	r8, r0
 80141ec:	4689      	mov	r9, r1
 80141ee:	f7ed f88b 	bl	8001308 <__aeabi_dcmpgt>
 80141f2:	2800      	cmp	r0, #0
 80141f4:	f040 8295 	bne.w	8014722 <_dtoa_r+0x97a>
 80141f8:	4652      	mov	r2, sl
 80141fa:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 80141fe:	4640      	mov	r0, r8
 8014200:	4649      	mov	r1, r9
 8014202:	f7ed f863 	bl	80012cc <__aeabi_dcmplt>
 8014206:	2800      	cmp	r0, #0
 8014208:	f040 8289 	bne.w	801471e <_dtoa_r+0x976>
 801420c:	ec5b ab19 	vmov	sl, fp, d9
 8014210:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8014212:	2b00      	cmp	r3, #0
 8014214:	f2c0 8148 	blt.w	80144a8 <_dtoa_r+0x700>
 8014218:	9a00      	ldr	r2, [sp, #0]
 801421a:	2a0e      	cmp	r2, #14
 801421c:	f300 8144 	bgt.w	80144a8 <_dtoa_r+0x700>
 8014220:	4b67      	ldr	r3, [pc, #412]	; (80143c0 <_dtoa_r+0x618>)
 8014222:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8014226:	e9d3 8900 	ldrd	r8, r9, [r3]
 801422a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801422c:	2b00      	cmp	r3, #0
 801422e:	f280 80d5 	bge.w	80143dc <_dtoa_r+0x634>
 8014232:	9b03      	ldr	r3, [sp, #12]
 8014234:	2b00      	cmp	r3, #0
 8014236:	f300 80d1 	bgt.w	80143dc <_dtoa_r+0x634>
 801423a:	f040 826f 	bne.w	801471c <_dtoa_r+0x974>
 801423e:	4b65      	ldr	r3, [pc, #404]	; (80143d4 <_dtoa_r+0x62c>)
 8014240:	2200      	movs	r2, #0
 8014242:	4640      	mov	r0, r8
 8014244:	4649      	mov	r1, r9
 8014246:	f7ec fdcf 	bl	8000de8 <__aeabi_dmul>
 801424a:	4652      	mov	r2, sl
 801424c:	465b      	mov	r3, fp
 801424e:	f7ed f851 	bl	80012f4 <__aeabi_dcmpge>
 8014252:	9e03      	ldr	r6, [sp, #12]
 8014254:	4637      	mov	r7, r6
 8014256:	2800      	cmp	r0, #0
 8014258:	f040 8245 	bne.w	80146e6 <_dtoa_r+0x93e>
 801425c:	9d01      	ldr	r5, [sp, #4]
 801425e:	2331      	movs	r3, #49	; 0x31
 8014260:	f805 3b01 	strb.w	r3, [r5], #1
 8014264:	9b00      	ldr	r3, [sp, #0]
 8014266:	3301      	adds	r3, #1
 8014268:	9300      	str	r3, [sp, #0]
 801426a:	e240      	b.n	80146ee <_dtoa_r+0x946>
 801426c:	07f2      	lsls	r2, r6, #31
 801426e:	d505      	bpl.n	801427c <_dtoa_r+0x4d4>
 8014270:	e9d7 2300 	ldrd	r2, r3, [r7]
 8014274:	f7ec fdb8 	bl	8000de8 <__aeabi_dmul>
 8014278:	3501      	adds	r5, #1
 801427a:	2301      	movs	r3, #1
 801427c:	1076      	asrs	r6, r6, #1
 801427e:	3708      	adds	r7, #8
 8014280:	e777      	b.n	8014172 <_dtoa_r+0x3ca>
 8014282:	2502      	movs	r5, #2
 8014284:	e779      	b.n	801417a <_dtoa_r+0x3d2>
 8014286:	9f00      	ldr	r7, [sp, #0]
 8014288:	9e03      	ldr	r6, [sp, #12]
 801428a:	e794      	b.n	80141b6 <_dtoa_r+0x40e>
 801428c:	9901      	ldr	r1, [sp, #4]
 801428e:	4b4c      	ldr	r3, [pc, #304]	; (80143c0 <_dtoa_r+0x618>)
 8014290:	4431      	add	r1, r6
 8014292:	910d      	str	r1, [sp, #52]	; 0x34
 8014294:	9908      	ldr	r1, [sp, #32]
 8014296:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 801429a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 801429e:	2900      	cmp	r1, #0
 80142a0:	d043      	beq.n	801432a <_dtoa_r+0x582>
 80142a2:	494d      	ldr	r1, [pc, #308]	; (80143d8 <_dtoa_r+0x630>)
 80142a4:	2000      	movs	r0, #0
 80142a6:	f7ec fec9 	bl	800103c <__aeabi_ddiv>
 80142aa:	4652      	mov	r2, sl
 80142ac:	465b      	mov	r3, fp
 80142ae:	f7ec fbe3 	bl	8000a78 <__aeabi_dsub>
 80142b2:	9d01      	ldr	r5, [sp, #4]
 80142b4:	4682      	mov	sl, r0
 80142b6:	468b      	mov	fp, r1
 80142b8:	4649      	mov	r1, r9
 80142ba:	4640      	mov	r0, r8
 80142bc:	f7ed f844 	bl	8001348 <__aeabi_d2iz>
 80142c0:	4606      	mov	r6, r0
 80142c2:	f7ec fd27 	bl	8000d14 <__aeabi_i2d>
 80142c6:	4602      	mov	r2, r0
 80142c8:	460b      	mov	r3, r1
 80142ca:	4640      	mov	r0, r8
 80142cc:	4649      	mov	r1, r9
 80142ce:	f7ec fbd3 	bl	8000a78 <__aeabi_dsub>
 80142d2:	3630      	adds	r6, #48	; 0x30
 80142d4:	f805 6b01 	strb.w	r6, [r5], #1
 80142d8:	4652      	mov	r2, sl
 80142da:	465b      	mov	r3, fp
 80142dc:	4680      	mov	r8, r0
 80142de:	4689      	mov	r9, r1
 80142e0:	f7ec fff4 	bl	80012cc <__aeabi_dcmplt>
 80142e4:	2800      	cmp	r0, #0
 80142e6:	d163      	bne.n	80143b0 <_dtoa_r+0x608>
 80142e8:	4642      	mov	r2, r8
 80142ea:	464b      	mov	r3, r9
 80142ec:	4936      	ldr	r1, [pc, #216]	; (80143c8 <_dtoa_r+0x620>)
 80142ee:	2000      	movs	r0, #0
 80142f0:	f7ec fbc2 	bl	8000a78 <__aeabi_dsub>
 80142f4:	4652      	mov	r2, sl
 80142f6:	465b      	mov	r3, fp
 80142f8:	f7ec ffe8 	bl	80012cc <__aeabi_dcmplt>
 80142fc:	2800      	cmp	r0, #0
 80142fe:	f040 80b5 	bne.w	801446c <_dtoa_r+0x6c4>
 8014302:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8014304:	429d      	cmp	r5, r3
 8014306:	d081      	beq.n	801420c <_dtoa_r+0x464>
 8014308:	4b30      	ldr	r3, [pc, #192]	; (80143cc <_dtoa_r+0x624>)
 801430a:	2200      	movs	r2, #0
 801430c:	4650      	mov	r0, sl
 801430e:	4659      	mov	r1, fp
 8014310:	f7ec fd6a 	bl	8000de8 <__aeabi_dmul>
 8014314:	4b2d      	ldr	r3, [pc, #180]	; (80143cc <_dtoa_r+0x624>)
 8014316:	4682      	mov	sl, r0
 8014318:	468b      	mov	fp, r1
 801431a:	4640      	mov	r0, r8
 801431c:	4649      	mov	r1, r9
 801431e:	2200      	movs	r2, #0
 8014320:	f7ec fd62 	bl	8000de8 <__aeabi_dmul>
 8014324:	4680      	mov	r8, r0
 8014326:	4689      	mov	r9, r1
 8014328:	e7c6      	b.n	80142b8 <_dtoa_r+0x510>
 801432a:	4650      	mov	r0, sl
 801432c:	4659      	mov	r1, fp
 801432e:	f7ec fd5b 	bl	8000de8 <__aeabi_dmul>
 8014332:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8014334:	9d01      	ldr	r5, [sp, #4]
 8014336:	930f      	str	r3, [sp, #60]	; 0x3c
 8014338:	4682      	mov	sl, r0
 801433a:	468b      	mov	fp, r1
 801433c:	4649      	mov	r1, r9
 801433e:	4640      	mov	r0, r8
 8014340:	f7ed f802 	bl	8001348 <__aeabi_d2iz>
 8014344:	4606      	mov	r6, r0
 8014346:	f7ec fce5 	bl	8000d14 <__aeabi_i2d>
 801434a:	3630      	adds	r6, #48	; 0x30
 801434c:	4602      	mov	r2, r0
 801434e:	460b      	mov	r3, r1
 8014350:	4640      	mov	r0, r8
 8014352:	4649      	mov	r1, r9
 8014354:	f7ec fb90 	bl	8000a78 <__aeabi_dsub>
 8014358:	f805 6b01 	strb.w	r6, [r5], #1
 801435c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801435e:	429d      	cmp	r5, r3
 8014360:	4680      	mov	r8, r0
 8014362:	4689      	mov	r9, r1
 8014364:	f04f 0200 	mov.w	r2, #0
 8014368:	d124      	bne.n	80143b4 <_dtoa_r+0x60c>
 801436a:	4b1b      	ldr	r3, [pc, #108]	; (80143d8 <_dtoa_r+0x630>)
 801436c:	4650      	mov	r0, sl
 801436e:	4659      	mov	r1, fp
 8014370:	f7ec fb84 	bl	8000a7c <__adddf3>
 8014374:	4602      	mov	r2, r0
 8014376:	460b      	mov	r3, r1
 8014378:	4640      	mov	r0, r8
 801437a:	4649      	mov	r1, r9
 801437c:	f7ec ffc4 	bl	8001308 <__aeabi_dcmpgt>
 8014380:	2800      	cmp	r0, #0
 8014382:	d173      	bne.n	801446c <_dtoa_r+0x6c4>
 8014384:	4652      	mov	r2, sl
 8014386:	465b      	mov	r3, fp
 8014388:	4913      	ldr	r1, [pc, #76]	; (80143d8 <_dtoa_r+0x630>)
 801438a:	2000      	movs	r0, #0
 801438c:	f7ec fb74 	bl	8000a78 <__aeabi_dsub>
 8014390:	4602      	mov	r2, r0
 8014392:	460b      	mov	r3, r1
 8014394:	4640      	mov	r0, r8
 8014396:	4649      	mov	r1, r9
 8014398:	f7ec ff98 	bl	80012cc <__aeabi_dcmplt>
 801439c:	2800      	cmp	r0, #0
 801439e:	f43f af35 	beq.w	801420c <_dtoa_r+0x464>
 80143a2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 80143a4:	1e6b      	subs	r3, r5, #1
 80143a6:	930f      	str	r3, [sp, #60]	; 0x3c
 80143a8:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 80143ac:	2b30      	cmp	r3, #48	; 0x30
 80143ae:	d0f8      	beq.n	80143a2 <_dtoa_r+0x5fa>
 80143b0:	9700      	str	r7, [sp, #0]
 80143b2:	e049      	b.n	8014448 <_dtoa_r+0x6a0>
 80143b4:	4b05      	ldr	r3, [pc, #20]	; (80143cc <_dtoa_r+0x624>)
 80143b6:	f7ec fd17 	bl	8000de8 <__aeabi_dmul>
 80143ba:	4680      	mov	r8, r0
 80143bc:	4689      	mov	r9, r1
 80143be:	e7bd      	b.n	801433c <_dtoa_r+0x594>
 80143c0:	0801a430 	.word	0x0801a430
 80143c4:	0801a408 	.word	0x0801a408
 80143c8:	3ff00000 	.word	0x3ff00000
 80143cc:	40240000 	.word	0x40240000
 80143d0:	401c0000 	.word	0x401c0000
 80143d4:	40140000 	.word	0x40140000
 80143d8:	3fe00000 	.word	0x3fe00000
 80143dc:	9d01      	ldr	r5, [sp, #4]
 80143de:	4656      	mov	r6, sl
 80143e0:	465f      	mov	r7, fp
 80143e2:	4642      	mov	r2, r8
 80143e4:	464b      	mov	r3, r9
 80143e6:	4630      	mov	r0, r6
 80143e8:	4639      	mov	r1, r7
 80143ea:	f7ec fe27 	bl	800103c <__aeabi_ddiv>
 80143ee:	f7ec ffab 	bl	8001348 <__aeabi_d2iz>
 80143f2:	4682      	mov	sl, r0
 80143f4:	f7ec fc8e 	bl	8000d14 <__aeabi_i2d>
 80143f8:	4642      	mov	r2, r8
 80143fa:	464b      	mov	r3, r9
 80143fc:	f7ec fcf4 	bl	8000de8 <__aeabi_dmul>
 8014400:	4602      	mov	r2, r0
 8014402:	460b      	mov	r3, r1
 8014404:	4630      	mov	r0, r6
 8014406:	4639      	mov	r1, r7
 8014408:	f10a 0630 	add.w	r6, sl, #48	; 0x30
 801440c:	f7ec fb34 	bl	8000a78 <__aeabi_dsub>
 8014410:	f805 6b01 	strb.w	r6, [r5], #1
 8014414:	9e01      	ldr	r6, [sp, #4]
 8014416:	9f03      	ldr	r7, [sp, #12]
 8014418:	1bae      	subs	r6, r5, r6
 801441a:	42b7      	cmp	r7, r6
 801441c:	4602      	mov	r2, r0
 801441e:	460b      	mov	r3, r1
 8014420:	d135      	bne.n	801448e <_dtoa_r+0x6e6>
 8014422:	f7ec fb2b 	bl	8000a7c <__adddf3>
 8014426:	4642      	mov	r2, r8
 8014428:	464b      	mov	r3, r9
 801442a:	4606      	mov	r6, r0
 801442c:	460f      	mov	r7, r1
 801442e:	f7ec ff6b 	bl	8001308 <__aeabi_dcmpgt>
 8014432:	b9d0      	cbnz	r0, 801446a <_dtoa_r+0x6c2>
 8014434:	4642      	mov	r2, r8
 8014436:	464b      	mov	r3, r9
 8014438:	4630      	mov	r0, r6
 801443a:	4639      	mov	r1, r7
 801443c:	f7ec ff3c 	bl	80012b8 <__aeabi_dcmpeq>
 8014440:	b110      	cbz	r0, 8014448 <_dtoa_r+0x6a0>
 8014442:	f01a 0f01 	tst.w	sl, #1
 8014446:	d110      	bne.n	801446a <_dtoa_r+0x6c2>
 8014448:	4620      	mov	r0, r4
 801444a:	ee18 1a10 	vmov	r1, s16
 801444e:	f000 faf7 	bl	8014a40 <_Bfree>
 8014452:	2300      	movs	r3, #0
 8014454:	9800      	ldr	r0, [sp, #0]
 8014456:	702b      	strb	r3, [r5, #0]
 8014458:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801445a:	3001      	adds	r0, #1
 801445c:	6018      	str	r0, [r3, #0]
 801445e:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8014460:	2b00      	cmp	r3, #0
 8014462:	f43f acf1 	beq.w	8013e48 <_dtoa_r+0xa0>
 8014466:	601d      	str	r5, [r3, #0]
 8014468:	e4ee      	b.n	8013e48 <_dtoa_r+0xa0>
 801446a:	9f00      	ldr	r7, [sp, #0]
 801446c:	462b      	mov	r3, r5
 801446e:	461d      	mov	r5, r3
 8014470:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8014474:	2a39      	cmp	r2, #57	; 0x39
 8014476:	d106      	bne.n	8014486 <_dtoa_r+0x6de>
 8014478:	9a01      	ldr	r2, [sp, #4]
 801447a:	429a      	cmp	r2, r3
 801447c:	d1f7      	bne.n	801446e <_dtoa_r+0x6c6>
 801447e:	9901      	ldr	r1, [sp, #4]
 8014480:	2230      	movs	r2, #48	; 0x30
 8014482:	3701      	adds	r7, #1
 8014484:	700a      	strb	r2, [r1, #0]
 8014486:	781a      	ldrb	r2, [r3, #0]
 8014488:	3201      	adds	r2, #1
 801448a:	701a      	strb	r2, [r3, #0]
 801448c:	e790      	b.n	80143b0 <_dtoa_r+0x608>
 801448e:	4ba6      	ldr	r3, [pc, #664]	; (8014728 <_dtoa_r+0x980>)
 8014490:	2200      	movs	r2, #0
 8014492:	f7ec fca9 	bl	8000de8 <__aeabi_dmul>
 8014496:	2200      	movs	r2, #0
 8014498:	2300      	movs	r3, #0
 801449a:	4606      	mov	r6, r0
 801449c:	460f      	mov	r7, r1
 801449e:	f7ec ff0b 	bl	80012b8 <__aeabi_dcmpeq>
 80144a2:	2800      	cmp	r0, #0
 80144a4:	d09d      	beq.n	80143e2 <_dtoa_r+0x63a>
 80144a6:	e7cf      	b.n	8014448 <_dtoa_r+0x6a0>
 80144a8:	9a08      	ldr	r2, [sp, #32]
 80144aa:	2a00      	cmp	r2, #0
 80144ac:	f000 80d7 	beq.w	801465e <_dtoa_r+0x8b6>
 80144b0:	9a06      	ldr	r2, [sp, #24]
 80144b2:	2a01      	cmp	r2, #1
 80144b4:	f300 80ba 	bgt.w	801462c <_dtoa_r+0x884>
 80144b8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80144ba:	2a00      	cmp	r2, #0
 80144bc:	f000 80b2 	beq.w	8014624 <_dtoa_r+0x87c>
 80144c0:	f203 4333 	addw	r3, r3, #1075	; 0x433
 80144c4:	9e07      	ldr	r6, [sp, #28]
 80144c6:	9d04      	ldr	r5, [sp, #16]
 80144c8:	9a04      	ldr	r2, [sp, #16]
 80144ca:	441a      	add	r2, r3
 80144cc:	9204      	str	r2, [sp, #16]
 80144ce:	9a05      	ldr	r2, [sp, #20]
 80144d0:	2101      	movs	r1, #1
 80144d2:	441a      	add	r2, r3
 80144d4:	4620      	mov	r0, r4
 80144d6:	9205      	str	r2, [sp, #20]
 80144d8:	f000 fb6a 	bl	8014bb0 <__i2b>
 80144dc:	4607      	mov	r7, r0
 80144de:	2d00      	cmp	r5, #0
 80144e0:	dd0c      	ble.n	80144fc <_dtoa_r+0x754>
 80144e2:	9b05      	ldr	r3, [sp, #20]
 80144e4:	2b00      	cmp	r3, #0
 80144e6:	dd09      	ble.n	80144fc <_dtoa_r+0x754>
 80144e8:	42ab      	cmp	r3, r5
 80144ea:	9a04      	ldr	r2, [sp, #16]
 80144ec:	bfa8      	it	ge
 80144ee:	462b      	movge	r3, r5
 80144f0:	1ad2      	subs	r2, r2, r3
 80144f2:	9204      	str	r2, [sp, #16]
 80144f4:	9a05      	ldr	r2, [sp, #20]
 80144f6:	1aed      	subs	r5, r5, r3
 80144f8:	1ad3      	subs	r3, r2, r3
 80144fa:	9305      	str	r3, [sp, #20]
 80144fc:	9b07      	ldr	r3, [sp, #28]
 80144fe:	b31b      	cbz	r3, 8014548 <_dtoa_r+0x7a0>
 8014500:	9b08      	ldr	r3, [sp, #32]
 8014502:	2b00      	cmp	r3, #0
 8014504:	f000 80af 	beq.w	8014666 <_dtoa_r+0x8be>
 8014508:	2e00      	cmp	r6, #0
 801450a:	dd13      	ble.n	8014534 <_dtoa_r+0x78c>
 801450c:	4639      	mov	r1, r7
 801450e:	4632      	mov	r2, r6
 8014510:	4620      	mov	r0, r4
 8014512:	f000 fc0d 	bl	8014d30 <__pow5mult>
 8014516:	ee18 2a10 	vmov	r2, s16
 801451a:	4601      	mov	r1, r0
 801451c:	4607      	mov	r7, r0
 801451e:	4620      	mov	r0, r4
 8014520:	f000 fb5c 	bl	8014bdc <__multiply>
 8014524:	ee18 1a10 	vmov	r1, s16
 8014528:	4680      	mov	r8, r0
 801452a:	4620      	mov	r0, r4
 801452c:	f000 fa88 	bl	8014a40 <_Bfree>
 8014530:	ee08 8a10 	vmov	s16, r8
 8014534:	9b07      	ldr	r3, [sp, #28]
 8014536:	1b9a      	subs	r2, r3, r6
 8014538:	d006      	beq.n	8014548 <_dtoa_r+0x7a0>
 801453a:	ee18 1a10 	vmov	r1, s16
 801453e:	4620      	mov	r0, r4
 8014540:	f000 fbf6 	bl	8014d30 <__pow5mult>
 8014544:	ee08 0a10 	vmov	s16, r0
 8014548:	2101      	movs	r1, #1
 801454a:	4620      	mov	r0, r4
 801454c:	f000 fb30 	bl	8014bb0 <__i2b>
 8014550:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014552:	2b00      	cmp	r3, #0
 8014554:	4606      	mov	r6, r0
 8014556:	f340 8088 	ble.w	801466a <_dtoa_r+0x8c2>
 801455a:	461a      	mov	r2, r3
 801455c:	4601      	mov	r1, r0
 801455e:	4620      	mov	r0, r4
 8014560:	f000 fbe6 	bl	8014d30 <__pow5mult>
 8014564:	9b06      	ldr	r3, [sp, #24]
 8014566:	2b01      	cmp	r3, #1
 8014568:	4606      	mov	r6, r0
 801456a:	f340 8081 	ble.w	8014670 <_dtoa_r+0x8c8>
 801456e:	f04f 0800 	mov.w	r8, #0
 8014572:	6933      	ldr	r3, [r6, #16]
 8014574:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8014578:	6918      	ldr	r0, [r3, #16]
 801457a:	f000 fac9 	bl	8014b10 <__hi0bits>
 801457e:	f1c0 0020 	rsb	r0, r0, #32
 8014582:	9b05      	ldr	r3, [sp, #20]
 8014584:	4418      	add	r0, r3
 8014586:	f010 001f 	ands.w	r0, r0, #31
 801458a:	f000 8092 	beq.w	80146b2 <_dtoa_r+0x90a>
 801458e:	f1c0 0320 	rsb	r3, r0, #32
 8014592:	2b04      	cmp	r3, #4
 8014594:	f340 808a 	ble.w	80146ac <_dtoa_r+0x904>
 8014598:	f1c0 001c 	rsb	r0, r0, #28
 801459c:	9b04      	ldr	r3, [sp, #16]
 801459e:	4403      	add	r3, r0
 80145a0:	9304      	str	r3, [sp, #16]
 80145a2:	9b05      	ldr	r3, [sp, #20]
 80145a4:	4403      	add	r3, r0
 80145a6:	4405      	add	r5, r0
 80145a8:	9305      	str	r3, [sp, #20]
 80145aa:	9b04      	ldr	r3, [sp, #16]
 80145ac:	2b00      	cmp	r3, #0
 80145ae:	dd07      	ble.n	80145c0 <_dtoa_r+0x818>
 80145b0:	ee18 1a10 	vmov	r1, s16
 80145b4:	461a      	mov	r2, r3
 80145b6:	4620      	mov	r0, r4
 80145b8:	f000 fc14 	bl	8014de4 <__lshift>
 80145bc:	ee08 0a10 	vmov	s16, r0
 80145c0:	9b05      	ldr	r3, [sp, #20]
 80145c2:	2b00      	cmp	r3, #0
 80145c4:	dd05      	ble.n	80145d2 <_dtoa_r+0x82a>
 80145c6:	4631      	mov	r1, r6
 80145c8:	461a      	mov	r2, r3
 80145ca:	4620      	mov	r0, r4
 80145cc:	f000 fc0a 	bl	8014de4 <__lshift>
 80145d0:	4606      	mov	r6, r0
 80145d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80145d4:	2b00      	cmp	r3, #0
 80145d6:	d06e      	beq.n	80146b6 <_dtoa_r+0x90e>
 80145d8:	ee18 0a10 	vmov	r0, s16
 80145dc:	4631      	mov	r1, r6
 80145de:	f000 fc71 	bl	8014ec4 <__mcmp>
 80145e2:	2800      	cmp	r0, #0
 80145e4:	da67      	bge.n	80146b6 <_dtoa_r+0x90e>
 80145e6:	9b00      	ldr	r3, [sp, #0]
 80145e8:	3b01      	subs	r3, #1
 80145ea:	ee18 1a10 	vmov	r1, s16
 80145ee:	9300      	str	r3, [sp, #0]
 80145f0:	220a      	movs	r2, #10
 80145f2:	2300      	movs	r3, #0
 80145f4:	4620      	mov	r0, r4
 80145f6:	f000 fa45 	bl	8014a84 <__multadd>
 80145fa:	9b08      	ldr	r3, [sp, #32]
 80145fc:	ee08 0a10 	vmov	s16, r0
 8014600:	2b00      	cmp	r3, #0
 8014602:	f000 81b1 	beq.w	8014968 <_dtoa_r+0xbc0>
 8014606:	2300      	movs	r3, #0
 8014608:	4639      	mov	r1, r7
 801460a:	220a      	movs	r2, #10
 801460c:	4620      	mov	r0, r4
 801460e:	f000 fa39 	bl	8014a84 <__multadd>
 8014612:	9b02      	ldr	r3, [sp, #8]
 8014614:	2b00      	cmp	r3, #0
 8014616:	4607      	mov	r7, r0
 8014618:	f300 808e 	bgt.w	8014738 <_dtoa_r+0x990>
 801461c:	9b06      	ldr	r3, [sp, #24]
 801461e:	2b02      	cmp	r3, #2
 8014620:	dc51      	bgt.n	80146c6 <_dtoa_r+0x91e>
 8014622:	e089      	b.n	8014738 <_dtoa_r+0x990>
 8014624:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014626:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 801462a:	e74b      	b.n	80144c4 <_dtoa_r+0x71c>
 801462c:	9b03      	ldr	r3, [sp, #12]
 801462e:	1e5e      	subs	r6, r3, #1
 8014630:	9b07      	ldr	r3, [sp, #28]
 8014632:	42b3      	cmp	r3, r6
 8014634:	bfbf      	itttt	lt
 8014636:	9b07      	ldrlt	r3, [sp, #28]
 8014638:	9607      	strlt	r6, [sp, #28]
 801463a:	1af2      	sublt	r2, r6, r3
 801463c:	9b0a      	ldrlt	r3, [sp, #40]	; 0x28
 801463e:	bfb6      	itet	lt
 8014640:	189b      	addlt	r3, r3, r2
 8014642:	1b9e      	subge	r6, r3, r6
 8014644:	930a      	strlt	r3, [sp, #40]	; 0x28
 8014646:	9b03      	ldr	r3, [sp, #12]
 8014648:	bfb8      	it	lt
 801464a:	2600      	movlt	r6, #0
 801464c:	2b00      	cmp	r3, #0
 801464e:	bfb7      	itett	lt
 8014650:	e9dd 2303 	ldrdlt	r2, r3, [sp, #12]
 8014654:	e9dd 3503 	ldrdge	r3, r5, [sp, #12]
 8014658:	1a9d      	sublt	r5, r3, r2
 801465a:	2300      	movlt	r3, #0
 801465c:	e734      	b.n	80144c8 <_dtoa_r+0x720>
 801465e:	9e07      	ldr	r6, [sp, #28]
 8014660:	9d04      	ldr	r5, [sp, #16]
 8014662:	9f08      	ldr	r7, [sp, #32]
 8014664:	e73b      	b.n	80144de <_dtoa_r+0x736>
 8014666:	9a07      	ldr	r2, [sp, #28]
 8014668:	e767      	b.n	801453a <_dtoa_r+0x792>
 801466a:	9b06      	ldr	r3, [sp, #24]
 801466c:	2b01      	cmp	r3, #1
 801466e:	dc18      	bgt.n	80146a2 <_dtoa_r+0x8fa>
 8014670:	f1ba 0f00 	cmp.w	sl, #0
 8014674:	d115      	bne.n	80146a2 <_dtoa_r+0x8fa>
 8014676:	f3cb 0313 	ubfx	r3, fp, #0, #20
 801467a:	b993      	cbnz	r3, 80146a2 <_dtoa_r+0x8fa>
 801467c:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8014680:	0d1b      	lsrs	r3, r3, #20
 8014682:	051b      	lsls	r3, r3, #20
 8014684:	b183      	cbz	r3, 80146a8 <_dtoa_r+0x900>
 8014686:	9b04      	ldr	r3, [sp, #16]
 8014688:	3301      	adds	r3, #1
 801468a:	9304      	str	r3, [sp, #16]
 801468c:	9b05      	ldr	r3, [sp, #20]
 801468e:	3301      	adds	r3, #1
 8014690:	9305      	str	r3, [sp, #20]
 8014692:	f04f 0801 	mov.w	r8, #1
 8014696:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014698:	2b00      	cmp	r3, #0
 801469a:	f47f af6a 	bne.w	8014572 <_dtoa_r+0x7ca>
 801469e:	2001      	movs	r0, #1
 80146a0:	e76f      	b.n	8014582 <_dtoa_r+0x7da>
 80146a2:	f04f 0800 	mov.w	r8, #0
 80146a6:	e7f6      	b.n	8014696 <_dtoa_r+0x8ee>
 80146a8:	4698      	mov	r8, r3
 80146aa:	e7f4      	b.n	8014696 <_dtoa_r+0x8ee>
 80146ac:	f43f af7d 	beq.w	80145aa <_dtoa_r+0x802>
 80146b0:	4618      	mov	r0, r3
 80146b2:	301c      	adds	r0, #28
 80146b4:	e772      	b.n	801459c <_dtoa_r+0x7f4>
 80146b6:	9b03      	ldr	r3, [sp, #12]
 80146b8:	2b00      	cmp	r3, #0
 80146ba:	dc37      	bgt.n	801472c <_dtoa_r+0x984>
 80146bc:	9b06      	ldr	r3, [sp, #24]
 80146be:	2b02      	cmp	r3, #2
 80146c0:	dd34      	ble.n	801472c <_dtoa_r+0x984>
 80146c2:	9b03      	ldr	r3, [sp, #12]
 80146c4:	9302      	str	r3, [sp, #8]
 80146c6:	9b02      	ldr	r3, [sp, #8]
 80146c8:	b96b      	cbnz	r3, 80146e6 <_dtoa_r+0x93e>
 80146ca:	4631      	mov	r1, r6
 80146cc:	2205      	movs	r2, #5
 80146ce:	4620      	mov	r0, r4
 80146d0:	f000 f9d8 	bl	8014a84 <__multadd>
 80146d4:	4601      	mov	r1, r0
 80146d6:	4606      	mov	r6, r0
 80146d8:	ee18 0a10 	vmov	r0, s16
 80146dc:	f000 fbf2 	bl	8014ec4 <__mcmp>
 80146e0:	2800      	cmp	r0, #0
 80146e2:	f73f adbb 	bgt.w	801425c <_dtoa_r+0x4b4>
 80146e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80146e8:	9d01      	ldr	r5, [sp, #4]
 80146ea:	43db      	mvns	r3, r3
 80146ec:	9300      	str	r3, [sp, #0]
 80146ee:	f04f 0800 	mov.w	r8, #0
 80146f2:	4631      	mov	r1, r6
 80146f4:	4620      	mov	r0, r4
 80146f6:	f000 f9a3 	bl	8014a40 <_Bfree>
 80146fa:	2f00      	cmp	r7, #0
 80146fc:	f43f aea4 	beq.w	8014448 <_dtoa_r+0x6a0>
 8014700:	f1b8 0f00 	cmp.w	r8, #0
 8014704:	d005      	beq.n	8014712 <_dtoa_r+0x96a>
 8014706:	45b8      	cmp	r8, r7
 8014708:	d003      	beq.n	8014712 <_dtoa_r+0x96a>
 801470a:	4641      	mov	r1, r8
 801470c:	4620      	mov	r0, r4
 801470e:	f000 f997 	bl	8014a40 <_Bfree>
 8014712:	4639      	mov	r1, r7
 8014714:	4620      	mov	r0, r4
 8014716:	f000 f993 	bl	8014a40 <_Bfree>
 801471a:	e695      	b.n	8014448 <_dtoa_r+0x6a0>
 801471c:	2600      	movs	r6, #0
 801471e:	4637      	mov	r7, r6
 8014720:	e7e1      	b.n	80146e6 <_dtoa_r+0x93e>
 8014722:	9700      	str	r7, [sp, #0]
 8014724:	4637      	mov	r7, r6
 8014726:	e599      	b.n	801425c <_dtoa_r+0x4b4>
 8014728:	40240000 	.word	0x40240000
 801472c:	9b08      	ldr	r3, [sp, #32]
 801472e:	2b00      	cmp	r3, #0
 8014730:	f000 80ca 	beq.w	80148c8 <_dtoa_r+0xb20>
 8014734:	9b03      	ldr	r3, [sp, #12]
 8014736:	9302      	str	r3, [sp, #8]
 8014738:	2d00      	cmp	r5, #0
 801473a:	dd05      	ble.n	8014748 <_dtoa_r+0x9a0>
 801473c:	4639      	mov	r1, r7
 801473e:	462a      	mov	r2, r5
 8014740:	4620      	mov	r0, r4
 8014742:	f000 fb4f 	bl	8014de4 <__lshift>
 8014746:	4607      	mov	r7, r0
 8014748:	f1b8 0f00 	cmp.w	r8, #0
 801474c:	d05b      	beq.n	8014806 <_dtoa_r+0xa5e>
 801474e:	6879      	ldr	r1, [r7, #4]
 8014750:	4620      	mov	r0, r4
 8014752:	f000 f935 	bl	80149c0 <_Balloc>
 8014756:	4605      	mov	r5, r0
 8014758:	b928      	cbnz	r0, 8014766 <_dtoa_r+0x9be>
 801475a:	4b87      	ldr	r3, [pc, #540]	; (8014978 <_dtoa_r+0xbd0>)
 801475c:	4602      	mov	r2, r0
 801475e:	f240 21ea 	movw	r1, #746	; 0x2ea
 8014762:	f7ff bb3b 	b.w	8013ddc <_dtoa_r+0x34>
 8014766:	693a      	ldr	r2, [r7, #16]
 8014768:	3202      	adds	r2, #2
 801476a:	0092      	lsls	r2, r2, #2
 801476c:	f107 010c 	add.w	r1, r7, #12
 8014770:	300c      	adds	r0, #12
 8014772:	f7fe fcd9 	bl	8013128 <memcpy>
 8014776:	2201      	movs	r2, #1
 8014778:	4629      	mov	r1, r5
 801477a:	4620      	mov	r0, r4
 801477c:	f000 fb32 	bl	8014de4 <__lshift>
 8014780:	9b01      	ldr	r3, [sp, #4]
 8014782:	f103 0901 	add.w	r9, r3, #1
 8014786:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
 801478a:	4413      	add	r3, r2
 801478c:	9305      	str	r3, [sp, #20]
 801478e:	f00a 0301 	and.w	r3, sl, #1
 8014792:	46b8      	mov	r8, r7
 8014794:	9304      	str	r3, [sp, #16]
 8014796:	4607      	mov	r7, r0
 8014798:	4631      	mov	r1, r6
 801479a:	ee18 0a10 	vmov	r0, s16
 801479e:	f7ff fa75 	bl	8013c8c <quorem>
 80147a2:	4641      	mov	r1, r8
 80147a4:	9002      	str	r0, [sp, #8]
 80147a6:	f100 0a30 	add.w	sl, r0, #48	; 0x30
 80147aa:	ee18 0a10 	vmov	r0, s16
 80147ae:	f000 fb89 	bl	8014ec4 <__mcmp>
 80147b2:	463a      	mov	r2, r7
 80147b4:	9003      	str	r0, [sp, #12]
 80147b6:	4631      	mov	r1, r6
 80147b8:	4620      	mov	r0, r4
 80147ba:	f000 fb9f 	bl	8014efc <__mdiff>
 80147be:	68c2      	ldr	r2, [r0, #12]
 80147c0:	f109 3bff 	add.w	fp, r9, #4294967295
 80147c4:	4605      	mov	r5, r0
 80147c6:	bb02      	cbnz	r2, 801480a <_dtoa_r+0xa62>
 80147c8:	4601      	mov	r1, r0
 80147ca:	ee18 0a10 	vmov	r0, s16
 80147ce:	f000 fb79 	bl	8014ec4 <__mcmp>
 80147d2:	4602      	mov	r2, r0
 80147d4:	4629      	mov	r1, r5
 80147d6:	4620      	mov	r0, r4
 80147d8:	9207      	str	r2, [sp, #28]
 80147da:	f000 f931 	bl	8014a40 <_Bfree>
 80147de:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 80147e2:	ea43 0102 	orr.w	r1, r3, r2
 80147e6:	9b04      	ldr	r3, [sp, #16]
 80147e8:	430b      	orrs	r3, r1
 80147ea:	464d      	mov	r5, r9
 80147ec:	d10f      	bne.n	801480e <_dtoa_r+0xa66>
 80147ee:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 80147f2:	d02a      	beq.n	801484a <_dtoa_r+0xaa2>
 80147f4:	9b03      	ldr	r3, [sp, #12]
 80147f6:	2b00      	cmp	r3, #0
 80147f8:	dd02      	ble.n	8014800 <_dtoa_r+0xa58>
 80147fa:	9b02      	ldr	r3, [sp, #8]
 80147fc:	f103 0a31 	add.w	sl, r3, #49	; 0x31
 8014800:	f88b a000 	strb.w	sl, [fp]
 8014804:	e775      	b.n	80146f2 <_dtoa_r+0x94a>
 8014806:	4638      	mov	r0, r7
 8014808:	e7ba      	b.n	8014780 <_dtoa_r+0x9d8>
 801480a:	2201      	movs	r2, #1
 801480c:	e7e2      	b.n	80147d4 <_dtoa_r+0xa2c>
 801480e:	9b03      	ldr	r3, [sp, #12]
 8014810:	2b00      	cmp	r3, #0
 8014812:	db04      	blt.n	801481e <_dtoa_r+0xa76>
 8014814:	9906      	ldr	r1, [sp, #24]
 8014816:	430b      	orrs	r3, r1
 8014818:	9904      	ldr	r1, [sp, #16]
 801481a:	430b      	orrs	r3, r1
 801481c:	d122      	bne.n	8014864 <_dtoa_r+0xabc>
 801481e:	2a00      	cmp	r2, #0
 8014820:	ddee      	ble.n	8014800 <_dtoa_r+0xa58>
 8014822:	ee18 1a10 	vmov	r1, s16
 8014826:	2201      	movs	r2, #1
 8014828:	4620      	mov	r0, r4
 801482a:	f000 fadb 	bl	8014de4 <__lshift>
 801482e:	4631      	mov	r1, r6
 8014830:	ee08 0a10 	vmov	s16, r0
 8014834:	f000 fb46 	bl	8014ec4 <__mcmp>
 8014838:	2800      	cmp	r0, #0
 801483a:	dc03      	bgt.n	8014844 <_dtoa_r+0xa9c>
 801483c:	d1e0      	bne.n	8014800 <_dtoa_r+0xa58>
 801483e:	f01a 0f01 	tst.w	sl, #1
 8014842:	d0dd      	beq.n	8014800 <_dtoa_r+0xa58>
 8014844:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 8014848:	d1d7      	bne.n	80147fa <_dtoa_r+0xa52>
 801484a:	2339      	movs	r3, #57	; 0x39
 801484c:	f88b 3000 	strb.w	r3, [fp]
 8014850:	462b      	mov	r3, r5
 8014852:	461d      	mov	r5, r3
 8014854:	3b01      	subs	r3, #1
 8014856:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 801485a:	2a39      	cmp	r2, #57	; 0x39
 801485c:	d071      	beq.n	8014942 <_dtoa_r+0xb9a>
 801485e:	3201      	adds	r2, #1
 8014860:	701a      	strb	r2, [r3, #0]
 8014862:	e746      	b.n	80146f2 <_dtoa_r+0x94a>
 8014864:	2a00      	cmp	r2, #0
 8014866:	dd07      	ble.n	8014878 <_dtoa_r+0xad0>
 8014868:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
 801486c:	d0ed      	beq.n	801484a <_dtoa_r+0xaa2>
 801486e:	f10a 0301 	add.w	r3, sl, #1
 8014872:	f88b 3000 	strb.w	r3, [fp]
 8014876:	e73c      	b.n	80146f2 <_dtoa_r+0x94a>
 8014878:	9b05      	ldr	r3, [sp, #20]
 801487a:	f809 ac01 	strb.w	sl, [r9, #-1]
 801487e:	4599      	cmp	r9, r3
 8014880:	d047      	beq.n	8014912 <_dtoa_r+0xb6a>
 8014882:	ee18 1a10 	vmov	r1, s16
 8014886:	2300      	movs	r3, #0
 8014888:	220a      	movs	r2, #10
 801488a:	4620      	mov	r0, r4
 801488c:	f000 f8fa 	bl	8014a84 <__multadd>
 8014890:	45b8      	cmp	r8, r7
 8014892:	ee08 0a10 	vmov	s16, r0
 8014896:	f04f 0300 	mov.w	r3, #0
 801489a:	f04f 020a 	mov.w	r2, #10
 801489e:	4641      	mov	r1, r8
 80148a0:	4620      	mov	r0, r4
 80148a2:	d106      	bne.n	80148b2 <_dtoa_r+0xb0a>
 80148a4:	f000 f8ee 	bl	8014a84 <__multadd>
 80148a8:	4680      	mov	r8, r0
 80148aa:	4607      	mov	r7, r0
 80148ac:	f109 0901 	add.w	r9, r9, #1
 80148b0:	e772      	b.n	8014798 <_dtoa_r+0x9f0>
 80148b2:	f000 f8e7 	bl	8014a84 <__multadd>
 80148b6:	4639      	mov	r1, r7
 80148b8:	4680      	mov	r8, r0
 80148ba:	2300      	movs	r3, #0
 80148bc:	220a      	movs	r2, #10
 80148be:	4620      	mov	r0, r4
 80148c0:	f000 f8e0 	bl	8014a84 <__multadd>
 80148c4:	4607      	mov	r7, r0
 80148c6:	e7f1      	b.n	80148ac <_dtoa_r+0xb04>
 80148c8:	9b03      	ldr	r3, [sp, #12]
 80148ca:	9302      	str	r3, [sp, #8]
 80148cc:	9d01      	ldr	r5, [sp, #4]
 80148ce:	ee18 0a10 	vmov	r0, s16
 80148d2:	4631      	mov	r1, r6
 80148d4:	f7ff f9da 	bl	8013c8c <quorem>
 80148d8:	f100 0a30 	add.w	sl, r0, #48	; 0x30
 80148dc:	9b01      	ldr	r3, [sp, #4]
 80148de:	f805 ab01 	strb.w	sl, [r5], #1
 80148e2:	1aea      	subs	r2, r5, r3
 80148e4:	9b02      	ldr	r3, [sp, #8]
 80148e6:	4293      	cmp	r3, r2
 80148e8:	dd09      	ble.n	80148fe <_dtoa_r+0xb56>
 80148ea:	ee18 1a10 	vmov	r1, s16
 80148ee:	2300      	movs	r3, #0
 80148f0:	220a      	movs	r2, #10
 80148f2:	4620      	mov	r0, r4
 80148f4:	f000 f8c6 	bl	8014a84 <__multadd>
 80148f8:	ee08 0a10 	vmov	s16, r0
 80148fc:	e7e7      	b.n	80148ce <_dtoa_r+0xb26>
 80148fe:	9b02      	ldr	r3, [sp, #8]
 8014900:	2b00      	cmp	r3, #0
 8014902:	bfc8      	it	gt
 8014904:	461d      	movgt	r5, r3
 8014906:	9b01      	ldr	r3, [sp, #4]
 8014908:	bfd8      	it	le
 801490a:	2501      	movle	r5, #1
 801490c:	441d      	add	r5, r3
 801490e:	f04f 0800 	mov.w	r8, #0
 8014912:	ee18 1a10 	vmov	r1, s16
 8014916:	2201      	movs	r2, #1
 8014918:	4620      	mov	r0, r4
 801491a:	f000 fa63 	bl	8014de4 <__lshift>
 801491e:	4631      	mov	r1, r6
 8014920:	ee08 0a10 	vmov	s16, r0
 8014924:	f000 face 	bl	8014ec4 <__mcmp>
 8014928:	2800      	cmp	r0, #0
 801492a:	dc91      	bgt.n	8014850 <_dtoa_r+0xaa8>
 801492c:	d102      	bne.n	8014934 <_dtoa_r+0xb8c>
 801492e:	f01a 0f01 	tst.w	sl, #1
 8014932:	d18d      	bne.n	8014850 <_dtoa_r+0xaa8>
 8014934:	462b      	mov	r3, r5
 8014936:	461d      	mov	r5, r3
 8014938:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 801493c:	2a30      	cmp	r2, #48	; 0x30
 801493e:	d0fa      	beq.n	8014936 <_dtoa_r+0xb8e>
 8014940:	e6d7      	b.n	80146f2 <_dtoa_r+0x94a>
 8014942:	9a01      	ldr	r2, [sp, #4]
 8014944:	429a      	cmp	r2, r3
 8014946:	d184      	bne.n	8014852 <_dtoa_r+0xaaa>
 8014948:	9b00      	ldr	r3, [sp, #0]
 801494a:	3301      	adds	r3, #1
 801494c:	9300      	str	r3, [sp, #0]
 801494e:	2331      	movs	r3, #49	; 0x31
 8014950:	7013      	strb	r3, [r2, #0]
 8014952:	e6ce      	b.n	80146f2 <_dtoa_r+0x94a>
 8014954:	4b09      	ldr	r3, [pc, #36]	; (801497c <_dtoa_r+0xbd4>)
 8014956:	f7ff ba95 	b.w	8013e84 <_dtoa_r+0xdc>
 801495a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801495c:	2b00      	cmp	r3, #0
 801495e:	f47f aa6e 	bne.w	8013e3e <_dtoa_r+0x96>
 8014962:	4b07      	ldr	r3, [pc, #28]	; (8014980 <_dtoa_r+0xbd8>)
 8014964:	f7ff ba8e 	b.w	8013e84 <_dtoa_r+0xdc>
 8014968:	9b02      	ldr	r3, [sp, #8]
 801496a:	2b00      	cmp	r3, #0
 801496c:	dcae      	bgt.n	80148cc <_dtoa_r+0xb24>
 801496e:	9b06      	ldr	r3, [sp, #24]
 8014970:	2b02      	cmp	r3, #2
 8014972:	f73f aea8 	bgt.w	80146c6 <_dtoa_r+0x91e>
 8014976:	e7a9      	b.n	80148cc <_dtoa_r+0xb24>
 8014978:	0801a395 	.word	0x0801a395
 801497c:	0801a519 	.word	0x0801a519
 8014980:	0801a316 	.word	0x0801a316

08014984 <_localeconv_r>:
 8014984:	4800      	ldr	r0, [pc, #0]	; (8014988 <_localeconv_r+0x4>)
 8014986:	4770      	bx	lr
 8014988:	200007e8 	.word	0x200007e8

0801498c <_lseek_r>:
 801498c:	b538      	push	{r3, r4, r5, lr}
 801498e:	4d07      	ldr	r5, [pc, #28]	; (80149ac <_lseek_r+0x20>)
 8014990:	4604      	mov	r4, r0
 8014992:	4608      	mov	r0, r1
 8014994:	4611      	mov	r1, r2
 8014996:	2200      	movs	r2, #0
 8014998:	602a      	str	r2, [r5, #0]
 801499a:	461a      	mov	r2, r3
 801499c:	f7ee fb0a 	bl	8002fb4 <_lseek>
 80149a0:	1c43      	adds	r3, r0, #1
 80149a2:	d102      	bne.n	80149aa <_lseek_r+0x1e>
 80149a4:	682b      	ldr	r3, [r5, #0]
 80149a6:	b103      	cbz	r3, 80149aa <_lseek_r+0x1e>
 80149a8:	6023      	str	r3, [r4, #0]
 80149aa:	bd38      	pop	{r3, r4, r5, pc}
 80149ac:	2004ee60 	.word	0x2004ee60

080149b0 <malloc>:
 80149b0:	4b02      	ldr	r3, [pc, #8]	; (80149bc <malloc+0xc>)
 80149b2:	4601      	mov	r1, r0
 80149b4:	6818      	ldr	r0, [r3, #0]
 80149b6:	f000 bc09 	b.w	80151cc <_malloc_r>
 80149ba:	bf00      	nop
 80149bc:	20000694 	.word	0x20000694

080149c0 <_Balloc>:
 80149c0:	b570      	push	{r4, r5, r6, lr}
 80149c2:	6a46      	ldr	r6, [r0, #36]	; 0x24
 80149c4:	4604      	mov	r4, r0
 80149c6:	460d      	mov	r5, r1
 80149c8:	b976      	cbnz	r6, 80149e8 <_Balloc+0x28>
 80149ca:	2010      	movs	r0, #16
 80149cc:	f7ff fff0 	bl	80149b0 <malloc>
 80149d0:	4602      	mov	r2, r0
 80149d2:	6260      	str	r0, [r4, #36]	; 0x24
 80149d4:	b920      	cbnz	r0, 80149e0 <_Balloc+0x20>
 80149d6:	4b18      	ldr	r3, [pc, #96]	; (8014a38 <_Balloc+0x78>)
 80149d8:	4818      	ldr	r0, [pc, #96]	; (8014a3c <_Balloc+0x7c>)
 80149da:	2166      	movs	r1, #102	; 0x66
 80149dc:	f001 fa76 	bl	8015ecc <__assert_func>
 80149e0:	e9c0 6601 	strd	r6, r6, [r0, #4]
 80149e4:	6006      	str	r6, [r0, #0]
 80149e6:	60c6      	str	r6, [r0, #12]
 80149e8:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80149ea:	68f3      	ldr	r3, [r6, #12]
 80149ec:	b183      	cbz	r3, 8014a10 <_Balloc+0x50>
 80149ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80149f0:	68db      	ldr	r3, [r3, #12]
 80149f2:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 80149f6:	b9b8      	cbnz	r0, 8014a28 <_Balloc+0x68>
 80149f8:	2101      	movs	r1, #1
 80149fa:	fa01 f605 	lsl.w	r6, r1, r5
 80149fe:	1d72      	adds	r2, r6, #5
 8014a00:	0092      	lsls	r2, r2, #2
 8014a02:	4620      	mov	r0, r4
 8014a04:	f000 fb60 	bl	80150c8 <_calloc_r>
 8014a08:	b160      	cbz	r0, 8014a24 <_Balloc+0x64>
 8014a0a:	e9c0 5601 	strd	r5, r6, [r0, #4]
 8014a0e:	e00e      	b.n	8014a2e <_Balloc+0x6e>
 8014a10:	2221      	movs	r2, #33	; 0x21
 8014a12:	2104      	movs	r1, #4
 8014a14:	4620      	mov	r0, r4
 8014a16:	f000 fb57 	bl	80150c8 <_calloc_r>
 8014a1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8014a1c:	60f0      	str	r0, [r6, #12]
 8014a1e:	68db      	ldr	r3, [r3, #12]
 8014a20:	2b00      	cmp	r3, #0
 8014a22:	d1e4      	bne.n	80149ee <_Balloc+0x2e>
 8014a24:	2000      	movs	r0, #0
 8014a26:	bd70      	pop	{r4, r5, r6, pc}
 8014a28:	6802      	ldr	r2, [r0, #0]
 8014a2a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 8014a2e:	2300      	movs	r3, #0
 8014a30:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8014a34:	e7f7      	b.n	8014a26 <_Balloc+0x66>
 8014a36:	bf00      	nop
 8014a38:	0801a323 	.word	0x0801a323
 8014a3c:	0801a3a6 	.word	0x0801a3a6

08014a40 <_Bfree>:
 8014a40:	b570      	push	{r4, r5, r6, lr}
 8014a42:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8014a44:	4605      	mov	r5, r0
 8014a46:	460c      	mov	r4, r1
 8014a48:	b976      	cbnz	r6, 8014a68 <_Bfree+0x28>
 8014a4a:	2010      	movs	r0, #16
 8014a4c:	f7ff ffb0 	bl	80149b0 <malloc>
 8014a50:	4602      	mov	r2, r0
 8014a52:	6268      	str	r0, [r5, #36]	; 0x24
 8014a54:	b920      	cbnz	r0, 8014a60 <_Bfree+0x20>
 8014a56:	4b09      	ldr	r3, [pc, #36]	; (8014a7c <_Bfree+0x3c>)
 8014a58:	4809      	ldr	r0, [pc, #36]	; (8014a80 <_Bfree+0x40>)
 8014a5a:	218a      	movs	r1, #138	; 0x8a
 8014a5c:	f001 fa36 	bl	8015ecc <__assert_func>
 8014a60:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8014a64:	6006      	str	r6, [r0, #0]
 8014a66:	60c6      	str	r6, [r0, #12]
 8014a68:	b13c      	cbz	r4, 8014a7a <_Bfree+0x3a>
 8014a6a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8014a6c:	6862      	ldr	r2, [r4, #4]
 8014a6e:	68db      	ldr	r3, [r3, #12]
 8014a70:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8014a74:	6021      	str	r1, [r4, #0]
 8014a76:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8014a7a:	bd70      	pop	{r4, r5, r6, pc}
 8014a7c:	0801a323 	.word	0x0801a323
 8014a80:	0801a3a6 	.word	0x0801a3a6

08014a84 <__multadd>:
 8014a84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014a88:	690d      	ldr	r5, [r1, #16]
 8014a8a:	4607      	mov	r7, r0
 8014a8c:	460c      	mov	r4, r1
 8014a8e:	461e      	mov	r6, r3
 8014a90:	f101 0c14 	add.w	ip, r1, #20
 8014a94:	2000      	movs	r0, #0
 8014a96:	f8dc 3000 	ldr.w	r3, [ip]
 8014a9a:	b299      	uxth	r1, r3
 8014a9c:	fb02 6101 	mla	r1, r2, r1, r6
 8014aa0:	0c1e      	lsrs	r6, r3, #16
 8014aa2:	0c0b      	lsrs	r3, r1, #16
 8014aa4:	fb02 3306 	mla	r3, r2, r6, r3
 8014aa8:	b289      	uxth	r1, r1
 8014aaa:	3001      	adds	r0, #1
 8014aac:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8014ab0:	4285      	cmp	r5, r0
 8014ab2:	f84c 1b04 	str.w	r1, [ip], #4
 8014ab6:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8014aba:	dcec      	bgt.n	8014a96 <__multadd+0x12>
 8014abc:	b30e      	cbz	r6, 8014b02 <__multadd+0x7e>
 8014abe:	68a3      	ldr	r3, [r4, #8]
 8014ac0:	42ab      	cmp	r3, r5
 8014ac2:	dc19      	bgt.n	8014af8 <__multadd+0x74>
 8014ac4:	6861      	ldr	r1, [r4, #4]
 8014ac6:	4638      	mov	r0, r7
 8014ac8:	3101      	adds	r1, #1
 8014aca:	f7ff ff79 	bl	80149c0 <_Balloc>
 8014ace:	4680      	mov	r8, r0
 8014ad0:	b928      	cbnz	r0, 8014ade <__multadd+0x5a>
 8014ad2:	4602      	mov	r2, r0
 8014ad4:	4b0c      	ldr	r3, [pc, #48]	; (8014b08 <__multadd+0x84>)
 8014ad6:	480d      	ldr	r0, [pc, #52]	; (8014b0c <__multadd+0x88>)
 8014ad8:	21b5      	movs	r1, #181	; 0xb5
 8014ada:	f001 f9f7 	bl	8015ecc <__assert_func>
 8014ade:	6922      	ldr	r2, [r4, #16]
 8014ae0:	3202      	adds	r2, #2
 8014ae2:	f104 010c 	add.w	r1, r4, #12
 8014ae6:	0092      	lsls	r2, r2, #2
 8014ae8:	300c      	adds	r0, #12
 8014aea:	f7fe fb1d 	bl	8013128 <memcpy>
 8014aee:	4621      	mov	r1, r4
 8014af0:	4638      	mov	r0, r7
 8014af2:	f7ff ffa5 	bl	8014a40 <_Bfree>
 8014af6:	4644      	mov	r4, r8
 8014af8:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8014afc:	3501      	adds	r5, #1
 8014afe:	615e      	str	r6, [r3, #20]
 8014b00:	6125      	str	r5, [r4, #16]
 8014b02:	4620      	mov	r0, r4
 8014b04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014b08:	0801a395 	.word	0x0801a395
 8014b0c:	0801a3a6 	.word	0x0801a3a6

08014b10 <__hi0bits>:
 8014b10:	0c03      	lsrs	r3, r0, #16
 8014b12:	041b      	lsls	r3, r3, #16
 8014b14:	b9d3      	cbnz	r3, 8014b4c <__hi0bits+0x3c>
 8014b16:	0400      	lsls	r0, r0, #16
 8014b18:	2310      	movs	r3, #16
 8014b1a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 8014b1e:	bf04      	itt	eq
 8014b20:	0200      	lsleq	r0, r0, #8
 8014b22:	3308      	addeq	r3, #8
 8014b24:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8014b28:	bf04      	itt	eq
 8014b2a:	0100      	lsleq	r0, r0, #4
 8014b2c:	3304      	addeq	r3, #4
 8014b2e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8014b32:	bf04      	itt	eq
 8014b34:	0080      	lsleq	r0, r0, #2
 8014b36:	3302      	addeq	r3, #2
 8014b38:	2800      	cmp	r0, #0
 8014b3a:	db05      	blt.n	8014b48 <__hi0bits+0x38>
 8014b3c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8014b40:	f103 0301 	add.w	r3, r3, #1
 8014b44:	bf08      	it	eq
 8014b46:	2320      	moveq	r3, #32
 8014b48:	4618      	mov	r0, r3
 8014b4a:	4770      	bx	lr
 8014b4c:	2300      	movs	r3, #0
 8014b4e:	e7e4      	b.n	8014b1a <__hi0bits+0xa>

08014b50 <__lo0bits>:
 8014b50:	6803      	ldr	r3, [r0, #0]
 8014b52:	f013 0207 	ands.w	r2, r3, #7
 8014b56:	4601      	mov	r1, r0
 8014b58:	d00b      	beq.n	8014b72 <__lo0bits+0x22>
 8014b5a:	07da      	lsls	r2, r3, #31
 8014b5c:	d423      	bmi.n	8014ba6 <__lo0bits+0x56>
 8014b5e:	0798      	lsls	r0, r3, #30
 8014b60:	bf49      	itett	mi
 8014b62:	085b      	lsrmi	r3, r3, #1
 8014b64:	089b      	lsrpl	r3, r3, #2
 8014b66:	2001      	movmi	r0, #1
 8014b68:	600b      	strmi	r3, [r1, #0]
 8014b6a:	bf5c      	itt	pl
 8014b6c:	600b      	strpl	r3, [r1, #0]
 8014b6e:	2002      	movpl	r0, #2
 8014b70:	4770      	bx	lr
 8014b72:	b298      	uxth	r0, r3
 8014b74:	b9a8      	cbnz	r0, 8014ba2 <__lo0bits+0x52>
 8014b76:	0c1b      	lsrs	r3, r3, #16
 8014b78:	2010      	movs	r0, #16
 8014b7a:	b2da      	uxtb	r2, r3
 8014b7c:	b90a      	cbnz	r2, 8014b82 <__lo0bits+0x32>
 8014b7e:	3008      	adds	r0, #8
 8014b80:	0a1b      	lsrs	r3, r3, #8
 8014b82:	071a      	lsls	r2, r3, #28
 8014b84:	bf04      	itt	eq
 8014b86:	091b      	lsreq	r3, r3, #4
 8014b88:	3004      	addeq	r0, #4
 8014b8a:	079a      	lsls	r2, r3, #30
 8014b8c:	bf04      	itt	eq
 8014b8e:	089b      	lsreq	r3, r3, #2
 8014b90:	3002      	addeq	r0, #2
 8014b92:	07da      	lsls	r2, r3, #31
 8014b94:	d403      	bmi.n	8014b9e <__lo0bits+0x4e>
 8014b96:	085b      	lsrs	r3, r3, #1
 8014b98:	f100 0001 	add.w	r0, r0, #1
 8014b9c:	d005      	beq.n	8014baa <__lo0bits+0x5a>
 8014b9e:	600b      	str	r3, [r1, #0]
 8014ba0:	4770      	bx	lr
 8014ba2:	4610      	mov	r0, r2
 8014ba4:	e7e9      	b.n	8014b7a <__lo0bits+0x2a>
 8014ba6:	2000      	movs	r0, #0
 8014ba8:	4770      	bx	lr
 8014baa:	2020      	movs	r0, #32
 8014bac:	4770      	bx	lr
	...

08014bb0 <__i2b>:
 8014bb0:	b510      	push	{r4, lr}
 8014bb2:	460c      	mov	r4, r1
 8014bb4:	2101      	movs	r1, #1
 8014bb6:	f7ff ff03 	bl	80149c0 <_Balloc>
 8014bba:	4602      	mov	r2, r0
 8014bbc:	b928      	cbnz	r0, 8014bca <__i2b+0x1a>
 8014bbe:	4b05      	ldr	r3, [pc, #20]	; (8014bd4 <__i2b+0x24>)
 8014bc0:	4805      	ldr	r0, [pc, #20]	; (8014bd8 <__i2b+0x28>)
 8014bc2:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8014bc6:	f001 f981 	bl	8015ecc <__assert_func>
 8014bca:	2301      	movs	r3, #1
 8014bcc:	6144      	str	r4, [r0, #20]
 8014bce:	6103      	str	r3, [r0, #16]
 8014bd0:	bd10      	pop	{r4, pc}
 8014bd2:	bf00      	nop
 8014bd4:	0801a395 	.word	0x0801a395
 8014bd8:	0801a3a6 	.word	0x0801a3a6

08014bdc <__multiply>:
 8014bdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014be0:	4691      	mov	r9, r2
 8014be2:	690a      	ldr	r2, [r1, #16]
 8014be4:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8014be8:	429a      	cmp	r2, r3
 8014bea:	bfb8      	it	lt
 8014bec:	460b      	movlt	r3, r1
 8014bee:	460c      	mov	r4, r1
 8014bf0:	bfbc      	itt	lt
 8014bf2:	464c      	movlt	r4, r9
 8014bf4:	4699      	movlt	r9, r3
 8014bf6:	6927      	ldr	r7, [r4, #16]
 8014bf8:	f8d9 a010 	ldr.w	sl, [r9, #16]
 8014bfc:	68a3      	ldr	r3, [r4, #8]
 8014bfe:	6861      	ldr	r1, [r4, #4]
 8014c00:	eb07 060a 	add.w	r6, r7, sl
 8014c04:	42b3      	cmp	r3, r6
 8014c06:	b085      	sub	sp, #20
 8014c08:	bfb8      	it	lt
 8014c0a:	3101      	addlt	r1, #1
 8014c0c:	f7ff fed8 	bl	80149c0 <_Balloc>
 8014c10:	b930      	cbnz	r0, 8014c20 <__multiply+0x44>
 8014c12:	4602      	mov	r2, r0
 8014c14:	4b44      	ldr	r3, [pc, #272]	; (8014d28 <__multiply+0x14c>)
 8014c16:	4845      	ldr	r0, [pc, #276]	; (8014d2c <__multiply+0x150>)
 8014c18:	f240 115d 	movw	r1, #349	; 0x15d
 8014c1c:	f001 f956 	bl	8015ecc <__assert_func>
 8014c20:	f100 0514 	add.w	r5, r0, #20
 8014c24:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 8014c28:	462b      	mov	r3, r5
 8014c2a:	2200      	movs	r2, #0
 8014c2c:	4543      	cmp	r3, r8
 8014c2e:	d321      	bcc.n	8014c74 <__multiply+0x98>
 8014c30:	f104 0314 	add.w	r3, r4, #20
 8014c34:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8014c38:	f109 0314 	add.w	r3, r9, #20
 8014c3c:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 8014c40:	9202      	str	r2, [sp, #8]
 8014c42:	1b3a      	subs	r2, r7, r4
 8014c44:	3a15      	subs	r2, #21
 8014c46:	f022 0203 	bic.w	r2, r2, #3
 8014c4a:	3204      	adds	r2, #4
 8014c4c:	f104 0115 	add.w	r1, r4, #21
 8014c50:	428f      	cmp	r7, r1
 8014c52:	bf38      	it	cc
 8014c54:	2204      	movcc	r2, #4
 8014c56:	9201      	str	r2, [sp, #4]
 8014c58:	9a02      	ldr	r2, [sp, #8]
 8014c5a:	9303      	str	r3, [sp, #12]
 8014c5c:	429a      	cmp	r2, r3
 8014c5e:	d80c      	bhi.n	8014c7a <__multiply+0x9e>
 8014c60:	2e00      	cmp	r6, #0
 8014c62:	dd03      	ble.n	8014c6c <__multiply+0x90>
 8014c64:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8014c68:	2b00      	cmp	r3, #0
 8014c6a:	d05a      	beq.n	8014d22 <__multiply+0x146>
 8014c6c:	6106      	str	r6, [r0, #16]
 8014c6e:	b005      	add	sp, #20
 8014c70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014c74:	f843 2b04 	str.w	r2, [r3], #4
 8014c78:	e7d8      	b.n	8014c2c <__multiply+0x50>
 8014c7a:	f8b3 a000 	ldrh.w	sl, [r3]
 8014c7e:	f1ba 0f00 	cmp.w	sl, #0
 8014c82:	d024      	beq.n	8014cce <__multiply+0xf2>
 8014c84:	f104 0e14 	add.w	lr, r4, #20
 8014c88:	46a9      	mov	r9, r5
 8014c8a:	f04f 0c00 	mov.w	ip, #0
 8014c8e:	f85e 2b04 	ldr.w	r2, [lr], #4
 8014c92:	f8d9 1000 	ldr.w	r1, [r9]
 8014c96:	fa1f fb82 	uxth.w	fp, r2
 8014c9a:	b289      	uxth	r1, r1
 8014c9c:	fb0a 110b 	mla	r1, sl, fp, r1
 8014ca0:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 8014ca4:	f8d9 2000 	ldr.w	r2, [r9]
 8014ca8:	4461      	add	r1, ip
 8014caa:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8014cae:	fb0a c20b 	mla	r2, sl, fp, ip
 8014cb2:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 8014cb6:	b289      	uxth	r1, r1
 8014cb8:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8014cbc:	4577      	cmp	r7, lr
 8014cbe:	f849 1b04 	str.w	r1, [r9], #4
 8014cc2:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 8014cc6:	d8e2      	bhi.n	8014c8e <__multiply+0xb2>
 8014cc8:	9a01      	ldr	r2, [sp, #4]
 8014cca:	f845 c002 	str.w	ip, [r5, r2]
 8014cce:	9a03      	ldr	r2, [sp, #12]
 8014cd0:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 8014cd4:	3304      	adds	r3, #4
 8014cd6:	f1b9 0f00 	cmp.w	r9, #0
 8014cda:	d020      	beq.n	8014d1e <__multiply+0x142>
 8014cdc:	6829      	ldr	r1, [r5, #0]
 8014cde:	f104 0c14 	add.w	ip, r4, #20
 8014ce2:	46ae      	mov	lr, r5
 8014ce4:	f04f 0a00 	mov.w	sl, #0
 8014ce8:	f8bc b000 	ldrh.w	fp, [ip]
 8014cec:	f8be 2002 	ldrh.w	r2, [lr, #2]
 8014cf0:	fb09 220b 	mla	r2, r9, fp, r2
 8014cf4:	4492      	add	sl, r2
 8014cf6:	b289      	uxth	r1, r1
 8014cf8:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 8014cfc:	f84e 1b04 	str.w	r1, [lr], #4
 8014d00:	f85c 2b04 	ldr.w	r2, [ip], #4
 8014d04:	f8be 1000 	ldrh.w	r1, [lr]
 8014d08:	0c12      	lsrs	r2, r2, #16
 8014d0a:	fb09 1102 	mla	r1, r9, r2, r1
 8014d0e:	eb01 411a 	add.w	r1, r1, sl, lsr #16
 8014d12:	4567      	cmp	r7, ip
 8014d14:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 8014d18:	d8e6      	bhi.n	8014ce8 <__multiply+0x10c>
 8014d1a:	9a01      	ldr	r2, [sp, #4]
 8014d1c:	50a9      	str	r1, [r5, r2]
 8014d1e:	3504      	adds	r5, #4
 8014d20:	e79a      	b.n	8014c58 <__multiply+0x7c>
 8014d22:	3e01      	subs	r6, #1
 8014d24:	e79c      	b.n	8014c60 <__multiply+0x84>
 8014d26:	bf00      	nop
 8014d28:	0801a395 	.word	0x0801a395
 8014d2c:	0801a3a6 	.word	0x0801a3a6

08014d30 <__pow5mult>:
 8014d30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014d34:	4615      	mov	r5, r2
 8014d36:	f012 0203 	ands.w	r2, r2, #3
 8014d3a:	4606      	mov	r6, r0
 8014d3c:	460f      	mov	r7, r1
 8014d3e:	d007      	beq.n	8014d50 <__pow5mult+0x20>
 8014d40:	4c25      	ldr	r4, [pc, #148]	; (8014dd8 <__pow5mult+0xa8>)
 8014d42:	3a01      	subs	r2, #1
 8014d44:	2300      	movs	r3, #0
 8014d46:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8014d4a:	f7ff fe9b 	bl	8014a84 <__multadd>
 8014d4e:	4607      	mov	r7, r0
 8014d50:	10ad      	asrs	r5, r5, #2
 8014d52:	d03d      	beq.n	8014dd0 <__pow5mult+0xa0>
 8014d54:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8014d56:	b97c      	cbnz	r4, 8014d78 <__pow5mult+0x48>
 8014d58:	2010      	movs	r0, #16
 8014d5a:	f7ff fe29 	bl	80149b0 <malloc>
 8014d5e:	4602      	mov	r2, r0
 8014d60:	6270      	str	r0, [r6, #36]	; 0x24
 8014d62:	b928      	cbnz	r0, 8014d70 <__pow5mult+0x40>
 8014d64:	4b1d      	ldr	r3, [pc, #116]	; (8014ddc <__pow5mult+0xac>)
 8014d66:	481e      	ldr	r0, [pc, #120]	; (8014de0 <__pow5mult+0xb0>)
 8014d68:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8014d6c:	f001 f8ae 	bl	8015ecc <__assert_func>
 8014d70:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8014d74:	6004      	str	r4, [r0, #0]
 8014d76:	60c4      	str	r4, [r0, #12]
 8014d78:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 8014d7c:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8014d80:	b94c      	cbnz	r4, 8014d96 <__pow5mult+0x66>
 8014d82:	f240 2171 	movw	r1, #625	; 0x271
 8014d86:	4630      	mov	r0, r6
 8014d88:	f7ff ff12 	bl	8014bb0 <__i2b>
 8014d8c:	2300      	movs	r3, #0
 8014d8e:	f8c8 0008 	str.w	r0, [r8, #8]
 8014d92:	4604      	mov	r4, r0
 8014d94:	6003      	str	r3, [r0, #0]
 8014d96:	f04f 0900 	mov.w	r9, #0
 8014d9a:	07eb      	lsls	r3, r5, #31
 8014d9c:	d50a      	bpl.n	8014db4 <__pow5mult+0x84>
 8014d9e:	4639      	mov	r1, r7
 8014da0:	4622      	mov	r2, r4
 8014da2:	4630      	mov	r0, r6
 8014da4:	f7ff ff1a 	bl	8014bdc <__multiply>
 8014da8:	4639      	mov	r1, r7
 8014daa:	4680      	mov	r8, r0
 8014dac:	4630      	mov	r0, r6
 8014dae:	f7ff fe47 	bl	8014a40 <_Bfree>
 8014db2:	4647      	mov	r7, r8
 8014db4:	106d      	asrs	r5, r5, #1
 8014db6:	d00b      	beq.n	8014dd0 <__pow5mult+0xa0>
 8014db8:	6820      	ldr	r0, [r4, #0]
 8014dba:	b938      	cbnz	r0, 8014dcc <__pow5mult+0x9c>
 8014dbc:	4622      	mov	r2, r4
 8014dbe:	4621      	mov	r1, r4
 8014dc0:	4630      	mov	r0, r6
 8014dc2:	f7ff ff0b 	bl	8014bdc <__multiply>
 8014dc6:	6020      	str	r0, [r4, #0]
 8014dc8:	f8c0 9000 	str.w	r9, [r0]
 8014dcc:	4604      	mov	r4, r0
 8014dce:	e7e4      	b.n	8014d9a <__pow5mult+0x6a>
 8014dd0:	4638      	mov	r0, r7
 8014dd2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8014dd6:	bf00      	nop
 8014dd8:	0801a4f8 	.word	0x0801a4f8
 8014ddc:	0801a323 	.word	0x0801a323
 8014de0:	0801a3a6 	.word	0x0801a3a6

08014de4 <__lshift>:
 8014de4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014de8:	460c      	mov	r4, r1
 8014dea:	6849      	ldr	r1, [r1, #4]
 8014dec:	6923      	ldr	r3, [r4, #16]
 8014dee:	eb03 1862 	add.w	r8, r3, r2, asr #5
 8014df2:	68a3      	ldr	r3, [r4, #8]
 8014df4:	4607      	mov	r7, r0
 8014df6:	4691      	mov	r9, r2
 8014df8:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8014dfc:	f108 0601 	add.w	r6, r8, #1
 8014e00:	42b3      	cmp	r3, r6
 8014e02:	db0b      	blt.n	8014e1c <__lshift+0x38>
 8014e04:	4638      	mov	r0, r7
 8014e06:	f7ff fddb 	bl	80149c0 <_Balloc>
 8014e0a:	4605      	mov	r5, r0
 8014e0c:	b948      	cbnz	r0, 8014e22 <__lshift+0x3e>
 8014e0e:	4602      	mov	r2, r0
 8014e10:	4b2a      	ldr	r3, [pc, #168]	; (8014ebc <__lshift+0xd8>)
 8014e12:	482b      	ldr	r0, [pc, #172]	; (8014ec0 <__lshift+0xdc>)
 8014e14:	f240 11d9 	movw	r1, #473	; 0x1d9
 8014e18:	f001 f858 	bl	8015ecc <__assert_func>
 8014e1c:	3101      	adds	r1, #1
 8014e1e:	005b      	lsls	r3, r3, #1
 8014e20:	e7ee      	b.n	8014e00 <__lshift+0x1c>
 8014e22:	2300      	movs	r3, #0
 8014e24:	f100 0114 	add.w	r1, r0, #20
 8014e28:	f100 0210 	add.w	r2, r0, #16
 8014e2c:	4618      	mov	r0, r3
 8014e2e:	4553      	cmp	r3, sl
 8014e30:	db37      	blt.n	8014ea2 <__lshift+0xbe>
 8014e32:	6920      	ldr	r0, [r4, #16]
 8014e34:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8014e38:	f104 0314 	add.w	r3, r4, #20
 8014e3c:	f019 091f 	ands.w	r9, r9, #31
 8014e40:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8014e44:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8014e48:	d02f      	beq.n	8014eaa <__lshift+0xc6>
 8014e4a:	f1c9 0e20 	rsb	lr, r9, #32
 8014e4e:	468a      	mov	sl, r1
 8014e50:	f04f 0c00 	mov.w	ip, #0
 8014e54:	681a      	ldr	r2, [r3, #0]
 8014e56:	fa02 f209 	lsl.w	r2, r2, r9
 8014e5a:	ea42 020c 	orr.w	r2, r2, ip
 8014e5e:	f84a 2b04 	str.w	r2, [sl], #4
 8014e62:	f853 2b04 	ldr.w	r2, [r3], #4
 8014e66:	4298      	cmp	r0, r3
 8014e68:	fa22 fc0e 	lsr.w	ip, r2, lr
 8014e6c:	d8f2      	bhi.n	8014e54 <__lshift+0x70>
 8014e6e:	1b03      	subs	r3, r0, r4
 8014e70:	3b15      	subs	r3, #21
 8014e72:	f023 0303 	bic.w	r3, r3, #3
 8014e76:	3304      	adds	r3, #4
 8014e78:	f104 0215 	add.w	r2, r4, #21
 8014e7c:	4290      	cmp	r0, r2
 8014e7e:	bf38      	it	cc
 8014e80:	2304      	movcc	r3, #4
 8014e82:	f841 c003 	str.w	ip, [r1, r3]
 8014e86:	f1bc 0f00 	cmp.w	ip, #0
 8014e8a:	d001      	beq.n	8014e90 <__lshift+0xac>
 8014e8c:	f108 0602 	add.w	r6, r8, #2
 8014e90:	3e01      	subs	r6, #1
 8014e92:	4638      	mov	r0, r7
 8014e94:	612e      	str	r6, [r5, #16]
 8014e96:	4621      	mov	r1, r4
 8014e98:	f7ff fdd2 	bl	8014a40 <_Bfree>
 8014e9c:	4628      	mov	r0, r5
 8014e9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8014ea2:	f842 0f04 	str.w	r0, [r2, #4]!
 8014ea6:	3301      	adds	r3, #1
 8014ea8:	e7c1      	b.n	8014e2e <__lshift+0x4a>
 8014eaa:	3904      	subs	r1, #4
 8014eac:	f853 2b04 	ldr.w	r2, [r3], #4
 8014eb0:	f841 2f04 	str.w	r2, [r1, #4]!
 8014eb4:	4298      	cmp	r0, r3
 8014eb6:	d8f9      	bhi.n	8014eac <__lshift+0xc8>
 8014eb8:	e7ea      	b.n	8014e90 <__lshift+0xac>
 8014eba:	bf00      	nop
 8014ebc:	0801a395 	.word	0x0801a395
 8014ec0:	0801a3a6 	.word	0x0801a3a6

08014ec4 <__mcmp>:
 8014ec4:	b530      	push	{r4, r5, lr}
 8014ec6:	6902      	ldr	r2, [r0, #16]
 8014ec8:	690c      	ldr	r4, [r1, #16]
 8014eca:	1b12      	subs	r2, r2, r4
 8014ecc:	d10e      	bne.n	8014eec <__mcmp+0x28>
 8014ece:	f100 0314 	add.w	r3, r0, #20
 8014ed2:	3114      	adds	r1, #20
 8014ed4:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 8014ed8:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8014edc:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 8014ee0:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 8014ee4:	42a5      	cmp	r5, r4
 8014ee6:	d003      	beq.n	8014ef0 <__mcmp+0x2c>
 8014ee8:	d305      	bcc.n	8014ef6 <__mcmp+0x32>
 8014eea:	2201      	movs	r2, #1
 8014eec:	4610      	mov	r0, r2
 8014eee:	bd30      	pop	{r4, r5, pc}
 8014ef0:	4283      	cmp	r3, r0
 8014ef2:	d3f3      	bcc.n	8014edc <__mcmp+0x18>
 8014ef4:	e7fa      	b.n	8014eec <__mcmp+0x28>
 8014ef6:	f04f 32ff 	mov.w	r2, #4294967295
 8014efa:	e7f7      	b.n	8014eec <__mcmp+0x28>

08014efc <__mdiff>:
 8014efc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014f00:	460c      	mov	r4, r1
 8014f02:	4606      	mov	r6, r0
 8014f04:	4611      	mov	r1, r2
 8014f06:	4620      	mov	r0, r4
 8014f08:	4690      	mov	r8, r2
 8014f0a:	f7ff ffdb 	bl	8014ec4 <__mcmp>
 8014f0e:	1e05      	subs	r5, r0, #0
 8014f10:	d110      	bne.n	8014f34 <__mdiff+0x38>
 8014f12:	4629      	mov	r1, r5
 8014f14:	4630      	mov	r0, r6
 8014f16:	f7ff fd53 	bl	80149c0 <_Balloc>
 8014f1a:	b930      	cbnz	r0, 8014f2a <__mdiff+0x2e>
 8014f1c:	4b3a      	ldr	r3, [pc, #232]	; (8015008 <__mdiff+0x10c>)
 8014f1e:	4602      	mov	r2, r0
 8014f20:	f240 2132 	movw	r1, #562	; 0x232
 8014f24:	4839      	ldr	r0, [pc, #228]	; (801500c <__mdiff+0x110>)
 8014f26:	f000 ffd1 	bl	8015ecc <__assert_func>
 8014f2a:	2301      	movs	r3, #1
 8014f2c:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8014f30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014f34:	bfa4      	itt	ge
 8014f36:	4643      	movge	r3, r8
 8014f38:	46a0      	movge	r8, r4
 8014f3a:	4630      	mov	r0, r6
 8014f3c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8014f40:	bfa6      	itte	ge
 8014f42:	461c      	movge	r4, r3
 8014f44:	2500      	movge	r5, #0
 8014f46:	2501      	movlt	r5, #1
 8014f48:	f7ff fd3a 	bl	80149c0 <_Balloc>
 8014f4c:	b920      	cbnz	r0, 8014f58 <__mdiff+0x5c>
 8014f4e:	4b2e      	ldr	r3, [pc, #184]	; (8015008 <__mdiff+0x10c>)
 8014f50:	4602      	mov	r2, r0
 8014f52:	f44f 7110 	mov.w	r1, #576	; 0x240
 8014f56:	e7e5      	b.n	8014f24 <__mdiff+0x28>
 8014f58:	f8d8 7010 	ldr.w	r7, [r8, #16]
 8014f5c:	6926      	ldr	r6, [r4, #16]
 8014f5e:	60c5      	str	r5, [r0, #12]
 8014f60:	f104 0914 	add.w	r9, r4, #20
 8014f64:	f108 0514 	add.w	r5, r8, #20
 8014f68:	f100 0e14 	add.w	lr, r0, #20
 8014f6c:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
 8014f70:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 8014f74:	f108 0210 	add.w	r2, r8, #16
 8014f78:	46f2      	mov	sl, lr
 8014f7a:	2100      	movs	r1, #0
 8014f7c:	f859 3b04 	ldr.w	r3, [r9], #4
 8014f80:	f852 bf04 	ldr.w	fp, [r2, #4]!
 8014f84:	fa1f f883 	uxth.w	r8, r3
 8014f88:	fa11 f18b 	uxtah	r1, r1, fp
 8014f8c:	0c1b      	lsrs	r3, r3, #16
 8014f8e:	eba1 0808 	sub.w	r8, r1, r8
 8014f92:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 8014f96:	eb03 4328 	add.w	r3, r3, r8, asr #16
 8014f9a:	fa1f f888 	uxth.w	r8, r8
 8014f9e:	1419      	asrs	r1, r3, #16
 8014fa0:	454e      	cmp	r6, r9
 8014fa2:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 8014fa6:	f84a 3b04 	str.w	r3, [sl], #4
 8014faa:	d8e7      	bhi.n	8014f7c <__mdiff+0x80>
 8014fac:	1b33      	subs	r3, r6, r4
 8014fae:	3b15      	subs	r3, #21
 8014fb0:	f023 0303 	bic.w	r3, r3, #3
 8014fb4:	3304      	adds	r3, #4
 8014fb6:	3415      	adds	r4, #21
 8014fb8:	42a6      	cmp	r6, r4
 8014fba:	bf38      	it	cc
 8014fbc:	2304      	movcc	r3, #4
 8014fbe:	441d      	add	r5, r3
 8014fc0:	4473      	add	r3, lr
 8014fc2:	469e      	mov	lr, r3
 8014fc4:	462e      	mov	r6, r5
 8014fc6:	4566      	cmp	r6, ip
 8014fc8:	d30e      	bcc.n	8014fe8 <__mdiff+0xec>
 8014fca:	f10c 0203 	add.w	r2, ip, #3
 8014fce:	1b52      	subs	r2, r2, r5
 8014fd0:	f022 0203 	bic.w	r2, r2, #3
 8014fd4:	3d03      	subs	r5, #3
 8014fd6:	45ac      	cmp	ip, r5
 8014fd8:	bf38      	it	cc
 8014fda:	2200      	movcc	r2, #0
 8014fdc:	441a      	add	r2, r3
 8014fde:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 8014fe2:	b17b      	cbz	r3, 8015004 <__mdiff+0x108>
 8014fe4:	6107      	str	r7, [r0, #16]
 8014fe6:	e7a3      	b.n	8014f30 <__mdiff+0x34>
 8014fe8:	f856 8b04 	ldr.w	r8, [r6], #4
 8014fec:	fa11 f288 	uxtah	r2, r1, r8
 8014ff0:	1414      	asrs	r4, r2, #16
 8014ff2:	eb04 4418 	add.w	r4, r4, r8, lsr #16
 8014ff6:	b292      	uxth	r2, r2
 8014ff8:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 8014ffc:	f84e 2b04 	str.w	r2, [lr], #4
 8015000:	1421      	asrs	r1, r4, #16
 8015002:	e7e0      	b.n	8014fc6 <__mdiff+0xca>
 8015004:	3f01      	subs	r7, #1
 8015006:	e7ea      	b.n	8014fde <__mdiff+0xe2>
 8015008:	0801a395 	.word	0x0801a395
 801500c:	0801a3a6 	.word	0x0801a3a6

08015010 <__d2b>:
 8015010:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8015014:	4689      	mov	r9, r1
 8015016:	2101      	movs	r1, #1
 8015018:	ec57 6b10 	vmov	r6, r7, d0
 801501c:	4690      	mov	r8, r2
 801501e:	f7ff fccf 	bl	80149c0 <_Balloc>
 8015022:	4604      	mov	r4, r0
 8015024:	b930      	cbnz	r0, 8015034 <__d2b+0x24>
 8015026:	4602      	mov	r2, r0
 8015028:	4b25      	ldr	r3, [pc, #148]	; (80150c0 <__d2b+0xb0>)
 801502a:	4826      	ldr	r0, [pc, #152]	; (80150c4 <__d2b+0xb4>)
 801502c:	f240 310a 	movw	r1, #778	; 0x30a
 8015030:	f000 ff4c 	bl	8015ecc <__assert_func>
 8015034:	f3c7 550a 	ubfx	r5, r7, #20, #11
 8015038:	f3c7 0313 	ubfx	r3, r7, #0, #20
 801503c:	bb35      	cbnz	r5, 801508c <__d2b+0x7c>
 801503e:	2e00      	cmp	r6, #0
 8015040:	9301      	str	r3, [sp, #4]
 8015042:	d028      	beq.n	8015096 <__d2b+0x86>
 8015044:	4668      	mov	r0, sp
 8015046:	9600      	str	r6, [sp, #0]
 8015048:	f7ff fd82 	bl	8014b50 <__lo0bits>
 801504c:	9900      	ldr	r1, [sp, #0]
 801504e:	b300      	cbz	r0, 8015092 <__d2b+0x82>
 8015050:	9a01      	ldr	r2, [sp, #4]
 8015052:	f1c0 0320 	rsb	r3, r0, #32
 8015056:	fa02 f303 	lsl.w	r3, r2, r3
 801505a:	430b      	orrs	r3, r1
 801505c:	40c2      	lsrs	r2, r0
 801505e:	6163      	str	r3, [r4, #20]
 8015060:	9201      	str	r2, [sp, #4]
 8015062:	9b01      	ldr	r3, [sp, #4]
 8015064:	61a3      	str	r3, [r4, #24]
 8015066:	2b00      	cmp	r3, #0
 8015068:	bf14      	ite	ne
 801506a:	2202      	movne	r2, #2
 801506c:	2201      	moveq	r2, #1
 801506e:	6122      	str	r2, [r4, #16]
 8015070:	b1d5      	cbz	r5, 80150a8 <__d2b+0x98>
 8015072:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8015076:	4405      	add	r5, r0
 8015078:	f8c9 5000 	str.w	r5, [r9]
 801507c:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8015080:	f8c8 0000 	str.w	r0, [r8]
 8015084:	4620      	mov	r0, r4
 8015086:	b003      	add	sp, #12
 8015088:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801508c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8015090:	e7d5      	b.n	801503e <__d2b+0x2e>
 8015092:	6161      	str	r1, [r4, #20]
 8015094:	e7e5      	b.n	8015062 <__d2b+0x52>
 8015096:	a801      	add	r0, sp, #4
 8015098:	f7ff fd5a 	bl	8014b50 <__lo0bits>
 801509c:	9b01      	ldr	r3, [sp, #4]
 801509e:	6163      	str	r3, [r4, #20]
 80150a0:	2201      	movs	r2, #1
 80150a2:	6122      	str	r2, [r4, #16]
 80150a4:	3020      	adds	r0, #32
 80150a6:	e7e3      	b.n	8015070 <__d2b+0x60>
 80150a8:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 80150ac:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 80150b0:	f8c9 0000 	str.w	r0, [r9]
 80150b4:	6918      	ldr	r0, [r3, #16]
 80150b6:	f7ff fd2b 	bl	8014b10 <__hi0bits>
 80150ba:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 80150be:	e7df      	b.n	8015080 <__d2b+0x70>
 80150c0:	0801a395 	.word	0x0801a395
 80150c4:	0801a3a6 	.word	0x0801a3a6

080150c8 <_calloc_r>:
 80150c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80150ca:	fba1 2402 	umull	r2, r4, r1, r2
 80150ce:	b94c      	cbnz	r4, 80150e4 <_calloc_r+0x1c>
 80150d0:	4611      	mov	r1, r2
 80150d2:	9201      	str	r2, [sp, #4]
 80150d4:	f000 f87a 	bl	80151cc <_malloc_r>
 80150d8:	9a01      	ldr	r2, [sp, #4]
 80150da:	4605      	mov	r5, r0
 80150dc:	b930      	cbnz	r0, 80150ec <_calloc_r+0x24>
 80150de:	4628      	mov	r0, r5
 80150e0:	b003      	add	sp, #12
 80150e2:	bd30      	pop	{r4, r5, pc}
 80150e4:	220c      	movs	r2, #12
 80150e6:	6002      	str	r2, [r0, #0]
 80150e8:	2500      	movs	r5, #0
 80150ea:	e7f8      	b.n	80150de <_calloc_r+0x16>
 80150ec:	4621      	mov	r1, r4
 80150ee:	f7fe f843 	bl	8013178 <memset>
 80150f2:	e7f4      	b.n	80150de <_calloc_r+0x16>

080150f4 <_free_r>:
 80150f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80150f6:	2900      	cmp	r1, #0
 80150f8:	d044      	beq.n	8015184 <_free_r+0x90>
 80150fa:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80150fe:	9001      	str	r0, [sp, #4]
 8015100:	2b00      	cmp	r3, #0
 8015102:	f1a1 0404 	sub.w	r4, r1, #4
 8015106:	bfb8      	it	lt
 8015108:	18e4      	addlt	r4, r4, r3
 801510a:	f001 f8db 	bl	80162c4 <__malloc_lock>
 801510e:	4a1e      	ldr	r2, [pc, #120]	; (8015188 <_free_r+0x94>)
 8015110:	9801      	ldr	r0, [sp, #4]
 8015112:	6813      	ldr	r3, [r2, #0]
 8015114:	b933      	cbnz	r3, 8015124 <_free_r+0x30>
 8015116:	6063      	str	r3, [r4, #4]
 8015118:	6014      	str	r4, [r2, #0]
 801511a:	b003      	add	sp, #12
 801511c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8015120:	f001 b8d6 	b.w	80162d0 <__malloc_unlock>
 8015124:	42a3      	cmp	r3, r4
 8015126:	d908      	bls.n	801513a <_free_r+0x46>
 8015128:	6825      	ldr	r5, [r4, #0]
 801512a:	1961      	adds	r1, r4, r5
 801512c:	428b      	cmp	r3, r1
 801512e:	bf01      	itttt	eq
 8015130:	6819      	ldreq	r1, [r3, #0]
 8015132:	685b      	ldreq	r3, [r3, #4]
 8015134:	1949      	addeq	r1, r1, r5
 8015136:	6021      	streq	r1, [r4, #0]
 8015138:	e7ed      	b.n	8015116 <_free_r+0x22>
 801513a:	461a      	mov	r2, r3
 801513c:	685b      	ldr	r3, [r3, #4]
 801513e:	b10b      	cbz	r3, 8015144 <_free_r+0x50>
 8015140:	42a3      	cmp	r3, r4
 8015142:	d9fa      	bls.n	801513a <_free_r+0x46>
 8015144:	6811      	ldr	r1, [r2, #0]
 8015146:	1855      	adds	r5, r2, r1
 8015148:	42a5      	cmp	r5, r4
 801514a:	d10b      	bne.n	8015164 <_free_r+0x70>
 801514c:	6824      	ldr	r4, [r4, #0]
 801514e:	4421      	add	r1, r4
 8015150:	1854      	adds	r4, r2, r1
 8015152:	42a3      	cmp	r3, r4
 8015154:	6011      	str	r1, [r2, #0]
 8015156:	d1e0      	bne.n	801511a <_free_r+0x26>
 8015158:	681c      	ldr	r4, [r3, #0]
 801515a:	685b      	ldr	r3, [r3, #4]
 801515c:	6053      	str	r3, [r2, #4]
 801515e:	4421      	add	r1, r4
 8015160:	6011      	str	r1, [r2, #0]
 8015162:	e7da      	b.n	801511a <_free_r+0x26>
 8015164:	d902      	bls.n	801516c <_free_r+0x78>
 8015166:	230c      	movs	r3, #12
 8015168:	6003      	str	r3, [r0, #0]
 801516a:	e7d6      	b.n	801511a <_free_r+0x26>
 801516c:	6825      	ldr	r5, [r4, #0]
 801516e:	1961      	adds	r1, r4, r5
 8015170:	428b      	cmp	r3, r1
 8015172:	bf04      	itt	eq
 8015174:	6819      	ldreq	r1, [r3, #0]
 8015176:	685b      	ldreq	r3, [r3, #4]
 8015178:	6063      	str	r3, [r4, #4]
 801517a:	bf04      	itt	eq
 801517c:	1949      	addeq	r1, r1, r5
 801517e:	6021      	streq	r1, [r4, #0]
 8015180:	6054      	str	r4, [r2, #4]
 8015182:	e7ca      	b.n	801511a <_free_r+0x26>
 8015184:	b003      	add	sp, #12
 8015186:	bd30      	pop	{r4, r5, pc}
 8015188:	2004ee58 	.word	0x2004ee58

0801518c <sbrk_aligned>:
 801518c:	b570      	push	{r4, r5, r6, lr}
 801518e:	4e0e      	ldr	r6, [pc, #56]	; (80151c8 <sbrk_aligned+0x3c>)
 8015190:	460c      	mov	r4, r1
 8015192:	6831      	ldr	r1, [r6, #0]
 8015194:	4605      	mov	r5, r0
 8015196:	b911      	cbnz	r1, 801519e <sbrk_aligned+0x12>
 8015198:	f000 fd1e 	bl	8015bd8 <_sbrk_r>
 801519c:	6030      	str	r0, [r6, #0]
 801519e:	4621      	mov	r1, r4
 80151a0:	4628      	mov	r0, r5
 80151a2:	f000 fd19 	bl	8015bd8 <_sbrk_r>
 80151a6:	1c43      	adds	r3, r0, #1
 80151a8:	d00a      	beq.n	80151c0 <sbrk_aligned+0x34>
 80151aa:	1cc4      	adds	r4, r0, #3
 80151ac:	f024 0403 	bic.w	r4, r4, #3
 80151b0:	42a0      	cmp	r0, r4
 80151b2:	d007      	beq.n	80151c4 <sbrk_aligned+0x38>
 80151b4:	1a21      	subs	r1, r4, r0
 80151b6:	4628      	mov	r0, r5
 80151b8:	f000 fd0e 	bl	8015bd8 <_sbrk_r>
 80151bc:	3001      	adds	r0, #1
 80151be:	d101      	bne.n	80151c4 <sbrk_aligned+0x38>
 80151c0:	f04f 34ff 	mov.w	r4, #4294967295
 80151c4:	4620      	mov	r0, r4
 80151c6:	bd70      	pop	{r4, r5, r6, pc}
 80151c8:	2004ee5c 	.word	0x2004ee5c

080151cc <_malloc_r>:
 80151cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80151d0:	1ccd      	adds	r5, r1, #3
 80151d2:	f025 0503 	bic.w	r5, r5, #3
 80151d6:	3508      	adds	r5, #8
 80151d8:	2d0c      	cmp	r5, #12
 80151da:	bf38      	it	cc
 80151dc:	250c      	movcc	r5, #12
 80151de:	2d00      	cmp	r5, #0
 80151e0:	4607      	mov	r7, r0
 80151e2:	db01      	blt.n	80151e8 <_malloc_r+0x1c>
 80151e4:	42a9      	cmp	r1, r5
 80151e6:	d905      	bls.n	80151f4 <_malloc_r+0x28>
 80151e8:	230c      	movs	r3, #12
 80151ea:	603b      	str	r3, [r7, #0]
 80151ec:	2600      	movs	r6, #0
 80151ee:	4630      	mov	r0, r6
 80151f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80151f4:	4e2e      	ldr	r6, [pc, #184]	; (80152b0 <_malloc_r+0xe4>)
 80151f6:	f001 f865 	bl	80162c4 <__malloc_lock>
 80151fa:	6833      	ldr	r3, [r6, #0]
 80151fc:	461c      	mov	r4, r3
 80151fe:	bb34      	cbnz	r4, 801524e <_malloc_r+0x82>
 8015200:	4629      	mov	r1, r5
 8015202:	4638      	mov	r0, r7
 8015204:	f7ff ffc2 	bl	801518c <sbrk_aligned>
 8015208:	1c43      	adds	r3, r0, #1
 801520a:	4604      	mov	r4, r0
 801520c:	d14d      	bne.n	80152aa <_malloc_r+0xde>
 801520e:	6834      	ldr	r4, [r6, #0]
 8015210:	4626      	mov	r6, r4
 8015212:	2e00      	cmp	r6, #0
 8015214:	d140      	bne.n	8015298 <_malloc_r+0xcc>
 8015216:	6823      	ldr	r3, [r4, #0]
 8015218:	4631      	mov	r1, r6
 801521a:	4638      	mov	r0, r7
 801521c:	eb04 0803 	add.w	r8, r4, r3
 8015220:	f000 fcda 	bl	8015bd8 <_sbrk_r>
 8015224:	4580      	cmp	r8, r0
 8015226:	d13a      	bne.n	801529e <_malloc_r+0xd2>
 8015228:	6821      	ldr	r1, [r4, #0]
 801522a:	3503      	adds	r5, #3
 801522c:	1a6d      	subs	r5, r5, r1
 801522e:	f025 0503 	bic.w	r5, r5, #3
 8015232:	3508      	adds	r5, #8
 8015234:	2d0c      	cmp	r5, #12
 8015236:	bf38      	it	cc
 8015238:	250c      	movcc	r5, #12
 801523a:	4629      	mov	r1, r5
 801523c:	4638      	mov	r0, r7
 801523e:	f7ff ffa5 	bl	801518c <sbrk_aligned>
 8015242:	3001      	adds	r0, #1
 8015244:	d02b      	beq.n	801529e <_malloc_r+0xd2>
 8015246:	6823      	ldr	r3, [r4, #0]
 8015248:	442b      	add	r3, r5
 801524a:	6023      	str	r3, [r4, #0]
 801524c:	e00e      	b.n	801526c <_malloc_r+0xa0>
 801524e:	6822      	ldr	r2, [r4, #0]
 8015250:	1b52      	subs	r2, r2, r5
 8015252:	d41e      	bmi.n	8015292 <_malloc_r+0xc6>
 8015254:	2a0b      	cmp	r2, #11
 8015256:	d916      	bls.n	8015286 <_malloc_r+0xba>
 8015258:	1961      	adds	r1, r4, r5
 801525a:	42a3      	cmp	r3, r4
 801525c:	6025      	str	r5, [r4, #0]
 801525e:	bf18      	it	ne
 8015260:	6059      	strne	r1, [r3, #4]
 8015262:	6863      	ldr	r3, [r4, #4]
 8015264:	bf08      	it	eq
 8015266:	6031      	streq	r1, [r6, #0]
 8015268:	5162      	str	r2, [r4, r5]
 801526a:	604b      	str	r3, [r1, #4]
 801526c:	4638      	mov	r0, r7
 801526e:	f104 060b 	add.w	r6, r4, #11
 8015272:	f001 f82d 	bl	80162d0 <__malloc_unlock>
 8015276:	f026 0607 	bic.w	r6, r6, #7
 801527a:	1d23      	adds	r3, r4, #4
 801527c:	1af2      	subs	r2, r6, r3
 801527e:	d0b6      	beq.n	80151ee <_malloc_r+0x22>
 8015280:	1b9b      	subs	r3, r3, r6
 8015282:	50a3      	str	r3, [r4, r2]
 8015284:	e7b3      	b.n	80151ee <_malloc_r+0x22>
 8015286:	6862      	ldr	r2, [r4, #4]
 8015288:	42a3      	cmp	r3, r4
 801528a:	bf0c      	ite	eq
 801528c:	6032      	streq	r2, [r6, #0]
 801528e:	605a      	strne	r2, [r3, #4]
 8015290:	e7ec      	b.n	801526c <_malloc_r+0xa0>
 8015292:	4623      	mov	r3, r4
 8015294:	6864      	ldr	r4, [r4, #4]
 8015296:	e7b2      	b.n	80151fe <_malloc_r+0x32>
 8015298:	4634      	mov	r4, r6
 801529a:	6876      	ldr	r6, [r6, #4]
 801529c:	e7b9      	b.n	8015212 <_malloc_r+0x46>
 801529e:	230c      	movs	r3, #12
 80152a0:	603b      	str	r3, [r7, #0]
 80152a2:	4638      	mov	r0, r7
 80152a4:	f001 f814 	bl	80162d0 <__malloc_unlock>
 80152a8:	e7a1      	b.n	80151ee <_malloc_r+0x22>
 80152aa:	6025      	str	r5, [r4, #0]
 80152ac:	e7de      	b.n	801526c <_malloc_r+0xa0>
 80152ae:	bf00      	nop
 80152b0:	2004ee58 	.word	0x2004ee58

080152b4 <__ssputs_r>:
 80152b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80152b8:	688e      	ldr	r6, [r1, #8]
 80152ba:	429e      	cmp	r6, r3
 80152bc:	4682      	mov	sl, r0
 80152be:	460c      	mov	r4, r1
 80152c0:	4690      	mov	r8, r2
 80152c2:	461f      	mov	r7, r3
 80152c4:	d838      	bhi.n	8015338 <__ssputs_r+0x84>
 80152c6:	898a      	ldrh	r2, [r1, #12]
 80152c8:	f412 6f90 	tst.w	r2, #1152	; 0x480
 80152cc:	d032      	beq.n	8015334 <__ssputs_r+0x80>
 80152ce:	6825      	ldr	r5, [r4, #0]
 80152d0:	6909      	ldr	r1, [r1, #16]
 80152d2:	eba5 0901 	sub.w	r9, r5, r1
 80152d6:	6965      	ldr	r5, [r4, #20]
 80152d8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80152dc:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80152e0:	3301      	adds	r3, #1
 80152e2:	444b      	add	r3, r9
 80152e4:	106d      	asrs	r5, r5, #1
 80152e6:	429d      	cmp	r5, r3
 80152e8:	bf38      	it	cc
 80152ea:	461d      	movcc	r5, r3
 80152ec:	0553      	lsls	r3, r2, #21
 80152ee:	d531      	bpl.n	8015354 <__ssputs_r+0xa0>
 80152f0:	4629      	mov	r1, r5
 80152f2:	f7ff ff6b 	bl	80151cc <_malloc_r>
 80152f6:	4606      	mov	r6, r0
 80152f8:	b950      	cbnz	r0, 8015310 <__ssputs_r+0x5c>
 80152fa:	230c      	movs	r3, #12
 80152fc:	f8ca 3000 	str.w	r3, [sl]
 8015300:	89a3      	ldrh	r3, [r4, #12]
 8015302:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015306:	81a3      	strh	r3, [r4, #12]
 8015308:	f04f 30ff 	mov.w	r0, #4294967295
 801530c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015310:	6921      	ldr	r1, [r4, #16]
 8015312:	464a      	mov	r2, r9
 8015314:	f7fd ff08 	bl	8013128 <memcpy>
 8015318:	89a3      	ldrh	r3, [r4, #12]
 801531a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 801531e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8015322:	81a3      	strh	r3, [r4, #12]
 8015324:	6126      	str	r6, [r4, #16]
 8015326:	6165      	str	r5, [r4, #20]
 8015328:	444e      	add	r6, r9
 801532a:	eba5 0509 	sub.w	r5, r5, r9
 801532e:	6026      	str	r6, [r4, #0]
 8015330:	60a5      	str	r5, [r4, #8]
 8015332:	463e      	mov	r6, r7
 8015334:	42be      	cmp	r6, r7
 8015336:	d900      	bls.n	801533a <__ssputs_r+0x86>
 8015338:	463e      	mov	r6, r7
 801533a:	6820      	ldr	r0, [r4, #0]
 801533c:	4632      	mov	r2, r6
 801533e:	4641      	mov	r1, r8
 8015340:	f7fd ff00 	bl	8013144 <memmove>
 8015344:	68a3      	ldr	r3, [r4, #8]
 8015346:	1b9b      	subs	r3, r3, r6
 8015348:	60a3      	str	r3, [r4, #8]
 801534a:	6823      	ldr	r3, [r4, #0]
 801534c:	4433      	add	r3, r6
 801534e:	6023      	str	r3, [r4, #0]
 8015350:	2000      	movs	r0, #0
 8015352:	e7db      	b.n	801530c <__ssputs_r+0x58>
 8015354:	462a      	mov	r2, r5
 8015356:	f000 ffc1 	bl	80162dc <_realloc_r>
 801535a:	4606      	mov	r6, r0
 801535c:	2800      	cmp	r0, #0
 801535e:	d1e1      	bne.n	8015324 <__ssputs_r+0x70>
 8015360:	6921      	ldr	r1, [r4, #16]
 8015362:	4650      	mov	r0, sl
 8015364:	f7ff fec6 	bl	80150f4 <_free_r>
 8015368:	e7c7      	b.n	80152fa <__ssputs_r+0x46>
	...

0801536c <_svfiprintf_r>:
 801536c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015370:	4698      	mov	r8, r3
 8015372:	898b      	ldrh	r3, [r1, #12]
 8015374:	061b      	lsls	r3, r3, #24
 8015376:	b09d      	sub	sp, #116	; 0x74
 8015378:	4607      	mov	r7, r0
 801537a:	460d      	mov	r5, r1
 801537c:	4614      	mov	r4, r2
 801537e:	d50e      	bpl.n	801539e <_svfiprintf_r+0x32>
 8015380:	690b      	ldr	r3, [r1, #16]
 8015382:	b963      	cbnz	r3, 801539e <_svfiprintf_r+0x32>
 8015384:	2140      	movs	r1, #64	; 0x40
 8015386:	f7ff ff21 	bl	80151cc <_malloc_r>
 801538a:	6028      	str	r0, [r5, #0]
 801538c:	6128      	str	r0, [r5, #16]
 801538e:	b920      	cbnz	r0, 801539a <_svfiprintf_r+0x2e>
 8015390:	230c      	movs	r3, #12
 8015392:	603b      	str	r3, [r7, #0]
 8015394:	f04f 30ff 	mov.w	r0, #4294967295
 8015398:	e0d1      	b.n	801553e <_svfiprintf_r+0x1d2>
 801539a:	2340      	movs	r3, #64	; 0x40
 801539c:	616b      	str	r3, [r5, #20]
 801539e:	2300      	movs	r3, #0
 80153a0:	9309      	str	r3, [sp, #36]	; 0x24
 80153a2:	2320      	movs	r3, #32
 80153a4:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80153a8:	f8cd 800c 	str.w	r8, [sp, #12]
 80153ac:	2330      	movs	r3, #48	; 0x30
 80153ae:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8015558 <_svfiprintf_r+0x1ec>
 80153b2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80153b6:	f04f 0901 	mov.w	r9, #1
 80153ba:	4623      	mov	r3, r4
 80153bc:	469a      	mov	sl, r3
 80153be:	f813 2b01 	ldrb.w	r2, [r3], #1
 80153c2:	b10a      	cbz	r2, 80153c8 <_svfiprintf_r+0x5c>
 80153c4:	2a25      	cmp	r2, #37	; 0x25
 80153c6:	d1f9      	bne.n	80153bc <_svfiprintf_r+0x50>
 80153c8:	ebba 0b04 	subs.w	fp, sl, r4
 80153cc:	d00b      	beq.n	80153e6 <_svfiprintf_r+0x7a>
 80153ce:	465b      	mov	r3, fp
 80153d0:	4622      	mov	r2, r4
 80153d2:	4629      	mov	r1, r5
 80153d4:	4638      	mov	r0, r7
 80153d6:	f7ff ff6d 	bl	80152b4 <__ssputs_r>
 80153da:	3001      	adds	r0, #1
 80153dc:	f000 80aa 	beq.w	8015534 <_svfiprintf_r+0x1c8>
 80153e0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80153e2:	445a      	add	r2, fp
 80153e4:	9209      	str	r2, [sp, #36]	; 0x24
 80153e6:	f89a 3000 	ldrb.w	r3, [sl]
 80153ea:	2b00      	cmp	r3, #0
 80153ec:	f000 80a2 	beq.w	8015534 <_svfiprintf_r+0x1c8>
 80153f0:	2300      	movs	r3, #0
 80153f2:	f04f 32ff 	mov.w	r2, #4294967295
 80153f6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80153fa:	f10a 0a01 	add.w	sl, sl, #1
 80153fe:	9304      	str	r3, [sp, #16]
 8015400:	9307      	str	r3, [sp, #28]
 8015402:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8015406:	931a      	str	r3, [sp, #104]	; 0x68
 8015408:	4654      	mov	r4, sl
 801540a:	2205      	movs	r2, #5
 801540c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015410:	4851      	ldr	r0, [pc, #324]	; (8015558 <_svfiprintf_r+0x1ec>)
 8015412:	f7eb fadd 	bl	80009d0 <memchr>
 8015416:	9a04      	ldr	r2, [sp, #16]
 8015418:	b9d8      	cbnz	r0, 8015452 <_svfiprintf_r+0xe6>
 801541a:	06d0      	lsls	r0, r2, #27
 801541c:	bf44      	itt	mi
 801541e:	2320      	movmi	r3, #32
 8015420:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8015424:	0711      	lsls	r1, r2, #28
 8015426:	bf44      	itt	mi
 8015428:	232b      	movmi	r3, #43	; 0x2b
 801542a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801542e:	f89a 3000 	ldrb.w	r3, [sl]
 8015432:	2b2a      	cmp	r3, #42	; 0x2a
 8015434:	d015      	beq.n	8015462 <_svfiprintf_r+0xf6>
 8015436:	9a07      	ldr	r2, [sp, #28]
 8015438:	4654      	mov	r4, sl
 801543a:	2000      	movs	r0, #0
 801543c:	f04f 0c0a 	mov.w	ip, #10
 8015440:	4621      	mov	r1, r4
 8015442:	f811 3b01 	ldrb.w	r3, [r1], #1
 8015446:	3b30      	subs	r3, #48	; 0x30
 8015448:	2b09      	cmp	r3, #9
 801544a:	d94e      	bls.n	80154ea <_svfiprintf_r+0x17e>
 801544c:	b1b0      	cbz	r0, 801547c <_svfiprintf_r+0x110>
 801544e:	9207      	str	r2, [sp, #28]
 8015450:	e014      	b.n	801547c <_svfiprintf_r+0x110>
 8015452:	eba0 0308 	sub.w	r3, r0, r8
 8015456:	fa09 f303 	lsl.w	r3, r9, r3
 801545a:	4313      	orrs	r3, r2
 801545c:	9304      	str	r3, [sp, #16]
 801545e:	46a2      	mov	sl, r4
 8015460:	e7d2      	b.n	8015408 <_svfiprintf_r+0x9c>
 8015462:	9b03      	ldr	r3, [sp, #12]
 8015464:	1d19      	adds	r1, r3, #4
 8015466:	681b      	ldr	r3, [r3, #0]
 8015468:	9103      	str	r1, [sp, #12]
 801546a:	2b00      	cmp	r3, #0
 801546c:	bfbb      	ittet	lt
 801546e:	425b      	neglt	r3, r3
 8015470:	f042 0202 	orrlt.w	r2, r2, #2
 8015474:	9307      	strge	r3, [sp, #28]
 8015476:	9307      	strlt	r3, [sp, #28]
 8015478:	bfb8      	it	lt
 801547a:	9204      	strlt	r2, [sp, #16]
 801547c:	7823      	ldrb	r3, [r4, #0]
 801547e:	2b2e      	cmp	r3, #46	; 0x2e
 8015480:	d10c      	bne.n	801549c <_svfiprintf_r+0x130>
 8015482:	7863      	ldrb	r3, [r4, #1]
 8015484:	2b2a      	cmp	r3, #42	; 0x2a
 8015486:	d135      	bne.n	80154f4 <_svfiprintf_r+0x188>
 8015488:	9b03      	ldr	r3, [sp, #12]
 801548a:	1d1a      	adds	r2, r3, #4
 801548c:	681b      	ldr	r3, [r3, #0]
 801548e:	9203      	str	r2, [sp, #12]
 8015490:	2b00      	cmp	r3, #0
 8015492:	bfb8      	it	lt
 8015494:	f04f 33ff 	movlt.w	r3, #4294967295
 8015498:	3402      	adds	r4, #2
 801549a:	9305      	str	r3, [sp, #20]
 801549c:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 8015568 <_svfiprintf_r+0x1fc>
 80154a0:	7821      	ldrb	r1, [r4, #0]
 80154a2:	2203      	movs	r2, #3
 80154a4:	4650      	mov	r0, sl
 80154a6:	f7eb fa93 	bl	80009d0 <memchr>
 80154aa:	b140      	cbz	r0, 80154be <_svfiprintf_r+0x152>
 80154ac:	2340      	movs	r3, #64	; 0x40
 80154ae:	eba0 000a 	sub.w	r0, r0, sl
 80154b2:	fa03 f000 	lsl.w	r0, r3, r0
 80154b6:	9b04      	ldr	r3, [sp, #16]
 80154b8:	4303      	orrs	r3, r0
 80154ba:	3401      	adds	r4, #1
 80154bc:	9304      	str	r3, [sp, #16]
 80154be:	f814 1b01 	ldrb.w	r1, [r4], #1
 80154c2:	4826      	ldr	r0, [pc, #152]	; (801555c <_svfiprintf_r+0x1f0>)
 80154c4:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80154c8:	2206      	movs	r2, #6
 80154ca:	f7eb fa81 	bl	80009d0 <memchr>
 80154ce:	2800      	cmp	r0, #0
 80154d0:	d038      	beq.n	8015544 <_svfiprintf_r+0x1d8>
 80154d2:	4b23      	ldr	r3, [pc, #140]	; (8015560 <_svfiprintf_r+0x1f4>)
 80154d4:	bb1b      	cbnz	r3, 801551e <_svfiprintf_r+0x1b2>
 80154d6:	9b03      	ldr	r3, [sp, #12]
 80154d8:	3307      	adds	r3, #7
 80154da:	f023 0307 	bic.w	r3, r3, #7
 80154de:	3308      	adds	r3, #8
 80154e0:	9303      	str	r3, [sp, #12]
 80154e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80154e4:	4433      	add	r3, r6
 80154e6:	9309      	str	r3, [sp, #36]	; 0x24
 80154e8:	e767      	b.n	80153ba <_svfiprintf_r+0x4e>
 80154ea:	fb0c 3202 	mla	r2, ip, r2, r3
 80154ee:	460c      	mov	r4, r1
 80154f0:	2001      	movs	r0, #1
 80154f2:	e7a5      	b.n	8015440 <_svfiprintf_r+0xd4>
 80154f4:	2300      	movs	r3, #0
 80154f6:	3401      	adds	r4, #1
 80154f8:	9305      	str	r3, [sp, #20]
 80154fa:	4619      	mov	r1, r3
 80154fc:	f04f 0c0a 	mov.w	ip, #10
 8015500:	4620      	mov	r0, r4
 8015502:	f810 2b01 	ldrb.w	r2, [r0], #1
 8015506:	3a30      	subs	r2, #48	; 0x30
 8015508:	2a09      	cmp	r2, #9
 801550a:	d903      	bls.n	8015514 <_svfiprintf_r+0x1a8>
 801550c:	2b00      	cmp	r3, #0
 801550e:	d0c5      	beq.n	801549c <_svfiprintf_r+0x130>
 8015510:	9105      	str	r1, [sp, #20]
 8015512:	e7c3      	b.n	801549c <_svfiprintf_r+0x130>
 8015514:	fb0c 2101 	mla	r1, ip, r1, r2
 8015518:	4604      	mov	r4, r0
 801551a:	2301      	movs	r3, #1
 801551c:	e7f0      	b.n	8015500 <_svfiprintf_r+0x194>
 801551e:	ab03      	add	r3, sp, #12
 8015520:	9300      	str	r3, [sp, #0]
 8015522:	462a      	mov	r2, r5
 8015524:	4b0f      	ldr	r3, [pc, #60]	; (8015564 <_svfiprintf_r+0x1f8>)
 8015526:	a904      	add	r1, sp, #16
 8015528:	4638      	mov	r0, r7
 801552a:	f7fd fecd 	bl	80132c8 <_printf_float>
 801552e:	1c42      	adds	r2, r0, #1
 8015530:	4606      	mov	r6, r0
 8015532:	d1d6      	bne.n	80154e2 <_svfiprintf_r+0x176>
 8015534:	89ab      	ldrh	r3, [r5, #12]
 8015536:	065b      	lsls	r3, r3, #25
 8015538:	f53f af2c 	bmi.w	8015394 <_svfiprintf_r+0x28>
 801553c:	9809      	ldr	r0, [sp, #36]	; 0x24
 801553e:	b01d      	add	sp, #116	; 0x74
 8015540:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015544:	ab03      	add	r3, sp, #12
 8015546:	9300      	str	r3, [sp, #0]
 8015548:	462a      	mov	r2, r5
 801554a:	4b06      	ldr	r3, [pc, #24]	; (8015564 <_svfiprintf_r+0x1f8>)
 801554c:	a904      	add	r1, sp, #16
 801554e:	4638      	mov	r0, r7
 8015550:	f7fe f95e 	bl	8013810 <_printf_i>
 8015554:	e7eb      	b.n	801552e <_svfiprintf_r+0x1c2>
 8015556:	bf00      	nop
 8015558:	0801a504 	.word	0x0801a504
 801555c:	0801a50e 	.word	0x0801a50e
 8015560:	080132c9 	.word	0x080132c9
 8015564:	080152b5 	.word	0x080152b5
 8015568:	0801a50a 	.word	0x0801a50a

0801556c <_sungetc_r>:
 801556c:	b538      	push	{r3, r4, r5, lr}
 801556e:	1c4b      	adds	r3, r1, #1
 8015570:	4614      	mov	r4, r2
 8015572:	d103      	bne.n	801557c <_sungetc_r+0x10>
 8015574:	f04f 35ff 	mov.w	r5, #4294967295
 8015578:	4628      	mov	r0, r5
 801557a:	bd38      	pop	{r3, r4, r5, pc}
 801557c:	8993      	ldrh	r3, [r2, #12]
 801557e:	f023 0320 	bic.w	r3, r3, #32
 8015582:	8193      	strh	r3, [r2, #12]
 8015584:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8015586:	6852      	ldr	r2, [r2, #4]
 8015588:	b2cd      	uxtb	r5, r1
 801558a:	b18b      	cbz	r3, 80155b0 <_sungetc_r+0x44>
 801558c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 801558e:	4293      	cmp	r3, r2
 8015590:	dd08      	ble.n	80155a4 <_sungetc_r+0x38>
 8015592:	6823      	ldr	r3, [r4, #0]
 8015594:	1e5a      	subs	r2, r3, #1
 8015596:	6022      	str	r2, [r4, #0]
 8015598:	f803 5c01 	strb.w	r5, [r3, #-1]
 801559c:	6863      	ldr	r3, [r4, #4]
 801559e:	3301      	adds	r3, #1
 80155a0:	6063      	str	r3, [r4, #4]
 80155a2:	e7e9      	b.n	8015578 <_sungetc_r+0xc>
 80155a4:	4621      	mov	r1, r4
 80155a6:	f000 fc57 	bl	8015e58 <__submore>
 80155aa:	2800      	cmp	r0, #0
 80155ac:	d0f1      	beq.n	8015592 <_sungetc_r+0x26>
 80155ae:	e7e1      	b.n	8015574 <_sungetc_r+0x8>
 80155b0:	6921      	ldr	r1, [r4, #16]
 80155b2:	6823      	ldr	r3, [r4, #0]
 80155b4:	b151      	cbz	r1, 80155cc <_sungetc_r+0x60>
 80155b6:	4299      	cmp	r1, r3
 80155b8:	d208      	bcs.n	80155cc <_sungetc_r+0x60>
 80155ba:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 80155be:	42a9      	cmp	r1, r5
 80155c0:	d104      	bne.n	80155cc <_sungetc_r+0x60>
 80155c2:	3b01      	subs	r3, #1
 80155c4:	3201      	adds	r2, #1
 80155c6:	6023      	str	r3, [r4, #0]
 80155c8:	6062      	str	r2, [r4, #4]
 80155ca:	e7d5      	b.n	8015578 <_sungetc_r+0xc>
 80155cc:	e9c4 320f 	strd	r3, r2, [r4, #60]	; 0x3c
 80155d0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80155d4:	6363      	str	r3, [r4, #52]	; 0x34
 80155d6:	2303      	movs	r3, #3
 80155d8:	63a3      	str	r3, [r4, #56]	; 0x38
 80155da:	4623      	mov	r3, r4
 80155dc:	f803 5f46 	strb.w	r5, [r3, #70]!
 80155e0:	6023      	str	r3, [r4, #0]
 80155e2:	2301      	movs	r3, #1
 80155e4:	e7dc      	b.n	80155a0 <_sungetc_r+0x34>

080155e6 <__ssrefill_r>:
 80155e6:	b510      	push	{r4, lr}
 80155e8:	460c      	mov	r4, r1
 80155ea:	6b49      	ldr	r1, [r1, #52]	; 0x34
 80155ec:	b169      	cbz	r1, 801560a <__ssrefill_r+0x24>
 80155ee:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80155f2:	4299      	cmp	r1, r3
 80155f4:	d001      	beq.n	80155fa <__ssrefill_r+0x14>
 80155f6:	f7ff fd7d 	bl	80150f4 <_free_r>
 80155fa:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80155fc:	6063      	str	r3, [r4, #4]
 80155fe:	2000      	movs	r0, #0
 8015600:	6360      	str	r0, [r4, #52]	; 0x34
 8015602:	b113      	cbz	r3, 801560a <__ssrefill_r+0x24>
 8015604:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8015606:	6023      	str	r3, [r4, #0]
 8015608:	bd10      	pop	{r4, pc}
 801560a:	6923      	ldr	r3, [r4, #16]
 801560c:	6023      	str	r3, [r4, #0]
 801560e:	2300      	movs	r3, #0
 8015610:	6063      	str	r3, [r4, #4]
 8015612:	89a3      	ldrh	r3, [r4, #12]
 8015614:	f043 0320 	orr.w	r3, r3, #32
 8015618:	81a3      	strh	r3, [r4, #12]
 801561a:	f04f 30ff 	mov.w	r0, #4294967295
 801561e:	e7f3      	b.n	8015608 <__ssrefill_r+0x22>

08015620 <__ssvfiscanf_r>:
 8015620:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015624:	460c      	mov	r4, r1
 8015626:	f5ad 7d22 	sub.w	sp, sp, #648	; 0x288
 801562a:	2100      	movs	r1, #0
 801562c:	e9cd 1144 	strd	r1, r1, [sp, #272]	; 0x110
 8015630:	49a6      	ldr	r1, [pc, #664]	; (80158cc <__ssvfiscanf_r+0x2ac>)
 8015632:	91a0      	str	r1, [sp, #640]	; 0x280
 8015634:	f10d 0804 	add.w	r8, sp, #4
 8015638:	49a5      	ldr	r1, [pc, #660]	; (80158d0 <__ssvfiscanf_r+0x2b0>)
 801563a:	4fa6      	ldr	r7, [pc, #664]	; (80158d4 <__ssvfiscanf_r+0x2b4>)
 801563c:	f8df 9298 	ldr.w	r9, [pc, #664]	; 80158d8 <__ssvfiscanf_r+0x2b8>
 8015640:	f8cd 8118 	str.w	r8, [sp, #280]	; 0x118
 8015644:	4606      	mov	r6, r0
 8015646:	91a1      	str	r1, [sp, #644]	; 0x284
 8015648:	9300      	str	r3, [sp, #0]
 801564a:	7813      	ldrb	r3, [r2, #0]
 801564c:	2b00      	cmp	r3, #0
 801564e:	f000 815a 	beq.w	8015906 <__ssvfiscanf_r+0x2e6>
 8015652:	5dd9      	ldrb	r1, [r3, r7]
 8015654:	f011 0108 	ands.w	r1, r1, #8
 8015658:	f102 0501 	add.w	r5, r2, #1
 801565c:	d019      	beq.n	8015692 <__ssvfiscanf_r+0x72>
 801565e:	6863      	ldr	r3, [r4, #4]
 8015660:	2b00      	cmp	r3, #0
 8015662:	dd0f      	ble.n	8015684 <__ssvfiscanf_r+0x64>
 8015664:	6823      	ldr	r3, [r4, #0]
 8015666:	781a      	ldrb	r2, [r3, #0]
 8015668:	5cba      	ldrb	r2, [r7, r2]
 801566a:	0712      	lsls	r2, r2, #28
 801566c:	d401      	bmi.n	8015672 <__ssvfiscanf_r+0x52>
 801566e:	462a      	mov	r2, r5
 8015670:	e7eb      	b.n	801564a <__ssvfiscanf_r+0x2a>
 8015672:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8015674:	3201      	adds	r2, #1
 8015676:	9245      	str	r2, [sp, #276]	; 0x114
 8015678:	6862      	ldr	r2, [r4, #4]
 801567a:	3301      	adds	r3, #1
 801567c:	3a01      	subs	r2, #1
 801567e:	6062      	str	r2, [r4, #4]
 8015680:	6023      	str	r3, [r4, #0]
 8015682:	e7ec      	b.n	801565e <__ssvfiscanf_r+0x3e>
 8015684:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 8015686:	4621      	mov	r1, r4
 8015688:	4630      	mov	r0, r6
 801568a:	4798      	blx	r3
 801568c:	2800      	cmp	r0, #0
 801568e:	d0e9      	beq.n	8015664 <__ssvfiscanf_r+0x44>
 8015690:	e7ed      	b.n	801566e <__ssvfiscanf_r+0x4e>
 8015692:	2b25      	cmp	r3, #37	; 0x25
 8015694:	d012      	beq.n	80156bc <__ssvfiscanf_r+0x9c>
 8015696:	469a      	mov	sl, r3
 8015698:	6863      	ldr	r3, [r4, #4]
 801569a:	2b00      	cmp	r3, #0
 801569c:	f340 8091 	ble.w	80157c2 <__ssvfiscanf_r+0x1a2>
 80156a0:	6822      	ldr	r2, [r4, #0]
 80156a2:	7813      	ldrb	r3, [r2, #0]
 80156a4:	4553      	cmp	r3, sl
 80156a6:	f040 812e 	bne.w	8015906 <__ssvfiscanf_r+0x2e6>
 80156aa:	6863      	ldr	r3, [r4, #4]
 80156ac:	3b01      	subs	r3, #1
 80156ae:	6063      	str	r3, [r4, #4]
 80156b0:	9b45      	ldr	r3, [sp, #276]	; 0x114
 80156b2:	3201      	adds	r2, #1
 80156b4:	3301      	adds	r3, #1
 80156b6:	6022      	str	r2, [r4, #0]
 80156b8:	9345      	str	r3, [sp, #276]	; 0x114
 80156ba:	e7d8      	b.n	801566e <__ssvfiscanf_r+0x4e>
 80156bc:	9141      	str	r1, [sp, #260]	; 0x104
 80156be:	9143      	str	r1, [sp, #268]	; 0x10c
 80156c0:	7853      	ldrb	r3, [r2, #1]
 80156c2:	2b2a      	cmp	r3, #42	; 0x2a
 80156c4:	bf02      	ittt	eq
 80156c6:	2310      	moveq	r3, #16
 80156c8:	1c95      	addeq	r5, r2, #2
 80156ca:	9341      	streq	r3, [sp, #260]	; 0x104
 80156cc:	220a      	movs	r2, #10
 80156ce:	46aa      	mov	sl, r5
 80156d0:	f81a 1b01 	ldrb.w	r1, [sl], #1
 80156d4:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 80156d8:	2b09      	cmp	r3, #9
 80156da:	d91d      	bls.n	8015718 <__ssvfiscanf_r+0xf8>
 80156dc:	487e      	ldr	r0, [pc, #504]	; (80158d8 <__ssvfiscanf_r+0x2b8>)
 80156de:	2203      	movs	r2, #3
 80156e0:	f7eb f976 	bl	80009d0 <memchr>
 80156e4:	b140      	cbz	r0, 80156f8 <__ssvfiscanf_r+0xd8>
 80156e6:	2301      	movs	r3, #1
 80156e8:	eba0 0009 	sub.w	r0, r0, r9
 80156ec:	fa03 f000 	lsl.w	r0, r3, r0
 80156f0:	9b41      	ldr	r3, [sp, #260]	; 0x104
 80156f2:	4318      	orrs	r0, r3
 80156f4:	9041      	str	r0, [sp, #260]	; 0x104
 80156f6:	4655      	mov	r5, sl
 80156f8:	f815 3b01 	ldrb.w	r3, [r5], #1
 80156fc:	2b78      	cmp	r3, #120	; 0x78
 80156fe:	d806      	bhi.n	801570e <__ssvfiscanf_r+0xee>
 8015700:	2b57      	cmp	r3, #87	; 0x57
 8015702:	d810      	bhi.n	8015726 <__ssvfiscanf_r+0x106>
 8015704:	2b25      	cmp	r3, #37	; 0x25
 8015706:	d0c6      	beq.n	8015696 <__ssvfiscanf_r+0x76>
 8015708:	d856      	bhi.n	80157b8 <__ssvfiscanf_r+0x198>
 801570a:	2b00      	cmp	r3, #0
 801570c:	d064      	beq.n	80157d8 <__ssvfiscanf_r+0x1b8>
 801570e:	2303      	movs	r3, #3
 8015710:	9347      	str	r3, [sp, #284]	; 0x11c
 8015712:	230a      	movs	r3, #10
 8015714:	9342      	str	r3, [sp, #264]	; 0x108
 8015716:	e071      	b.n	80157fc <__ssvfiscanf_r+0x1dc>
 8015718:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 801571a:	fb02 1103 	mla	r1, r2, r3, r1
 801571e:	3930      	subs	r1, #48	; 0x30
 8015720:	9143      	str	r1, [sp, #268]	; 0x10c
 8015722:	4655      	mov	r5, sl
 8015724:	e7d3      	b.n	80156ce <__ssvfiscanf_r+0xae>
 8015726:	f1a3 0258 	sub.w	r2, r3, #88	; 0x58
 801572a:	2a20      	cmp	r2, #32
 801572c:	d8ef      	bhi.n	801570e <__ssvfiscanf_r+0xee>
 801572e:	a101      	add	r1, pc, #4	; (adr r1, 8015734 <__ssvfiscanf_r+0x114>)
 8015730:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 8015734:	080157e7 	.word	0x080157e7
 8015738:	0801570f 	.word	0x0801570f
 801573c:	0801570f 	.word	0x0801570f
 8015740:	08015845 	.word	0x08015845
 8015744:	0801570f 	.word	0x0801570f
 8015748:	0801570f 	.word	0x0801570f
 801574c:	0801570f 	.word	0x0801570f
 8015750:	0801570f 	.word	0x0801570f
 8015754:	0801570f 	.word	0x0801570f
 8015758:	0801570f 	.word	0x0801570f
 801575c:	0801570f 	.word	0x0801570f
 8015760:	0801585b 	.word	0x0801585b
 8015764:	08015831 	.word	0x08015831
 8015768:	080157bf 	.word	0x080157bf
 801576c:	080157bf 	.word	0x080157bf
 8015770:	080157bf 	.word	0x080157bf
 8015774:	0801570f 	.word	0x0801570f
 8015778:	08015835 	.word	0x08015835
 801577c:	0801570f 	.word	0x0801570f
 8015780:	0801570f 	.word	0x0801570f
 8015784:	0801570f 	.word	0x0801570f
 8015788:	0801570f 	.word	0x0801570f
 801578c:	0801586b 	.word	0x0801586b
 8015790:	0801583d 	.word	0x0801583d
 8015794:	080157df 	.word	0x080157df
 8015798:	0801570f 	.word	0x0801570f
 801579c:	0801570f 	.word	0x0801570f
 80157a0:	08015867 	.word	0x08015867
 80157a4:	0801570f 	.word	0x0801570f
 80157a8:	08015831 	.word	0x08015831
 80157ac:	0801570f 	.word	0x0801570f
 80157b0:	0801570f 	.word	0x0801570f
 80157b4:	080157e7 	.word	0x080157e7
 80157b8:	3b45      	subs	r3, #69	; 0x45
 80157ba:	2b02      	cmp	r3, #2
 80157bc:	d8a7      	bhi.n	801570e <__ssvfiscanf_r+0xee>
 80157be:	2305      	movs	r3, #5
 80157c0:	e01b      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 80157c2:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 80157c4:	4621      	mov	r1, r4
 80157c6:	4630      	mov	r0, r6
 80157c8:	4798      	blx	r3
 80157ca:	2800      	cmp	r0, #0
 80157cc:	f43f af68 	beq.w	80156a0 <__ssvfiscanf_r+0x80>
 80157d0:	9844      	ldr	r0, [sp, #272]	; 0x110
 80157d2:	2800      	cmp	r0, #0
 80157d4:	f040 808d 	bne.w	80158f2 <__ssvfiscanf_r+0x2d2>
 80157d8:	f04f 30ff 	mov.w	r0, #4294967295
 80157dc:	e08f      	b.n	80158fe <__ssvfiscanf_r+0x2de>
 80157de:	9a41      	ldr	r2, [sp, #260]	; 0x104
 80157e0:	f042 0220 	orr.w	r2, r2, #32
 80157e4:	9241      	str	r2, [sp, #260]	; 0x104
 80157e6:	9a41      	ldr	r2, [sp, #260]	; 0x104
 80157e8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80157ec:	9241      	str	r2, [sp, #260]	; 0x104
 80157ee:	2210      	movs	r2, #16
 80157f0:	2b6f      	cmp	r3, #111	; 0x6f
 80157f2:	9242      	str	r2, [sp, #264]	; 0x108
 80157f4:	bf34      	ite	cc
 80157f6:	2303      	movcc	r3, #3
 80157f8:	2304      	movcs	r3, #4
 80157fa:	9347      	str	r3, [sp, #284]	; 0x11c
 80157fc:	6863      	ldr	r3, [r4, #4]
 80157fe:	2b00      	cmp	r3, #0
 8015800:	dd42      	ble.n	8015888 <__ssvfiscanf_r+0x268>
 8015802:	9b41      	ldr	r3, [sp, #260]	; 0x104
 8015804:	0659      	lsls	r1, r3, #25
 8015806:	d404      	bmi.n	8015812 <__ssvfiscanf_r+0x1f2>
 8015808:	6823      	ldr	r3, [r4, #0]
 801580a:	781a      	ldrb	r2, [r3, #0]
 801580c:	5cba      	ldrb	r2, [r7, r2]
 801580e:	0712      	lsls	r2, r2, #28
 8015810:	d441      	bmi.n	8015896 <__ssvfiscanf_r+0x276>
 8015812:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 8015814:	2b02      	cmp	r3, #2
 8015816:	dc50      	bgt.n	80158ba <__ssvfiscanf_r+0x29a>
 8015818:	466b      	mov	r3, sp
 801581a:	4622      	mov	r2, r4
 801581c:	a941      	add	r1, sp, #260	; 0x104
 801581e:	4630      	mov	r0, r6
 8015820:	f000 f876 	bl	8015910 <_scanf_chars>
 8015824:	2801      	cmp	r0, #1
 8015826:	d06e      	beq.n	8015906 <__ssvfiscanf_r+0x2e6>
 8015828:	2802      	cmp	r0, #2
 801582a:	f47f af20 	bne.w	801566e <__ssvfiscanf_r+0x4e>
 801582e:	e7cf      	b.n	80157d0 <__ssvfiscanf_r+0x1b0>
 8015830:	220a      	movs	r2, #10
 8015832:	e7dd      	b.n	80157f0 <__ssvfiscanf_r+0x1d0>
 8015834:	2300      	movs	r3, #0
 8015836:	9342      	str	r3, [sp, #264]	; 0x108
 8015838:	2303      	movs	r3, #3
 801583a:	e7de      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 801583c:	2308      	movs	r3, #8
 801583e:	9342      	str	r3, [sp, #264]	; 0x108
 8015840:	2304      	movs	r3, #4
 8015842:	e7da      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 8015844:	4629      	mov	r1, r5
 8015846:	4640      	mov	r0, r8
 8015848:	f000 f9d6 	bl	8015bf8 <__sccl>
 801584c:	9b41      	ldr	r3, [sp, #260]	; 0x104
 801584e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015852:	9341      	str	r3, [sp, #260]	; 0x104
 8015854:	4605      	mov	r5, r0
 8015856:	2301      	movs	r3, #1
 8015858:	e7cf      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 801585a:	9b41      	ldr	r3, [sp, #260]	; 0x104
 801585c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015860:	9341      	str	r3, [sp, #260]	; 0x104
 8015862:	2300      	movs	r3, #0
 8015864:	e7c9      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 8015866:	2302      	movs	r3, #2
 8015868:	e7c7      	b.n	80157fa <__ssvfiscanf_r+0x1da>
 801586a:	9841      	ldr	r0, [sp, #260]	; 0x104
 801586c:	06c3      	lsls	r3, r0, #27
 801586e:	f53f aefe 	bmi.w	801566e <__ssvfiscanf_r+0x4e>
 8015872:	9b00      	ldr	r3, [sp, #0]
 8015874:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8015876:	1d19      	adds	r1, r3, #4
 8015878:	9100      	str	r1, [sp, #0]
 801587a:	681b      	ldr	r3, [r3, #0]
 801587c:	f010 0f01 	tst.w	r0, #1
 8015880:	bf14      	ite	ne
 8015882:	801a      	strhne	r2, [r3, #0]
 8015884:	601a      	streq	r2, [r3, #0]
 8015886:	e6f2      	b.n	801566e <__ssvfiscanf_r+0x4e>
 8015888:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 801588a:	4621      	mov	r1, r4
 801588c:	4630      	mov	r0, r6
 801588e:	4798      	blx	r3
 8015890:	2800      	cmp	r0, #0
 8015892:	d0b6      	beq.n	8015802 <__ssvfiscanf_r+0x1e2>
 8015894:	e79c      	b.n	80157d0 <__ssvfiscanf_r+0x1b0>
 8015896:	9a45      	ldr	r2, [sp, #276]	; 0x114
 8015898:	3201      	adds	r2, #1
 801589a:	9245      	str	r2, [sp, #276]	; 0x114
 801589c:	6862      	ldr	r2, [r4, #4]
 801589e:	3a01      	subs	r2, #1
 80158a0:	2a00      	cmp	r2, #0
 80158a2:	6062      	str	r2, [r4, #4]
 80158a4:	dd02      	ble.n	80158ac <__ssvfiscanf_r+0x28c>
 80158a6:	3301      	adds	r3, #1
 80158a8:	6023      	str	r3, [r4, #0]
 80158aa:	e7ad      	b.n	8015808 <__ssvfiscanf_r+0x1e8>
 80158ac:	9ba1      	ldr	r3, [sp, #644]	; 0x284
 80158ae:	4621      	mov	r1, r4
 80158b0:	4630      	mov	r0, r6
 80158b2:	4798      	blx	r3
 80158b4:	2800      	cmp	r0, #0
 80158b6:	d0a7      	beq.n	8015808 <__ssvfiscanf_r+0x1e8>
 80158b8:	e78a      	b.n	80157d0 <__ssvfiscanf_r+0x1b0>
 80158ba:	2b04      	cmp	r3, #4
 80158bc:	dc0e      	bgt.n	80158dc <__ssvfiscanf_r+0x2bc>
 80158be:	466b      	mov	r3, sp
 80158c0:	4622      	mov	r2, r4
 80158c2:	a941      	add	r1, sp, #260	; 0x104
 80158c4:	4630      	mov	r0, r6
 80158c6:	f000 f87d 	bl	80159c4 <_scanf_i>
 80158ca:	e7ab      	b.n	8015824 <__ssvfiscanf_r+0x204>
 80158cc:	0801556d 	.word	0x0801556d
 80158d0:	080155e7 	.word	0x080155e7
 80158d4:	0801a56d 	.word	0x0801a56d
 80158d8:	0801a50a 	.word	0x0801a50a
 80158dc:	4b0b      	ldr	r3, [pc, #44]	; (801590c <__ssvfiscanf_r+0x2ec>)
 80158de:	2b00      	cmp	r3, #0
 80158e0:	f43f aec5 	beq.w	801566e <__ssvfiscanf_r+0x4e>
 80158e4:	466b      	mov	r3, sp
 80158e6:	4622      	mov	r2, r4
 80158e8:	a941      	add	r1, sp, #260	; 0x104
 80158ea:	4630      	mov	r0, r6
 80158ec:	f3af 8000 	nop.w
 80158f0:	e798      	b.n	8015824 <__ssvfiscanf_r+0x204>
 80158f2:	89a3      	ldrh	r3, [r4, #12]
 80158f4:	f013 0f40 	tst.w	r3, #64	; 0x40
 80158f8:	bf18      	it	ne
 80158fa:	f04f 30ff 	movne.w	r0, #4294967295
 80158fe:	f50d 7d22 	add.w	sp, sp, #648	; 0x288
 8015902:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015906:	9844      	ldr	r0, [sp, #272]	; 0x110
 8015908:	e7f9      	b.n	80158fe <__ssvfiscanf_r+0x2de>
 801590a:	bf00      	nop
 801590c:	00000000 	.word	0x00000000

08015910 <_scanf_chars>:
 8015910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015914:	4615      	mov	r5, r2
 8015916:	688a      	ldr	r2, [r1, #8]
 8015918:	4680      	mov	r8, r0
 801591a:	460c      	mov	r4, r1
 801591c:	b932      	cbnz	r2, 801592c <_scanf_chars+0x1c>
 801591e:	698a      	ldr	r2, [r1, #24]
 8015920:	2a00      	cmp	r2, #0
 8015922:	bf0c      	ite	eq
 8015924:	2201      	moveq	r2, #1
 8015926:	f04f 32ff 	movne.w	r2, #4294967295
 801592a:	608a      	str	r2, [r1, #8]
 801592c:	6822      	ldr	r2, [r4, #0]
 801592e:	f8df 9090 	ldr.w	r9, [pc, #144]	; 80159c0 <_scanf_chars+0xb0>
 8015932:	06d1      	lsls	r1, r2, #27
 8015934:	bf5f      	itttt	pl
 8015936:	681a      	ldrpl	r2, [r3, #0]
 8015938:	1d11      	addpl	r1, r2, #4
 801593a:	6019      	strpl	r1, [r3, #0]
 801593c:	6816      	ldrpl	r6, [r2, #0]
 801593e:	2700      	movs	r7, #0
 8015940:	69a0      	ldr	r0, [r4, #24]
 8015942:	b188      	cbz	r0, 8015968 <_scanf_chars+0x58>
 8015944:	2801      	cmp	r0, #1
 8015946:	d107      	bne.n	8015958 <_scanf_chars+0x48>
 8015948:	682a      	ldr	r2, [r5, #0]
 801594a:	7811      	ldrb	r1, [r2, #0]
 801594c:	6962      	ldr	r2, [r4, #20]
 801594e:	5c52      	ldrb	r2, [r2, r1]
 8015950:	b952      	cbnz	r2, 8015968 <_scanf_chars+0x58>
 8015952:	2f00      	cmp	r7, #0
 8015954:	d031      	beq.n	80159ba <_scanf_chars+0xaa>
 8015956:	e022      	b.n	801599e <_scanf_chars+0x8e>
 8015958:	2802      	cmp	r0, #2
 801595a:	d120      	bne.n	801599e <_scanf_chars+0x8e>
 801595c:	682b      	ldr	r3, [r5, #0]
 801595e:	781b      	ldrb	r3, [r3, #0]
 8015960:	f813 3009 	ldrb.w	r3, [r3, r9]
 8015964:	071b      	lsls	r3, r3, #28
 8015966:	d41a      	bmi.n	801599e <_scanf_chars+0x8e>
 8015968:	6823      	ldr	r3, [r4, #0]
 801596a:	06da      	lsls	r2, r3, #27
 801596c:	bf5e      	ittt	pl
 801596e:	682b      	ldrpl	r3, [r5, #0]
 8015970:	781b      	ldrbpl	r3, [r3, #0]
 8015972:	f806 3b01 	strbpl.w	r3, [r6], #1
 8015976:	682a      	ldr	r2, [r5, #0]
 8015978:	686b      	ldr	r3, [r5, #4]
 801597a:	3201      	adds	r2, #1
 801597c:	602a      	str	r2, [r5, #0]
 801597e:	68a2      	ldr	r2, [r4, #8]
 8015980:	3b01      	subs	r3, #1
 8015982:	3a01      	subs	r2, #1
 8015984:	606b      	str	r3, [r5, #4]
 8015986:	3701      	adds	r7, #1
 8015988:	60a2      	str	r2, [r4, #8]
 801598a:	b142      	cbz	r2, 801599e <_scanf_chars+0x8e>
 801598c:	2b00      	cmp	r3, #0
 801598e:	dcd7      	bgt.n	8015940 <_scanf_chars+0x30>
 8015990:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 8015994:	4629      	mov	r1, r5
 8015996:	4640      	mov	r0, r8
 8015998:	4798      	blx	r3
 801599a:	2800      	cmp	r0, #0
 801599c:	d0d0      	beq.n	8015940 <_scanf_chars+0x30>
 801599e:	6823      	ldr	r3, [r4, #0]
 80159a0:	f013 0310 	ands.w	r3, r3, #16
 80159a4:	d105      	bne.n	80159b2 <_scanf_chars+0xa2>
 80159a6:	68e2      	ldr	r2, [r4, #12]
 80159a8:	3201      	adds	r2, #1
 80159aa:	60e2      	str	r2, [r4, #12]
 80159ac:	69a2      	ldr	r2, [r4, #24]
 80159ae:	b102      	cbz	r2, 80159b2 <_scanf_chars+0xa2>
 80159b0:	7033      	strb	r3, [r6, #0]
 80159b2:	6923      	ldr	r3, [r4, #16]
 80159b4:	443b      	add	r3, r7
 80159b6:	6123      	str	r3, [r4, #16]
 80159b8:	2000      	movs	r0, #0
 80159ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80159be:	bf00      	nop
 80159c0:	0801a56d 	.word	0x0801a56d

080159c4 <_scanf_i>:
 80159c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80159c8:	4698      	mov	r8, r3
 80159ca:	4b76      	ldr	r3, [pc, #472]	; (8015ba4 <_scanf_i+0x1e0>)
 80159cc:	460c      	mov	r4, r1
 80159ce:	4682      	mov	sl, r0
 80159d0:	4616      	mov	r6, r2
 80159d2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80159d6:	b087      	sub	sp, #28
 80159d8:	ab03      	add	r3, sp, #12
 80159da:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80159de:	4b72      	ldr	r3, [pc, #456]	; (8015ba8 <_scanf_i+0x1e4>)
 80159e0:	69a1      	ldr	r1, [r4, #24]
 80159e2:	4a72      	ldr	r2, [pc, #456]	; (8015bac <_scanf_i+0x1e8>)
 80159e4:	2903      	cmp	r1, #3
 80159e6:	bf18      	it	ne
 80159e8:	461a      	movne	r2, r3
 80159ea:	68a3      	ldr	r3, [r4, #8]
 80159ec:	9201      	str	r2, [sp, #4]
 80159ee:	1e5a      	subs	r2, r3, #1
 80159f0:	f5b2 7fae 	cmp.w	r2, #348	; 0x15c
 80159f4:	bf88      	it	hi
 80159f6:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
 80159fa:	4627      	mov	r7, r4
 80159fc:	bf82      	ittt	hi
 80159fe:	eb03 0905 	addhi.w	r9, r3, r5
 8015a02:	f240 135d 	movwhi	r3, #349	; 0x15d
 8015a06:	60a3      	strhi	r3, [r4, #8]
 8015a08:	f857 3b1c 	ldr.w	r3, [r7], #28
 8015a0c:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
 8015a10:	bf98      	it	ls
 8015a12:	f04f 0900 	movls.w	r9, #0
 8015a16:	6023      	str	r3, [r4, #0]
 8015a18:	463d      	mov	r5, r7
 8015a1a:	f04f 0b00 	mov.w	fp, #0
 8015a1e:	6831      	ldr	r1, [r6, #0]
 8015a20:	ab03      	add	r3, sp, #12
 8015a22:	7809      	ldrb	r1, [r1, #0]
 8015a24:	f853 002b 	ldr.w	r0, [r3, fp, lsl #2]
 8015a28:	2202      	movs	r2, #2
 8015a2a:	f7ea ffd1 	bl	80009d0 <memchr>
 8015a2e:	b328      	cbz	r0, 8015a7c <_scanf_i+0xb8>
 8015a30:	f1bb 0f01 	cmp.w	fp, #1
 8015a34:	d159      	bne.n	8015aea <_scanf_i+0x126>
 8015a36:	6862      	ldr	r2, [r4, #4]
 8015a38:	b92a      	cbnz	r2, 8015a46 <_scanf_i+0x82>
 8015a3a:	6822      	ldr	r2, [r4, #0]
 8015a3c:	2308      	movs	r3, #8
 8015a3e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8015a42:	6063      	str	r3, [r4, #4]
 8015a44:	6022      	str	r2, [r4, #0]
 8015a46:	6822      	ldr	r2, [r4, #0]
 8015a48:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
 8015a4c:	6022      	str	r2, [r4, #0]
 8015a4e:	68a2      	ldr	r2, [r4, #8]
 8015a50:	1e51      	subs	r1, r2, #1
 8015a52:	60a1      	str	r1, [r4, #8]
 8015a54:	b192      	cbz	r2, 8015a7c <_scanf_i+0xb8>
 8015a56:	6832      	ldr	r2, [r6, #0]
 8015a58:	1c51      	adds	r1, r2, #1
 8015a5a:	6031      	str	r1, [r6, #0]
 8015a5c:	7812      	ldrb	r2, [r2, #0]
 8015a5e:	f805 2b01 	strb.w	r2, [r5], #1
 8015a62:	6872      	ldr	r2, [r6, #4]
 8015a64:	3a01      	subs	r2, #1
 8015a66:	2a00      	cmp	r2, #0
 8015a68:	6072      	str	r2, [r6, #4]
 8015a6a:	dc07      	bgt.n	8015a7c <_scanf_i+0xb8>
 8015a6c:	f8d4 2180 	ldr.w	r2, [r4, #384]	; 0x180
 8015a70:	4631      	mov	r1, r6
 8015a72:	4650      	mov	r0, sl
 8015a74:	4790      	blx	r2
 8015a76:	2800      	cmp	r0, #0
 8015a78:	f040 8085 	bne.w	8015b86 <_scanf_i+0x1c2>
 8015a7c:	f10b 0b01 	add.w	fp, fp, #1
 8015a80:	f1bb 0f03 	cmp.w	fp, #3
 8015a84:	d1cb      	bne.n	8015a1e <_scanf_i+0x5a>
 8015a86:	6863      	ldr	r3, [r4, #4]
 8015a88:	b90b      	cbnz	r3, 8015a8e <_scanf_i+0xca>
 8015a8a:	230a      	movs	r3, #10
 8015a8c:	6063      	str	r3, [r4, #4]
 8015a8e:	6863      	ldr	r3, [r4, #4]
 8015a90:	4947      	ldr	r1, [pc, #284]	; (8015bb0 <_scanf_i+0x1ec>)
 8015a92:	6960      	ldr	r0, [r4, #20]
 8015a94:	1ac9      	subs	r1, r1, r3
 8015a96:	f000 f8af 	bl	8015bf8 <__sccl>
 8015a9a:	f04f 0b00 	mov.w	fp, #0
 8015a9e:	68a3      	ldr	r3, [r4, #8]
 8015aa0:	6822      	ldr	r2, [r4, #0]
 8015aa2:	2b00      	cmp	r3, #0
 8015aa4:	d03d      	beq.n	8015b22 <_scanf_i+0x15e>
 8015aa6:	6831      	ldr	r1, [r6, #0]
 8015aa8:	6960      	ldr	r0, [r4, #20]
 8015aaa:	f891 c000 	ldrb.w	ip, [r1]
 8015aae:	f810 000c 	ldrb.w	r0, [r0, ip]
 8015ab2:	2800      	cmp	r0, #0
 8015ab4:	d035      	beq.n	8015b22 <_scanf_i+0x15e>
 8015ab6:	f1bc 0f30 	cmp.w	ip, #48	; 0x30
 8015aba:	d124      	bne.n	8015b06 <_scanf_i+0x142>
 8015abc:	0510      	lsls	r0, r2, #20
 8015abe:	d522      	bpl.n	8015b06 <_scanf_i+0x142>
 8015ac0:	f10b 0b01 	add.w	fp, fp, #1
 8015ac4:	f1b9 0f00 	cmp.w	r9, #0
 8015ac8:	d003      	beq.n	8015ad2 <_scanf_i+0x10e>
 8015aca:	3301      	adds	r3, #1
 8015acc:	f109 39ff 	add.w	r9, r9, #4294967295
 8015ad0:	60a3      	str	r3, [r4, #8]
 8015ad2:	6873      	ldr	r3, [r6, #4]
 8015ad4:	3b01      	subs	r3, #1
 8015ad6:	2b00      	cmp	r3, #0
 8015ad8:	6073      	str	r3, [r6, #4]
 8015ada:	dd1b      	ble.n	8015b14 <_scanf_i+0x150>
 8015adc:	6833      	ldr	r3, [r6, #0]
 8015ade:	3301      	adds	r3, #1
 8015ae0:	6033      	str	r3, [r6, #0]
 8015ae2:	68a3      	ldr	r3, [r4, #8]
 8015ae4:	3b01      	subs	r3, #1
 8015ae6:	60a3      	str	r3, [r4, #8]
 8015ae8:	e7d9      	b.n	8015a9e <_scanf_i+0xda>
 8015aea:	f1bb 0f02 	cmp.w	fp, #2
 8015aee:	d1ae      	bne.n	8015a4e <_scanf_i+0x8a>
 8015af0:	6822      	ldr	r2, [r4, #0]
 8015af2:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
 8015af6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8015afa:	d1bf      	bne.n	8015a7c <_scanf_i+0xb8>
 8015afc:	2310      	movs	r3, #16
 8015afe:	6063      	str	r3, [r4, #4]
 8015b00:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8015b04:	e7a2      	b.n	8015a4c <_scanf_i+0x88>
 8015b06:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
 8015b0a:	6022      	str	r2, [r4, #0]
 8015b0c:	780b      	ldrb	r3, [r1, #0]
 8015b0e:	f805 3b01 	strb.w	r3, [r5], #1
 8015b12:	e7de      	b.n	8015ad2 <_scanf_i+0x10e>
 8015b14:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 8015b18:	4631      	mov	r1, r6
 8015b1a:	4650      	mov	r0, sl
 8015b1c:	4798      	blx	r3
 8015b1e:	2800      	cmp	r0, #0
 8015b20:	d0df      	beq.n	8015ae2 <_scanf_i+0x11e>
 8015b22:	6823      	ldr	r3, [r4, #0]
 8015b24:	05db      	lsls	r3, r3, #23
 8015b26:	d50d      	bpl.n	8015b44 <_scanf_i+0x180>
 8015b28:	42bd      	cmp	r5, r7
 8015b2a:	d909      	bls.n	8015b40 <_scanf_i+0x17c>
 8015b2c:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 8015b30:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 8015b34:	4632      	mov	r2, r6
 8015b36:	4650      	mov	r0, sl
 8015b38:	4798      	blx	r3
 8015b3a:	f105 39ff 	add.w	r9, r5, #4294967295
 8015b3e:	464d      	mov	r5, r9
 8015b40:	42bd      	cmp	r5, r7
 8015b42:	d02d      	beq.n	8015ba0 <_scanf_i+0x1dc>
 8015b44:	6822      	ldr	r2, [r4, #0]
 8015b46:	f012 0210 	ands.w	r2, r2, #16
 8015b4a:	d113      	bne.n	8015b74 <_scanf_i+0x1b0>
 8015b4c:	702a      	strb	r2, [r5, #0]
 8015b4e:	6863      	ldr	r3, [r4, #4]
 8015b50:	9e01      	ldr	r6, [sp, #4]
 8015b52:	4639      	mov	r1, r7
 8015b54:	4650      	mov	r0, sl
 8015b56:	47b0      	blx	r6
 8015b58:	6821      	ldr	r1, [r4, #0]
 8015b5a:	f8d8 3000 	ldr.w	r3, [r8]
 8015b5e:	f011 0f20 	tst.w	r1, #32
 8015b62:	d013      	beq.n	8015b8c <_scanf_i+0x1c8>
 8015b64:	1d1a      	adds	r2, r3, #4
 8015b66:	f8c8 2000 	str.w	r2, [r8]
 8015b6a:	681b      	ldr	r3, [r3, #0]
 8015b6c:	6018      	str	r0, [r3, #0]
 8015b6e:	68e3      	ldr	r3, [r4, #12]
 8015b70:	3301      	adds	r3, #1
 8015b72:	60e3      	str	r3, [r4, #12]
 8015b74:	1bed      	subs	r5, r5, r7
 8015b76:	44ab      	add	fp, r5
 8015b78:	6925      	ldr	r5, [r4, #16]
 8015b7a:	445d      	add	r5, fp
 8015b7c:	6125      	str	r5, [r4, #16]
 8015b7e:	2000      	movs	r0, #0
 8015b80:	b007      	add	sp, #28
 8015b82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015b86:	f04f 0b00 	mov.w	fp, #0
 8015b8a:	e7ca      	b.n	8015b22 <_scanf_i+0x15e>
 8015b8c:	1d1a      	adds	r2, r3, #4
 8015b8e:	f8c8 2000 	str.w	r2, [r8]
 8015b92:	681b      	ldr	r3, [r3, #0]
 8015b94:	f011 0f01 	tst.w	r1, #1
 8015b98:	bf14      	ite	ne
 8015b9a:	8018      	strhne	r0, [r3, #0]
 8015b9c:	6018      	streq	r0, [r3, #0]
 8015b9e:	e7e6      	b.n	8015b6e <_scanf_i+0x1aa>
 8015ba0:	2001      	movs	r0, #1
 8015ba2:	e7ed      	b.n	8015b80 <_scanf_i+0x1bc>
 8015ba4:	08016958 	.word	0x08016958
 8015ba8:	08015e55 	.word	0x08015e55
 8015bac:	08015d6d 	.word	0x08015d6d
 8015bb0:	0801a52e 	.word	0x0801a52e

08015bb4 <_read_r>:
 8015bb4:	b538      	push	{r3, r4, r5, lr}
 8015bb6:	4d07      	ldr	r5, [pc, #28]	; (8015bd4 <_read_r+0x20>)
 8015bb8:	4604      	mov	r4, r0
 8015bba:	4608      	mov	r0, r1
 8015bbc:	4611      	mov	r1, r2
 8015bbe:	2200      	movs	r2, #0
 8015bc0:	602a      	str	r2, [r5, #0]
 8015bc2:	461a      	mov	r2, r3
 8015bc4:	f7ed f9ce 	bl	8002f64 <_read>
 8015bc8:	1c43      	adds	r3, r0, #1
 8015bca:	d102      	bne.n	8015bd2 <_read_r+0x1e>
 8015bcc:	682b      	ldr	r3, [r5, #0]
 8015bce:	b103      	cbz	r3, 8015bd2 <_read_r+0x1e>
 8015bd0:	6023      	str	r3, [r4, #0]
 8015bd2:	bd38      	pop	{r3, r4, r5, pc}
 8015bd4:	2004ee60 	.word	0x2004ee60

08015bd8 <_sbrk_r>:
 8015bd8:	b538      	push	{r3, r4, r5, lr}
 8015bda:	4d06      	ldr	r5, [pc, #24]	; (8015bf4 <_sbrk_r+0x1c>)
 8015bdc:	2300      	movs	r3, #0
 8015bde:	4604      	mov	r4, r0
 8015be0:	4608      	mov	r0, r1
 8015be2:	602b      	str	r3, [r5, #0]
 8015be4:	f7ed f9e8 	bl	8002fb8 <_sbrk>
 8015be8:	1c43      	adds	r3, r0, #1
 8015bea:	d102      	bne.n	8015bf2 <_sbrk_r+0x1a>
 8015bec:	682b      	ldr	r3, [r5, #0]
 8015bee:	b103      	cbz	r3, 8015bf2 <_sbrk_r+0x1a>
 8015bf0:	6023      	str	r3, [r4, #0]
 8015bf2:	bd38      	pop	{r3, r4, r5, pc}
 8015bf4:	2004ee60 	.word	0x2004ee60

08015bf8 <__sccl>:
 8015bf8:	b570      	push	{r4, r5, r6, lr}
 8015bfa:	780b      	ldrb	r3, [r1, #0]
 8015bfc:	4604      	mov	r4, r0
 8015bfe:	2b5e      	cmp	r3, #94	; 0x5e
 8015c00:	bf0b      	itete	eq
 8015c02:	784b      	ldrbeq	r3, [r1, #1]
 8015c04:	1c48      	addne	r0, r1, #1
 8015c06:	1c88      	addeq	r0, r1, #2
 8015c08:	2200      	movne	r2, #0
 8015c0a:	bf08      	it	eq
 8015c0c:	2201      	moveq	r2, #1
 8015c0e:	1e61      	subs	r1, r4, #1
 8015c10:	f104 05ff 	add.w	r5, r4, #255	; 0xff
 8015c14:	f801 2f01 	strb.w	r2, [r1, #1]!
 8015c18:	42a9      	cmp	r1, r5
 8015c1a:	d1fb      	bne.n	8015c14 <__sccl+0x1c>
 8015c1c:	b90b      	cbnz	r3, 8015c22 <__sccl+0x2a>
 8015c1e:	3801      	subs	r0, #1
 8015c20:	bd70      	pop	{r4, r5, r6, pc}
 8015c22:	f082 0201 	eor.w	r2, r2, #1
 8015c26:	54e2      	strb	r2, [r4, r3]
 8015c28:	4605      	mov	r5, r0
 8015c2a:	4628      	mov	r0, r5
 8015c2c:	f810 1b01 	ldrb.w	r1, [r0], #1
 8015c30:	292d      	cmp	r1, #45	; 0x2d
 8015c32:	d006      	beq.n	8015c42 <__sccl+0x4a>
 8015c34:	295d      	cmp	r1, #93	; 0x5d
 8015c36:	d0f3      	beq.n	8015c20 <__sccl+0x28>
 8015c38:	b909      	cbnz	r1, 8015c3e <__sccl+0x46>
 8015c3a:	4628      	mov	r0, r5
 8015c3c:	e7f0      	b.n	8015c20 <__sccl+0x28>
 8015c3e:	460b      	mov	r3, r1
 8015c40:	e7f1      	b.n	8015c26 <__sccl+0x2e>
 8015c42:	786e      	ldrb	r6, [r5, #1]
 8015c44:	2e5d      	cmp	r6, #93	; 0x5d
 8015c46:	d0fa      	beq.n	8015c3e <__sccl+0x46>
 8015c48:	42b3      	cmp	r3, r6
 8015c4a:	dcf8      	bgt.n	8015c3e <__sccl+0x46>
 8015c4c:	3502      	adds	r5, #2
 8015c4e:	4619      	mov	r1, r3
 8015c50:	3101      	adds	r1, #1
 8015c52:	428e      	cmp	r6, r1
 8015c54:	5462      	strb	r2, [r4, r1]
 8015c56:	dcfb      	bgt.n	8015c50 <__sccl+0x58>
 8015c58:	1af1      	subs	r1, r6, r3
 8015c5a:	3901      	subs	r1, #1
 8015c5c:	1c58      	adds	r0, r3, #1
 8015c5e:	42b3      	cmp	r3, r6
 8015c60:	bfa8      	it	ge
 8015c62:	2100      	movge	r1, #0
 8015c64:	1843      	adds	r3, r0, r1
 8015c66:	e7e0      	b.n	8015c2a <__sccl+0x32>

08015c68 <_strtol_l.constprop.0>:
 8015c68:	2b01      	cmp	r3, #1
 8015c6a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8015c6e:	d001      	beq.n	8015c74 <_strtol_l.constprop.0+0xc>
 8015c70:	2b24      	cmp	r3, #36	; 0x24
 8015c72:	d906      	bls.n	8015c82 <_strtol_l.constprop.0+0x1a>
 8015c74:	f7fd fa2e 	bl	80130d4 <__errno>
 8015c78:	2316      	movs	r3, #22
 8015c7a:	6003      	str	r3, [r0, #0]
 8015c7c:	2000      	movs	r0, #0
 8015c7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015c82:	f8df c0e4 	ldr.w	ip, [pc, #228]	; 8015d68 <_strtol_l.constprop.0+0x100>
 8015c86:	460d      	mov	r5, r1
 8015c88:	462e      	mov	r6, r5
 8015c8a:	f815 4b01 	ldrb.w	r4, [r5], #1
 8015c8e:	f814 700c 	ldrb.w	r7, [r4, ip]
 8015c92:	f017 0708 	ands.w	r7, r7, #8
 8015c96:	d1f7      	bne.n	8015c88 <_strtol_l.constprop.0+0x20>
 8015c98:	2c2d      	cmp	r4, #45	; 0x2d
 8015c9a:	d132      	bne.n	8015d02 <_strtol_l.constprop.0+0x9a>
 8015c9c:	782c      	ldrb	r4, [r5, #0]
 8015c9e:	2701      	movs	r7, #1
 8015ca0:	1cb5      	adds	r5, r6, #2
 8015ca2:	2b00      	cmp	r3, #0
 8015ca4:	d05b      	beq.n	8015d5e <_strtol_l.constprop.0+0xf6>
 8015ca6:	2b10      	cmp	r3, #16
 8015ca8:	d109      	bne.n	8015cbe <_strtol_l.constprop.0+0x56>
 8015caa:	2c30      	cmp	r4, #48	; 0x30
 8015cac:	d107      	bne.n	8015cbe <_strtol_l.constprop.0+0x56>
 8015cae:	782c      	ldrb	r4, [r5, #0]
 8015cb0:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 8015cb4:	2c58      	cmp	r4, #88	; 0x58
 8015cb6:	d14d      	bne.n	8015d54 <_strtol_l.constprop.0+0xec>
 8015cb8:	786c      	ldrb	r4, [r5, #1]
 8015cba:	2310      	movs	r3, #16
 8015cbc:	3502      	adds	r5, #2
 8015cbe:	f107 4800 	add.w	r8, r7, #2147483648	; 0x80000000
 8015cc2:	f108 38ff 	add.w	r8, r8, #4294967295
 8015cc6:	f04f 0c00 	mov.w	ip, #0
 8015cca:	fbb8 f9f3 	udiv	r9, r8, r3
 8015cce:	4666      	mov	r6, ip
 8015cd0:	fb03 8a19 	mls	sl, r3, r9, r8
 8015cd4:	f1a4 0e30 	sub.w	lr, r4, #48	; 0x30
 8015cd8:	f1be 0f09 	cmp.w	lr, #9
 8015cdc:	d816      	bhi.n	8015d0c <_strtol_l.constprop.0+0xa4>
 8015cde:	4674      	mov	r4, lr
 8015ce0:	42a3      	cmp	r3, r4
 8015ce2:	dd24      	ble.n	8015d2e <_strtol_l.constprop.0+0xc6>
 8015ce4:	f1bc 0f00 	cmp.w	ip, #0
 8015ce8:	db1e      	blt.n	8015d28 <_strtol_l.constprop.0+0xc0>
 8015cea:	45b1      	cmp	r9, r6
 8015cec:	d31c      	bcc.n	8015d28 <_strtol_l.constprop.0+0xc0>
 8015cee:	d101      	bne.n	8015cf4 <_strtol_l.constprop.0+0x8c>
 8015cf0:	45a2      	cmp	sl, r4
 8015cf2:	db19      	blt.n	8015d28 <_strtol_l.constprop.0+0xc0>
 8015cf4:	fb06 4603 	mla	r6, r6, r3, r4
 8015cf8:	f04f 0c01 	mov.w	ip, #1
 8015cfc:	f815 4b01 	ldrb.w	r4, [r5], #1
 8015d00:	e7e8      	b.n	8015cd4 <_strtol_l.constprop.0+0x6c>
 8015d02:	2c2b      	cmp	r4, #43	; 0x2b
 8015d04:	bf04      	itt	eq
 8015d06:	782c      	ldrbeq	r4, [r5, #0]
 8015d08:	1cb5      	addeq	r5, r6, #2
 8015d0a:	e7ca      	b.n	8015ca2 <_strtol_l.constprop.0+0x3a>
 8015d0c:	f1a4 0e41 	sub.w	lr, r4, #65	; 0x41
 8015d10:	f1be 0f19 	cmp.w	lr, #25
 8015d14:	d801      	bhi.n	8015d1a <_strtol_l.constprop.0+0xb2>
 8015d16:	3c37      	subs	r4, #55	; 0x37
 8015d18:	e7e2      	b.n	8015ce0 <_strtol_l.constprop.0+0x78>
 8015d1a:	f1a4 0e61 	sub.w	lr, r4, #97	; 0x61
 8015d1e:	f1be 0f19 	cmp.w	lr, #25
 8015d22:	d804      	bhi.n	8015d2e <_strtol_l.constprop.0+0xc6>
 8015d24:	3c57      	subs	r4, #87	; 0x57
 8015d26:	e7db      	b.n	8015ce0 <_strtol_l.constprop.0+0x78>
 8015d28:	f04f 3cff 	mov.w	ip, #4294967295
 8015d2c:	e7e6      	b.n	8015cfc <_strtol_l.constprop.0+0x94>
 8015d2e:	f1bc 0f00 	cmp.w	ip, #0
 8015d32:	da05      	bge.n	8015d40 <_strtol_l.constprop.0+0xd8>
 8015d34:	2322      	movs	r3, #34	; 0x22
 8015d36:	6003      	str	r3, [r0, #0]
 8015d38:	4646      	mov	r6, r8
 8015d3a:	b942      	cbnz	r2, 8015d4e <_strtol_l.constprop.0+0xe6>
 8015d3c:	4630      	mov	r0, r6
 8015d3e:	e79e      	b.n	8015c7e <_strtol_l.constprop.0+0x16>
 8015d40:	b107      	cbz	r7, 8015d44 <_strtol_l.constprop.0+0xdc>
 8015d42:	4276      	negs	r6, r6
 8015d44:	2a00      	cmp	r2, #0
 8015d46:	d0f9      	beq.n	8015d3c <_strtol_l.constprop.0+0xd4>
 8015d48:	f1bc 0f00 	cmp.w	ip, #0
 8015d4c:	d000      	beq.n	8015d50 <_strtol_l.constprop.0+0xe8>
 8015d4e:	1e69      	subs	r1, r5, #1
 8015d50:	6011      	str	r1, [r2, #0]
 8015d52:	e7f3      	b.n	8015d3c <_strtol_l.constprop.0+0xd4>
 8015d54:	2430      	movs	r4, #48	; 0x30
 8015d56:	2b00      	cmp	r3, #0
 8015d58:	d1b1      	bne.n	8015cbe <_strtol_l.constprop.0+0x56>
 8015d5a:	2308      	movs	r3, #8
 8015d5c:	e7af      	b.n	8015cbe <_strtol_l.constprop.0+0x56>
 8015d5e:	2c30      	cmp	r4, #48	; 0x30
 8015d60:	d0a5      	beq.n	8015cae <_strtol_l.constprop.0+0x46>
 8015d62:	230a      	movs	r3, #10
 8015d64:	e7ab      	b.n	8015cbe <_strtol_l.constprop.0+0x56>
 8015d66:	bf00      	nop
 8015d68:	0801a56d 	.word	0x0801a56d

08015d6c <_strtol_r>:
 8015d6c:	f7ff bf7c 	b.w	8015c68 <_strtol_l.constprop.0>

08015d70 <_strtoul_l.constprop.0>:
 8015d70:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015d74:	4f36      	ldr	r7, [pc, #216]	; (8015e50 <_strtoul_l.constprop.0+0xe0>)
 8015d76:	4686      	mov	lr, r0
 8015d78:	460d      	mov	r5, r1
 8015d7a:	4628      	mov	r0, r5
 8015d7c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8015d80:	5de6      	ldrb	r6, [r4, r7]
 8015d82:	f016 0608 	ands.w	r6, r6, #8
 8015d86:	d1f8      	bne.n	8015d7a <_strtoul_l.constprop.0+0xa>
 8015d88:	2c2d      	cmp	r4, #45	; 0x2d
 8015d8a:	d12f      	bne.n	8015dec <_strtoul_l.constprop.0+0x7c>
 8015d8c:	782c      	ldrb	r4, [r5, #0]
 8015d8e:	2601      	movs	r6, #1
 8015d90:	1c85      	adds	r5, r0, #2
 8015d92:	2b00      	cmp	r3, #0
 8015d94:	d057      	beq.n	8015e46 <_strtoul_l.constprop.0+0xd6>
 8015d96:	2b10      	cmp	r3, #16
 8015d98:	d109      	bne.n	8015dae <_strtoul_l.constprop.0+0x3e>
 8015d9a:	2c30      	cmp	r4, #48	; 0x30
 8015d9c:	d107      	bne.n	8015dae <_strtoul_l.constprop.0+0x3e>
 8015d9e:	7828      	ldrb	r0, [r5, #0]
 8015da0:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8015da4:	2858      	cmp	r0, #88	; 0x58
 8015da6:	d149      	bne.n	8015e3c <_strtoul_l.constprop.0+0xcc>
 8015da8:	786c      	ldrb	r4, [r5, #1]
 8015daa:	2310      	movs	r3, #16
 8015dac:	3502      	adds	r5, #2
 8015dae:	f04f 38ff 	mov.w	r8, #4294967295
 8015db2:	2700      	movs	r7, #0
 8015db4:	fbb8 f8f3 	udiv	r8, r8, r3
 8015db8:	fb03 f908 	mul.w	r9, r3, r8
 8015dbc:	ea6f 0909 	mvn.w	r9, r9
 8015dc0:	4638      	mov	r0, r7
 8015dc2:	f1a4 0c30 	sub.w	ip, r4, #48	; 0x30
 8015dc6:	f1bc 0f09 	cmp.w	ip, #9
 8015dca:	d814      	bhi.n	8015df6 <_strtoul_l.constprop.0+0x86>
 8015dcc:	4664      	mov	r4, ip
 8015dce:	42a3      	cmp	r3, r4
 8015dd0:	dd22      	ble.n	8015e18 <_strtoul_l.constprop.0+0xa8>
 8015dd2:	2f00      	cmp	r7, #0
 8015dd4:	db1d      	blt.n	8015e12 <_strtoul_l.constprop.0+0xa2>
 8015dd6:	4580      	cmp	r8, r0
 8015dd8:	d31b      	bcc.n	8015e12 <_strtoul_l.constprop.0+0xa2>
 8015dda:	d101      	bne.n	8015de0 <_strtoul_l.constprop.0+0x70>
 8015ddc:	45a1      	cmp	r9, r4
 8015dde:	db18      	blt.n	8015e12 <_strtoul_l.constprop.0+0xa2>
 8015de0:	fb00 4003 	mla	r0, r0, r3, r4
 8015de4:	2701      	movs	r7, #1
 8015de6:	f815 4b01 	ldrb.w	r4, [r5], #1
 8015dea:	e7ea      	b.n	8015dc2 <_strtoul_l.constprop.0+0x52>
 8015dec:	2c2b      	cmp	r4, #43	; 0x2b
 8015dee:	bf04      	itt	eq
 8015df0:	782c      	ldrbeq	r4, [r5, #0]
 8015df2:	1c85      	addeq	r5, r0, #2
 8015df4:	e7cd      	b.n	8015d92 <_strtoul_l.constprop.0+0x22>
 8015df6:	f1a4 0c41 	sub.w	ip, r4, #65	; 0x41
 8015dfa:	f1bc 0f19 	cmp.w	ip, #25
 8015dfe:	d801      	bhi.n	8015e04 <_strtoul_l.constprop.0+0x94>
 8015e00:	3c37      	subs	r4, #55	; 0x37
 8015e02:	e7e4      	b.n	8015dce <_strtoul_l.constprop.0+0x5e>
 8015e04:	f1a4 0c61 	sub.w	ip, r4, #97	; 0x61
 8015e08:	f1bc 0f19 	cmp.w	ip, #25
 8015e0c:	d804      	bhi.n	8015e18 <_strtoul_l.constprop.0+0xa8>
 8015e0e:	3c57      	subs	r4, #87	; 0x57
 8015e10:	e7dd      	b.n	8015dce <_strtoul_l.constprop.0+0x5e>
 8015e12:	f04f 37ff 	mov.w	r7, #4294967295
 8015e16:	e7e6      	b.n	8015de6 <_strtoul_l.constprop.0+0x76>
 8015e18:	2f00      	cmp	r7, #0
 8015e1a:	da07      	bge.n	8015e2c <_strtoul_l.constprop.0+0xbc>
 8015e1c:	2322      	movs	r3, #34	; 0x22
 8015e1e:	f8ce 3000 	str.w	r3, [lr]
 8015e22:	f04f 30ff 	mov.w	r0, #4294967295
 8015e26:	b932      	cbnz	r2, 8015e36 <_strtoul_l.constprop.0+0xc6>
 8015e28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015e2c:	b106      	cbz	r6, 8015e30 <_strtoul_l.constprop.0+0xc0>
 8015e2e:	4240      	negs	r0, r0
 8015e30:	2a00      	cmp	r2, #0
 8015e32:	d0f9      	beq.n	8015e28 <_strtoul_l.constprop.0+0xb8>
 8015e34:	b107      	cbz	r7, 8015e38 <_strtoul_l.constprop.0+0xc8>
 8015e36:	1e69      	subs	r1, r5, #1
 8015e38:	6011      	str	r1, [r2, #0]
 8015e3a:	e7f5      	b.n	8015e28 <_strtoul_l.constprop.0+0xb8>
 8015e3c:	2430      	movs	r4, #48	; 0x30
 8015e3e:	2b00      	cmp	r3, #0
 8015e40:	d1b5      	bne.n	8015dae <_strtoul_l.constprop.0+0x3e>
 8015e42:	2308      	movs	r3, #8
 8015e44:	e7b3      	b.n	8015dae <_strtoul_l.constprop.0+0x3e>
 8015e46:	2c30      	cmp	r4, #48	; 0x30
 8015e48:	d0a9      	beq.n	8015d9e <_strtoul_l.constprop.0+0x2e>
 8015e4a:	230a      	movs	r3, #10
 8015e4c:	e7af      	b.n	8015dae <_strtoul_l.constprop.0+0x3e>
 8015e4e:	bf00      	nop
 8015e50:	0801a56d 	.word	0x0801a56d

08015e54 <_strtoul_r>:
 8015e54:	f7ff bf8c 	b.w	8015d70 <_strtoul_l.constprop.0>

08015e58 <__submore>:
 8015e58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015e5c:	460c      	mov	r4, r1
 8015e5e:	6b49      	ldr	r1, [r1, #52]	; 0x34
 8015e60:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8015e64:	4299      	cmp	r1, r3
 8015e66:	d11d      	bne.n	8015ea4 <__submore+0x4c>
 8015e68:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8015e6c:	f7ff f9ae 	bl	80151cc <_malloc_r>
 8015e70:	b918      	cbnz	r0, 8015e7a <__submore+0x22>
 8015e72:	f04f 30ff 	mov.w	r0, #4294967295
 8015e76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015e7a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8015e7e:	63a3      	str	r3, [r4, #56]	; 0x38
 8015e80:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8015e84:	6360      	str	r0, [r4, #52]	; 0x34
 8015e86:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 8015e8a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8015e8e:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 8015e92:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8015e96:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 8015e9a:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 8015e9e:	6020      	str	r0, [r4, #0]
 8015ea0:	2000      	movs	r0, #0
 8015ea2:	e7e8      	b.n	8015e76 <__submore+0x1e>
 8015ea4:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8015ea6:	0077      	lsls	r7, r6, #1
 8015ea8:	463a      	mov	r2, r7
 8015eaa:	f000 fa17 	bl	80162dc <_realloc_r>
 8015eae:	4605      	mov	r5, r0
 8015eb0:	2800      	cmp	r0, #0
 8015eb2:	d0de      	beq.n	8015e72 <__submore+0x1a>
 8015eb4:	eb00 0806 	add.w	r8, r0, r6
 8015eb8:	4601      	mov	r1, r0
 8015eba:	4632      	mov	r2, r6
 8015ebc:	4640      	mov	r0, r8
 8015ebe:	f7fd f933 	bl	8013128 <memcpy>
 8015ec2:	e9c4 570d 	strd	r5, r7, [r4, #52]	; 0x34
 8015ec6:	f8c4 8000 	str.w	r8, [r4]
 8015eca:	e7e9      	b.n	8015ea0 <__submore+0x48>

08015ecc <__assert_func>:
 8015ecc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8015ece:	4614      	mov	r4, r2
 8015ed0:	461a      	mov	r2, r3
 8015ed2:	4b09      	ldr	r3, [pc, #36]	; (8015ef8 <__assert_func+0x2c>)
 8015ed4:	681b      	ldr	r3, [r3, #0]
 8015ed6:	4605      	mov	r5, r0
 8015ed8:	68d8      	ldr	r0, [r3, #12]
 8015eda:	b14c      	cbz	r4, 8015ef0 <__assert_func+0x24>
 8015edc:	4b07      	ldr	r3, [pc, #28]	; (8015efc <__assert_func+0x30>)
 8015ede:	9100      	str	r1, [sp, #0]
 8015ee0:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8015ee4:	4906      	ldr	r1, [pc, #24]	; (8015f00 <__assert_func+0x34>)
 8015ee6:	462b      	mov	r3, r5
 8015ee8:	f000 f9a6 	bl	8016238 <fiprintf>
 8015eec:	f000 fc4c 	bl	8016788 <abort>
 8015ef0:	4b04      	ldr	r3, [pc, #16]	; (8015f04 <__assert_func+0x38>)
 8015ef2:	461c      	mov	r4, r3
 8015ef4:	e7f3      	b.n	8015ede <__assert_func+0x12>
 8015ef6:	bf00      	nop
 8015ef8:	20000694 	.word	0x20000694
 8015efc:	0801a530 	.word	0x0801a530
 8015f00:	0801a53d 	.word	0x0801a53d
 8015f04:	0801a56b 	.word	0x0801a56b

08015f08 <__sflush_r>:
 8015f08:	898a      	ldrh	r2, [r1, #12]
 8015f0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015f0e:	4605      	mov	r5, r0
 8015f10:	0710      	lsls	r0, r2, #28
 8015f12:	460c      	mov	r4, r1
 8015f14:	d458      	bmi.n	8015fc8 <__sflush_r+0xc0>
 8015f16:	684b      	ldr	r3, [r1, #4]
 8015f18:	2b00      	cmp	r3, #0
 8015f1a:	dc05      	bgt.n	8015f28 <__sflush_r+0x20>
 8015f1c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8015f1e:	2b00      	cmp	r3, #0
 8015f20:	dc02      	bgt.n	8015f28 <__sflush_r+0x20>
 8015f22:	2000      	movs	r0, #0
 8015f24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015f28:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015f2a:	2e00      	cmp	r6, #0
 8015f2c:	d0f9      	beq.n	8015f22 <__sflush_r+0x1a>
 8015f2e:	2300      	movs	r3, #0
 8015f30:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8015f34:	682f      	ldr	r7, [r5, #0]
 8015f36:	602b      	str	r3, [r5, #0]
 8015f38:	d032      	beq.n	8015fa0 <__sflush_r+0x98>
 8015f3a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8015f3c:	89a3      	ldrh	r3, [r4, #12]
 8015f3e:	075a      	lsls	r2, r3, #29
 8015f40:	d505      	bpl.n	8015f4e <__sflush_r+0x46>
 8015f42:	6863      	ldr	r3, [r4, #4]
 8015f44:	1ac0      	subs	r0, r0, r3
 8015f46:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8015f48:	b10b      	cbz	r3, 8015f4e <__sflush_r+0x46>
 8015f4a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8015f4c:	1ac0      	subs	r0, r0, r3
 8015f4e:	2300      	movs	r3, #0
 8015f50:	4602      	mov	r2, r0
 8015f52:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015f54:	6a21      	ldr	r1, [r4, #32]
 8015f56:	4628      	mov	r0, r5
 8015f58:	47b0      	blx	r6
 8015f5a:	1c43      	adds	r3, r0, #1
 8015f5c:	89a3      	ldrh	r3, [r4, #12]
 8015f5e:	d106      	bne.n	8015f6e <__sflush_r+0x66>
 8015f60:	6829      	ldr	r1, [r5, #0]
 8015f62:	291d      	cmp	r1, #29
 8015f64:	d82c      	bhi.n	8015fc0 <__sflush_r+0xb8>
 8015f66:	4a2a      	ldr	r2, [pc, #168]	; (8016010 <__sflush_r+0x108>)
 8015f68:	40ca      	lsrs	r2, r1
 8015f6a:	07d6      	lsls	r6, r2, #31
 8015f6c:	d528      	bpl.n	8015fc0 <__sflush_r+0xb8>
 8015f6e:	2200      	movs	r2, #0
 8015f70:	6062      	str	r2, [r4, #4]
 8015f72:	04d9      	lsls	r1, r3, #19
 8015f74:	6922      	ldr	r2, [r4, #16]
 8015f76:	6022      	str	r2, [r4, #0]
 8015f78:	d504      	bpl.n	8015f84 <__sflush_r+0x7c>
 8015f7a:	1c42      	adds	r2, r0, #1
 8015f7c:	d101      	bne.n	8015f82 <__sflush_r+0x7a>
 8015f7e:	682b      	ldr	r3, [r5, #0]
 8015f80:	b903      	cbnz	r3, 8015f84 <__sflush_r+0x7c>
 8015f82:	6560      	str	r0, [r4, #84]	; 0x54
 8015f84:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8015f86:	602f      	str	r7, [r5, #0]
 8015f88:	2900      	cmp	r1, #0
 8015f8a:	d0ca      	beq.n	8015f22 <__sflush_r+0x1a>
 8015f8c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8015f90:	4299      	cmp	r1, r3
 8015f92:	d002      	beq.n	8015f9a <__sflush_r+0x92>
 8015f94:	4628      	mov	r0, r5
 8015f96:	f7ff f8ad 	bl	80150f4 <_free_r>
 8015f9a:	2000      	movs	r0, #0
 8015f9c:	6360      	str	r0, [r4, #52]	; 0x34
 8015f9e:	e7c1      	b.n	8015f24 <__sflush_r+0x1c>
 8015fa0:	6a21      	ldr	r1, [r4, #32]
 8015fa2:	2301      	movs	r3, #1
 8015fa4:	4628      	mov	r0, r5
 8015fa6:	47b0      	blx	r6
 8015fa8:	1c41      	adds	r1, r0, #1
 8015faa:	d1c7      	bne.n	8015f3c <__sflush_r+0x34>
 8015fac:	682b      	ldr	r3, [r5, #0]
 8015fae:	2b00      	cmp	r3, #0
 8015fb0:	d0c4      	beq.n	8015f3c <__sflush_r+0x34>
 8015fb2:	2b1d      	cmp	r3, #29
 8015fb4:	d001      	beq.n	8015fba <__sflush_r+0xb2>
 8015fb6:	2b16      	cmp	r3, #22
 8015fb8:	d101      	bne.n	8015fbe <__sflush_r+0xb6>
 8015fba:	602f      	str	r7, [r5, #0]
 8015fbc:	e7b1      	b.n	8015f22 <__sflush_r+0x1a>
 8015fbe:	89a3      	ldrh	r3, [r4, #12]
 8015fc0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015fc4:	81a3      	strh	r3, [r4, #12]
 8015fc6:	e7ad      	b.n	8015f24 <__sflush_r+0x1c>
 8015fc8:	690f      	ldr	r7, [r1, #16]
 8015fca:	2f00      	cmp	r7, #0
 8015fcc:	d0a9      	beq.n	8015f22 <__sflush_r+0x1a>
 8015fce:	0793      	lsls	r3, r2, #30
 8015fd0:	680e      	ldr	r6, [r1, #0]
 8015fd2:	bf08      	it	eq
 8015fd4:	694b      	ldreq	r3, [r1, #20]
 8015fd6:	600f      	str	r7, [r1, #0]
 8015fd8:	bf18      	it	ne
 8015fda:	2300      	movne	r3, #0
 8015fdc:	eba6 0807 	sub.w	r8, r6, r7
 8015fe0:	608b      	str	r3, [r1, #8]
 8015fe2:	f1b8 0f00 	cmp.w	r8, #0
 8015fe6:	dd9c      	ble.n	8015f22 <__sflush_r+0x1a>
 8015fe8:	6a21      	ldr	r1, [r4, #32]
 8015fea:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8015fec:	4643      	mov	r3, r8
 8015fee:	463a      	mov	r2, r7
 8015ff0:	4628      	mov	r0, r5
 8015ff2:	47b0      	blx	r6
 8015ff4:	2800      	cmp	r0, #0
 8015ff6:	dc06      	bgt.n	8016006 <__sflush_r+0xfe>
 8015ff8:	89a3      	ldrh	r3, [r4, #12]
 8015ffa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015ffe:	81a3      	strh	r3, [r4, #12]
 8016000:	f04f 30ff 	mov.w	r0, #4294967295
 8016004:	e78e      	b.n	8015f24 <__sflush_r+0x1c>
 8016006:	4407      	add	r7, r0
 8016008:	eba8 0800 	sub.w	r8, r8, r0
 801600c:	e7e9      	b.n	8015fe2 <__sflush_r+0xda>
 801600e:	bf00      	nop
 8016010:	20400001 	.word	0x20400001

08016014 <_fflush_r>:
 8016014:	b538      	push	{r3, r4, r5, lr}
 8016016:	690b      	ldr	r3, [r1, #16]
 8016018:	4605      	mov	r5, r0
 801601a:	460c      	mov	r4, r1
 801601c:	b913      	cbnz	r3, 8016024 <_fflush_r+0x10>
 801601e:	2500      	movs	r5, #0
 8016020:	4628      	mov	r0, r5
 8016022:	bd38      	pop	{r3, r4, r5, pc}
 8016024:	b118      	cbz	r0, 801602e <_fflush_r+0x1a>
 8016026:	6983      	ldr	r3, [r0, #24]
 8016028:	b90b      	cbnz	r3, 801602e <_fflush_r+0x1a>
 801602a:	f000 f887 	bl	801613c <__sinit>
 801602e:	4b14      	ldr	r3, [pc, #80]	; (8016080 <_fflush_r+0x6c>)
 8016030:	429c      	cmp	r4, r3
 8016032:	d11b      	bne.n	801606c <_fflush_r+0x58>
 8016034:	686c      	ldr	r4, [r5, #4]
 8016036:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801603a:	2b00      	cmp	r3, #0
 801603c:	d0ef      	beq.n	801601e <_fflush_r+0xa>
 801603e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8016040:	07d0      	lsls	r0, r2, #31
 8016042:	d404      	bmi.n	801604e <_fflush_r+0x3a>
 8016044:	0599      	lsls	r1, r3, #22
 8016046:	d402      	bmi.n	801604e <_fflush_r+0x3a>
 8016048:	6da0      	ldr	r0, [r4, #88]	; 0x58
 801604a:	f000 f927 	bl	801629c <__retarget_lock_acquire_recursive>
 801604e:	4628      	mov	r0, r5
 8016050:	4621      	mov	r1, r4
 8016052:	f7ff ff59 	bl	8015f08 <__sflush_r>
 8016056:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8016058:	07da      	lsls	r2, r3, #31
 801605a:	4605      	mov	r5, r0
 801605c:	d4e0      	bmi.n	8016020 <_fflush_r+0xc>
 801605e:	89a3      	ldrh	r3, [r4, #12]
 8016060:	059b      	lsls	r3, r3, #22
 8016062:	d4dd      	bmi.n	8016020 <_fflush_r+0xc>
 8016064:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8016066:	f000 f91a 	bl	801629e <__retarget_lock_release_recursive>
 801606a:	e7d9      	b.n	8016020 <_fflush_r+0xc>
 801606c:	4b05      	ldr	r3, [pc, #20]	; (8016084 <_fflush_r+0x70>)
 801606e:	429c      	cmp	r4, r3
 8016070:	d101      	bne.n	8016076 <_fflush_r+0x62>
 8016072:	68ac      	ldr	r4, [r5, #8]
 8016074:	e7df      	b.n	8016036 <_fflush_r+0x22>
 8016076:	4b04      	ldr	r3, [pc, #16]	; (8016088 <_fflush_r+0x74>)
 8016078:	429c      	cmp	r4, r3
 801607a:	bf08      	it	eq
 801607c:	68ec      	ldreq	r4, [r5, #12]
 801607e:	e7da      	b.n	8016036 <_fflush_r+0x22>
 8016080:	0801a690 	.word	0x0801a690
 8016084:	0801a6b0 	.word	0x0801a6b0
 8016088:	0801a670 	.word	0x0801a670

0801608c <std>:
 801608c:	2300      	movs	r3, #0
 801608e:	b510      	push	{r4, lr}
 8016090:	4604      	mov	r4, r0
 8016092:	e9c0 3300 	strd	r3, r3, [r0]
 8016096:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801609a:	6083      	str	r3, [r0, #8]
 801609c:	8181      	strh	r1, [r0, #12]
 801609e:	6643      	str	r3, [r0, #100]	; 0x64
 80160a0:	81c2      	strh	r2, [r0, #14]
 80160a2:	6183      	str	r3, [r0, #24]
 80160a4:	4619      	mov	r1, r3
 80160a6:	2208      	movs	r2, #8
 80160a8:	305c      	adds	r0, #92	; 0x5c
 80160aa:	f7fd f865 	bl	8013178 <memset>
 80160ae:	4b05      	ldr	r3, [pc, #20]	; (80160c4 <std+0x38>)
 80160b0:	6263      	str	r3, [r4, #36]	; 0x24
 80160b2:	4b05      	ldr	r3, [pc, #20]	; (80160c8 <std+0x3c>)
 80160b4:	62a3      	str	r3, [r4, #40]	; 0x28
 80160b6:	4b05      	ldr	r3, [pc, #20]	; (80160cc <std+0x40>)
 80160b8:	62e3      	str	r3, [r4, #44]	; 0x2c
 80160ba:	4b05      	ldr	r3, [pc, #20]	; (80160d0 <std+0x44>)
 80160bc:	6224      	str	r4, [r4, #32]
 80160be:	6323      	str	r3, [r4, #48]	; 0x30
 80160c0:	bd10      	pop	{r4, pc}
 80160c2:	bf00      	nop
 80160c4:	08013af5 	.word	0x08013af5
 80160c8:	08013b1b 	.word	0x08013b1b
 80160cc:	08013b53 	.word	0x08013b53
 80160d0:	08013b77 	.word	0x08013b77

080160d4 <_cleanup_r>:
 80160d4:	4901      	ldr	r1, [pc, #4]	; (80160dc <_cleanup_r+0x8>)
 80160d6:	f000 b8c1 	b.w	801625c <_fwalk_reent>
 80160da:	bf00      	nop
 80160dc:	08016015 	.word	0x08016015

080160e0 <__sfmoreglue>:
 80160e0:	b570      	push	{r4, r5, r6, lr}
 80160e2:	2268      	movs	r2, #104	; 0x68
 80160e4:	1e4d      	subs	r5, r1, #1
 80160e6:	4355      	muls	r5, r2
 80160e8:	460e      	mov	r6, r1
 80160ea:	f105 0174 	add.w	r1, r5, #116	; 0x74
 80160ee:	f7ff f86d 	bl	80151cc <_malloc_r>
 80160f2:	4604      	mov	r4, r0
 80160f4:	b140      	cbz	r0, 8016108 <__sfmoreglue+0x28>
 80160f6:	2100      	movs	r1, #0
 80160f8:	e9c0 1600 	strd	r1, r6, [r0]
 80160fc:	300c      	adds	r0, #12
 80160fe:	60a0      	str	r0, [r4, #8]
 8016100:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8016104:	f7fd f838 	bl	8013178 <memset>
 8016108:	4620      	mov	r0, r4
 801610a:	bd70      	pop	{r4, r5, r6, pc}

0801610c <__sfp_lock_acquire>:
 801610c:	4801      	ldr	r0, [pc, #4]	; (8016114 <__sfp_lock_acquire+0x8>)
 801610e:	f000 b8c5 	b.w	801629c <__retarget_lock_acquire_recursive>
 8016112:	bf00      	nop
 8016114:	2004ee65 	.word	0x2004ee65

08016118 <__sfp_lock_release>:
 8016118:	4801      	ldr	r0, [pc, #4]	; (8016120 <__sfp_lock_release+0x8>)
 801611a:	f000 b8c0 	b.w	801629e <__retarget_lock_release_recursive>
 801611e:	bf00      	nop
 8016120:	2004ee65 	.word	0x2004ee65

08016124 <__sinit_lock_acquire>:
 8016124:	4801      	ldr	r0, [pc, #4]	; (801612c <__sinit_lock_acquire+0x8>)
 8016126:	f000 b8b9 	b.w	801629c <__retarget_lock_acquire_recursive>
 801612a:	bf00      	nop
 801612c:	2004ee66 	.word	0x2004ee66

08016130 <__sinit_lock_release>:
 8016130:	4801      	ldr	r0, [pc, #4]	; (8016138 <__sinit_lock_release+0x8>)
 8016132:	f000 b8b4 	b.w	801629e <__retarget_lock_release_recursive>
 8016136:	bf00      	nop
 8016138:	2004ee66 	.word	0x2004ee66

0801613c <__sinit>:
 801613c:	b510      	push	{r4, lr}
 801613e:	4604      	mov	r4, r0
 8016140:	f7ff fff0 	bl	8016124 <__sinit_lock_acquire>
 8016144:	69a3      	ldr	r3, [r4, #24]
 8016146:	b11b      	cbz	r3, 8016150 <__sinit+0x14>
 8016148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801614c:	f7ff bff0 	b.w	8016130 <__sinit_lock_release>
 8016150:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 8016154:	6523      	str	r3, [r4, #80]	; 0x50
 8016156:	4b13      	ldr	r3, [pc, #76]	; (80161a4 <__sinit+0x68>)
 8016158:	4a13      	ldr	r2, [pc, #76]	; (80161a8 <__sinit+0x6c>)
 801615a:	681b      	ldr	r3, [r3, #0]
 801615c:	62a2      	str	r2, [r4, #40]	; 0x28
 801615e:	42a3      	cmp	r3, r4
 8016160:	bf04      	itt	eq
 8016162:	2301      	moveq	r3, #1
 8016164:	61a3      	streq	r3, [r4, #24]
 8016166:	4620      	mov	r0, r4
 8016168:	f000 f820 	bl	80161ac <__sfp>
 801616c:	6060      	str	r0, [r4, #4]
 801616e:	4620      	mov	r0, r4
 8016170:	f000 f81c 	bl	80161ac <__sfp>
 8016174:	60a0      	str	r0, [r4, #8]
 8016176:	4620      	mov	r0, r4
 8016178:	f000 f818 	bl	80161ac <__sfp>
 801617c:	2200      	movs	r2, #0
 801617e:	60e0      	str	r0, [r4, #12]
 8016180:	2104      	movs	r1, #4
 8016182:	6860      	ldr	r0, [r4, #4]
 8016184:	f7ff ff82 	bl	801608c <std>
 8016188:	68a0      	ldr	r0, [r4, #8]
 801618a:	2201      	movs	r2, #1
 801618c:	2109      	movs	r1, #9
 801618e:	f7ff ff7d 	bl	801608c <std>
 8016192:	68e0      	ldr	r0, [r4, #12]
 8016194:	2202      	movs	r2, #2
 8016196:	2112      	movs	r1, #18
 8016198:	f7ff ff78 	bl	801608c <std>
 801619c:	2301      	movs	r3, #1
 801619e:	61a3      	str	r3, [r4, #24]
 80161a0:	e7d2      	b.n	8016148 <__sinit+0xc>
 80161a2:	bf00      	nop
 80161a4:	0801a2e0 	.word	0x0801a2e0
 80161a8:	080160d5 	.word	0x080160d5

080161ac <__sfp>:
 80161ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80161ae:	4607      	mov	r7, r0
 80161b0:	f7ff ffac 	bl	801610c <__sfp_lock_acquire>
 80161b4:	4b1e      	ldr	r3, [pc, #120]	; (8016230 <__sfp+0x84>)
 80161b6:	681e      	ldr	r6, [r3, #0]
 80161b8:	69b3      	ldr	r3, [r6, #24]
 80161ba:	b913      	cbnz	r3, 80161c2 <__sfp+0x16>
 80161bc:	4630      	mov	r0, r6
 80161be:	f7ff ffbd 	bl	801613c <__sinit>
 80161c2:	3648      	adds	r6, #72	; 0x48
 80161c4:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 80161c8:	3b01      	subs	r3, #1
 80161ca:	d503      	bpl.n	80161d4 <__sfp+0x28>
 80161cc:	6833      	ldr	r3, [r6, #0]
 80161ce:	b30b      	cbz	r3, 8016214 <__sfp+0x68>
 80161d0:	6836      	ldr	r6, [r6, #0]
 80161d2:	e7f7      	b.n	80161c4 <__sfp+0x18>
 80161d4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 80161d8:	b9d5      	cbnz	r5, 8016210 <__sfp+0x64>
 80161da:	4b16      	ldr	r3, [pc, #88]	; (8016234 <__sfp+0x88>)
 80161dc:	60e3      	str	r3, [r4, #12]
 80161de:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80161e2:	6665      	str	r5, [r4, #100]	; 0x64
 80161e4:	f000 f859 	bl	801629a <__retarget_lock_init_recursive>
 80161e8:	f7ff ff96 	bl	8016118 <__sfp_lock_release>
 80161ec:	e9c4 5501 	strd	r5, r5, [r4, #4]
 80161f0:	e9c4 5504 	strd	r5, r5, [r4, #16]
 80161f4:	6025      	str	r5, [r4, #0]
 80161f6:	61a5      	str	r5, [r4, #24]
 80161f8:	2208      	movs	r2, #8
 80161fa:	4629      	mov	r1, r5
 80161fc:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8016200:	f7fc ffba 	bl	8013178 <memset>
 8016204:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8016208:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 801620c:	4620      	mov	r0, r4
 801620e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8016210:	3468      	adds	r4, #104	; 0x68
 8016212:	e7d9      	b.n	80161c8 <__sfp+0x1c>
 8016214:	2104      	movs	r1, #4
 8016216:	4638      	mov	r0, r7
 8016218:	f7ff ff62 	bl	80160e0 <__sfmoreglue>
 801621c:	4604      	mov	r4, r0
 801621e:	6030      	str	r0, [r6, #0]
 8016220:	2800      	cmp	r0, #0
 8016222:	d1d5      	bne.n	80161d0 <__sfp+0x24>
 8016224:	f7ff ff78 	bl	8016118 <__sfp_lock_release>
 8016228:	230c      	movs	r3, #12
 801622a:	603b      	str	r3, [r7, #0]
 801622c:	e7ee      	b.n	801620c <__sfp+0x60>
 801622e:	bf00      	nop
 8016230:	0801a2e0 	.word	0x0801a2e0
 8016234:	ffff0001 	.word	0xffff0001

08016238 <fiprintf>:
 8016238:	b40e      	push	{r1, r2, r3}
 801623a:	b503      	push	{r0, r1, lr}
 801623c:	4601      	mov	r1, r0
 801623e:	ab03      	add	r3, sp, #12
 8016240:	4805      	ldr	r0, [pc, #20]	; (8016258 <fiprintf+0x20>)
 8016242:	f853 2b04 	ldr.w	r2, [r3], #4
 8016246:	6800      	ldr	r0, [r0, #0]
 8016248:	9301      	str	r3, [sp, #4]
 801624a:	f000 f89f 	bl	801638c <_vfiprintf_r>
 801624e:	b002      	add	sp, #8
 8016250:	f85d eb04 	ldr.w	lr, [sp], #4
 8016254:	b003      	add	sp, #12
 8016256:	4770      	bx	lr
 8016258:	20000694 	.word	0x20000694

0801625c <_fwalk_reent>:
 801625c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016260:	4606      	mov	r6, r0
 8016262:	4688      	mov	r8, r1
 8016264:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8016268:	2700      	movs	r7, #0
 801626a:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 801626e:	f1b9 0901 	subs.w	r9, r9, #1
 8016272:	d505      	bpl.n	8016280 <_fwalk_reent+0x24>
 8016274:	6824      	ldr	r4, [r4, #0]
 8016276:	2c00      	cmp	r4, #0
 8016278:	d1f7      	bne.n	801626a <_fwalk_reent+0xe>
 801627a:	4638      	mov	r0, r7
 801627c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016280:	89ab      	ldrh	r3, [r5, #12]
 8016282:	2b01      	cmp	r3, #1
 8016284:	d907      	bls.n	8016296 <_fwalk_reent+0x3a>
 8016286:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801628a:	3301      	adds	r3, #1
 801628c:	d003      	beq.n	8016296 <_fwalk_reent+0x3a>
 801628e:	4629      	mov	r1, r5
 8016290:	4630      	mov	r0, r6
 8016292:	47c0      	blx	r8
 8016294:	4307      	orrs	r7, r0
 8016296:	3568      	adds	r5, #104	; 0x68
 8016298:	e7e9      	b.n	801626e <_fwalk_reent+0x12>

0801629a <__retarget_lock_init_recursive>:
 801629a:	4770      	bx	lr

0801629c <__retarget_lock_acquire_recursive>:
 801629c:	4770      	bx	lr

0801629e <__retarget_lock_release_recursive>:
 801629e:	4770      	bx	lr

080162a0 <__ascii_mbtowc>:
 80162a0:	b082      	sub	sp, #8
 80162a2:	b901      	cbnz	r1, 80162a6 <__ascii_mbtowc+0x6>
 80162a4:	a901      	add	r1, sp, #4
 80162a6:	b142      	cbz	r2, 80162ba <__ascii_mbtowc+0x1a>
 80162a8:	b14b      	cbz	r3, 80162be <__ascii_mbtowc+0x1e>
 80162aa:	7813      	ldrb	r3, [r2, #0]
 80162ac:	600b      	str	r3, [r1, #0]
 80162ae:	7812      	ldrb	r2, [r2, #0]
 80162b0:	1e10      	subs	r0, r2, #0
 80162b2:	bf18      	it	ne
 80162b4:	2001      	movne	r0, #1
 80162b6:	b002      	add	sp, #8
 80162b8:	4770      	bx	lr
 80162ba:	4610      	mov	r0, r2
 80162bc:	e7fb      	b.n	80162b6 <__ascii_mbtowc+0x16>
 80162be:	f06f 0001 	mvn.w	r0, #1
 80162c2:	e7f8      	b.n	80162b6 <__ascii_mbtowc+0x16>

080162c4 <__malloc_lock>:
 80162c4:	4801      	ldr	r0, [pc, #4]	; (80162cc <__malloc_lock+0x8>)
 80162c6:	f7ff bfe9 	b.w	801629c <__retarget_lock_acquire_recursive>
 80162ca:	bf00      	nop
 80162cc:	2004ee64 	.word	0x2004ee64

080162d0 <__malloc_unlock>:
 80162d0:	4801      	ldr	r0, [pc, #4]	; (80162d8 <__malloc_unlock+0x8>)
 80162d2:	f7ff bfe4 	b.w	801629e <__retarget_lock_release_recursive>
 80162d6:	bf00      	nop
 80162d8:	2004ee64 	.word	0x2004ee64

080162dc <_realloc_r>:
 80162dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80162e0:	4680      	mov	r8, r0
 80162e2:	4614      	mov	r4, r2
 80162e4:	460e      	mov	r6, r1
 80162e6:	b921      	cbnz	r1, 80162f2 <_realloc_r+0x16>
 80162e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80162ec:	4611      	mov	r1, r2
 80162ee:	f7fe bf6d 	b.w	80151cc <_malloc_r>
 80162f2:	b92a      	cbnz	r2, 8016300 <_realloc_r+0x24>
 80162f4:	f7fe fefe 	bl	80150f4 <_free_r>
 80162f8:	4625      	mov	r5, r4
 80162fa:	4628      	mov	r0, r5
 80162fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8016300:	f000 faae 	bl	8016860 <_malloc_usable_size_r>
 8016304:	4284      	cmp	r4, r0
 8016306:	4607      	mov	r7, r0
 8016308:	d802      	bhi.n	8016310 <_realloc_r+0x34>
 801630a:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 801630e:	d812      	bhi.n	8016336 <_realloc_r+0x5a>
 8016310:	4621      	mov	r1, r4
 8016312:	4640      	mov	r0, r8
 8016314:	f7fe ff5a 	bl	80151cc <_malloc_r>
 8016318:	4605      	mov	r5, r0
 801631a:	2800      	cmp	r0, #0
 801631c:	d0ed      	beq.n	80162fa <_realloc_r+0x1e>
 801631e:	42bc      	cmp	r4, r7
 8016320:	4622      	mov	r2, r4
 8016322:	4631      	mov	r1, r6
 8016324:	bf28      	it	cs
 8016326:	463a      	movcs	r2, r7
 8016328:	f7fc fefe 	bl	8013128 <memcpy>
 801632c:	4631      	mov	r1, r6
 801632e:	4640      	mov	r0, r8
 8016330:	f7fe fee0 	bl	80150f4 <_free_r>
 8016334:	e7e1      	b.n	80162fa <_realloc_r+0x1e>
 8016336:	4635      	mov	r5, r6
 8016338:	e7df      	b.n	80162fa <_realloc_r+0x1e>

0801633a <__sfputc_r>:
 801633a:	6893      	ldr	r3, [r2, #8]
 801633c:	3b01      	subs	r3, #1
 801633e:	2b00      	cmp	r3, #0
 8016340:	b410      	push	{r4}
 8016342:	6093      	str	r3, [r2, #8]
 8016344:	da08      	bge.n	8016358 <__sfputc_r+0x1e>
 8016346:	6994      	ldr	r4, [r2, #24]
 8016348:	42a3      	cmp	r3, r4
 801634a:	db01      	blt.n	8016350 <__sfputc_r+0x16>
 801634c:	290a      	cmp	r1, #10
 801634e:	d103      	bne.n	8016358 <__sfputc_r+0x1e>
 8016350:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016354:	f000 b94a 	b.w	80165ec <__swbuf_r>
 8016358:	6813      	ldr	r3, [r2, #0]
 801635a:	1c58      	adds	r0, r3, #1
 801635c:	6010      	str	r0, [r2, #0]
 801635e:	7019      	strb	r1, [r3, #0]
 8016360:	4608      	mov	r0, r1
 8016362:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016366:	4770      	bx	lr

08016368 <__sfputs_r>:
 8016368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801636a:	4606      	mov	r6, r0
 801636c:	460f      	mov	r7, r1
 801636e:	4614      	mov	r4, r2
 8016370:	18d5      	adds	r5, r2, r3
 8016372:	42ac      	cmp	r4, r5
 8016374:	d101      	bne.n	801637a <__sfputs_r+0x12>
 8016376:	2000      	movs	r0, #0
 8016378:	e007      	b.n	801638a <__sfputs_r+0x22>
 801637a:	f814 1b01 	ldrb.w	r1, [r4], #1
 801637e:	463a      	mov	r2, r7
 8016380:	4630      	mov	r0, r6
 8016382:	f7ff ffda 	bl	801633a <__sfputc_r>
 8016386:	1c43      	adds	r3, r0, #1
 8016388:	d1f3      	bne.n	8016372 <__sfputs_r+0xa>
 801638a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801638c <_vfiprintf_r>:
 801638c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016390:	460d      	mov	r5, r1
 8016392:	b09d      	sub	sp, #116	; 0x74
 8016394:	4614      	mov	r4, r2
 8016396:	4698      	mov	r8, r3
 8016398:	4606      	mov	r6, r0
 801639a:	b118      	cbz	r0, 80163a4 <_vfiprintf_r+0x18>
 801639c:	6983      	ldr	r3, [r0, #24]
 801639e:	b90b      	cbnz	r3, 80163a4 <_vfiprintf_r+0x18>
 80163a0:	f7ff fecc 	bl	801613c <__sinit>
 80163a4:	4b89      	ldr	r3, [pc, #548]	; (80165cc <_vfiprintf_r+0x240>)
 80163a6:	429d      	cmp	r5, r3
 80163a8:	d11b      	bne.n	80163e2 <_vfiprintf_r+0x56>
 80163aa:	6875      	ldr	r5, [r6, #4]
 80163ac:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80163ae:	07d9      	lsls	r1, r3, #31
 80163b0:	d405      	bmi.n	80163be <_vfiprintf_r+0x32>
 80163b2:	89ab      	ldrh	r3, [r5, #12]
 80163b4:	059a      	lsls	r2, r3, #22
 80163b6:	d402      	bmi.n	80163be <_vfiprintf_r+0x32>
 80163b8:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80163ba:	f7ff ff6f 	bl	801629c <__retarget_lock_acquire_recursive>
 80163be:	89ab      	ldrh	r3, [r5, #12]
 80163c0:	071b      	lsls	r3, r3, #28
 80163c2:	d501      	bpl.n	80163c8 <_vfiprintf_r+0x3c>
 80163c4:	692b      	ldr	r3, [r5, #16]
 80163c6:	b9eb      	cbnz	r3, 8016404 <_vfiprintf_r+0x78>
 80163c8:	4629      	mov	r1, r5
 80163ca:	4630      	mov	r0, r6
 80163cc:	f000 f96e 	bl	80166ac <__swsetup_r>
 80163d0:	b1c0      	cbz	r0, 8016404 <_vfiprintf_r+0x78>
 80163d2:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 80163d4:	07dc      	lsls	r4, r3, #31
 80163d6:	d50e      	bpl.n	80163f6 <_vfiprintf_r+0x6a>
 80163d8:	f04f 30ff 	mov.w	r0, #4294967295
 80163dc:	b01d      	add	sp, #116	; 0x74
 80163de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80163e2:	4b7b      	ldr	r3, [pc, #492]	; (80165d0 <_vfiprintf_r+0x244>)
 80163e4:	429d      	cmp	r5, r3
 80163e6:	d101      	bne.n	80163ec <_vfiprintf_r+0x60>
 80163e8:	68b5      	ldr	r5, [r6, #8]
 80163ea:	e7df      	b.n	80163ac <_vfiprintf_r+0x20>
 80163ec:	4b79      	ldr	r3, [pc, #484]	; (80165d4 <_vfiprintf_r+0x248>)
 80163ee:	429d      	cmp	r5, r3
 80163f0:	bf08      	it	eq
 80163f2:	68f5      	ldreq	r5, [r6, #12]
 80163f4:	e7da      	b.n	80163ac <_vfiprintf_r+0x20>
 80163f6:	89ab      	ldrh	r3, [r5, #12]
 80163f8:	0598      	lsls	r0, r3, #22
 80163fa:	d4ed      	bmi.n	80163d8 <_vfiprintf_r+0x4c>
 80163fc:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80163fe:	f7ff ff4e 	bl	801629e <__retarget_lock_release_recursive>
 8016402:	e7e9      	b.n	80163d8 <_vfiprintf_r+0x4c>
 8016404:	2300      	movs	r3, #0
 8016406:	9309      	str	r3, [sp, #36]	; 0x24
 8016408:	2320      	movs	r3, #32
 801640a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 801640e:	f8cd 800c 	str.w	r8, [sp, #12]
 8016412:	2330      	movs	r3, #48	; 0x30
 8016414:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 80165d8 <_vfiprintf_r+0x24c>
 8016418:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 801641c:	f04f 0901 	mov.w	r9, #1
 8016420:	4623      	mov	r3, r4
 8016422:	469a      	mov	sl, r3
 8016424:	f813 2b01 	ldrb.w	r2, [r3], #1
 8016428:	b10a      	cbz	r2, 801642e <_vfiprintf_r+0xa2>
 801642a:	2a25      	cmp	r2, #37	; 0x25
 801642c:	d1f9      	bne.n	8016422 <_vfiprintf_r+0x96>
 801642e:	ebba 0b04 	subs.w	fp, sl, r4
 8016432:	d00b      	beq.n	801644c <_vfiprintf_r+0xc0>
 8016434:	465b      	mov	r3, fp
 8016436:	4622      	mov	r2, r4
 8016438:	4629      	mov	r1, r5
 801643a:	4630      	mov	r0, r6
 801643c:	f7ff ff94 	bl	8016368 <__sfputs_r>
 8016440:	3001      	adds	r0, #1
 8016442:	f000 80aa 	beq.w	801659a <_vfiprintf_r+0x20e>
 8016446:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016448:	445a      	add	r2, fp
 801644a:	9209      	str	r2, [sp, #36]	; 0x24
 801644c:	f89a 3000 	ldrb.w	r3, [sl]
 8016450:	2b00      	cmp	r3, #0
 8016452:	f000 80a2 	beq.w	801659a <_vfiprintf_r+0x20e>
 8016456:	2300      	movs	r3, #0
 8016458:	f04f 32ff 	mov.w	r2, #4294967295
 801645c:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8016460:	f10a 0a01 	add.w	sl, sl, #1
 8016464:	9304      	str	r3, [sp, #16]
 8016466:	9307      	str	r3, [sp, #28]
 8016468:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801646c:	931a      	str	r3, [sp, #104]	; 0x68
 801646e:	4654      	mov	r4, sl
 8016470:	2205      	movs	r2, #5
 8016472:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016476:	4858      	ldr	r0, [pc, #352]	; (80165d8 <_vfiprintf_r+0x24c>)
 8016478:	f7ea faaa 	bl	80009d0 <memchr>
 801647c:	9a04      	ldr	r2, [sp, #16]
 801647e:	b9d8      	cbnz	r0, 80164b8 <_vfiprintf_r+0x12c>
 8016480:	06d1      	lsls	r1, r2, #27
 8016482:	bf44      	itt	mi
 8016484:	2320      	movmi	r3, #32
 8016486:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 801648a:	0713      	lsls	r3, r2, #28
 801648c:	bf44      	itt	mi
 801648e:	232b      	movmi	r3, #43	; 0x2b
 8016490:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 8016494:	f89a 3000 	ldrb.w	r3, [sl]
 8016498:	2b2a      	cmp	r3, #42	; 0x2a
 801649a:	d015      	beq.n	80164c8 <_vfiprintf_r+0x13c>
 801649c:	9a07      	ldr	r2, [sp, #28]
 801649e:	4654      	mov	r4, sl
 80164a0:	2000      	movs	r0, #0
 80164a2:	f04f 0c0a 	mov.w	ip, #10
 80164a6:	4621      	mov	r1, r4
 80164a8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80164ac:	3b30      	subs	r3, #48	; 0x30
 80164ae:	2b09      	cmp	r3, #9
 80164b0:	d94e      	bls.n	8016550 <_vfiprintf_r+0x1c4>
 80164b2:	b1b0      	cbz	r0, 80164e2 <_vfiprintf_r+0x156>
 80164b4:	9207      	str	r2, [sp, #28]
 80164b6:	e014      	b.n	80164e2 <_vfiprintf_r+0x156>
 80164b8:	eba0 0308 	sub.w	r3, r0, r8
 80164bc:	fa09 f303 	lsl.w	r3, r9, r3
 80164c0:	4313      	orrs	r3, r2
 80164c2:	9304      	str	r3, [sp, #16]
 80164c4:	46a2      	mov	sl, r4
 80164c6:	e7d2      	b.n	801646e <_vfiprintf_r+0xe2>
 80164c8:	9b03      	ldr	r3, [sp, #12]
 80164ca:	1d19      	adds	r1, r3, #4
 80164cc:	681b      	ldr	r3, [r3, #0]
 80164ce:	9103      	str	r1, [sp, #12]
 80164d0:	2b00      	cmp	r3, #0
 80164d2:	bfbb      	ittet	lt
 80164d4:	425b      	neglt	r3, r3
 80164d6:	f042 0202 	orrlt.w	r2, r2, #2
 80164da:	9307      	strge	r3, [sp, #28]
 80164dc:	9307      	strlt	r3, [sp, #28]
 80164de:	bfb8      	it	lt
 80164e0:	9204      	strlt	r2, [sp, #16]
 80164e2:	7823      	ldrb	r3, [r4, #0]
 80164e4:	2b2e      	cmp	r3, #46	; 0x2e
 80164e6:	d10c      	bne.n	8016502 <_vfiprintf_r+0x176>
 80164e8:	7863      	ldrb	r3, [r4, #1]
 80164ea:	2b2a      	cmp	r3, #42	; 0x2a
 80164ec:	d135      	bne.n	801655a <_vfiprintf_r+0x1ce>
 80164ee:	9b03      	ldr	r3, [sp, #12]
 80164f0:	1d1a      	adds	r2, r3, #4
 80164f2:	681b      	ldr	r3, [r3, #0]
 80164f4:	9203      	str	r2, [sp, #12]
 80164f6:	2b00      	cmp	r3, #0
 80164f8:	bfb8      	it	lt
 80164fa:	f04f 33ff 	movlt.w	r3, #4294967295
 80164fe:	3402      	adds	r4, #2
 8016500:	9305      	str	r3, [sp, #20]
 8016502:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 80165e8 <_vfiprintf_r+0x25c>
 8016506:	7821      	ldrb	r1, [r4, #0]
 8016508:	2203      	movs	r2, #3
 801650a:	4650      	mov	r0, sl
 801650c:	f7ea fa60 	bl	80009d0 <memchr>
 8016510:	b140      	cbz	r0, 8016524 <_vfiprintf_r+0x198>
 8016512:	2340      	movs	r3, #64	; 0x40
 8016514:	eba0 000a 	sub.w	r0, r0, sl
 8016518:	fa03 f000 	lsl.w	r0, r3, r0
 801651c:	9b04      	ldr	r3, [sp, #16]
 801651e:	4303      	orrs	r3, r0
 8016520:	3401      	adds	r4, #1
 8016522:	9304      	str	r3, [sp, #16]
 8016524:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016528:	482c      	ldr	r0, [pc, #176]	; (80165dc <_vfiprintf_r+0x250>)
 801652a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801652e:	2206      	movs	r2, #6
 8016530:	f7ea fa4e 	bl	80009d0 <memchr>
 8016534:	2800      	cmp	r0, #0
 8016536:	d03f      	beq.n	80165b8 <_vfiprintf_r+0x22c>
 8016538:	4b29      	ldr	r3, [pc, #164]	; (80165e0 <_vfiprintf_r+0x254>)
 801653a:	bb1b      	cbnz	r3, 8016584 <_vfiprintf_r+0x1f8>
 801653c:	9b03      	ldr	r3, [sp, #12]
 801653e:	3307      	adds	r3, #7
 8016540:	f023 0307 	bic.w	r3, r3, #7
 8016544:	3308      	adds	r3, #8
 8016546:	9303      	str	r3, [sp, #12]
 8016548:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801654a:	443b      	add	r3, r7
 801654c:	9309      	str	r3, [sp, #36]	; 0x24
 801654e:	e767      	b.n	8016420 <_vfiprintf_r+0x94>
 8016550:	fb0c 3202 	mla	r2, ip, r2, r3
 8016554:	460c      	mov	r4, r1
 8016556:	2001      	movs	r0, #1
 8016558:	e7a5      	b.n	80164a6 <_vfiprintf_r+0x11a>
 801655a:	2300      	movs	r3, #0
 801655c:	3401      	adds	r4, #1
 801655e:	9305      	str	r3, [sp, #20]
 8016560:	4619      	mov	r1, r3
 8016562:	f04f 0c0a 	mov.w	ip, #10
 8016566:	4620      	mov	r0, r4
 8016568:	f810 2b01 	ldrb.w	r2, [r0], #1
 801656c:	3a30      	subs	r2, #48	; 0x30
 801656e:	2a09      	cmp	r2, #9
 8016570:	d903      	bls.n	801657a <_vfiprintf_r+0x1ee>
 8016572:	2b00      	cmp	r3, #0
 8016574:	d0c5      	beq.n	8016502 <_vfiprintf_r+0x176>
 8016576:	9105      	str	r1, [sp, #20]
 8016578:	e7c3      	b.n	8016502 <_vfiprintf_r+0x176>
 801657a:	fb0c 2101 	mla	r1, ip, r1, r2
 801657e:	4604      	mov	r4, r0
 8016580:	2301      	movs	r3, #1
 8016582:	e7f0      	b.n	8016566 <_vfiprintf_r+0x1da>
 8016584:	ab03      	add	r3, sp, #12
 8016586:	9300      	str	r3, [sp, #0]
 8016588:	462a      	mov	r2, r5
 801658a:	4b16      	ldr	r3, [pc, #88]	; (80165e4 <_vfiprintf_r+0x258>)
 801658c:	a904      	add	r1, sp, #16
 801658e:	4630      	mov	r0, r6
 8016590:	f7fc fe9a 	bl	80132c8 <_printf_float>
 8016594:	4607      	mov	r7, r0
 8016596:	1c78      	adds	r0, r7, #1
 8016598:	d1d6      	bne.n	8016548 <_vfiprintf_r+0x1bc>
 801659a:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 801659c:	07d9      	lsls	r1, r3, #31
 801659e:	d405      	bmi.n	80165ac <_vfiprintf_r+0x220>
 80165a0:	89ab      	ldrh	r3, [r5, #12]
 80165a2:	059a      	lsls	r2, r3, #22
 80165a4:	d402      	bmi.n	80165ac <_vfiprintf_r+0x220>
 80165a6:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80165a8:	f7ff fe79 	bl	801629e <__retarget_lock_release_recursive>
 80165ac:	89ab      	ldrh	r3, [r5, #12]
 80165ae:	065b      	lsls	r3, r3, #25
 80165b0:	f53f af12 	bmi.w	80163d8 <_vfiprintf_r+0x4c>
 80165b4:	9809      	ldr	r0, [sp, #36]	; 0x24
 80165b6:	e711      	b.n	80163dc <_vfiprintf_r+0x50>
 80165b8:	ab03      	add	r3, sp, #12
 80165ba:	9300      	str	r3, [sp, #0]
 80165bc:	462a      	mov	r2, r5
 80165be:	4b09      	ldr	r3, [pc, #36]	; (80165e4 <_vfiprintf_r+0x258>)
 80165c0:	a904      	add	r1, sp, #16
 80165c2:	4630      	mov	r0, r6
 80165c4:	f7fd f924 	bl	8013810 <_printf_i>
 80165c8:	e7e4      	b.n	8016594 <_vfiprintf_r+0x208>
 80165ca:	bf00      	nop
 80165cc:	0801a690 	.word	0x0801a690
 80165d0:	0801a6b0 	.word	0x0801a6b0
 80165d4:	0801a670 	.word	0x0801a670
 80165d8:	0801a504 	.word	0x0801a504
 80165dc:	0801a50e 	.word	0x0801a50e
 80165e0:	080132c9 	.word	0x080132c9
 80165e4:	08016369 	.word	0x08016369
 80165e8:	0801a50a 	.word	0x0801a50a

080165ec <__swbuf_r>:
 80165ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80165ee:	460e      	mov	r6, r1
 80165f0:	4614      	mov	r4, r2
 80165f2:	4605      	mov	r5, r0
 80165f4:	b118      	cbz	r0, 80165fe <__swbuf_r+0x12>
 80165f6:	6983      	ldr	r3, [r0, #24]
 80165f8:	b90b      	cbnz	r3, 80165fe <__swbuf_r+0x12>
 80165fa:	f7ff fd9f 	bl	801613c <__sinit>
 80165fe:	4b21      	ldr	r3, [pc, #132]	; (8016684 <__swbuf_r+0x98>)
 8016600:	429c      	cmp	r4, r3
 8016602:	d12b      	bne.n	801665c <__swbuf_r+0x70>
 8016604:	686c      	ldr	r4, [r5, #4]
 8016606:	69a3      	ldr	r3, [r4, #24]
 8016608:	60a3      	str	r3, [r4, #8]
 801660a:	89a3      	ldrh	r3, [r4, #12]
 801660c:	071a      	lsls	r2, r3, #28
 801660e:	d52f      	bpl.n	8016670 <__swbuf_r+0x84>
 8016610:	6923      	ldr	r3, [r4, #16]
 8016612:	b36b      	cbz	r3, 8016670 <__swbuf_r+0x84>
 8016614:	6923      	ldr	r3, [r4, #16]
 8016616:	6820      	ldr	r0, [r4, #0]
 8016618:	1ac0      	subs	r0, r0, r3
 801661a:	6963      	ldr	r3, [r4, #20]
 801661c:	b2f6      	uxtb	r6, r6
 801661e:	4283      	cmp	r3, r0
 8016620:	4637      	mov	r7, r6
 8016622:	dc04      	bgt.n	801662e <__swbuf_r+0x42>
 8016624:	4621      	mov	r1, r4
 8016626:	4628      	mov	r0, r5
 8016628:	f7ff fcf4 	bl	8016014 <_fflush_r>
 801662c:	bb30      	cbnz	r0, 801667c <__swbuf_r+0x90>
 801662e:	68a3      	ldr	r3, [r4, #8]
 8016630:	3b01      	subs	r3, #1
 8016632:	60a3      	str	r3, [r4, #8]
 8016634:	6823      	ldr	r3, [r4, #0]
 8016636:	1c5a      	adds	r2, r3, #1
 8016638:	6022      	str	r2, [r4, #0]
 801663a:	701e      	strb	r6, [r3, #0]
 801663c:	6963      	ldr	r3, [r4, #20]
 801663e:	3001      	adds	r0, #1
 8016640:	4283      	cmp	r3, r0
 8016642:	d004      	beq.n	801664e <__swbuf_r+0x62>
 8016644:	89a3      	ldrh	r3, [r4, #12]
 8016646:	07db      	lsls	r3, r3, #31
 8016648:	d506      	bpl.n	8016658 <__swbuf_r+0x6c>
 801664a:	2e0a      	cmp	r6, #10
 801664c:	d104      	bne.n	8016658 <__swbuf_r+0x6c>
 801664e:	4621      	mov	r1, r4
 8016650:	4628      	mov	r0, r5
 8016652:	f7ff fcdf 	bl	8016014 <_fflush_r>
 8016656:	b988      	cbnz	r0, 801667c <__swbuf_r+0x90>
 8016658:	4638      	mov	r0, r7
 801665a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801665c:	4b0a      	ldr	r3, [pc, #40]	; (8016688 <__swbuf_r+0x9c>)
 801665e:	429c      	cmp	r4, r3
 8016660:	d101      	bne.n	8016666 <__swbuf_r+0x7a>
 8016662:	68ac      	ldr	r4, [r5, #8]
 8016664:	e7cf      	b.n	8016606 <__swbuf_r+0x1a>
 8016666:	4b09      	ldr	r3, [pc, #36]	; (801668c <__swbuf_r+0xa0>)
 8016668:	429c      	cmp	r4, r3
 801666a:	bf08      	it	eq
 801666c:	68ec      	ldreq	r4, [r5, #12]
 801666e:	e7ca      	b.n	8016606 <__swbuf_r+0x1a>
 8016670:	4621      	mov	r1, r4
 8016672:	4628      	mov	r0, r5
 8016674:	f000 f81a 	bl	80166ac <__swsetup_r>
 8016678:	2800      	cmp	r0, #0
 801667a:	d0cb      	beq.n	8016614 <__swbuf_r+0x28>
 801667c:	f04f 37ff 	mov.w	r7, #4294967295
 8016680:	e7ea      	b.n	8016658 <__swbuf_r+0x6c>
 8016682:	bf00      	nop
 8016684:	0801a690 	.word	0x0801a690
 8016688:	0801a6b0 	.word	0x0801a6b0
 801668c:	0801a670 	.word	0x0801a670

08016690 <__ascii_wctomb>:
 8016690:	b149      	cbz	r1, 80166a6 <__ascii_wctomb+0x16>
 8016692:	2aff      	cmp	r2, #255	; 0xff
 8016694:	bf85      	ittet	hi
 8016696:	238a      	movhi	r3, #138	; 0x8a
 8016698:	6003      	strhi	r3, [r0, #0]
 801669a:	700a      	strbls	r2, [r1, #0]
 801669c:	f04f 30ff 	movhi.w	r0, #4294967295
 80166a0:	bf98      	it	ls
 80166a2:	2001      	movls	r0, #1
 80166a4:	4770      	bx	lr
 80166a6:	4608      	mov	r0, r1
 80166a8:	4770      	bx	lr
	...

080166ac <__swsetup_r>:
 80166ac:	4b32      	ldr	r3, [pc, #200]	; (8016778 <__swsetup_r+0xcc>)
 80166ae:	b570      	push	{r4, r5, r6, lr}
 80166b0:	681d      	ldr	r5, [r3, #0]
 80166b2:	4606      	mov	r6, r0
 80166b4:	460c      	mov	r4, r1
 80166b6:	b125      	cbz	r5, 80166c2 <__swsetup_r+0x16>
 80166b8:	69ab      	ldr	r3, [r5, #24]
 80166ba:	b913      	cbnz	r3, 80166c2 <__swsetup_r+0x16>
 80166bc:	4628      	mov	r0, r5
 80166be:	f7ff fd3d 	bl	801613c <__sinit>
 80166c2:	4b2e      	ldr	r3, [pc, #184]	; (801677c <__swsetup_r+0xd0>)
 80166c4:	429c      	cmp	r4, r3
 80166c6:	d10f      	bne.n	80166e8 <__swsetup_r+0x3c>
 80166c8:	686c      	ldr	r4, [r5, #4]
 80166ca:	89a3      	ldrh	r3, [r4, #12]
 80166cc:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80166d0:	0719      	lsls	r1, r3, #28
 80166d2:	d42c      	bmi.n	801672e <__swsetup_r+0x82>
 80166d4:	06dd      	lsls	r5, r3, #27
 80166d6:	d411      	bmi.n	80166fc <__swsetup_r+0x50>
 80166d8:	2309      	movs	r3, #9
 80166da:	6033      	str	r3, [r6, #0]
 80166dc:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 80166e0:	81a3      	strh	r3, [r4, #12]
 80166e2:	f04f 30ff 	mov.w	r0, #4294967295
 80166e6:	e03e      	b.n	8016766 <__swsetup_r+0xba>
 80166e8:	4b25      	ldr	r3, [pc, #148]	; (8016780 <__swsetup_r+0xd4>)
 80166ea:	429c      	cmp	r4, r3
 80166ec:	d101      	bne.n	80166f2 <__swsetup_r+0x46>
 80166ee:	68ac      	ldr	r4, [r5, #8]
 80166f0:	e7eb      	b.n	80166ca <__swsetup_r+0x1e>
 80166f2:	4b24      	ldr	r3, [pc, #144]	; (8016784 <__swsetup_r+0xd8>)
 80166f4:	429c      	cmp	r4, r3
 80166f6:	bf08      	it	eq
 80166f8:	68ec      	ldreq	r4, [r5, #12]
 80166fa:	e7e6      	b.n	80166ca <__swsetup_r+0x1e>
 80166fc:	0758      	lsls	r0, r3, #29
 80166fe:	d512      	bpl.n	8016726 <__swsetup_r+0x7a>
 8016700:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8016702:	b141      	cbz	r1, 8016716 <__swsetup_r+0x6a>
 8016704:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8016708:	4299      	cmp	r1, r3
 801670a:	d002      	beq.n	8016712 <__swsetup_r+0x66>
 801670c:	4630      	mov	r0, r6
 801670e:	f7fe fcf1 	bl	80150f4 <_free_r>
 8016712:	2300      	movs	r3, #0
 8016714:	6363      	str	r3, [r4, #52]	; 0x34
 8016716:	89a3      	ldrh	r3, [r4, #12]
 8016718:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 801671c:	81a3      	strh	r3, [r4, #12]
 801671e:	2300      	movs	r3, #0
 8016720:	6063      	str	r3, [r4, #4]
 8016722:	6923      	ldr	r3, [r4, #16]
 8016724:	6023      	str	r3, [r4, #0]
 8016726:	89a3      	ldrh	r3, [r4, #12]
 8016728:	f043 0308 	orr.w	r3, r3, #8
 801672c:	81a3      	strh	r3, [r4, #12]
 801672e:	6923      	ldr	r3, [r4, #16]
 8016730:	b94b      	cbnz	r3, 8016746 <__swsetup_r+0x9a>
 8016732:	89a3      	ldrh	r3, [r4, #12]
 8016734:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8016738:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801673c:	d003      	beq.n	8016746 <__swsetup_r+0x9a>
 801673e:	4621      	mov	r1, r4
 8016740:	4630      	mov	r0, r6
 8016742:	f000 f84d 	bl	80167e0 <__smakebuf_r>
 8016746:	89a0      	ldrh	r0, [r4, #12]
 8016748:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 801674c:	f010 0301 	ands.w	r3, r0, #1
 8016750:	d00a      	beq.n	8016768 <__swsetup_r+0xbc>
 8016752:	2300      	movs	r3, #0
 8016754:	60a3      	str	r3, [r4, #8]
 8016756:	6963      	ldr	r3, [r4, #20]
 8016758:	425b      	negs	r3, r3
 801675a:	61a3      	str	r3, [r4, #24]
 801675c:	6923      	ldr	r3, [r4, #16]
 801675e:	b943      	cbnz	r3, 8016772 <__swsetup_r+0xc6>
 8016760:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8016764:	d1ba      	bne.n	80166dc <__swsetup_r+0x30>
 8016766:	bd70      	pop	{r4, r5, r6, pc}
 8016768:	0781      	lsls	r1, r0, #30
 801676a:	bf58      	it	pl
 801676c:	6963      	ldrpl	r3, [r4, #20]
 801676e:	60a3      	str	r3, [r4, #8]
 8016770:	e7f4      	b.n	801675c <__swsetup_r+0xb0>
 8016772:	2000      	movs	r0, #0
 8016774:	e7f7      	b.n	8016766 <__swsetup_r+0xba>
 8016776:	bf00      	nop
 8016778:	20000694 	.word	0x20000694
 801677c:	0801a690 	.word	0x0801a690
 8016780:	0801a6b0 	.word	0x0801a6b0
 8016784:	0801a670 	.word	0x0801a670

08016788 <abort>:
 8016788:	b508      	push	{r3, lr}
 801678a:	2006      	movs	r0, #6
 801678c:	f000 f898 	bl	80168c0 <raise>
 8016790:	2001      	movs	r0, #1
 8016792:	f7ec fbe1 	bl	8002f58 <_exit>

08016796 <__swhatbuf_r>:
 8016796:	b570      	push	{r4, r5, r6, lr}
 8016798:	460e      	mov	r6, r1
 801679a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801679e:	2900      	cmp	r1, #0
 80167a0:	b096      	sub	sp, #88	; 0x58
 80167a2:	4614      	mov	r4, r2
 80167a4:	461d      	mov	r5, r3
 80167a6:	da08      	bge.n	80167ba <__swhatbuf_r+0x24>
 80167a8:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 80167ac:	2200      	movs	r2, #0
 80167ae:	602a      	str	r2, [r5, #0]
 80167b0:	061a      	lsls	r2, r3, #24
 80167b2:	d410      	bmi.n	80167d6 <__swhatbuf_r+0x40>
 80167b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80167b8:	e00e      	b.n	80167d8 <__swhatbuf_r+0x42>
 80167ba:	466a      	mov	r2, sp
 80167bc:	f000 f89c 	bl	80168f8 <_fstat_r>
 80167c0:	2800      	cmp	r0, #0
 80167c2:	dbf1      	blt.n	80167a8 <__swhatbuf_r+0x12>
 80167c4:	9a01      	ldr	r2, [sp, #4]
 80167c6:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80167ca:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80167ce:	425a      	negs	r2, r3
 80167d0:	415a      	adcs	r2, r3
 80167d2:	602a      	str	r2, [r5, #0]
 80167d4:	e7ee      	b.n	80167b4 <__swhatbuf_r+0x1e>
 80167d6:	2340      	movs	r3, #64	; 0x40
 80167d8:	2000      	movs	r0, #0
 80167da:	6023      	str	r3, [r4, #0]
 80167dc:	b016      	add	sp, #88	; 0x58
 80167de:	bd70      	pop	{r4, r5, r6, pc}

080167e0 <__smakebuf_r>:
 80167e0:	898b      	ldrh	r3, [r1, #12]
 80167e2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80167e4:	079d      	lsls	r5, r3, #30
 80167e6:	4606      	mov	r6, r0
 80167e8:	460c      	mov	r4, r1
 80167ea:	d507      	bpl.n	80167fc <__smakebuf_r+0x1c>
 80167ec:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80167f0:	6023      	str	r3, [r4, #0]
 80167f2:	6123      	str	r3, [r4, #16]
 80167f4:	2301      	movs	r3, #1
 80167f6:	6163      	str	r3, [r4, #20]
 80167f8:	b002      	add	sp, #8
 80167fa:	bd70      	pop	{r4, r5, r6, pc}
 80167fc:	ab01      	add	r3, sp, #4
 80167fe:	466a      	mov	r2, sp
 8016800:	f7ff ffc9 	bl	8016796 <__swhatbuf_r>
 8016804:	9900      	ldr	r1, [sp, #0]
 8016806:	4605      	mov	r5, r0
 8016808:	4630      	mov	r0, r6
 801680a:	f7fe fcdf 	bl	80151cc <_malloc_r>
 801680e:	b948      	cbnz	r0, 8016824 <__smakebuf_r+0x44>
 8016810:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8016814:	059a      	lsls	r2, r3, #22
 8016816:	d4ef      	bmi.n	80167f8 <__smakebuf_r+0x18>
 8016818:	f023 0303 	bic.w	r3, r3, #3
 801681c:	f043 0302 	orr.w	r3, r3, #2
 8016820:	81a3      	strh	r3, [r4, #12]
 8016822:	e7e3      	b.n	80167ec <__smakebuf_r+0xc>
 8016824:	4b0d      	ldr	r3, [pc, #52]	; (801685c <__smakebuf_r+0x7c>)
 8016826:	62b3      	str	r3, [r6, #40]	; 0x28
 8016828:	89a3      	ldrh	r3, [r4, #12]
 801682a:	6020      	str	r0, [r4, #0]
 801682c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8016830:	81a3      	strh	r3, [r4, #12]
 8016832:	9b00      	ldr	r3, [sp, #0]
 8016834:	6163      	str	r3, [r4, #20]
 8016836:	9b01      	ldr	r3, [sp, #4]
 8016838:	6120      	str	r0, [r4, #16]
 801683a:	b15b      	cbz	r3, 8016854 <__smakebuf_r+0x74>
 801683c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8016840:	4630      	mov	r0, r6
 8016842:	f000 f86b 	bl	801691c <_isatty_r>
 8016846:	b128      	cbz	r0, 8016854 <__smakebuf_r+0x74>
 8016848:	89a3      	ldrh	r3, [r4, #12]
 801684a:	f023 0303 	bic.w	r3, r3, #3
 801684e:	f043 0301 	orr.w	r3, r3, #1
 8016852:	81a3      	strh	r3, [r4, #12]
 8016854:	89a0      	ldrh	r0, [r4, #12]
 8016856:	4305      	orrs	r5, r0
 8016858:	81a5      	strh	r5, [r4, #12]
 801685a:	e7cd      	b.n	80167f8 <__smakebuf_r+0x18>
 801685c:	080160d5 	.word	0x080160d5

08016860 <_malloc_usable_size_r>:
 8016860:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8016864:	1f18      	subs	r0, r3, #4
 8016866:	2b00      	cmp	r3, #0
 8016868:	bfbc      	itt	lt
 801686a:	580b      	ldrlt	r3, [r1, r0]
 801686c:	18c0      	addlt	r0, r0, r3
 801686e:	4770      	bx	lr

08016870 <_raise_r>:
 8016870:	291f      	cmp	r1, #31
 8016872:	b538      	push	{r3, r4, r5, lr}
 8016874:	4604      	mov	r4, r0
 8016876:	460d      	mov	r5, r1
 8016878:	d904      	bls.n	8016884 <_raise_r+0x14>
 801687a:	2316      	movs	r3, #22
 801687c:	6003      	str	r3, [r0, #0]
 801687e:	f04f 30ff 	mov.w	r0, #4294967295
 8016882:	bd38      	pop	{r3, r4, r5, pc}
 8016884:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8016886:	b112      	cbz	r2, 801688e <_raise_r+0x1e>
 8016888:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 801688c:	b94b      	cbnz	r3, 80168a2 <_raise_r+0x32>
 801688e:	4620      	mov	r0, r4
 8016890:	f000 f830 	bl	80168f4 <_getpid_r>
 8016894:	462a      	mov	r2, r5
 8016896:	4601      	mov	r1, r0
 8016898:	4620      	mov	r0, r4
 801689a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801689e:	f000 b817 	b.w	80168d0 <_kill_r>
 80168a2:	2b01      	cmp	r3, #1
 80168a4:	d00a      	beq.n	80168bc <_raise_r+0x4c>
 80168a6:	1c59      	adds	r1, r3, #1
 80168a8:	d103      	bne.n	80168b2 <_raise_r+0x42>
 80168aa:	2316      	movs	r3, #22
 80168ac:	6003      	str	r3, [r0, #0]
 80168ae:	2001      	movs	r0, #1
 80168b0:	e7e7      	b.n	8016882 <_raise_r+0x12>
 80168b2:	2400      	movs	r4, #0
 80168b4:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 80168b8:	4628      	mov	r0, r5
 80168ba:	4798      	blx	r3
 80168bc:	2000      	movs	r0, #0
 80168be:	e7e0      	b.n	8016882 <_raise_r+0x12>

080168c0 <raise>:
 80168c0:	4b02      	ldr	r3, [pc, #8]	; (80168cc <raise+0xc>)
 80168c2:	4601      	mov	r1, r0
 80168c4:	6818      	ldr	r0, [r3, #0]
 80168c6:	f7ff bfd3 	b.w	8016870 <_raise_r>
 80168ca:	bf00      	nop
 80168cc:	20000694 	.word	0x20000694

080168d0 <_kill_r>:
 80168d0:	b538      	push	{r3, r4, r5, lr}
 80168d2:	4d07      	ldr	r5, [pc, #28]	; (80168f0 <_kill_r+0x20>)
 80168d4:	2300      	movs	r3, #0
 80168d6:	4604      	mov	r4, r0
 80168d8:	4608      	mov	r0, r1
 80168da:	4611      	mov	r1, r2
 80168dc:	602b      	str	r3, [r5, #0]
 80168de:	f7ec fb31 	bl	8002f44 <_kill>
 80168e2:	1c43      	adds	r3, r0, #1
 80168e4:	d102      	bne.n	80168ec <_kill_r+0x1c>
 80168e6:	682b      	ldr	r3, [r5, #0]
 80168e8:	b103      	cbz	r3, 80168ec <_kill_r+0x1c>
 80168ea:	6023      	str	r3, [r4, #0]
 80168ec:	bd38      	pop	{r3, r4, r5, pc}
 80168ee:	bf00      	nop
 80168f0:	2004ee60 	.word	0x2004ee60

080168f4 <_getpid_r>:
 80168f4:	f7ec bb24 	b.w	8002f40 <_getpid>

080168f8 <_fstat_r>:
 80168f8:	b538      	push	{r3, r4, r5, lr}
 80168fa:	4d07      	ldr	r5, [pc, #28]	; (8016918 <_fstat_r+0x20>)
 80168fc:	2300      	movs	r3, #0
 80168fe:	4604      	mov	r4, r0
 8016900:	4608      	mov	r0, r1
 8016902:	4611      	mov	r1, r2
 8016904:	602b      	str	r3, [r5, #0]
 8016906:	f7ec fb4d 	bl	8002fa4 <_fstat>
 801690a:	1c43      	adds	r3, r0, #1
 801690c:	d102      	bne.n	8016914 <_fstat_r+0x1c>
 801690e:	682b      	ldr	r3, [r5, #0]
 8016910:	b103      	cbz	r3, 8016914 <_fstat_r+0x1c>
 8016912:	6023      	str	r3, [r4, #0]
 8016914:	bd38      	pop	{r3, r4, r5, pc}
 8016916:	bf00      	nop
 8016918:	2004ee60 	.word	0x2004ee60

0801691c <_isatty_r>:
 801691c:	b538      	push	{r3, r4, r5, lr}
 801691e:	4d06      	ldr	r5, [pc, #24]	; (8016938 <_isatty_r+0x1c>)
 8016920:	2300      	movs	r3, #0
 8016922:	4604      	mov	r4, r0
 8016924:	4608      	mov	r0, r1
 8016926:	602b      	str	r3, [r5, #0]
 8016928:	f7ec fb42 	bl	8002fb0 <_isatty>
 801692c:	1c43      	adds	r3, r0, #1
 801692e:	d102      	bne.n	8016936 <_isatty_r+0x1a>
 8016930:	682b      	ldr	r3, [r5, #0]
 8016932:	b103      	cbz	r3, 8016936 <_isatty_r+0x1a>
 8016934:	6023      	str	r3, [r4, #0]
 8016936:	bd38      	pop	{r3, r4, r5, pc}
 8016938:	2004ee60 	.word	0x2004ee60

0801693c <_init>:
 801693c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801693e:	bf00      	nop
 8016940:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8016942:	bc08      	pop	{r3}
 8016944:	469e      	mov	lr, r3
 8016946:	4770      	bx	lr

08016948 <_fini>:
 8016948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801694a:	bf00      	nop
 801694c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801694e:	bc08      	pop	{r3}
 8016950:	469e      	mov	lr, r3
 8016952:	4770      	bx	lr
